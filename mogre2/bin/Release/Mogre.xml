<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Mogre</name>
  </assembly>
  <members>
    <member name="T:Mogre.Radian">
      <summary>Wrapper class which indicates a given angle value is in Radians. Radian values are interchangeable with Degree values, and conversions will be done automatically between them. </summary>
    </member>
    <member name="T:Mogre.Degree">
      <summary>Wrapper class which indicates a given angle value is in Degrees. Degree values are interchangeable with Radian values, and conversions will be done automatically between them. </summary>
    </member>
    <member name="T:Mogre.Angle">
      <summary>Wrapper class which identifies a value as the currently default angle type, as defined by Math::setAngleUnit. Angle values will be automatically converted between radians and degrees, as appropriate. </summary>
    </member>
    <member name="T:Mogre.Math">
      <summary>Class to provide access to common mathematical functions. Most of the maths functions are aliased versions of the C runtime library functions. They are aliased here to provide future optimisation opportunities, either from faster RTLs or custom math approximations. 
This is based on MgcMath.h from Wild Magic. </summary>
    </member>
    <member name="M:Mogre.Math.Cos(System.Single)">
      <summary>Cosine function. </summary>
      <param name="fValue">Angle in radians </param>
    </member>
    <member name="M:Mogre.Math.Cos(System.Single,System.Boolean)">
      <summary>Cosine function. </summary>
      <param name="fValue">Angle in radians </param>
      <param name="useTables">If true, uses lookup tables rather than calculation - faster but less accurate. </param>
    </member>
    <member name="M:Mogre.Math.Cos(Mogre.Radian)">
      <summary>Cosine function. </summary>
      <param name="fValue">Angle in radians </param>
    </member>
    <member name="M:Mogre.Math.Cos(Mogre.Radian,System.Boolean)">
      <summary>Cosine function. </summary>
      <param name="fValue">Angle in radians </param>
      <param name="useTables">If true, uses lookup tables rather than calculation - faster but less accurate. </param>
    </member>
    <member name="M:Mogre.Math.Sin(System.Single)">
      <summary>Sine function. </summary>
      <param name="fValue">Angle in radians </param>
    </member>
    <member name="M:Mogre.Math.Sin(System.Single,System.Boolean)">
      <summary>Sine function. </summary>
      <param name="fValue">Angle in radians </param>
      <param name="useTables">If true, uses lookup tables rather than calculation - faster but less accurate. </param>
    </member>
    <member name="M:Mogre.Math.Sin(Mogre.Radian)">
      <summary>Sine function. </summary>
      <param name="fValue">Angle in radians </param>
    </member>
    <member name="M:Mogre.Math.Sin(Mogre.Radian,System.Boolean)">
      <summary>Sine function. </summary>
      <param name="fValue">Angle in radians </param>
      <param name="useTables">If true, uses lookup tables rather than calculation - faster but less accurate. </param>
    </member>
    <member name="M:Mogre.Math.InvSqrt(System.Single)">
      <summary>Inverse square root i.e. 1 / Sqrt(x), good for vector normalisation. </summary>
    </member>
    <member name="M:Mogre.Math.SetAngleUnit(Mogre.Math+AngleUnit)">
      <summary>These functions used to set the assumed angle units (radians or degrees) expected when using the Angle type. You can set this directly after creating a new Root, and also before/after resource creation, depending on whether you want the change to affect resource files. </summary>
    </member>
    <member name="M:Mogre.Math.GetAngleUnit">
      <summary>Get the unit being used for angles. </summary>
    </member>
    <member name="M:Mogre.Math.AngleUnitsToRadians(System.Single)">
      <summary>Convert from the current AngleUnit to radians. </summary>
    </member>
    <member name="M:Mogre.Math.RadiansToAngleUnits(System.Single)">
      <summary>Convert from radians to the current AngleUnit . </summary>
    </member>
    <member name="M:Mogre.Math.AngleUnitsToDegrees(System.Single)">
      <summary>Convert from the current AngleUnit to degrees. </summary>
    </member>
    <member name="M:Mogre.Math.DegreesToAngleUnits(System.Single)">
      <summary>Convert from degrees to the current AngleUnit. </summary>
    </member>
    <member name="M:Mogre.Math.PointInTri2D(Mogre.Vector2,Mogre.Vector2,Mogre.Vector2,Mogre.Vector2)">
      <summary>Checks whether a given point is inside a triangle, in a 2-dimensional (Cartesian) space. The vertices of the triangle must be given in either trigonometrical (anticlockwise) or inverse trigonometrical (clockwise) order. If the point resides in the triangle, true is returned. If the point is outside the triangle, false is returned. </summary>
      <param name="p">The point. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
    </member>
    <member name="M:Mogre.Math.PointInTri3D(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Checks whether a given 3D point is inside a triangle. The vertices of the triangle must be given in either trigonometrical (anticlockwise) or inverse trigonometrical (clockwise) order, and the point must be guaranteed to be in the same plane as the triangle If the point resides in the triangle, true is returned. If the point is outside the triangle, false is returned. </summary>
      <param name="p">The point. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
      <param name="normal">The triangle plane's normal (passed in rather than calculated on demand since the caller may already have it) </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Sphere,Mogre.Plane)">
      <summary>Sphere / plane intersection test. NB just do a plane.getDistance(sphere.getCenter()) for more detail! </summary>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,System.Collections.Generic.IEnumerable`1[[Mogre.Plane, Mogre, Version=1.7.0.0, Culture=neutral, PublicKeyToken=null]],System.Boolean)">
      <summary>Ray / convex plane list intersection test. </summary>
      <param name="ray">The ray to test with </param>
      <param name="normalIsOutside">Does the normal point outside the volume </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,System.Collections.Generic.List`1[[Mogre.Plane, Mogre, Version=1.7.0.0, Culture=neutral, PublicKeyToken=null]],System.Boolean)">
      <summary>Ray / convex plane list intersection test. </summary>
      <param name="ray">The ray to test with </param>
      <param name="normalIsOutside">Does the normal point outside the volume </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Plane,Mogre.AxisAlignedBox)">
      <summary>Plane / box intersection test. </summary>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Sphere,Mogre.AxisAlignedBox)">
      <summary>Sphere / box intersection test. </summary>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Ray / triangle intersection, returns boolean result and distance. If the ray is intersects the triangle, a pair of true and the distance between intersection point and ray origin returned. If the ray isn't intersects the triangle, a pair of false and 0 returned. </summary>
      <param name="ray">The ray. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,System.Boolean)">
      <summary>Ray / triangle intersection, returns boolean result and distance. If the ray is intersects the triangle, a pair of true and the distance between intersection point and ray origin returned. If the ray isn't intersects the triangle, a pair of false and 0 returned. </summary>
      <param name="ray">The ray. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
      <param name="positiveSide">Intersect with "positive side" of the triangle </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,System.Boolean,System.Boolean)">
      <summary>Ray / triangle intersection, returns boolean result and distance. If the ray is intersects the triangle, a pair of true and the distance between intersection point and ray origin returned. If the ray isn't intersects the triangle, a pair of false and 0 returned. </summary>
      <param name="ray">The ray. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
      <param name="positiveSide">Intersect with "positive side" of the triangle </param>
      <param name="negativeSide">Intersect with "negative side" of the triangle </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Ray / triangle intersection, returns boolean result and distance. If the ray is intersects the triangle, a pair of true and the distance between intersection point and ray origin returned. If the ray isn't intersects the triangle, a pair of false and 0 returned. </summary>
      <param name="ray">The ray. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
      <param name="normal">The triangle plane's normal (passed in rather than calculated on demand since the caller may already have it), doesn't need normalised since we don't care. </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,System.Boolean)">
      <summary>Ray / triangle intersection, returns boolean result and distance. If the ray is intersects the triangle, a pair of true and the distance between intersection point and ray origin returned. If the ray isn't intersects the triangle, a pair of false and 0 returned. </summary>
      <param name="ray">The ray. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
      <param name="normal">The triangle plane's normal (passed in rather than calculated on demand since the caller may already have it), doesn't need normalised since we don't care. </param>
      <param name="positiveSide">Intersect with "positive side" of the triangle </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,System.Boolean,System.Boolean)">
      <summary>Ray / triangle intersection, returns boolean result and distance. If the ray is intersects the triangle, a pair of true and the distance between intersection point and ray origin returned. If the ray isn't intersects the triangle, a pair of false and 0 returned. </summary>
      <param name="ray">The ray. </param>
      <param name="a">The triangle's first vertex. </param>
      <param name="b">The triangle's second vertex. </param>
      <param name="c">The triangle's third vertex. </param>
      <param name="normal">The triangle plane's normal (passed in rather than calculated on demand since the caller may already have it), doesn't need normalised since we don't care. </param>
      <param name="positiveSide">Intersect with "positive side" of the triangle </param>
      <param name="negativeSide">Intersect with "negative side" of the triangle </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.AxisAlignedBox,System.Single&amp;,System.Single&amp;)">
      <summary>Ray / box intersection, returns boolean result and two intersection distance. If the ray is intersects the box, true is returned, and the near intersection distance is return by d1, the far intersection distance is return by d2. Guarantee 0 &lt;= d1 &lt;= d2. If the ray isn't intersects the box, false is returned, and d1 and d2 is unmodified. </summary>
      <param name="ray">The ray. </param>
      <param name="box">The box. </param>
      <param name="d1">A real pointer to retrieve the near intersection distance from the ray origin, maybe null which means don't care about the near intersection distance. </param>
      <param name="d2">A real pointer to retrieve the far intersection distance from the ray origin, maybe null which means don't care about the far intersection distance. </param>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.AxisAlignedBox)">
      <summary>Ray / box intersection, returns boolean result and distance. </summary>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Sphere)">
      <summary>Ray / sphere intersection, returns boolean result and distance. </summary>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Sphere,System.Boolean)">
      <summary>Ray / sphere intersection, returns boolean result and distance. </summary>
    </member>
    <member name="M:Mogre.Math.Intersects(Mogre.Ray,Mogre.Plane)">
      <summary>Ray / plane intersection, returns boolean result and distance. </summary>
    </member>
    <member name="M:Mogre.Math.RealEqual(System.Single,System.Single)">
      <summary>Compare 2 reals, using tolerance for inaccuracies. </summary>
    </member>
    <member name="M:Mogre.Math.RealEqual(System.Single,System.Single,System.Single)">
      <summary>Compare 2 reals, using tolerance for inaccuracies. </summary>
    </member>
    <member name="M:Mogre.Math.CalculateTangentSpaceVector(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Calculates the tangent space vector for a given set of positions / texture coords. </summary>
    </member>
    <member name="M:Mogre.Math.BuildReflectionMatrix(Mogre.Plane)">
      <summary>Build a reflection matrix for the passed in plane. </summary>
    </member>
    <member name="M:Mogre.Math.CalculateFaceNormal(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Calculate a face normal, including the w component which is the offset from the origin. </summary>
    </member>
    <member name="M:Mogre.Math.CalculateBasicFaceNormal(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Calculate a face normal, no w-information. </summary>
    </member>
    <member name="M:Mogre.Math.CalculateFaceNormalWithoutNormalize(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Calculate a face normal without normalize, including the w component which is the offset from the origin. </summary>
    </member>
    <member name="M:Mogre.Math.CalculateBasicFaceNormalWithoutNormalize(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Calculate a face normal without normalize, no w-information. </summary>
    </member>
    <member name="M:Mogre.Math.GaussianDistribution(System.Single)">
      <summary>Generates a value based on the Gaussian (normal) distribution function with the given offset and scale parameters. </summary>
    </member>
    <member name="M:Mogre.Math.GaussianDistribution(System.Single,System.Single)">
      <summary>Generates a value based on the Gaussian (normal) distribution function with the given offset and scale parameters. </summary>
    </member>
    <member name="M:Mogre.Math.GaussianDistribution(System.Single,System.Single,System.Single)">
      <summary>Generates a value based on the Gaussian (normal) distribution function with the given offset and scale parameters. </summary>
    </member>
    <member name="M:Mogre.Math.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="M:Mogre.Math.#ctor(System.UInt32)">
      <summary>Default constructor. </summary>
      <param name="trigTableSize">Optional parameter to set the size of the tables used to implement Sin, Cos, Tan </param>
    </member>
    <member name="T:Mogre.Math+AngleUnit">
      <summary>The angular units used by the API. This functionality is now deprecated in favor of discreet angular unit types ( see Degree and Radian above ). The only place this functionality is actually still used is when parsing files. Search for usage of the Angle class for those instances </summary>
    </member>
    <member name="T:Mogre.Vector3">
      <summary>Standard 3-dimensional vector. A direction in 3D space represented as distances along the 3 orthogonal axes (x, y, z). Note that positions, directions and scaling factors can be represented by a vector, depending on how you interpret the values. </summary>
    </member>
    <member name="M:Mogre.Vector3.DotProduct(Mogre.Vector3)">
      <summary>Calculates the dot (scalar) product of this vector with another. The dot product can be used to calculate the angle between 2 vectors. If both are unit vectors, the dot product is the cosine of the angle; otherwise the dot product must be divided by the product of the lengths of both vectors to get the cosine of the angle. This result can further be used to calculate the distance of a point from a plane. A float representing the dot product value. </summary>
      <param name="vec">Vector with which to calculate the dot product (together with this one). </param>
    </member>
    <member name="M:Mogre.Vector3.Normalise">
      <summary>Normalises the vector. This method normalises the vector such that it's length / magnitude is 1. The result is called a unit vector. This function will not crash for zero-sized vectors, but there will be no changes made to their components. The previous length of the vector. </summary>
    </member>
    <member name="M:Mogre.Vector3.CrossProduct(Mogre.Vector3)">
      <summary>Calculates the cross-product of 2 vectors, i.e. the vector that lies perpendicular to them both. The cross-product is normally used to calculate the normal vector of a plane, by calculating the cross-product of 2 non-equivalent vectors which lie on the plane (e.g. 2 edges of a triangle). A vector which is the result of the cross-product. This vector will NOT be normalised, to maximise efficiencycall Vector3::normalise on the result if you wish this to be done. As for which side the resultant vector will be on, the returned vector will be on the side from which the arc from 'this' to rkVector is anticlockwise, e.g. UNIT_Y.crossProduct(UNIT_Z) = UNIT_X, whilst UNIT_Z.crossProduct(UNIT_Y) = -UNIT_X. This is because OGRE uses a right-handed coordinate system. For a clearer explanation, look a the left and the bottom edges of your monitor's screen. Assume that the first vector is the left edge and the second vector is the bottom edge, both of them starting from the lower-left corner of the screen. The resulting vector is going to be perpendicular to both of them and will go inside the screen, towards the cathode tube (assuming you're using a CRT monitor, of course). </summary>
    </member>
    <member name="M:Mogre.Vector3.MidPoint(Mogre.Vector3)">
      <summary>Returns a vector at a point half way between this and the passed in vector. </summary>
    </member>
    <member name="M:Mogre.Vector3.MakeFloor(Mogre.Vector3)">
      <summary>Sets this vector's components to the minimum of its own and the ones of the passed in vector. 'Minimum' in this case means the combination of the lowest value of x, y and z from both vectors. Lowest is taken just numerically, not magnitude, so -1 &lt; 0. </summary>
    </member>
    <member name="M:Mogre.Vector3.MakeCeil(Mogre.Vector3)">
      <summary>Sets this vector's components to the maximum of its own and the ones of the passed in vector. 'Maximum' in this case means the combination of the highest value of x, y and z from both vectors. Highest is taken just numerically, not magnitude, so 1 &gt; -3. </summary>
    </member>
    <member name="M:Mogre.Vector3.RandomDeviant(Mogre.Radian,Mogre.Vector3)">
      <summary>Generates a new random vector which deviates from this vector by a given angle in a random direction. This method assumes that the random number generator has already been seeded appropriately. A random vector which deviates from this vector by angle. This vector will not be normalised, normalise it if you wish afterwards. </summary>
      <param name="angle">The angle at which to deviate </param>
      <param name="up">Any vector perpendicular to this one (which could generated by cross-product of this vector and any other non-colinear vector). If you choose not to provide this the function will derive one on it's own, however if you provide one yourself the function will be faster (this allows you to reuse up vectors if you call this method more than once) </param>
    </member>
    <member name="M:Mogre.Vector3.RandomDeviant(Mogre.Radian)">
      <summary>Generates a new random vector which deviates from this vector by a given angle in a random direction. This method assumes that the random number generator has already been seeded appropriately. A random vector which deviates from this vector by angle. This vector will not be normalised, normalise it if you wish afterwards. </summary>
      <param name="angle">The angle at which to deviate </param>
    </member>
    <member name="M:Mogre.Vector3.GetRotationTo(Mogre.Vector3)">
      <summary>Gets the shortest arc quaternion to rotate this vector to the destination vector. If you call this with a dest vector that is close to the inverse of this vector, we will rotate 180 degrees around the 'fallbackAxis' (if specified, or a generated axis if not) since in this case ANY axis of rotation is valid. </summary>
    </member>
    <member name="M:Mogre.Vector3.GetRotationTo(Mogre.Vector3,Mogre.Vector3)">
      <summary>Gets the shortest arc quaternion to rotate this vector to the destination vector. If you call this with a dest vector that is close to the inverse of this vector, we will rotate 180 degrees around the 'fallbackAxis' (if specified, or a generated axis if not) since in this case ANY axis of rotation is valid. </summary>
    </member>
    <member name="M:Mogre.Vector3.Reflect(Mogre.Vector3)">
      <summary>Calculates a reflection vector to the plane with the given normal . NB assumes 'this' is pointing AWAY FROM the plane, invert if it is not. </summary>
    </member>
    <member name="M:Mogre.Vector3.PositionEquals(Mogre.Vector3)">
      <summary>Returns whether this vector is within a positional tolerance of another vector. </summary>
      <param name="rhs">The vector to compare with </param>
    </member>
    <member name="M:Mogre.Vector3.PositionEquals(Mogre.Vector3,System.Single)">
      <summary>Returns whether this vector is within a positional tolerance of another vector. </summary>
      <param name="rhs">The vector to compare with </param>
      <param name="tolerance">The amount that each element of the vector may vary by and still be considered equal </param>
    </member>
    <member name="M:Mogre.Vector3.DirectionEquals(Mogre.Vector3,Mogre.Radian)">
      <summary>Returns whether this vector is within a directional tolerance of another vector. Both vectors should be normalised. </summary>
      <param name="rhs">The vector to compare with </param>
      <param name="tolerance">The maximum angle by which the vectors may vary and still be considered equal </param>
    </member>
    <member name="P:Mogre.Vector3.NormalisedCopy">
      <summary>As normalise, except that this vector is unaffected and the normalised vector is returned as a copy. </summary>
    </member>
    <member name="P:Mogre.Vector3.IsZeroLength">
      <summary>Returns true if this vector is zero length. </summary>
    </member>
    <member name="P:Mogre.Vector3.Perpendicular">
      <summary>Generates a vector perpendicular to this vector (eg an 'up' vector). This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the Quaternion class. </summary>
    </member>
    <member name="P:Mogre.Vector3.SquaredLength">
      <summary>Returns the square of the length(magnitude) of the vector. This method is for efficiency - calculating the actual length of a vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the length of the vector, i.e. the same as the length but before the square root is taken. Use this if you want to find the longest / shortest vector without incurring the square root. </summary>
    </member>
    <member name="P:Mogre.Vector3.Length">
      <summary>Returns the length (magnitude) of the vector. This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact length (e.g. for just comparing lengths) use squaredLength() instead. </summary>
    </member>
    <member name="T:Mogre.Matrix3">
      <summary>A 3x3 matrix which can represent rotations around axes. All the code is adapted from the Wild Magic 0.2 Matrix library (http://www.geometrictools.com/).The coordinate system is assumed to be right-handed. </summary>
    </member>
    <member name="M:Mogre.Matrix3.#ctor(System.Single[,])">
      <summary>Default constructor. It does NOT initialize the matrix for efficiency. </summary>
    </member>
    <member name="M:Mogre.Matrix3.#ctor">
      <summary>Default constructor. It does NOT initialize the matrix for efficiency. </summary>
    </member>
    <member name="T:Mogre.Quaternion">
      <summary>Implementation of a Quaternion, i.e. a rotation around an axis. </summary>
    </member>
    <member name="M:Mogre.Quaternion.Normalise">
      <summary>Normalises this quaternion, and returns the previous length. </summary>
    </member>
    <member name="M:Mogre.Quaternion.#ctor(System.Single[])">
      <summary>Construct a quaternion from 4 manual w/x/y/z values. </summary>
    </member>
    <member name="M:Mogre.Quaternion.#ctor(Mogre.Vector3[])">
      <summary>Construct a quaternion from 3 orthonormal local axes. </summary>
    </member>
    <member name="M:Mogre.Quaternion.#ctor(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Construct a quaternion from 3 orthonormal local axes. </summary>
    </member>
    <member name="M:Mogre.Quaternion.#ctor(Mogre.Radian,Mogre.Vector3)">
      <summary>Construct a quaternion from an angle/axis. </summary>
    </member>
    <member name="M:Mogre.Quaternion.#ctor(Mogre.Matrix3)">
      <summary>Construct a quaternion from a rotation matrix. </summary>
    </member>
    <member name="P:Mogre.Quaternion.Yaw">
      <summary>Calculate the local yaw element of this quaternion </summary>
    </member>
    <member name="P:Mogre.Quaternion.Pitch">
      <summary>Calculate the local pitch element of this quaternion </summary>
    </member>
    <member name="P:Mogre.Quaternion.Roll">
      <summary>Calculate the local roll element of this quaternion. </summary>
    </member>
    <member name="P:Mogre.Quaternion.ZAxis">
      <summary>Get the local z-axis. </summary>
    </member>
    <member name="P:Mogre.Quaternion.YAxis">
      <summary>Get the local y-axis. </summary>
    </member>
    <member name="P:Mogre.Quaternion.XAxis">
      <summary>Get the local x-axis. </summary>
    </member>
    <member name="T:Mogre.Vector4">
      <summary>4-dimensional homogeneous vector. </summary>
    </member>
    <member name="M:Mogre.Vector4.DotProduct(Mogre.Vector4)">
      <summary>Calculates the dot (scalar) product of this vector with another. A float representing the dot product value. </summary>
      <param name="vec">Vector with which to calculate the dot product (together with this one). </param>
    </member>
    <member name="T:Mogre.Plane">
      <summary>Defines a plane in 3D space. A plane is defined in 3D space by the equation Ax + By + Cz + D = 0 This equates to a vector (the normal of the plane, whose x, y and z components equate to the coefficients A, B and C respectively), and a constant (D) which is the distance along the normal you have to go to move the plane back to the origin. </summary>
    </member>
    <member name="M:Mogre.Plane.GetDistance(Mogre.Vector3)">
      <summary>This is a pseudodistance. The sign of the return value is positive if the point is on the positive side of the plane, negative if the point is on the negative side, and zero if the point is on the plane. The absolute value of the return value is the true distance only when the plane normal is a unit length vector. </summary>
    </member>
    <member name="M:Mogre.Plane.Redefine(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Redefine this plane based on 3 points. </summary>
    </member>
    <member name="M:Mogre.Plane.ProjectVector(Mogre.Vector3)">
      <summary>Project a vector onto the plane. This gives you the element of the input vector that is perpendicular to the normal of the plane. You can get the element which is parallel to the normal of the plane by subtracting the result of this method from the original vector, since parallel + perpendicular = original. </summary>
      <param name="v">The input vector </param>
    </member>
    <member name="M:Mogre.Plane.#ctor(Mogre.Vector3,System.Single)">
      <summary>Construct a plane through a normal, and a distance to move the plane along the normal. </summary>
    </member>
    <member name="T:Mogre.Plane+Side">
      <summary>The "positive side" of the plane is the half space to which the plane normal points. The "negative side" is the other half space. The flag "no side" indicates the plane itself. </summary>
    </member>
    <member name="T:Mogre.Matrix4">
      <summary>Class encapsulating a standard 4x4 homogeneous matrix. OGRE uses column vectors when applying matrix multiplications, This means a vector is represented as a single column, 4-row matrix. This has the effect that the transformations implemented by the matrices happens right-to-left e.g. if vector V is to be transformed by M1 then M2 then M3, the calculation would be M3 * M2 * M1 * V. The order that matrices are concatenated is vital since matrix multiplication is not commutative, i.e. you can get a different result if you concatenate in the wrong order. The use of column vectors and right-to-left ordering is the standard in most mathematical texts, and is the same as used in OpenGL. It is, however, the opposite of Direct3D, which has inexplicably chosen to differ from the accepted standard and uses row vectors and left-to-right matrix multiplication. OGRE deals with the differences between D3D and OpenGL etc. internally when operating through different render systems. OGRE users only need to conform to standard maths conventions, i.e. right-to-left matrix multiplication, (OGRE transposes matrices it passes to D3D to compensate). The generic form M * V which shows the layout of the matrix entries is shown below: 
                [ m[0][0]  m[0][1]  m[0][2]  m[0][3] ]   {x}
                | m[1][0]  m[1][1]  m[1][2]  m[1][3] | * {y}
                | m[2][0]  m[2][1]  m[2][2]  m[2][3] |   {z}
                [ m[3][0]  m[3][1]  m[3][2]  m[3][3] ]   {1}
            </summary>
    </member>
    <member name="M:Mogre.Matrix4.SetTrans(Mogre.Vector3)">
      <summary>Sets the translation transformation part of the matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.GetTrans(System.Single,System.Single,System.Single)">
      <summary>Gets a translation matrix - variation for not using a vector. </summary>
    </member>
    <member name="M:Mogre.Matrix4.GetTrans(Mogre.Vector3)">
      <summary>Gets a translation matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.GetTrans">
      <summary>Extracts the translation transformation part of the matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.MakeTrans(Mogre.Vector3)">
      <summary>Builds a translation matrix </summary>
    </member>
    <member name="M:Mogre.Matrix4.SetScale(Mogre.Vector3)">
      <summary>Sets the scale part of the matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.GetScale(System.Single,System.Single,System.Single)">
      <summary>Gets a scale matrix - variation for not using a vector. </summary>
    </member>
    <member name="M:Mogre.Matrix4.GetScale(Mogre.Vector3)">
      <summary>Gets a scale matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.Extract3x3Matrix">
      <summary>Extracts the rotation / scaling part of the Matrix as a 3x3 matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.ExtractQuaternion">
      <summary>Extracts the rotation / scaling part as a quaternion from the Matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.MakeTransform(Mogre.Vector3,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Building a Matrix4 from orientation / scale / position. Transform is performed in the order scale, rotate, translation, i.e. translation is independent of orientation axes, scale does not affect size of translation, rotation and scaling are always centered on the origin. </summary>
    </member>
    <member name="M:Mogre.Matrix4.MakeInverseTransform(Mogre.Vector3,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Building an inverse Matrix4 from orientation / scale / position. As makeTransform except it build the inverse given the same data as makeTransform, so performing -translation, -rotate, 1/scale in that order. </summary>
    </member>
    <member name="M:Mogre.Matrix4.InverseAffine">
      <summary>Returns the inverse of the affine matrix. The matrix must be an affine matrix.Matrix4::isAffine. </summary>
    </member>
    <member name="M:Mogre.Matrix4.ConcatenateAffine(Mogre.Matrix4)">
      <summary>Concatenate two affine matrices. The matrices must be affine matrix.Matrix4::isAffine. </summary>
    </member>
    <member name="M:Mogre.Matrix4.TransformAffine(Mogre.Vector4)">
      <summary>3-D Vector transformation specially for an affine matrix. Transforms the given 3-D vector by the matrix, projecting the result back into w = 1. The matrix must be an affine matrix.Matrix4::isAffine. </summary>
    </member>
    <member name="M:Mogre.Matrix4.TransformAffine(Mogre.Vector3)">
      <summary>3-D Vector transformation specially for an affine matrix. Transforms the given 3-D vector by the matrix, projecting the result back into w = 1. The matrix must be an affine matrix.Matrix4::isAffine. </summary>
    </member>
    <member name="M:Mogre.Matrix4.#ctor(Mogre.Quaternion)">
      <summary>Creates a standard 4x4 transformation matrix with a zero translation part from a rotation/scaling Quaternion. </summary>
    </member>
    <member name="M:Mogre.Matrix4.#ctor(Mogre.Matrix3)">
      <summary>Creates a standard 4x4 transformation matrix with a zero translation part from a rotation/scaling 3x3 matrix. </summary>
    </member>
    <member name="M:Mogre.Matrix4.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Default constructor. It does NOT initialize the matrix for efficiency. </summary>
    </member>
    <member name="M:Mogre.Matrix4.#ctor(Mogre.Matrix4)">
      <summary>Default constructor. It does NOT initialize the matrix for efficiency. </summary>
    </member>
    <member name="M:Mogre.Matrix4.#ctor">
      <summary>Default constructor. It does NOT initialize the matrix for efficiency. </summary>
    </member>
    <member name="P:Mogre.Matrix4.IsAffine">
      <summary>Check whether or not the matrix is affine matrix. An affine matrix is a 4x4 matrix with row 3 equal to (0, 0, 0, 1), e.g. no projective coefficients. </summary>
    </member>
    <member name="F:Mogre.Matrix4.CLIPSPACE2DTOIMAGESPACE">
      <summary>Useful little matrix which takes 2D clipspace {-1, 1} to {0,1} and inverts the Y. </summary>
    </member>
    <member name="T:Mogre.Sphere">
      <summary>A sphere primitive, mostly used for bounds checking. A sphere in math texts is normally represented by the function x^2 + y^2 + z^2 = r^2 (for sphere's centered on the origin). Ogre stores spheres simply as a center point and a radius. </summary>
    </member>
    <member name="M:Mogre.Sphere.Intersects(Mogre.Vector3)">
      <summary>Returns whether or not this sphere intersects another sphere. </summary>
    </member>
    <member name="M:Mogre.Sphere.Intersects(Mogre.Plane)">
      <summary>Returns whether or not this sphere intersects another sphere. </summary>
    </member>
    <member name="M:Mogre.Sphere.Intersects(Mogre.AxisAlignedBox)">
      <summary>Returns whether or not this sphere intersects another sphere. </summary>
    </member>
    <member name="M:Mogre.Sphere.Intersects(Mogre.Sphere)">
      <summary>Returns whether or not this sphere intersects another sphere. </summary>
    </member>
    <member name="M:Mogre.Sphere.#ctor(Mogre.Vector3,System.Single)">
      <summary>Constructor allowing arbitrary spheres. </summary>
      <param name="center">The center point of the sphere. </param>
      <param name="radius">The radius of the sphere. </param>
    </member>
    <member name="P:Mogre.Sphere.Center">
      <summary>Sets/Returns the center point of the sphere. </summary>
    </member>
    <member name="P:Mogre.Sphere.Radius">
      <summary>Sets/Returns the radius of the sphere. </summary>
    </member>
    <member name="T:Mogre.AxisAlignedBox">
      <summary>A 3D box aligned with the x/y/z axes. This class represents a simple box which is aligned with the axes. Internally it only stores 2 points as the extremeties of the box, one which is the minima of all 3 axes, and the other which is the maxima of all 3 axes. This class is typically used for an axis-aligned bounding box (AABB) for collision and visibility determination. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.SetMinimum(Mogre.Vector3)">
      <summary>Sets the minimum corner of the box. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.SetMinimumX(System.Single)">
      <summary>Changes one of the components of the minimum corner of the box used to resize only one dimension of the box </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.SetMaximum(Mogre.Vector3)">
      <summary>Sets the maximum corner of the box. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.SetMaximumX(System.Single)">
      <summary>Changes one of the components of the maximum corner of the box used to resize only one dimension of the box </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.SetExtents(Mogre.Vector3,Mogre.Vector3)">
      <summary>Sets both minimum and maximum extents at once. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.GetAllCorners">
      <summary>Returns a pointer to an array of 8 corner points, useful for collision vs. non-aligned objects. If the order of these corners is important, they are as follows: The 4 points of the minimum Z face (note that because Ogre uses right-handed coordinates, the minimum Z is at the 'back' of the box) starting with the minimum point of all, then anticlockwise around this face (if you are looking onto the face from outside the box). Then the 4 points of the maximum Z face, starting with maximum point of all, then anticlockwise around this face (looking onto the face from outside the box). Like this: 
		1-----2
		/|    /|
		/ |   / |
		5-----4  |
		|  0--|--3
		| /   | /
		|/    |/
		6-----7
		as this implementation uses a static member, make sure to use your own copy ! </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.GetCorner(Mogre.AxisAlignedBox+CornerEnum)">
      <summary>gets the position of one of the corners </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Merge(Mogre.Vector3)">
      <summary>Extends the box to encompass the specified point (if needed). </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Merge(Mogre.AxisAlignedBox)">
      <summary>Merges the passed in box into the current box. The result is the box which encompasses both. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Transform(Mogre.Matrix4)">
      <summary>Transforms the box according to the matrix supplied. By calling this method you get the axis-aligned box which surrounds the transformed version of this box. Therefore each corner of the box is transformed by the matrix, then the extents are mapped back onto the axes to produce another AABB. Useful when you have a local AABB for an object which is then transformed. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.TransformAffine(Mogre.Matrix4)">
      <summary>Transforms the box according to the affine matrix supplied. By calling this method you get the axis-aligned box which surrounds the transformed version of this box. Therefore each corner of the box is transformed by the matrix, then the extents are mapped back onto the axes to produce another AABB. Useful when you have a local AABB for an object which is then transformed. The matrix must be an affine matrix.Matrix4::isAffine. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.SetNull">
      <summary>Sets the box to a 'null' value i.e. not a box. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.SetInfinite">
      <summary>Sets the box to 'infinite' </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Intersects(Mogre.Vector3)">
      <summary>Returns whether or not this box intersects another. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Intersects(Mogre.Plane)">
      <summary>Returns whether or not this box intersects another. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Intersects(Mogre.Sphere)">
      <summary>Returns whether or not this box intersects another. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Intersects(Mogre.AxisAlignedBox)">
      <summary>Returns whether or not this box intersects another. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Intersection(Mogre.AxisAlignedBox)">
      <summary>Calculate the area of intersection of this box and another. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Volume">
      <summary>Calculate the volume of this box. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Scale(Mogre.Vector3)">
      <summary>Scales the AABB by the vector given. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Contains(Mogre.AxisAlignedBox)">
      <summary>Tests whether the given point contained by this box. </summary>
    </member>
    <member name="M:Mogre.AxisAlignedBox.Contains(Mogre.Vector3)">
      <summary>Tests whether the given point contained by this box. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBox.HalfSize">
      <summary>Gets the half-size of the box. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBox.Size">
      <summary>Gets the size of the box. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBox.Center">
      <summary>Gets the centre of the box. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBox.IsInfinite">
      <summary>Returns true if the box is infinite. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBox.IsFinite">
      <summary>Returns true if the box is finite. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBox.Maximum">
      <summary>Gets the maximum corner of the box. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBox.Minimum">
      <summary>Gets the minimum corner of the box. </summary>
    </member>
    <member name="T:Mogre.ColourValue">
      <summary>Class representing colour. Colour is represented as 4 components, each of which is a floating-point value from 0.0 to 1.0. The 3 'normal' colour components are red, green and blue, a higher number indicating greater amounts of that component in the colour. The forth component is the 'alpha' value, which represents transparency. In this case, 0.0 is completely transparent and 1.0 is fully opaque. </summary>
    </member>
    <member name="M:Mogre.ColourValue.GetAsRGBA">
      <summary>Retrieves colour as RGBA. </summary>
    </member>
    <member name="M:Mogre.ColourValue.GetAsARGB">
      <summary>Retrieves colour as ARGB. </summary>
    </member>
    <member name="M:Mogre.ColourValue.GetAsBGRA">
      <summary>Retrieves colour as BGRA. </summary>
    </member>
    <member name="M:Mogre.ColourValue.GetAsABGR">
      <summary>Retrieves colours as ABGR </summary>
    </member>
    <member name="M:Mogre.ColourValue.SetAsRGBA(System.UInt32)">
      <summary>Sets colour as RGBA. </summary>
    </member>
    <member name="M:Mogre.ColourValue.SetAsARGB(System.UInt32)">
      <summary>Sets colour as ARGB. </summary>
    </member>
    <member name="M:Mogre.ColourValue.SetAsBGRA(System.UInt32)">
      <summary>Sets colour as BGRA. </summary>
    </member>
    <member name="M:Mogre.ColourValue.SetAsABGR(System.UInt32)">
      <summary>Sets colour as ABGR. </summary>
    </member>
    <member name="M:Mogre.ColourValue.Saturate">
      <summary>Clamps colour value to the range [0, 1]. </summary>
    </member>
    <member name="M:Mogre.ColourValue.SaturateCopy">
      <summary>As saturate, except that this colour value is unaffected and the saturated colour value is returned as a copy. </summary>
    </member>
    <member name="M:Mogre.ColourValue.SetHSB(System.Single,System.Single,System.Single)">
      <summary>Set a colour value from Hue, Saturation and Brightness. </summary>
      <param name="hue">Hue value, scaled to the [0,1] range as opposed to the 0-360 </param>
      <param name="saturation">Saturation level, [0,1] </param>
      <param name="brightness">Brightness level, [0,1] </param>
    </member>
    <member name="T:Mogre.PlaneBoundedVolume">
      <summary>Represents a convex volume bounded by planes. </summary>
    </member>
    <member name="M:Mogre.PlaneBoundedVolume.Intersects(Mogre.Ray)">
      <summary>Intersection test with a Raystd::pair of hit (bool) and distance May return false positives but will never miss an intersection. </summary>
    </member>
    <member name="M:Mogre.PlaneBoundedVolume.Intersects(Mogre.Sphere)">
      <summary>Intersection test with AABB May return false positives but will never miss an intersection. </summary>
    </member>
    <member name="M:Mogre.PlaneBoundedVolume.Intersects(Mogre.AxisAlignedBox)">
      <summary>Intersection test with AABB May return false positives but will never miss an intersection. </summary>
    </member>
    <member name="M:Mogre.PlaneBoundedVolume.#ctor(Mogre.Plane+Side)">
      <summary>Constructor, determines which side is deemed to be 'outside' </summary>
    </member>
    <member name="P:Mogre.PlaneBoundedVolume.planes">
      <summary>Publicly accessible plane list, you can modify this direct. </summary>
    </member>
    <member name="T:Mogre.Ray">
      <summary>Representation of a ray in space, i.e. a line with an origin and direction. </summary>
    </member>
    <member name="M:Mogre.Ray.GetPoint(System.Single)">
      <summary>Gets the position of a point t units along the ray. </summary>
    </member>
    <member name="M:Mogre.Ray.Intersects(Mogre.AxisAlignedBox)">
      <summary>Tests whether this ray intersects the given plane. A pair structure where the first element indicates whether an intersection occurs, and if true, the second element will indicate the distance along the ray at which it intersects. This can be converted to a point in space by calling getPoint(). </summary>
    </member>
    <member name="M:Mogre.Ray.Intersects(Mogre.Sphere)">
      <summary>Tests whether this ray intersects the given plane. A pair structure where the first element indicates whether an intersection occurs, and if true, the second element will indicate the distance along the ray at which it intersects. This can be converted to a point in space by calling getPoint(). </summary>
    </member>
    <member name="M:Mogre.Ray.Intersects(Mogre.PlaneBoundedVolume)">
      <summary>Tests whether this ray intersects the given plane. A pair structure where the first element indicates whether an intersection occurs, and if true, the second element will indicate the distance along the ray at which it intersects. This can be converted to a point in space by calling getPoint(). </summary>
    </member>
    <member name="M:Mogre.Ray.Intersects(Mogre.Plane)">
      <summary>Tests whether this ray intersects the given plane. A pair structure where the first element indicates whether an intersection occurs, and if true, the second element will indicate the distance along the ray at which it intersects. This can be converted to a point in space by calling getPoint(). </summary>
    </member>
    <member name="P:Mogre.Ray.Direction">
      <summary>Sets/Gets the direction of the ray. </summary>
    </member>
    <member name="P:Mogre.Ray.Origin">
      <summary>Sets/Gets the origin of the ray. </summary>
    </member>
    <member name="T:Mogre.FloatRect">
      <summary>Structure used to define a rectangle in a 2-D floating point space. </summary>
    </member>
    <member name="T:Mogre.RealRect">
      <summary>Structure used to define a rectangle in a 2-D floating point space, subject to double / single floating point settings. </summary>
    </member>
    <member name="T:Mogre.Rect">
      <summary>Structure used to define a rectangle in a 2-D integer space. </summary>
    </member>
    <member name="T:Mogre.Vector2">
      <summary>Standard 2-dimensional vector. A direction in 2D space represented as distances along the 2 orthogonal axes (x, y). Note that positions, directions and scaling factors can be represented by a vector, depending on how you interpret the values. </summary>
    </member>
    <member name="M:Mogre.Vector2.DotProduct(Mogre.Vector2)">
      <summary>Calculates the dot (scalar) product of this vector with another. The dot product can be used to calculate the angle between 2 vectors. If both are unit vectors, the dot product is the cosine of the angle; otherwise the dot product must be divided by the product of the lengths of both vectors to get the cosine of the angle. This result can further be used to calculate the distance of a point from a plane. A float representing the dot product value. </summary>
      <param name="vec">Vector with which to calculate the dot product (together with this one). </param>
    </member>
    <member name="M:Mogre.Vector2.Normalise">
      <summary>Normalises the vector. This method normalises the vector such that it's length / magnitude is 1. The result is called a unit vector. This function will not crash for zero-sized vectors, but there will be no changes made to their components. The previous length of the vector. </summary>
    </member>
    <member name="M:Mogre.Vector2.MidPoint(Mogre.Vector2)">
      <summary>Returns a vector at a point half way between this and the passed in vector. </summary>
    </member>
    <member name="M:Mogre.Vector2.MakeFloor(Mogre.Vector2)">
      <summary>Sets this vector's components to the minimum of its own and the ones of the passed in vector. 'Minimum' in this case means the combination of the lowest value of x, y and z from both vectors. Lowest is taken just numerically, not magnitude, so -1 &lt; 0. </summary>
    </member>
    <member name="M:Mogre.Vector2.MakeCeil(Mogre.Vector2)">
      <summary>Sets this vector's components to the maximum of its own and the ones of the passed in vector. 'Maximum' in this case means the combination of the highest value of x, y and z from both vectors. Highest is taken just numerically, not magnitude, so 1 &gt; -3. </summary>
    </member>
    <member name="M:Mogre.Vector2.CrossProduct(Mogre.Vector2)">
      <summary>Calculates the 2 dimensional cross-product of 2 vectors, which results in a single floating point value which is 2 times the area of the triangle. </summary>
    </member>
    <member name="M:Mogre.Vector2.RandomDeviant(System.Single)">
      <summary>Generates a new random vector which deviates from this vector by a given angle in a random direction. This method assumes that the random number generator has already been seeded appropriately. A random vector which deviates from this vector by angle. This vector will not be normalised, normalise it if you wish afterwards. </summary>
      <param name="angle">The angle at which to deviate in radians </param>
    </member>
    <member name="M:Mogre.Vector2.Reflect(Mogre.Vector2)">
      <summary>Calculates a reflection vector to the plane with the given normal . NB assumes 'this' is pointing AWAY FROM the plane, invert if it is not. </summary>
    </member>
    <member name="P:Mogre.Vector2.NormalisedCopy">
      <summary>As normalise, except that this vector is unaffected and the normalised vector is returned as a copy. </summary>
    </member>
    <member name="P:Mogre.Vector2.IsZeroLength">
      <summary>Returns true if this vector is zero length. </summary>
    </member>
    <member name="P:Mogre.Vector2.Perpendicular">
      <summary>Generates a vector perpendicular to this vector (eg an 'up' vector). This method will return a vector which is perpendicular to this vector. There are an infinite number of possibilities but this method will guarantee to generate one of them. If you need more control you should use the Quaternion class. </summary>
    </member>
    <member name="P:Mogre.Vector2.SquaredLength">
      <summary>Returns the square of the length(magnitude) of the vector. This method is for efficiency - calculating the actual length of a vector requires a square root, which is expensive in terms of the operations required. This method returns the square of the length of the vector, i.e. the same as the length but before the square root is taken. Use this if you want to find the longest / shortest vector without incurring the square root. </summary>
    </member>
    <member name="P:Mogre.Vector2.Length">
      <summary>Returns the length (magnitude) of the vector. This operation requires a square root and is expensive in terms of CPU operations. If you don't need to know the exact length (e.g. for just comparing lengths) use squaredLength() instead. </summary>
    </member>
    <member name="T:Mogre.ParamCommand">
      <summary>Abstract class which is command object which gets/sets parameters. </summary>
    </member>
    <member name="T:Mogre.PixelUtil">
      <summary>Some utility functions for packing and unpacking pixel data </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetNumElemBytes(Mogre.PixelFormat)">
      <summary>Returns the size in bytes of an element of the given pixel format. The size in bytes of an element. See Remarks. Passing PF_UNKNOWN will result in returning a size of 0 bytes. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetNumElemBits(Mogre.PixelFormat)">
      <summary>Returns the size in bits of an element of the given pixel format. The size in bits of an element. See Remarks. Passing PF_UNKNOWN will result in returning a size of 0 bits. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetMemorySize(System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat)">
      <summary>Returns the size in memory of a region with the given extents and pixel format with consecutive memory layout. The size in bytes In case that the format is non-compressed, this simply returns width*height*depth*PixelUtilgetNumElemBytes(format). In the compressed case, this does serious magic. </summary>
      <param name="width">The width of the area </param>
      <param name="height">The height of the area </param>
      <param name="depth">The depth of the area </param>
      <param name="format">The format of the area </param>
    </member>
    <member name="M:Mogre.PixelUtil.GetFlags(Mogre.PixelFormat)">
      <summary>Returns the property flags for this pixel format A bitfield combination of PFF_HASALPHA, PFF_ISCOMPRESSED, PFF_FLOAT, PFF_DEPTH, PFF_NATIVEENDIAN, PFF_LUMINANCE This replaces the seperate functions for formatHasAlpha, formatIsFloat, ... </summary>
    </member>
    <member name="M:Mogre.PixelUtil.HasAlpha(Mogre.PixelFormat)">
      <summary>Shortcut method to determine if the format has an alpha component </summary>
    </member>
    <member name="M:Mogre.PixelUtil.IsFloatingPoint(Mogre.PixelFormat)">
      <summary>Shortcut method to determine if the format is floating point </summary>
    </member>
    <member name="M:Mogre.PixelUtil.IsCompressed(Mogre.PixelFormat)">
      <summary>Shortcut method to determine if the format is compressed </summary>
    </member>
    <member name="M:Mogre.PixelUtil.IsDepth(Mogre.PixelFormat)">
      <summary>Shortcut method to determine if the format is a depth format. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.IsNativeEndian(Mogre.PixelFormat)">
      <summary>Shortcut method to determine if the format is in native endian format. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.IsLuminance(Mogre.PixelFormat)">
      <summary>Shortcut method to determine if the format is a luminance format. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.IsValidExtent(System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat)">
      <summary>Return wether a certain image extent is valid for this image format. For non-compressed formats, this is always true. For DXT formats, only sizes with a width and height multiple of 4 and depth 1 are allowed. </summary>
      <param name="width">The width of the area </param>
      <param name="height">The height of the area </param>
      <param name="depth">The depth of the area </param>
      <param name="format">The format of the area </param>
    </member>
    <member name="M:Mogre.PixelUtil.GetBitDepths(Mogre.PixelFormat,System.Int32[]&amp;)">
      <summary>Gives the number of bits (RGBA) for a format. See remarks. For non-colour formats (dxt, depth) this returns [0,0,0,0]. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetBitMasks(Mogre.PixelFormat,System.UInt32[]&amp;)">
      <summary>Gives the masks for the R, G, B and A component Only valid for native endian formats </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetBitShifts(Mogre.PixelFormat,System.Byte[]&amp;)">
      <summary>Gives the bit shifts for R, G, B and A component Only valid for native endian formats </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetFormatName(Mogre.PixelFormat)">
      <summary>Gets the name of an image format </summary>
    </member>
    <member name="M:Mogre.PixelUtil.IsAccessible(Mogre.PixelFormat)">
      <summary>Returns wether the format can be packed or unpacked with the packColour() and unpackColour() functions. This is generally not true for compressed and depth formats as they are special. It can only be true for formats with a fixed element size. true if yes, otherwise false </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetComponentType(Mogre.PixelFormat)">
      <summary>Returns the component type for a certain pixel format. Returns PCT_BYTE in case there is no clear component type like with compressed formats. This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetComponentCount(Mogre.PixelFormat)">
      <summary>Returns the component count for a certain pixel format. Returns 3(no alpha) or 4 (has alpha) in case there is no clear component type like with compressed formats. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetFormatFromName(System.String)">
      <summary>Gets the format from given name. The format match the format name, or PF_UNKNOWN if is invalid name. </summary>
      <param name="name">The string of format name </param>
    </member>
    <member name="M:Mogre.PixelUtil.GetFormatFromName(System.String,System.Boolean)">
      <summary>Gets the format from given name. The format match the format name, or PF_UNKNOWN if is invalid name. </summary>
      <param name="name">The string of format name </param>
      <param name="accessibleOnly">If true, non-accessible format will treat as invalid format, otherwise, all supported format are valid. </param>
    </member>
    <member name="M:Mogre.PixelUtil.GetFormatFromName(System.String,System.Boolean,System.Boolean)">
      <summary>Gets the format from given name. The format match the format name, or PF_UNKNOWN if is invalid name. </summary>
      <param name="name">The string of format name </param>
      <param name="accessibleOnly">If true, non-accessible format will treat as invalid format, otherwise, all supported format are valid. </param>
      <param name="caseSensitive">Should be set true if string match should use case sensitivity. </param>
    </member>
    <member name="M:Mogre.PixelUtil.GetBNFExpressionOfPixelFormats">
      <summary>Gets the BNF expression of the pixel-formats. The string returned by this function is intented to use as a BNF expression to work with Compiler2Pass. A string contains the BNF expression. </summary>
    </member>
    <member name="M:Mogre.PixelUtil.GetBNFExpressionOfPixelFormats(System.Boolean)">
      <summary>Gets the BNF expression of the pixel-formats. The string returned by this function is intented to use as a BNF expression to work with Compiler2Pass. A string contains the BNF expression. </summary>
      <param name="accessibleOnly">If true, only accessible pixel format will take into account, otherwise all pixel formats list in PixelFormat enumeration will being returned. </param>
    </member>
    <member name="M:Mogre.PixelUtil.GetFormatForBitDepths(Mogre.PixelFormat,System.UInt16,System.UInt16)">
      <summary>Returns the similar format but acoording with given bit depths. The format that similar original format with bit depth according with preferred bit depth, or original format if no convertion occuring. </summary>
      <param name="fmt">The original foamt. </param>
      <param name="integerBits">Preferred bit depth (pixel bits) for integer pixel format. Available values: 0, 16 and 32, where 0 (the default) means as it is. </param>
      <param name="floatBits">Preferred bit depth (channel bits) for float pixel format. Available values: 0, 16 and 32, where 0 (the default) means as it is. </param>
    </member>
    <member name="M:Mogre.PixelUtil.PackColour(System.Single,System.Single,System.Single,System.Single,Mogre.PixelFormat,System.Void*)">
      <summary>Pack a colour value to memory </summary>
      <param name="r">The four colour components, range 0x00 to 0xFF </param>
      <param name="pf">Pixelformat in which to write the colour </param>
      <param name="dest">Destination memory location </param>
    </member>
    <member name="M:Mogre.PixelUtil.PackColour(System.Byte,System.Byte,System.Byte,System.Byte,Mogre.PixelFormat,System.Void*)">
      <summary>Pack a colour value to memory </summary>
      <param name="r">The four colour components, range 0x00 to 0xFF </param>
      <param name="pf">Pixelformat in which to write the colour </param>
      <param name="dest">Destination memory location </param>
    </member>
    <member name="M:Mogre.PixelUtil.PackColour(Mogre.ColourValue,Mogre.PixelFormat,System.Void*)">
      <summary>Pack a colour value to memory </summary>
      <param name="colour">The colour </param>
      <param name="pf">Pixelformat in which to write the colour </param>
      <param name="dest">Destination memory location </param>
    </member>
    <member name="M:Mogre.PixelUtil.UnpackColour(System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;,Mogre.PixelFormat,System.Void*)">
      <summary>Unpack a colour value from memory This function returns the colour components in 8 bit precision, this will lose precision when coming from PF_A2R10G10B10 or floating point formats. </summary>
      <param name="r">The colour is returned here (as byte) </param>
      <param name="pf">Pixelformat in which to read the colour </param>
      <param name="src">Source memory location </param>
    </member>
    <member name="M:Mogre.PixelUtil.UnpackColour(System.Byte&amp;,System.Byte&amp;,System.Byte&amp;,System.Byte&amp;,Mogre.PixelFormat,System.Void*)">
      <summary>Unpack a colour value from memory This function returns the colour components in 8 bit precision, this will lose precision when coming from PF_A2R10G10B10 or floating point formats. </summary>
      <param name="r">The colour is returned here (as byte) </param>
      <param name="pf">Pixelformat in which to read the colour </param>
      <param name="src">Source memory location </param>
    </member>
    <member name="M:Mogre.PixelUtil.UnpackColour(Mogre.ColourValue*,Mogre.PixelFormat,System.Void*)">
      <summary>Unpack a colour value from memory </summary>
      <param name="colour">The colour is returned here </param>
      <param name="pf">Pixelformat in which to read the colour </param>
      <param name="src">Source memory location </param>
    </member>
    <member name="M:Mogre.PixelUtil.BulkPixelConversion(Mogre.PixelBox,Mogre.PixelBox)">
      <summary>Convert pixels from one format to another. No dithering or filtering is being done. Converting from RGB to luminance takes the R channel. The source and destination boxes must have the same dimensions. In case the source and destination format match, a plain copy is done. </summary>
      <param name="src">PixelBox containing the source pixels, pitches and format </param>
      <param name="dst">PixelBox containing the destination pixels, pitches and format </param>
    </member>
    <member name="M:Mogre.PixelUtil.BulkPixelConversion(System.Void*,Mogre.PixelFormat,System.Void*,Mogre.PixelFormat,System.UInt32)">
      <summary>Convert consecutive pixels from one format to another. No dithering or filtering is being done. Converting from RGB to luminance takes the R channel. In case the source and destination format match, just a copy is done. </summary>
      <param name="src">Pointer to source region </param>
      <param name="srcFormat">Pixel format of source region </param>
      <param name="dstFormat">Pixel format of destination region </param>
    </member>
    <member name="T:Mogre.Box">
      <summary>Structure used to define a box in a 3-D integer space. Note that the left, top, and front edges are included but the right, bottom and back ones are not. </summary>
    </member>
    <member name="M:Mogre.Box.Contains(Mogre.Box)">
      <summary>Return true if the other box is a part of this one. </summary>
    </member>
    <member name="M:Mogre.Box.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Define a box from left, top, front, right, bottom and back coordinates. Note that the left, top, and front edges are included but the right, bottom and back ones are not. </summary>
      <param name="l">x value of left edge </param>
      <param name="t">y value of top edge </param>
      <param name="ff">z value of front edge </param>
      <param name="r">x value of right edge </param>
      <param name="b">y value of bottom edge </param>
      <param name="bb">z value of back edge </param>
    </member>
    <member name="M:Mogre.Box.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Define a box from left, top, right and bottom coordinates This box will have depth one (front=0 and back=1). Note that the left, top, and front edges are included but the right, bottom and back ones are not. </summary>
      <param name="l">x value of left edge </param>
      <param name="t">y value of top edge </param>
      <param name="r">x value of right edge </param>
      <param name="b">y value of bottom edge </param>
    </member>
    <member name="P:Mogre.Box.Depth">
      <summary>Get the depth of this box. </summary>
    </member>
    <member name="P:Mogre.Box.Height">
      <summary>Get the height of this box. </summary>
    </member>
    <member name="P:Mogre.Box.Width">
      <summary>Get the width of this box. </summary>
    </member>
    <member name="T:Mogre.PixelBox">
      <summary>A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory. In case of a rectangle, depth must be 1. Pixels are stored as a succession of "depth" slices, each containing "height" rows of "width" pixels. </summary>
    </member>
    <member name="M:Mogre.PixelBox.setConsecutive">
      <summary>Set the rowPitch and slicePitch so that the buffer is laid out consecutive in memory. </summary>
    </member>
    <member name="M:Mogre.PixelBox.GetConsecutiveSize">
      <summary>Return the size (in bytes) this image would take if it was laid out consecutive in memory </summary>
    </member>
    <member name="M:Mogre.PixelBox.GetSubVolume(Mogre.Box)">
      <summary>Return a subvolume of this PixelBox. A pixel box describing the region and the data in it This function does not copy any data, it just returns a PixelBox object with a data pointer pointing somewhere inside the data of object. Exception(ERR_INVALIDPARAMS)if def is not fully contained </summary>
      <param name="def">Defines the bounds of the subregion to return </param>
    </member>
    <member name="M:Mogre.PixelBox.#ctor(System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat)">
      <summary>Constructor providing width, height and depth. This constructor assumes the pixel data is laid out consecutively in memory. (this means row after row, slice after slice, with no space in between) </summary>
      <param name="width">Width of the region </param>
      <param name="height">Height of the region </param>
      <param name="depth">Depth of the region </param>
      <param name="pixelFormat">Format of this buffer </param>
    </member>
    <member name="M:Mogre.PixelBox.#ctor(System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat,System.IntPtr)">
      <summary>Constructor providing width, height and depth. This constructor assumes the pixel data is laid out consecutively in memory. (this means row after row, slice after slice, with no space in between) </summary>
      <param name="width">Width of the region </param>
      <param name="height">Height of the region </param>
      <param name="depth">Depth of the region </param>
      <param name="pixelFormat">Format of this buffer </param>
      <param name="pixelData">Pointer to the actual data </param>
    </member>
    <member name="M:Mogre.PixelBox.#ctor(Mogre.Box,Mogre.PixelFormat)">
      <summary>Constructor providing extents in the form of a Box object. This constructor assumes the pixel data is laid out consecutively in memory. (this means row after row, slice after slice, with no space in between) </summary>
      <param name="extents">Extents of the region defined by data </param>
      <param name="pixelFormat">Format of this buffer </param>
    </member>
    <member name="M:Mogre.PixelBox.#ctor(Mogre.Box,Mogre.PixelFormat,System.IntPtr)">
      <summary>Constructor providing extents in the form of a Box object. This constructor assumes the pixel data is laid out consecutively in memory. (this means row after row, slice after slice, with no space in between) </summary>
      <param name="extents">Extents of the region defined by data </param>
      <param name="pixelFormat">Format of this buffer </param>
      <param name="pixelData">Pointer to the actual data </param>
    </member>
    <member name="P:Mogre.PixelBox.IsConsecutive">
      <summary>Return whether this buffer is laid out consecutive in memory (ie the pitches are equal to the dimensions) </summary>
    </member>
    <member name="P:Mogre.PixelBox.SliceSkip">
      <summary>Get the number of elements between one past the right bottom pixel of one slice and the left top pixel of the next slice. (IE this is zero if slices are consecutive). </summary>
    </member>
    <member name="P:Mogre.PixelBox.RowSkip">
      <summary>Get the number of elements between one past the rightmost pixel of one row and the leftmost pixel of the next row. (IE this is zero if rows are consecutive). </summary>
    </member>
    <member name="F:Mogre.PixelBox.data">
      <summary>The data pointer. </summary>
    </member>
    <member name="F:Mogre.PixelBox.format">
      <summary>The pixel format. </summary>
    </member>
    <member name="F:Mogre.PixelBox.rowPitch">
      <summary>Number of elements between the leftmost pixel of one row and the left pixel of the next. This value must always be equal to getWidth() (consecutive) for compressed formats. </summary>
    </member>
    <member name="F:Mogre.PixelBox.slicePitch">
      <summary>Number of elements between the top left pixel of one (depth) slice and the top left pixel of the next. This can be a negative value. Must be a multiple of rowPitch. This value must always be equal to getWidth()*getHeight() (consecutive) for compressed formats. </summary>
    </member>
    <member name="T:Mogre.DataStream">
      <summary>General purpose class used for encapsulating the reading and writing of data. This class performs basically the same tasks as std::basic_istream, except that it does not have any formatting capabilities, and is designed to be subclassed to receive data from multiple sources, including libraries which have no compatibility with the STL's stream interfaces. As such, this is an abstraction of a set of wrapper classes which pretend to be standard stream classes but can actually be implemented quite differently. Generally, if a plugin or application provides an ArchiveFactory, it should also provide a DataStream subclass which will be used to stream data out of that Archive implementation, unless it can use one of the common implementations included. Ogre makes no guarantees about thread safety, for performance reasons. If you wish to access stream data asynchronously then you should organise your own mutexes to avoid race conditions. </summary>
    </member>
    <member name="M:Mogre.DataStream.GetAccessMode">
      <summary>Gets the access mode of the stream. </summary>
    </member>
    <member name="M:Mogre.DataStream.Read(System.Void*,System.UInt32)">
      <summary>Read the requisite number of bytes from the stream, stopping at the end of the file. The number of bytes read </summary>
      <param name="buf">Reference to a buffer pointer </param>
      <param name="count">Number of bytes to read </param>
    </member>
    <member name="M:Mogre.DataStream.Write(System.Void*,System.UInt32)">
      <summary>Write the requisite number of bytes from the stream (only applicable to streams that are not read-only) The number of bytes written </summary>
      <param name="buf">Pointer to a buffer containing the bytes to write </param>
      <param name="count">Number of bytes to write </param>
    </member>
    <member name="M:Mogre.DataStream.ReadLine(System.SByte&amp;,System.UInt32)">
      <summary>Get a single line from the stream. The delimiter character is not included in the data returned, and it is skipped over so the next read will occur after it. The buffer contents will include a terminating character. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. The number of bytes read, excluding the terminating character </summary>
      <param name="buf">Reference to a buffer pointer </param>
      <param name="maxCount">The maximum length of data to be read, excluding the terminating character </param>
    </member>
    <member name="M:Mogre.DataStream.ReadLine(System.SByte&amp;,System.UInt32,System.String)">
      <summary>Get a single line from the stream. The delimiter character is not included in the data returned, and it is skipped over so the next read will occur after it. The buffer contents will include a terminating character. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. The number of bytes read, excluding the terminating character </summary>
      <param name="buf">Reference to a buffer pointer </param>
      <param name="maxCount">The maximum length of data to be read, excluding the terminating character </param>
      <param name="delim">The delimiter to stop at </param>
    </member>
    <member name="M:Mogre.DataStream.GetLine">
      <summary>Returns a String containing the next line of data, optionally trimmed for whitespace. This is a convenience method for text streams only, allowing you to retrieve a String object containing the next line of data. The data is read up to the next newline character and the result trimmed if required. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. </summary>
    </member>
    <member name="M:Mogre.DataStream.GetLine(System.Boolean)">
      <summary>Returns a String containing the next line of data, optionally trimmed for whitespace. This is a convenience method for text streams only, allowing you to retrieve a String object containing the next line of data. The data is read up to the next newline character and the result trimmed if required. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. </summary>
      <param name="trimAfter">If true, the line is trimmed for whitespace (as in String.trim(true,true)) </param>
    </member>
    <member name="M:Mogre.DataStream.SkipLine">
      <summary>Skip a single line from the stream. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. The number of bytes skipped </summary>
    </member>
    <member name="M:Mogre.DataStream.SkipLine(System.String)">
      <summary>Skip a single line from the stream. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. The number of bytes skipped </summary>
      <param name="delim">The delimiter(s) to stop at </param>
    </member>
    <member name="M:Mogre.DataStream.Skip(System.Int32)">
      <summary>Skip a defined number of bytes. This can also be a negative value, in which case the file pointer rewinds a defined number of bytes. </summary>
    </member>
    <member name="M:Mogre.DataStream.Seek(System.UInt32)">
      <summary>Repositions the read point to a specified byte. </summary>
    </member>
    <member name="M:Mogre.DataStream.Tell">
      <summary>Returns the current byte offset from beginning </summary>
    </member>
    <member name="M:Mogre.DataStream.Eof">
      <summary>Returns true if the stream has reached the end. </summary>
    </member>
    <member name="M:Mogre.DataStream.Size">
      <summary>Returns the total size of the data to be read from the stream, or 0 if this is indeterminate for this stream. </summary>
    </member>
    <member name="M:Mogre.DataStream.Close">
      <summary>Close the stream; this makes further operations invalid. </summary>
    </member>
    <member name="P:Mogre.DataStream.Name">
      <summary>Returns the name of the stream, if it has one. </summary>
    </member>
    <member name="P:Mogre.DataStream.IsWriteable">
      <summary>Reports whether this stream is writeable. </summary>
    </member>
    <member name="P:Mogre.DataStream.IsReadable">
      <summary>Reports whether this stream is readable. </summary>
    </member>
    <member name="P:Mogre.DataStream.AsString">
      <summary>Returns a String containing the entire stream. This is a convenience method for text streams only, allowing you to retrieve a String object containing all the data in the stream. </summary>
    </member>
    <member name="T:Mogre.MemoryDataStream">
      <summary>Common subclass of DataStream for handling data from chunks of memory. </summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Read(System.Void*,System.UInt32)">
      <summary>Read the requisite number of bytes from the stream, stopping at the end of the file. bufReference to a buffer pointer countNumber of bytes to read The number of bytes read</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Write(System.Void*,System.UInt32)">
      <summary>Write the requisite number of bytes from the stream (only applicable to streams that are not read-only) bufPointer to a buffer containing the bytes to write countNumber of bytes to write The number of bytes written</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.ReadLine(System.SByte&amp;,System.UInt32)">
      <summary>Get a single line from the stream. The delimiter character is not included in the data returned, and it is skipped over so the next read will occur after it. The buffer contents will include a terminating character. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. bufReference to a buffer pointer maxCountThe maximum length of data to be read, excluding the terminating character delimThe delimiter to stop at The number of bytes read, excluding the terminating character</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.ReadLine(System.SByte&amp;,System.UInt32,System.String)">
      <summary>Get a single line from the stream. The delimiter character is not included in the data returned, and it is skipped over so the next read will occur after it. The buffer contents will include a terminating character. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. bufReference to a buffer pointer maxCountThe maximum length of data to be read, excluding the terminating character delimThe delimiter to stop at The number of bytes read, excluding the terminating character</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.SkipLine">
      <summary>Skip a single line from the stream. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. delimThe delimiter(s) to stop at The number of bytes skipped</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.SkipLine(System.String)">
      <summary>Skip a single line from the stream. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. delimThe delimiter(s) to stop at The number of bytes skipped</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Skip(System.Int32)">
      <summary>Skip a defined number of bytes. This can also be a negative value, in which case the file pointer rewinds a defined number of bytes.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Seek(System.UInt32)">
      <summary>Repositions the read point to a specified byte.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Tell">
      <summary>Returns the current byte offset from beginning</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Eof">
      <summary>Returns true if the stream has reached the end.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Close">
      <summary>Close the stream; this makes further operations invalid.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.SetFreeOnClose(System.Boolean)">
      <summary>Sets whether or not to free the encapsulated memory on close. </summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Read(System.Void*,System.UInt32)">
      <summary>Read the requisite number of bytes from the stream, stopping at the end of the file. bufReference to a buffer pointer countNumber of bytes to read The number of bytes read</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Write(System.Void*,System.UInt32)">
      <summary>Write the requisite number of bytes from the stream (only applicable to streams that are not read-only) bufPointer to a buffer containing the bytes to write countNumber of bytes to write The number of bytes written</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.ReadLine(System.SByte&amp;,System.UInt32)">
      <summary>Get a single line from the stream. The delimiter character is not included in the data returned, and it is skipped over so the next read will occur after it. The buffer contents will include a terminating character. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. bufReference to a buffer pointer maxCountThe maximum length of data to be read, excluding the terminating character delimThe delimiter to stop at The number of bytes read, excluding the terminating character</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.ReadLine(System.SByte&amp;,System.UInt32,System.String)">
      <summary>Get a single line from the stream. The delimiter character is not included in the data returned, and it is skipped over so the next read will occur after it. The buffer contents will include a terminating character. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. bufReference to a buffer pointer maxCountThe maximum length of data to be read, excluding the terminating character delimThe delimiter to stop at The number of bytes read, excluding the terminating character</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.SkipLine">
      <summary>Skip a single line from the stream. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. delimThe delimiter(s) to stop at The number of bytes skipped</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.SkipLine(System.String)">
      <summary>Skip a single line from the stream. If you used this function, you must open the stream in binary mode, otherwise, it'll produce unexpected results. delimThe delimiter(s) to stop at The number of bytes skipped</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Skip(System.Int32)">
      <summary>Skip a defined number of bytes. This can also be a negative value, in which case the file pointer rewinds a defined number of bytes.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Seek(System.UInt32)">
      <summary>Repositions the read point to a specified byte.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Tell">
      <summary>Returns the current byte offset from beginning</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Eof">
      <summary>Returns true if the stream has reached the end.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.Close">
      <summary>Close the stream; this makes further operations invalid.</summary>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(System.String,System.UInt32)">
      <summary>Create a named stream with a brand new empty memory chunk. </summary>
      <param name="name">The name to give the stream </param>
      <param name="size">The size of the memory chunk to create in bytes </param>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(System.UInt32)">
      <summary>Create a stream with a brand new empty memory chunk. </summary>
      <param name="size">The size of the memory chunk to create in bytes </param>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(System.String,Mogre.DataStreamPtr)">
      <summary>Create a named stream which pre-buffers the contents of another stream. This constructor can be used to intentionally read in the entire contents of another stream, copying them to the internal buffer and thus making them available in memory as a single unit. </summary>
      <param name="name">The name to give the stream </param>
      <param name="sourceStream">Another DataStream which will provide the source of data </param>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(System.String,Mogre.DataStream)">
      <summary>Create a named stream which pre-buffers the contents of another stream. This constructor can be used to intentionally read in the entire contents of another stream, copying them to the internal buffer and thus making them available in memory as a single unit. </summary>
      <param name="name">The name to give the stream </param>
      <param name="sourceStream">Another DataStream which will provide the source of data </param>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(Mogre.DataStreamPtr)">
      <summary>Create a stream which pre-buffers the contents of another stream. This constructor can be used to intentionally read in the entire contents of another stream, copying them to the internal buffer and thus making them available in memory as a single unit. </summary>
      <param name="sourceStream">Another DataStream which will provide the source of data </param>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(Mogre.DataStream)">
      <summary>Create a stream which pre-buffers the contents of another stream. This constructor can be used to intentionally read in the entire contents of another stream, copying them to the internal buffer and thus making them available in memory as a single unit. </summary>
      <param name="sourceStream">Another DataStream which will provide the source of data </param>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(System.String,System.Void*,System.UInt32)">
      <summary>Wrap an existing memory chunk in a named stream. </summary>
      <param name="name">The name to give the stream </param>
      <param name="pMem">Pointer to the existing memory </param>
      <param name="size">The size of the memory chunk in bytes </param>
    </member>
    <member name="M:Mogre.MemoryDataStream.#ctor(System.Void*,System.UInt32)">
      <summary>Wrap an existing memory chunk in a stream. </summary>
      <param name="pMem">Pointer to the existing memory </param>
      <param name="size">The size of the memory chunk in bytes </param>
    </member>
    <member name="P:Mogre.MemoryDataStream.Ptr">
      <summary>Get a pointer to the start of the memory block this stream holds. </summary>
    </member>
    <member name="P:Mogre.MemoryDataStream.CurrentPtr">
      <summary>Get a pointer to the current position in the memory block this stream holds. </summary>
    </member>
    <member name="T:Mogre.DataStreamPtr">
      <summary>Shared pointer to allow data streams to be passed around without worrying about deallocation </summary>
    </member>
    <member name="T:Mogre.DataStreamList">
      <summary>List of DataStream items. </summary>
    </member>
    <member name="T:Mogre.Const_DataStreamList">
      <summary>List of DataStream items. </summary>
    </member>
    <member name="T:Mogre.DataStreamListPtr">
      <summary>Shared pointer to list of DataStream items. </summary>
    </member>
    <member name="T:Mogre.MemoryDataStreamPtr">
      <summary>Shared pointer to allow memory data streams to be passed around without worrying about deallocation </summary>
    </member>
    <member name="T:Mogre.PixelComponentType">
      <summary>Pixel component format </summary>
    </member>
    <member name="F:Mogre.PixelComponentType.PCT_SHORT">
      <summary>Byte per component (8 bit fixed 0.0..1.0). </summary>
    </member>
    <member name="F:Mogre.PixelComponentType.PCT_FLOAT16">
      <summary>Short per component (16 bit fixed 0.0..1.0)). </summary>
    </member>
    <member name="F:Mogre.PixelComponentType.PCT_FLOAT32">
      <summary>16 bit float per component </summary>
    </member>
    <member name="F:Mogre.PixelComponentType.PCT_COUNT">
      <summary>32 bit float per component </summary>
    </member>
    <member name="T:Mogre.PixelFormatFlags">
      <summary>Flags defining some on/off properties of pixel formats </summary>
    </member>
    <member name="T:Mogre.PixelFormat">
      <summary>The pixel format used for images, textures, and render surfaces </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_UNKNOWN">
      <summary>Unknown pixel format. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_L8">
      <summary>8-bit pixel format, all bits luminace. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_L16">
      <summary>16-bit pixel format, all bits luminace. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A8">
      <summary>8-bit pixel format, all bits alpha. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A4L4">
      <summary>8-bit pixel format, 4 bits alpha, 4 bits luminance. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_BYTE_LA">
      <summary>2 byte pixel format, 1 byte luminance, 1 byte alpha </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_R5G6B5">
      <summary>16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_B5G6R5">
      <summary>16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_R3G3B2">
      <summary>8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A4R4G4B4">
      <summary>16-bit pixel format, 4 bits for alpha, red, green and blue. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A1R5G5B5">
      <summary>16-bit pixel format, 5 bits for blue, green, red and 1 for alpha. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_R8G8B8">
      <summary>24-bit pixel format, 8 bits for red, green and blue. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_B8G8R8">
      <summary>24-bit pixel format, 8 bits for blue, green and red. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A8R8G8B8">
      <summary>32-bit pixel format, 8 bits for alpha, red, green and blue. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A8B8G8R8">
      <summary>32-bit pixel format, 8 bits for blue, green, red and alpha. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_B8G8R8A8">
      <summary>32-bit pixel format, 8 bits for blue, green, red and alpha. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_R8G8B8A8">
      <summary>32-bit pixel format, 8 bits for red, green, blue and alpha. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_X8R8G8B8">
      <summary>32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for blue like PF_A8R8G8B8, but alpha will get discarded </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_X8B8G8R8">
      <summary>32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for red like PF_A8B8G8R8, but alpha will get discarded </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_BYTE_RGB">
      <summary>3 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_BYTE_BGR">
      <summary>3 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_BYTE_BGRA">
      <summary>4 byte pixel format, 1 byte for blue, 1 byte for green, 1 byte for red and one byte for alpha </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_BYTE_RGBA">
      <summary>4 byte pixel format, 1 byte for red, 1 byte for green, 1 byte for blue, and one byte for alpha </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A2R10G10B10">
      <summary>32-bit pixel format, 2 bits for alpha, 10 bits for red, green and blue. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_A2B10G10R10">
      <summary>32-bit pixel format, 10 bits for blue, green and red, 2 bits for alpha. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_DXT1">
      <summary>DDS (DirectDraw Surface) DXT1 format. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_DXT2">
      <summary>DDS (DirectDraw Surface) DXT2 format. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_DXT3">
      <summary>DDS (DirectDraw Surface) DXT3 format. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_DXT4">
      <summary>DDS (DirectDraw Surface) DXT4 format. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_DXT5">
      <summary>DDS (DirectDraw Surface) DXT5 format. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_PVRTC_RGB2">
      <summary>PVRTC (PowerVR) RGB 2 bpp. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_PVRTC_RGBA2">
      <summary>PVRTC (PowerVR) RGBA 2 bpp. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_PVRTC_RGB4">
      <summary>PVRTC (PowerVR) RGB 4 bpp. </summary>
    </member>
    <member name="F:Mogre.PixelFormat.PF_PVRTC_RGBA4">
      <summary>PVRTC (PowerVR) RGBA 4 bpp. </summary>
    </member>
    <member name="M:Mogre.Timer.SetOption(System.String,System.Void*)">
      <summary>Method for setting a specific option of the Timer. These options are usually specific for a certain implementation of the Timer class, and may (and probably will) not exist across different implementations. reset() must be called after all setOption() calls. Current options supported are: "QueryAffinityMask" (DWORD): Set the thread affinity mask to be used to check the timer. If 'reset' has been called already this mask should overlap with the process mask that was in force at that point, and should be a power of two (a single core).On success, true is returned. On failure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
      <param name="pValue">A pointer to the value - the size should be calculated by the timer based on the key </param>
    </member>
    <member name="M:Mogre.Timer.Reset">
      <summary>Resets timer </summary>
    </member>
    <member name="M:Mogre.Timer.#ctor">
      <summary>Timer constructor. MUST be called on same thread that calls getMilliseconds()</summary>
    </member>
    <member name="P:Mogre.Timer.MillisecondsCPU">
      <summary>Returns milliseconds since initialisation or last reset, only CPU time measured </summary>
    </member>
    <member name="P:Mogre.Timer.Milliseconds">
      <summary>Returns milliseconds since initialisation or last reset </summary>
    </member>
    <member name="P:Mogre.Timer.MicrosecondsCPU">
      <summary>Returns microseconds since initialisation or last reset, only CPU time measured </summary>
    </member>
    <member name="P:Mogre.Timer.Microseconds">
      <summary>Returns microseconds since initialisation or last reset </summary>
    </member>
    <member name="T:Mogre.AnimableValue">
      <summary>Defines an object property which is animable, i.e. may be keyframed. Animable properties are those which can be altered over time by a predefined keyframe sequence. They may be set directly, or they may be modified from their existing state (common if multiple animations are expected to apply at once). Implementors of this interface are expected to override the 'setValue', 'setCurrentStateAsBaseValue' and 'applyDeltaValue' methods appropriate to the type in question, and to initialise the type. AnimableValue instances are accessible through any class which extends AnimableObject in order to expose it's animable properties. This class is an instance of the Adapter pattern, since it generalises access to a particular property. Whilst it could have been templated such that the type which was being referenced was compiled in, this would make it more difficult to aggregated generically, and since animations are often comprised of multiple properties it helps to be able to deal with all values through a single class. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetCurrentStateAsBaseValue">
      <summary>Sets the current state as the 'base' value; used for delta animation. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(Mogre.Degree)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(Mogre.Radian)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(Mogre.ColourValue)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(Mogre.Quaternion)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(Mogre.Vector4)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(Mogre.Vector3)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(Mogre.Vector2)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(System.Single)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.SetValue(System.Int32)">
      <summary>Set value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(Mogre.Radian)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(Mogre.Degree)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(Mogre.ColourValue)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(Mogre.Quaternion)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(Mogre.Vector4)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(Mogre.Vector3)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(Mogre.Vector2)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(System.Single)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="M:Mogre.AnimableValue.ApplyDeltaValue(System.Int32)">
      <summary>Apply delta value. </summary>
    </member>
    <member name="P:Mogre.AnimableValue.Type">
      <summary>Gets the value type of this animable value. </summary>
    </member>
    <member name="T:Mogre.AnimableValue+ValueType">
      <summary>The type of the value being animated. </summary>
    </member>
    <member name="T:Mogre.AnimableObject">
      <summary>Defines an interface to classes which have one or more AnimableValue instances to expose. </summary>
    </member>
    <member name="M:Mogre.AnimableObject.GetAnimableValueNames">
      <summary>Gets a list of animable value names for this object. </summary>
    </member>
    <member name="M:Mogre.AnimableObject.CreateAnimableValue(System.String)">
      <summary>Create a reference-counted AnimableValuePtr for the named value. You can use the returned object to animate a value on this object, using AnimationTrack. Subclasses must override this if they wish to support animation of their values. </summary>
    </member>
    <member name="T:Mogre.Pose">
      <summary>A pose is a linked set of vertex offsets applying to one set of vertex data. The target index referred to by the pose has a meaning set by the user of this class; but for example when used by Mesh it refers to either the Mesh shared geometry (0) or a SubMesh dedicated geometry (1+). Pose instances can be referred to by keyframes in VertexAnimationTrack in order to animate based on blending poses together. </summary>
    </member>
    <member name="M:Mogre.Pose.AddVertex(System.UInt32,Mogre.Vector3)">
      <summary>Adds an offset to a vertex for this pose. </summary>
      <param name="index">The vertex index </param>
      <param name="offset">The position offset for this pose </param>
    </member>
    <member name="M:Mogre.Pose.RemoveVertex(System.UInt32)">
      <summary>Remove a vertex offset. </summary>
    </member>
    <member name="M:Mogre.Pose.ClearVertexOffsets">
      <summary>Clear all vertex offsets. </summary>
    </member>
    <member name="M:Mogre.Pose.GetVertexOffsetIterator">
      <summary>Gets an iterator over all the vertex offsets. </summary>
    </member>
    <member name="M:Mogre.Pose.GetVertexOffsets">
      <summary>Gets a const reference to the vertex offsets. </summary>
    </member>
    <member name="M:Mogre.Pose._getHardwareVertexBuffer(System.UInt32)">
      <summary>Get a hardware vertex buffer version of the vertex offsets. </summary>
    </member>
    <member name="M:Mogre.Pose.Clone">
      <summary>Clone this pose and create another one configured exactly the same way (only really useful for cloning holders of this class). </summary>
    </member>
    <member name="M:Mogre.Pose.#ctor(System.UInt16)">
      <summary>Constructor </summary>
      <param name="target">The target vertexdata index (0 for shared, 1+ for dedicated at the submesh index + 1) </param>
    </member>
    <member name="M:Mogre.Pose.#ctor(System.UInt16,System.String)">
      <summary>Constructor </summary>
      <param name="target">The target vertexdata index (0 for shared, 1+ for dedicated at the submesh index + 1) </param>
      <param name="name">Optional name </param>
    </member>
    <member name="P:Mogre.Pose.Name">
      <summary>Return the name of the pose (may be blank). </summary>
    </member>
    <member name="T:Mogre.TimeIndex">
      <summary>Time index object used to search keyframe at the given position. </summary>
    </member>
    <member name="M:Mogre.TimeIndex.#ctor(System.Single,System.UInt32)">
      <summary>Construct time index object by the given time position and global keyframe index. In normally, you don't need to use this constructor directly, use Animation::_getTimeIndex instead. </summary>
    </member>
    <member name="M:Mogre.TimeIndex.#ctor(System.Single)">
      <summary>Construct time index object by the given time position. </summary>
    </member>
    <member name="T:Mogre.AnimationTrack">
      <summary>A 'track' in an animation sequence, i.e. a sequence of keyframes which affect a certain type of animable object. This class is intended as a base for more complete classes which will actually animate specific types of object, e.g. a bone in a skeleton to affect skeletal animation. An animation will likely include multiple tracks each of which can be made up of many KeyFrame instances. Note that the use of tracks allows each animable object to have it's own number of keyframes, i.e. you do not have to have the maximum number of keyframes for all animable objects just to cope with the most animated one. Since the most common animable object is a Node, there are options in this class for associating the track with a Node which will receive keyframe updates automatically when the 'apply' method is called. By default rotation is done using shortest-path algorithm. It is possible to change this behaviour using setUseShortestRotationPath() method. </summary>
    </member>
    <member name="M:Mogre.AnimationTrack.GetKeyFrame(System.UInt16)">
      <summary>Returns the KeyFrame at the specified index. </summary>
    </member>
    <member name="M:Mogre.AnimationTrack.GetKeyFramesAtTime(Mogre.TimeIndex,Mogre.KeyFrame&amp;,Mogre.KeyFrame&amp;)">
      <summary>Gets the 2 KeyFrame objects which are active at the time given, and the blend value between them. At any point in time in an animation, there are either 1 or 2 keyframes which are 'active', 1 if the time index is exactly on a keyframe, 2 at all other times i.e. the keyframe before and the keyframe after. This method returns those keyframes given a time index, and also returns a parametric value indicating the value of 't' representing where the time index falls between them. E.g. if it returns 0, the time index is exactly on keyFrame1, if it returns 0.5 it is half way between keyFrame1 and keyFrame2 etc. Parametric value indicating how far along the gap between the 2 keyframes the timeIndex value is, e.g. 0.0 for exactly at 1, 0.25 for a quarter etc. By definition the range of this value is: 0.0 &lt;= returnValue &lt; 1.0 . </summary>
      <param name="timeIndex">The time index. </param>
      <param name="keyFrame1">Pointer to a KeyFrame pointer which will receive the pointer to the keyframe just before or at this time index. </param>
      <param name="keyFrame2">Pointer to a KeyFrame pointer which will receive the pointer to the keyframe just after this time index. </param>
    </member>
    <member name="M:Mogre.AnimationTrack.GetKeyFramesAtTime(Mogre.TimeIndex,Mogre.KeyFrame&amp;,Mogre.KeyFrame&amp;,System.UInt16&amp;)">
      <summary>Gets the 2 KeyFrame objects which are active at the time given, and the blend value between them. At any point in time in an animation, there are either 1 or 2 keyframes which are 'active', 1 if the time index is exactly on a keyframe, 2 at all other times i.e. the keyframe before and the keyframe after. This method returns those keyframes given a time index, and also returns a parametric value indicating the value of 't' representing where the time index falls between them. E.g. if it returns 0, the time index is exactly on keyFrame1, if it returns 0.5 it is half way between keyFrame1 and keyFrame2 etc. Parametric value indicating how far along the gap between the 2 keyframes the timeIndex value is, e.g. 0.0 for exactly at 1, 0.25 for a quarter etc. By definition the range of this value is: 0.0 &lt;= returnValue &lt; 1.0 . </summary>
      <param name="timeIndex">The time index. </param>
      <param name="keyFrame1">Pointer to a KeyFrame pointer which will receive the pointer to the keyframe just before or at this time index. </param>
      <param name="keyFrame2">Pointer to a KeyFrame pointer which will receive the pointer to the keyframe just after this time index. </param>
      <param name="firstKeyIndex">Pointer to an unsigned short which, if supplied, will receive the index of the 'from' keyframe in case the caller needs it. </param>
    </member>
    <member name="M:Mogre.AnimationTrack.CreateKeyFrame(System.Single)">
      <summary>Creates a new KeyFrame and adds it to this animation at the given time index. It is better to create KeyFrames in time order. Creating them out of order can result in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created for you, so you don't need to create this one, just access it using getKeyFrame(0); </summary>
      <param name="timePos">The time from which this KeyFrame will apply. </param>
    </member>
    <member name="M:Mogre.AnimationTrack.RemoveKeyFrame(System.UInt16)">
      <summary>Removes a KeyFrame by it's index. </summary>
    </member>
    <member name="M:Mogre.AnimationTrack.RemoveAllKeyFrames">
      <summary>Removes all the KeyFrames from this track. </summary>
    </member>
    <member name="M:Mogre.AnimationTrack.GetInterpolatedKeyFrame(Mogre.TimeIndex,Mogre.KeyFrame)">
      <summary>Gets a KeyFrame object which contains the interpolated transforms at the time index specified. The KeyFrame objects held by this class are transformation snapshots at discrete points in time. Normally however, you want to interpolate between these keyframes to produce smooth movement, and this method allows you to do this easily. In animation terminology this is called 'tweening'. </summary>
      <param name="timeIndex">The time (in relation to the whole animation sequence) </param>
      <param name="kf">Keyframe object to store results </param>
    </member>
    <member name="M:Mogre.AnimationTrack.Apply(Mogre.TimeIndex)">
      <summary>Applies an animation track to the designated target. </summary>
      <param name="timeIndex">The time position in the animation to apply. </param>
    </member>
    <member name="M:Mogre.AnimationTrack.Apply(Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to the designated target. </summary>
      <param name="timeIndex">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
    </member>
    <member name="M:Mogre.AnimationTrack.Apply(Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to the designated target. </summary>
      <param name="timeIndex">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
      <param name="scale">The scale to apply to translations and scalings, useful for adapting an animation to a different size target. </param>
    </member>
    <member name="M:Mogre.AnimationTrack._keyFrameDataChanged">
      <summary>Internal method used to tell the track that keyframe data has been changed, which may cause it to rebuild some internal data. </summary>
    </member>
    <member name="M:Mogre.AnimationTrack.Optimise">
      <summary>Optimise the current track by removing any duplicate keyframes. </summary>
    </member>
    <member name="M:Mogre.AnimationTrack.SetListener(Mogre.AnimationTrack+IListener)">
      <summary>Set a listener for this track. </summary>
    </member>
    <member name="P:Mogre.AnimationTrack.Parent">
      <summary>Returns the parent Animation object for this track. </summary>
    </member>
    <member name="P:Mogre.AnimationTrack.NumKeyFrames">
      <summary>Returns the number of keyframes in this animation. </summary>
    </member>
    <member name="P:Mogre.AnimationTrack.HasNonZeroKeyFrames">
      <summary>Method to determine if this track has any KeyFrames which are doing anything useful - can be used to determine if this track can be optimised out. </summary>
    </member>
    <member name="P:Mogre.AnimationTrack.Handle">
      <summary>Get the handle associated with this track. </summary>
    </member>
    <member name="T:Mogre.NumericAnimationTrack">
      <summary>Specialised AnimationTrack for dealing with generic animable values. </summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.CreateNumericKeyFrame(System.Single)">
      <summary>Creates a new KeyFrame and adds it to this animation at the given time index. It is better to create KeyFrames in time order. Creating them out of order can result in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created for you, so you don't need to create this one, just access it using getKeyFrame(0); </summary>
      <param name="timePos">The time from which this KeyFrame will apply. </param>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.GetInterpolatedKeyFrame(Mogre.TimeIndex,Mogre.KeyFrame)">
      <summary>Gets a KeyFrame object which contains the interpolated transforms at the time index specified. The KeyFrame objects held by this class are transformation snapshots at discrete points in time. Normally however, you want to interpolate between these keyframes to produce smooth movement, and this method allows you to do this easily. In animation terminology this is called 'tweening'. timeIndexThe time (in relation to the whole animation sequence) kfKeyframe object to store results</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.Apply(Mogre.TimeIndex)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.Apply(Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.Apply(Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.ApplyToAnimable(Mogre.AnimableValuePtr,Mogre.TimeIndex)">
      <summary>Applies an animation track to a given animable value. </summary>
      <param name="anim">The AnimableValue to which to apply the animation </param>
      <param name="timeIndex">The time position in the animation to apply. </param>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.ApplyToAnimable(Mogre.AnimableValuePtr,Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to a given animable value. </summary>
      <param name="anim">The AnimableValue to which to apply the animation </param>
      <param name="timeIndex">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.ApplyToAnimable(Mogre.AnimableValuePtr,Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to a given animable value. </summary>
      <param name="anim">The AnimableValue to which to apply the animation </param>
      <param name="timeIndex">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
      <param name="scale">The scale to apply to translations and scalings, useful for adapting an animation to a different size target. </param>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.GetAssociatedAnimable">
      <summary>Returns a pointer to the associated animable object (if any). </summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.SetAssociatedAnimable(Mogre.AnimableValuePtr)">
      <summary>Sets the associated animable object which will be automatically affected by calls to 'apply'. </summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.GetNumericKeyFrame(System.UInt16)">
      <summary>Returns the KeyFrame at the specified index. </summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack._clone(Mogre.Animation)">
      <summary>Clone this track (internal use only) </summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.GetInterpolatedKeyFrame(Mogre.TimeIndex,Mogre.KeyFrame)">
      <summary>Gets a KeyFrame object which contains the interpolated transforms at the time index specified. The KeyFrame objects held by this class are transformation snapshots at discrete points in time. Normally however, you want to interpolate between these keyframes to produce smooth movement, and this method allows you to do this easily. In animation terminology this is called 'tweening'. timeIndexThe time (in relation to the whole animation sequence) kfKeyframe object to store results</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.Apply(Mogre.TimeIndex)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.Apply(Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.Apply(Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.#ctor(Mogre.Animation,System.UInt16,Mogre.AnimableValuePtr)">
      <summary>Constructor, associates with an AnimableValue. </summary>
    </member>
    <member name="M:Mogre.NumericAnimationTrack.#ctor(Mogre.Animation,System.UInt16)">
      <summary>Constructor. </summary>
    </member>
    <member name="T:Mogre.NodeAnimationTrack">
      <summary>Specialised AnimationTrack for dealing with node transforms. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.CreateNodeKeyFrame(System.Single)">
      <summary>Creates a new KeyFrame and adds it to this animation at the given time index. It is better to create KeyFrames in time order. Creating them out of order can result in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created for you, so you don't need to create this one, just access it using getKeyFrame(0); </summary>
      <param name="timePos">The time from which this KeyFrame will apply. </param>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.ApplyToNode(Mogre.Node,Mogre.TimeIndex)">
      <summary>As the 'apply' method but applies to a specified Node instead of associated node. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.ApplyToNode(Mogre.Node,Mogre.TimeIndex,System.Single)">
      <summary>As the 'apply' method but applies to a specified Node instead of associated node. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.ApplyToNode(Mogre.Node,Mogre.TimeIndex,System.Single,System.Single)">
      <summary>As the 'apply' method but applies to a specified Node instead of associated node. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.GetInterpolatedKeyFrame(Mogre.TimeIndex,Mogre.KeyFrame)">
      <summary>Gets a KeyFrame object which contains the interpolated transforms at the time index specified. The KeyFrame objects held by this class are transformation snapshots at discrete points in time. Normally however, you want to interpolate between these keyframes to produce smooth movement, and this method allows you to do this easily. In animation terminology this is called 'tweening'. timeIndexThe time (in relation to the whole animation sequence) kfKeyframe object to store results</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Apply(Mogre.TimeIndex)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Apply(Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Apply(Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack._keyFrameDataChanged">
      <summary>Internal method used to tell the track that keyframe data has been changed, which may cause it to rebuild some internal data.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.GetNodeKeyFrame(System.UInt16)">
      <summary>Returns the KeyFrame at the specified index. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Optimise">
      <summary>Optimise the current track by removing any duplicate keyframes. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack._clone(Mogre.Animation)">
      <summary>Clone this track (internal use only) </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.GetInterpolatedKeyFrame(Mogre.TimeIndex,Mogre.KeyFrame)">
      <summary>Gets a KeyFrame object which contains the interpolated transforms at the time index specified. The KeyFrame objects held by this class are transformation snapshots at discrete points in time. Normally however, you want to interpolate between these keyframes to produce smooth movement, and this method allows you to do this easily. In animation terminology this is called 'tweening'. timeIndexThe time (in relation to the whole animation sequence) kfKeyframe object to store results</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Apply(Mogre.TimeIndex)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Apply(Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Apply(Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack._keyFrameDataChanged">
      <summary>Internal method used to tell the track that keyframe data has been changed, which may cause it to rebuild some internal data.</summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.Optimise">
      <summary>Optimise the current track by removing any duplicate keyframes. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.#ctor(Mogre.Animation,System.UInt16,Mogre.Node)">
      <summary>Constructor, associates with a Node. </summary>
    </member>
    <member name="M:Mogre.NodeAnimationTrack.#ctor(Mogre.Animation,System.UInt16)">
      <summary>Constructor. </summary>
    </member>
    <member name="P:Mogre.NodeAnimationTrack.UseShortestRotationPath">
      <summary>Sets/Gets the method of rotation calculation </summary>
    </member>
    <member name="P:Mogre.NodeAnimationTrack.HasNonZeroKeyFrames">
      <summary>Method to determine if this track has any KeyFrames which are doing anything useful - can be used to determine if this track can be optimised out. </summary>
    </member>
    <member name="P:Mogre.NodeAnimationTrack.AssociatedNode">
      <summary>Sets/Returns a pointer to the associated Node object (if any). </summary>
    </member>
    <member name="T:Mogre.VertexAnimationTrack">
      <summary>Specialised AnimationTrack for dealing with changing vertex position information. VertexAnimationType</summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.CreateVertexMorphKeyFrame(System.Single)">
      <summary>Creates a new morph KeyFrame and adds it to this animation at the given time index. It is better to create KeyFrames in time order. Creating them out of order can result in expensive reordering processing. Note that a KeyFrame at time index 0.0 is always created for you, so you don't need to create this one, just access it using getKeyFrame(0); </summary>
      <param name="timePos">The time from which this KeyFrame will apply. </param>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.CreateVertexPoseKeyFrame(System.Single)">
      <summary>Creates the single pose KeyFrame and adds it to this animation. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.GetInterpolatedKeyFrame(Mogre.TimeIndex,Mogre.KeyFrame)">
      <summary>This method in fact does nothing, since interpolation is not performed inside the keyframes for this type of track. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Apply(Mogre.TimeIndex)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Apply(Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Apply(Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.ApplyToVertexData(Mogre.VertexData,Mogre.TimeIndex)">
      <summary>As the 'apply' method but applies to specified VertexData instead of associated data. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.ApplyToVertexData(Mogre.VertexData,Mogre.TimeIndex,System.Single)">
      <summary>As the 'apply' method but applies to specified VertexData instead of associated data. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.ApplyToVertexData(Mogre.VertexData,Mogre.TimeIndex,System.Single,Mogre.Const_PoseList)">
      <summary>As the 'apply' method but applies to specified VertexData instead of associated data. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.GetVertexMorphKeyFrame(System.UInt16)">
      <summary>Returns the morph KeyFrame at the specified index. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.GetVertexPoseKeyFrame(System.UInt16)">
      <summary>Returns the pose KeyFrame at the specified index. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.SetTargetMode(Mogre.VertexAnimationTrack+TargetMode)">
      <summary>Set the target mode. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.GetTargetMode">
      <summary>Get the target mode. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Optimise">
      <summary>Optimise the current track by removing any duplicate keyframes. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack._clone(Mogre.Animation)">
      <summary>Clone this track (internal use only) </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.GetInterpolatedKeyFrame(Mogre.TimeIndex,Mogre.KeyFrame)">
      <summary>This method in fact does nothing, since interpolation is not performed inside the keyframes for this type of track. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Apply(Mogre.TimeIndex)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Apply(Mogre.TimeIndex,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Apply(Mogre.TimeIndex,System.Single,System.Single)">
      <summary>Applies an animation track to the designated target. timeIndexThe time position in the animation to apply. weightThe influence to give to this track, 1.0 for full influence, less to blend with other animations. scaleThe scale to apply to translations and scalings, useful for adapting an animation to a different size target.</summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.Optimise">
      <summary>Optimise the current track by removing any duplicate keyframes. </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.#ctor(Mogre.Animation,System.UInt16,Mogre.VertexAnimationType,Mogre.VertexData)">
      <summary>Constructor, associates with target VertexData and temp buffer (for software). </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.#ctor(Mogre.Animation,System.UInt16,Mogre.VertexAnimationType,Mogre.VertexData,Mogre.VertexAnimationTrack+TargetMode)">
      <summary>Constructor, associates with target VertexData and temp buffer (for software). </summary>
    </member>
    <member name="M:Mogre.VertexAnimationTrack.#ctor(Mogre.Animation,System.UInt16,Mogre.VertexAnimationType)">
      <summary>Constructor. </summary>
    </member>
    <member name="P:Mogre.VertexAnimationTrack.HasNonZeroKeyFrames">
      <summary>Method to determine if this track has any KeyFrames which are doing anything useful - can be used to determine if this track can be optimised out. </summary>
    </member>
    <member name="P:Mogre.VertexAnimationTrack.AssociatedVertexData">
      <summary>Sets/Gets the associated VertexData which this track will update. </summary>
    </member>
    <member name="P:Mogre.VertexAnimationTrack.AnimationType">
      <summary>Get the type of vertex animation we're performing. </summary>
    </member>
    <member name="T:Mogre.VertexAnimationTrack+TargetMode">
      <summary>The target animation mode </summary>
    </member>
    <member name="F:Mogre.VertexAnimationTrack+TargetMode.TM_SOFTWARE">
      <summary>Interpolate vertex positions in software. </summary>
    </member>
    <member name="F:Mogre.VertexAnimationTrack+TargetMode.TM_HARDWARE">
      <summary>Bind keyframe 1 to position, and keyframe 2 to a texture coordinate for interpolation in hardware </summary>
    </member>
    <member name="T:Mogre.AnimationState">
      <summary>Represents the state of an animation and the weight of it's influence. Other classes can hold instances of this class to store the state of any animations they are using. </summary>
    </member>
    <member name="M:Mogre.AnimationState.AddTime(System.Single)">
      <summary>Modifies the time position, adjusting for animation length This method loops at the edges if animation looping is enabled. </summary>
    </member>
    <member name="M:Mogre.AnimationState.CopyStateFrom(Mogre.AnimationState)">
      <summary>Copies the states from another animation state, preserving the animation name (unlike operator=) but copying everything else. </summary>
      <param name="animState">Reference to animation state which will use as source. </param>
    </member>
    <member name="M:Mogre.AnimationState.CreateBlendMask(System.UInt32)">
      <summary>create a new blend mask with the given number of entries </summary>
    </member>
    <member name="M:Mogre.AnimationState.CreateBlendMask(System.UInt32,System.Single)">
      <summary>create a new blend mask with the given number of entries </summary>
    </member>
    <member name="M:Mogre.AnimationState.DestroyBlendMask">
      <summary>destroy the currently set blend mask </summary>
    </member>
    <member name="M:Mogre.AnimationState._setBlendMaskData(System.Single*)">
      <summary>set the blend mask data (might be dangerous) </summary>
    </member>
    <member name="M:Mogre.AnimationState._setBlendMask(Mogre.AnimationState+Const_BoneBlendMask)">
      <summary>set the blend mask </summary>
    </member>
    <member name="M:Mogre.AnimationState.GetBlendMask">
      <summary>get the current blend mask (const version, may be 0) </summary>
    </member>
    <member name="M:Mogre.AnimationState.SetBlendMaskEntry(System.UInt32,System.Single)">
      <summary>set the weight for the bone identified by the given handle </summary>
    </member>
    <member name="M:Mogre.AnimationState.GetBlendMaskEntry(System.UInt32)">
      <summary>get the weight for the bone identified by the given handle </summary>
    </member>
    <member name="M:Mogre.AnimationState.#ctor(Mogre.AnimationStateSet,Mogre.AnimationState)">
      <summary>constructor to copy from an existing state with new parent </summary>
    </member>
    <member name="M:Mogre.AnimationState.#ctor(System.String,Mogre.AnimationStateSet,System.Single,System.Single)">
      <summary>Normal constructor with all params supplied. </summary>
    </member>
    <member name="M:Mogre.AnimationState.#ctor(System.String,Mogre.AnimationStateSet,System.Single,System.Single,System.Single)">
      <summary>Normal constructor with all params supplied. </summary>
    </member>
    <member name="M:Mogre.AnimationState.#ctor(System.String,Mogre.AnimationStateSet,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>Normal constructor with all params supplied. </summary>
    </member>
    <member name="P:Mogre.AnimationState.Weight">
      <summary>Sets/Gets the weight (influence) of this animation. </summary>
    </member>
    <member name="P:Mogre.AnimationState.TimePosition">
      <summary>Sets/Gets the time position for this animation. </summary>
    </member>
    <member name="P:Mogre.AnimationState.Parent">
      <summary>Get the parent animation state set. </summary>
    </member>
    <member name="P:Mogre.AnimationState.Loop">
      <summary>Sets/Gets whether or not this animation loops. </summary>
    </member>
    <member name="P:Mogre.AnimationState.Length">
      <summary>Sets/Gets the total length of this animation (may be shorter than whole animation). </summary>
    </member>
    <member name="P:Mogre.AnimationState.HasEnded">
      <summary>Returns true if the animation has reached the end and is not looping. </summary>
    </member>
    <member name="P:Mogre.AnimationState.HasBlendMask">
      <summary>return whether there is currently a valid blend mask set </summary>
    </member>
    <member name="P:Mogre.AnimationState.Enabled">
      <summary>Sets/Returns true if this animation is currently enabled. </summary>
    </member>
    <member name="P:Mogre.AnimationState.AnimationName">
      <summary>Gets the name of the animation to which this state applies. </summary>
    </member>
    <member name="T:Mogre.AnimationStateSet">
      <summary>Class encapsulating a set of AnimationState objects. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.CreateAnimationState(System.String,System.Single,System.Single)">
      <summary>Create a new AnimationState instance. </summary>
      <param name="animName">The name of the animation </param>
      <param name="timePos">Starting time position </param>
      <param name="length">Length of the animation to play </param>
    </member>
    <member name="M:Mogre.AnimationStateSet.CreateAnimationState(System.String,System.Single,System.Single,System.Single)">
      <summary>Create a new AnimationState instance. </summary>
      <param name="animName">The name of the animation </param>
      <param name="timePos">Starting time position </param>
      <param name="length">Length of the animation to play </param>
      <param name="weight">Weight to apply the animation with </param>
    </member>
    <member name="M:Mogre.AnimationStateSet.CreateAnimationState(System.String,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>Create a new AnimationState instance. </summary>
      <param name="animName">The name of the animation </param>
      <param name="timePos">Starting time position </param>
      <param name="length">Length of the animation to play </param>
      <param name="weight">Weight to apply the animation with </param>
      <param name="enabled">Whether the animation is enabled </param>
    </member>
    <member name="M:Mogre.AnimationStateSet.GetAnimationState(System.String)">
      <summary>Get an animation state by the name of the animation. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.HasAnimationState(System.String)">
      <summary>Tests if state for the named animation is present. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.RemoveAnimationState(System.String)">
      <summary>Remove animation state with the given name. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.RemoveAllAnimationStates">
      <summary>Remove all animation states. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.GetAnimationStateIterator">
      <summary>Get an iterator over all the animation states in this set. The iterator returned from this method is not threadsafe, you will need to manually lock the public mutex on this class to ensure thread safety if you need it. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.CopyMatchingState(Mogre.AnimationStateSet)">
      <summary>Copy the state of any matching animation states from this to another. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet._notifyDirty">
      <summary>Set the dirty flag and dirty frame number on this state set. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet._notifyAnimationStateEnabled(Mogre.AnimationState,System.Boolean)">
      <summary>Internal method respond to enable/disable an animation state. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.GetEnabledAnimationStateIterator">
      <summary>Get an iterator over all the enabled animation states in this set The iterator returned from this method is not threadsafe, you will need to manually lock the public mutex on this class to ensure thread safety if you need it. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.#ctor(Mogre.AnimationStateSet)">
      <summary>Create an animation set by copying the contents of another. </summary>
    </member>
    <member name="M:Mogre.AnimationStateSet.#ctor">
      <summary>Create a blank animation state set. </summary>
    </member>
    <member name="P:Mogre.AnimationStateSet.HasEnabledAnimationState">
      <summary>Tests if exists enabled animation state in this set. </summary>
    </member>
    <member name="P:Mogre.AnimationStateSet.DirtyFrameNumber">
      <summary>Get the latest animation state been altered frame number. </summary>
    </member>
    <member name="T:Mogre.Animation">
      <summary>An animation sequence. This class defines the interface for a sequence of animation, whether that be animation of a mesh, a path along a spline, or possibly more than one type of animation in one. An animation is made up of many 'tracks', which are the more specific types of animation. You should not create these animations directly. They will be created via a parent object which owns the animation, e.g. Skeleton. </summary>
    </member>
    <member name="M:Mogre.Animation.CreateNodeTrack(System.UInt16,Mogre.Node)">
      <summary>Creates a new AnimationTrack automatically associated with a Node. This method creates a standard AnimationTrack, but also associates it with a target Node which will receive all keyframe effects. </summary>
      <param name="handle">Numeric handle to give the track, used for accessing the track later. Must be unique within this Animation. </param>
      <param name="node">A pointer to the Node object which will be affected by this track </param>
    </member>
    <member name="M:Mogre.Animation.CreateNodeTrack(System.UInt16)">
      <summary>Creates a NodeAnimationTrack for animating a Node. </summary>
      <param name="handle">Handle to give the track, used for accessing the track later. Must be unique within this Animation. </param>
    </member>
    <member name="M:Mogre.Animation.CreateNumericTrack(System.UInt16,Mogre.AnimableValuePtr)">
      <summary>Creates a NumericAnimationTrack and associates it with an animable. </summary>
      <param name="handle">Handle to give the track, used for accessing the track later. </param>
      <param name="anim">Animable object link Must be unique within this Animation. </param>
    </member>
    <member name="M:Mogre.Animation.CreateNumericTrack(System.UInt16)">
      <summary>Creates a NumericAnimationTrack for animating any numeric value. </summary>
      <param name="handle">Handle to give the track, used for accessing the track later. Must be unique within this Animation. </param>
    </member>
    <member name="M:Mogre.Animation.CreateVertexTrack(System.UInt16,Mogre.VertexData,Mogre.VertexAnimationType)">
      <summary>Creates a VertexAnimationTrack and associates it with VertexData. </summary>
      <param name="handle">Handle to give the track, used for accessing the track later. </param>
      <param name="data">VertexData object link </param>
      <param name="animType">The animation type Must be unique within this Animation. </param>
    </member>
    <member name="M:Mogre.Animation.CreateVertexTrack(System.UInt16,Mogre.VertexAnimationType)">
      <summary>Creates a VertexAnimationTrack for animating vertex position data. </summary>
      <param name="handle">Handle to give the track, used for accessing the track later. Must be unique within this Animation, and is used to identify the target. For example when applied to a Mesh, the handle must reference the index of the geometry being modified; 0 for the shared geometry, and 1+ for SubMesh geometry with the same index-1. </param>
      <param name="animType">Either morph or pose animation, </param>
    </member>
    <member name="M:Mogre.Animation.GetNodeTrack(System.UInt16)">
      <summary>Gets a node track by it's handle. </summary>
    </member>
    <member name="M:Mogre.Animation.HasNodeTrack(System.UInt16)">
      <summary>Does a track exist with the given handle? </summary>
    </member>
    <member name="M:Mogre.Animation.GetNumericTrack(System.UInt16)">
      <summary>Gets a numeric track by it's handle. </summary>
    </member>
    <member name="M:Mogre.Animation.HasNumericTrack(System.UInt16)">
      <summary>Does a track exist with the given handle? </summary>
    </member>
    <member name="M:Mogre.Animation.GetVertexTrack(System.UInt16)">
      <summary>Gets a Vertex track by it's handle. </summary>
    </member>
    <member name="M:Mogre.Animation.HasVertexTrack(System.UInt16)">
      <summary>Does a track exist with the given handle? </summary>
    </member>
    <member name="M:Mogre.Animation.DestroyNodeTrack(System.UInt16)">
      <summary>Destroys the node track with the given handle. </summary>
    </member>
    <member name="M:Mogre.Animation.DestroyNumericTrack(System.UInt16)">
      <summary>Destroys the numeric track with the given handle. </summary>
    </member>
    <member name="M:Mogre.Animation.DestroyVertexTrack(System.UInt16)">
      <summary>Destroys the Vertex track with the given handle. </summary>
    </member>
    <member name="M:Mogre.Animation.DestroyAllTracks">
      <summary>Removes and destroys all tracks making up this animation. </summary>
    </member>
    <member name="M:Mogre.Animation.DestroyAllNodeTracks">
      <summary>Removes and destroys all tracks making up this animation. </summary>
    </member>
    <member name="M:Mogre.Animation.DestroyAllNumericTracks">
      <summary>Removes and destroys all tracks making up this animation. </summary>
    </member>
    <member name="M:Mogre.Animation.DestroyAllVertexTracks">
      <summary>Removes and destroys all tracks making up this animation. </summary>
    </member>
    <member name="M:Mogre.Animation.Apply(Mogre.Entity,System.Single,System.Single,System.Boolean,System.Boolean)">
      <summary>Applies all vertex tracks given a specific time point and weight to a given entity. </summary>
      <param name="entity">The Entity to which this animation should be applied </param>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The weight at which the animation should be applied (only affects pose animation) </param>
      <param name="software">Whether to populate the software morph vertex data </param>
      <param name="hardware">Whether to populate the hardware morph vertex data </param>
    </member>
    <member name="M:Mogre.Animation.Apply(Mogre.Skeleton,System.Single,System.Single,Mogre.AnimationState+Const_BoneBlendMask,System.Single)">
      <summary>Applies all node tracks given a specific time point and weight to a given skeleton. Where you have associated animation tracks with Node objects, you can easily apply an animation to those nodes by calling this method. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
      <param name="blendMask">The influence array defining additional per bone weights. These will be modulated with the weight factor. </param>
      <param name="scale">The scale to apply to translations and scalings, useful for adapting an animation to a different size target. </param>
    </member>
    <member name="M:Mogre.Animation.Apply(Mogre.Skeleton,System.Single)">
      <summary>Applies all node tracks given a specific time point and weight to a given skeleton. Where you have associated animation tracks with Node objects, you can easily apply an animation to those nodes by calling this method. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
    </member>
    <member name="M:Mogre.Animation.Apply(Mogre.Skeleton,System.Single,System.Single)">
      <summary>Applies all node tracks given a specific time point and weight to a given skeleton. Where you have associated animation tracks with Node objects, you can easily apply an animation to those nodes by calling this method. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
    </member>
    <member name="M:Mogre.Animation.Apply(Mogre.Skeleton,System.Single,System.Single,System.Single)">
      <summary>Applies all node tracks given a specific time point and weight to a given skeleton. Where you have associated animation tracks with Node objects, you can easily apply an animation to those nodes by calling this method. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
      <param name="scale">The scale to apply to translations and scalings, useful for adapting an animation to a different size target. </param>
    </member>
    <member name="M:Mogre.Animation.Apply(System.Single)">
      <summary>Applies an animation given a specific time point and weight. Where you have associated animation tracks with objects, you can easily apply an animation to those objects by calling this method. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
    </member>
    <member name="M:Mogre.Animation.Apply(System.Single,System.Single)">
      <summary>Applies an animation given a specific time point and weight. Where you have associated animation tracks with objects, you can easily apply an animation to those objects by calling this method. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
    </member>
    <member name="M:Mogre.Animation.Apply(System.Single,System.Single,System.Single)">
      <summary>Applies an animation given a specific time point and weight. Where you have associated animation tracks with objects, you can easily apply an animation to those objects by calling this method. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
      <param name="scale">The scale to apply to translations and scalings, useful for adapting an animation to a different size target. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToNode(Mogre.Node,System.Single)">
      <summary>Applies all node tracks given a specific time point and weight to the specified node. It does not consider the actual node tracks are attached to. As such, it resembles the apply method for a given skeleton (see below). </summary>
      <param name="timePos">The time position in the animation to apply. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToNode(Mogre.Node,System.Single,System.Single)">
      <summary>Applies all node tracks given a specific time point and weight to the specified node. It does not consider the actual node tracks are attached to. As such, it resembles the apply method for a given skeleton (see below). </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToNode(Mogre.Node,System.Single,System.Single,System.Single)">
      <summary>Applies all node tracks given a specific time point and weight to the specified node. It does not consider the actual node tracks are attached to. As such, it resembles the apply method for a given skeleton (see below). </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
      <param name="scale">The scale to apply to translations and scalings, useful for adapting an animation to a different size target. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToAnimable(Mogre.AnimableValuePtr,System.Single)">
      <summary>Applies all numeric tracks given a specific time point and weight to the specified animable value. It does not applies to actual attached animable values but rather uses all tracks for a single animable value. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToAnimable(Mogre.AnimableValuePtr,System.Single,System.Single)">
      <summary>Applies all numeric tracks given a specific time point and weight to the specified animable value. It does not applies to actual attached animable values but rather uses all tracks for a single animable value. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToAnimable(Mogre.AnimableValuePtr,System.Single,System.Single,System.Single)">
      <summary>Applies all numeric tracks given a specific time point and weight to the specified animable value. It does not applies to actual attached animable values but rather uses all tracks for a single animable value. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
      <param name="scale">The scale to apply to translations and scalings, useful for adapting an animation to a different size target. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToVertexData(Mogre.VertexData,System.Single)">
      <summary>Applies all vertex tracks given a specific time point and weight to the specified vertex data. It does not apply to the actual attached vertex data but rather uses all tracks for a given vertex data. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
    </member>
    <member name="M:Mogre.Animation.ApplyToVertexData(Mogre.VertexData,System.Single,System.Single)">
      <summary>Applies all vertex tracks given a specific time point and weight to the specified vertex data. It does not apply to the actual attached vertex data but rather uses all tracks for a given vertex data. </summary>
      <param name="timePos">The time position in the animation to apply. </param>
      <param name="weight">The influence to give to this track, 1.0 for full influence, less to blend with other animations. </param>
    </member>
    <member name="M:Mogre.Animation.SetInterpolationMode(Mogre.Animation+InterpolationMode)">
      <summary>Tells the animation how to interpolate between keyframes. By default, animations normally interpolate linearly between keyframes. This is fast, but when animations include quick changes in direction it can look a little unnatural because directions change instantly at keyframes. An alternative is to tell the animation to interpolate along a spline, which is more expensive in terms of calculation time, but looks smoother because major changes in direction are distributed around the keyframes rather than just at the keyframe. You can also change the default animation behaviour by calling Animation::setDefaultInterpolationMode. </summary>
    </member>
    <member name="M:Mogre.Animation.GetInterpolationMode">
      <summary>Gets the current interpolation mode of this animation. See setInterpolationMode for more info. </summary>
    </member>
    <member name="M:Mogre.Animation.SetRotationInterpolationMode(Mogre.Animation+RotationInterpolationMode)">
      <summary>Tells the animation how to interpolate rotations. By default, animations interpolate linearly between rotations. This is fast but not necessarily completely accurate. If you want more accurate interpolation, use spherical interpolation, but be aware that it will incur a higher cost. You can also change the default rotation behaviour by calling Animation::setDefaultRotationInterpolationMode. </summary>
    </member>
    <member name="M:Mogre.Animation.GetRotationInterpolationMode">
      <summary>Gets the current rotation interpolation mode of this animation. See setRotationInterpolationMode for more info. </summary>
    </member>
    <member name="M:Mogre.Animation._getNodeTrackList">
      <summary>Fast access to NON-UPDATEABLE node track list. </summary>
    </member>
    <member name="M:Mogre.Animation.GetNodeTrackIterator">
      <summary>Get non-updateable iterator over node tracks. </summary>
    </member>
    <member name="M:Mogre.Animation._getNumericTrackList">
      <summary>Fast access to NON-UPDATEABLE numeric track list. </summary>
    </member>
    <member name="M:Mogre.Animation.GetNumericTrackIterator">
      <summary>Get non-updateable iterator over node tracks. </summary>
    </member>
    <member name="M:Mogre.Animation._getVertexTrackList">
      <summary>Fast access to NON-UPDATEABLE Vertex track list. </summary>
    </member>
    <member name="M:Mogre.Animation.GetVertexTrackIterator">
      <summary>Get non-updateable iterator over node tracks. </summary>
    </member>
    <member name="M:Mogre.Animation.Optimise">
      <summary>Optimise an animation by removing unnecessary tracks and keyframes. When you export an animation, it is possible that certain tracks have been keyframed but actually don't include anything useful - the keyframes include no transformation. These tracks can be completely eliminated from the animation and thus speed up the animation. In addition, if several keyframes in a row have the same value, then they are just adding overhead and can be removed. Since track-less and identity track has difference behavior for accumulate animation blending if corresponding track presenting at other animation that is non-identity, and in normally this method didn't known about the situation of other animation, it can't deciding whether or not discards identity tracks. So there have a parameter allow you choose what you want, in case you aren't sure how to do that, you should use Skeleton::optimiseAllAnimations instead. </summary>
    </member>
    <member name="M:Mogre.Animation.Optimise(System.Boolean)">
      <summary>Optimise an animation by removing unnecessary tracks and keyframes. When you export an animation, it is possible that certain tracks have been keyframed but actually don't include anything useful - the keyframes include no transformation. These tracks can be completely eliminated from the animation and thus speed up the animation. In addition, if several keyframes in a row have the same value, then they are just adding overhead and can be removed. Since track-less and identity track has difference behavior for accumulate animation blending if corresponding track presenting at other animation that is non-identity, and in normally this method didn't known about the situation of other animation, it can't deciding whether or not discards identity tracks. So there have a parameter allow you choose what you want, in case you aren't sure how to do that, you should use Skeleton::optimiseAllAnimations instead. </summary>
      <param name="discardIdentityNodeTracks">If true, discard identity node tracks. </param>
    </member>
    <member name="M:Mogre.Animation._collectIdentityNodeTracks(Mogre.Animation+TrackHandleList)">
      <summary>Internal method for collecting identity node tracks. This method remove non-identity node tracks form the track handle list. </summary>
      <param name="tracks">A list of track handle of non-identity node tracks, where this method will remove non-identity node track handles. </param>
    </member>
    <member name="M:Mogre.Animation._destroyNodeTracks(Mogre.Animation+Const_TrackHandleList)">
      <summary>Internal method for destroy given node tracks. </summary>
    </member>
    <member name="M:Mogre.Animation.Clone(System.String)">
      <summary>Clone this animation. The pointer returned from this method is the only one recorded, thus it is up to the caller to arrange for the deletion of this object. </summary>
    </member>
    <member name="M:Mogre.Animation._keyFrameListChanged">
      <summary>Internal method used to tell the animation that keyframe list has been changed, which may cause it to rebuild some internal data </summary>
    </member>
    <member name="M:Mogre.Animation._getTimeIndex(System.Single)">
      <summary>Internal method used to convert time position to time index object. The time index returns by this function are associated with state of the animation object, if the animation object altered (e.g. create/remove keyframe or track), all related time index will invalidated. The time index object which contains wrapped time position (in relation to the whole animation sequence) and lower bound index of global keyframe time list. </summary>
      <param name="timePos">The time position. </param>
    </member>
    <member name="M:Mogre.Animation.#ctor(System.String,System.Single)">
      <summary>You should not use this constructor directly, use the parent object such as Skeleton instead. </summary>
      <param name="name">The name of the animation, should be unique within it's parent (e.g. Skeleton) </param>
      <param name="length">The length of the animation in seconds. </param>
    </member>
    <member name="P:Mogre.Animation.NumVertexTracks">
      <summary>Gets the number of VertexAnimationTrack objects contained in this animation. </summary>
    </member>
    <member name="P:Mogre.Animation.NumNumericTracks">
      <summary>Gets the number of NumericAnimationTrack objects contained in this animation. </summary>
    </member>
    <member name="P:Mogre.Animation.NumNodeTracks">
      <summary>Gets the number of NodeAnimationTrack objects contained in this animation. </summary>
    </member>
    <member name="P:Mogre.Animation.Name">
      <summary>Gets the name of this animation. </summary>
    </member>
    <member name="P:Mogre.Animation.Length">
      <summary>Sets/Gets the total length of the animation. </summary>
    </member>
    <member name="P:Mogre.Animation.DefaultRotationInterpolationMode">
      <summary>Sets/Gets the default rotation interpolation mode for all animations. </summary>
    </member>
    <member name="P:Mogre.Animation.DefaultInterpolationMode">
      <summary>Sets/Gets the default interpolation mode for all animations. </summary>
    </member>
    <member name="T:Mogre.Animation+InterpolationMode">
      <summary>The types of animation interpolation available. </summary>
    </member>
    <member name="F:Mogre.Animation+InterpolationMode.IM_LINEAR">
      <summary>Values are interpolated along straight lines. </summary>
    </member>
    <member name="F:Mogre.Animation+InterpolationMode.IM_SPLINE">
      <summary>Values are interpolated along a spline, resulting in smoother changes in direction. </summary>
    </member>
    <member name="T:Mogre.Animation+RotationInterpolationMode">
      <summary>The types of rotational interpolation available. </summary>
    </member>
    <member name="F:Mogre.Animation+RotationInterpolationMode.RIM_LINEAR">
      <summary>Values are interpolated linearly. This is faster but does not necessarily give a completely accurate result. </summary>
    </member>
    <member name="F:Mogre.Animation+RotationInterpolationMode.RIM_SPHERICAL">
      <summary>Values are interpolated spherically. This is more accurate but has a higher cost. </summary>
    </member>
    <member name="T:Mogre.Node">
      <summary>Class representing a general-purpose node an articulated scene graph. A node in the scene graph is a node in a structured tree. A node contains information about the transformation which will apply to it and all of it's children. Child nodes can have transforms of their own, which are combined with their parent's transformations. This is an abstract class - concrete classes are based on this for specific purposes, e.g. SceneNode, Bone</summary>
    </member>
    <member name="M:Mogre.Node.SetOrientation(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the orientation of this node via quaternion parameters. Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. Note that rotations are oriented around the node's origin. </summary>
    </member>
    <member name="M:Mogre.Node.ResetOrientation">
      <summary>Resets the nodes orientation (local axes as world axes, no rotation). Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. Note that rotations are oriented around the node's origin. </summary>
    </member>
    <member name="M:Mogre.Node.SetPosition(System.Single,System.Single,System.Single)">
      <summary>Sets the position of the node relative to it's parent. </summary>
    </member>
    <member name="M:Mogre.Node.SetScale(System.Single,System.Single,System.Single)">
      <summary>Sets the scaling factor applied to this node. Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. Note that like rotations, scalings are oriented around the node's origin. </summary>
    </member>
    <member name="M:Mogre.Node.SetScale(Mogre.Vector3)">
      <summary>Sets the scaling factor applied to this node. Scaling factors, unlike other transforms, are not always inherited by child nodes. Whether or not scalings affect the size of the child nodes depends on the setInheritScale option of the child. In some cases you want a scaling factor of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative size based on the parent's size), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own size). The default is to inherit as with other transforms. Note that like rotations, scalings are oriented around the node's origin. </summary>
    </member>
    <member name="M:Mogre.Node.GetScale">
      <summary>Gets the scaling factor of this node. </summary>
    </member>
    <member name="M:Mogre.Node.Scale(System.Single,System.Single,System.Single)">
      <summary>Scales the node, combining it's current scale with the passed in scaling factor. This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. Note that like rotations, scalings are oriented around the node's origin. </summary>
    </member>
    <member name="M:Mogre.Node.Scale(Mogre.Vector3)">
      <summary>Scales the node, combining it's current scale with the passed in scaling factor. This method applies an extra scaling factor to the node's existing scale, (unlike setScale which overwrites it) combining it's current scale with the new one. E.g. calling this method twice with Vector3(2,2,2) would have the same effect as setScale(Vector3(4,4,4)) if the existing scale was 1. Note that like rotations, scalings are oriented around the node's origin. </summary>
    </member>
    <member name="M:Mogre.Node.Translate(Mogre.Matrix3,System.Single,System.Single,System.Single)">
      <summary>Moves the node along arbitrary axes. This method translates the node by a vector which is relative to a custom set of axes. </summary>
      <param name="axes">A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as 
                1 0 0
                0 1 0
                0 0 1
                 i.e. the identity matrix. </param>
      <param name="x">Translation components relative to the axes above. </param>
    </member>
    <member name="M:Mogre.Node.Translate(Mogre.Matrix3,System.Single,System.Single,System.Single,Mogre.Node+TransformSpace)">
      <summary>Moves the node along arbitrary axes. This method translates the node by a vector which is relative to a custom set of axes. </summary>
      <param name="axes">A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as 
                1 0 0
                0 1 0
                0 0 1
                 i.e. the identity matrix. </param>
      <param name="x">Translation components relative to the axes above. </param>
      <param name="relativeTo">The space which this transform is relative to. </param>
    </member>
    <member name="M:Mogre.Node.Translate(Mogre.Matrix3,Mogre.Vector3)">
      <summary>Moves the node along arbitrary axes. This method translates the node by a vector which is relative to a custom set of axes. </summary>
      <param name="axes">A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as: 
                1 0 0
                0 1 0
                0 0 1
                 i.e. the identity matrix. </param>
      <param name="move">Vector relative to the axes above. </param>
    </member>
    <member name="M:Mogre.Node.Translate(Mogre.Matrix3,Mogre.Vector3,Mogre.Node+TransformSpace)">
      <summary>Moves the node along arbitrary axes. This method translates the node by a vector which is relative to a custom set of axes. </summary>
      <param name="axes">A 3x3 Matrix containg 3 column vectors each representing the axes X, Y and Z respectively. In this format the standard cartesian axes would be expressed as: 
                1 0 0
                0 1 0
                0 0 1
                 i.e. the identity matrix. </param>
      <param name="move">Vector relative to the axes above. </param>
      <param name="relativeTo">The space which this transform is relative to. </param>
    </member>
    <member name="M:Mogre.Node.Translate(System.Single,System.Single,System.Single)">
      <summary>Moves the node along the Cartesian axes. This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </summary>
      <param name="x" />
      <param name="y" />
      <param name="z">Real x, y and z values representing the translation. </param>
    </member>
    <member name="M:Mogre.Node.Translate(System.Single,System.Single,System.Single,Mogre.Node+TransformSpace)">
      <summary>Moves the node along the Cartesian axes. This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </summary>
      <param name="x" />
      <param name="y" />
      <param name="z">Real x, y and z values representing the translation. </param>
      <param name="relativeTo">The space which this transform is relative to. </param>
    </member>
    <member name="M:Mogre.Node.Translate(Mogre.Vector3)">
      <summary>Moves the node along the Cartesian axes. This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </summary>
      <param name="d">Vector with x,y,z values representing the translation. </param>
    </member>
    <member name="M:Mogre.Node.Translate(Mogre.Vector3,Mogre.Node+TransformSpace)">
      <summary>Moves the node along the Cartesian axes. This method moves the node by the supplied vector along the world Cartesian axes, i.e. along world x,y,z </summary>
      <param name="d">Vector with x,y,z values representing the translation. </param>
      <param name="relativeTo">The space which this transform is relative to. </param>
    </member>
    <member name="M:Mogre.Node.Roll(Mogre.Radian)">
      <summary>Rotate the node around the Z-axis. </summary>
    </member>
    <member name="M:Mogre.Node.Roll(Mogre.Radian,Mogre.Node+TransformSpace)">
      <summary>Rotate the node around the Z-axis. </summary>
    </member>
    <member name="M:Mogre.Node.Pitch(Mogre.Radian)">
      <summary>Rotate the node around the X-axis. </summary>
    </member>
    <member name="M:Mogre.Node.Pitch(Mogre.Radian,Mogre.Node+TransformSpace)">
      <summary>Rotate the node around the X-axis. </summary>
    </member>
    <member name="M:Mogre.Node.Yaw(Mogre.Radian)">
      <summary>Rotate the node around the Y-axis. </summary>
    </member>
    <member name="M:Mogre.Node.Yaw(Mogre.Radian,Mogre.Node+TransformSpace)">
      <summary>Rotate the node around the Y-axis. </summary>
    </member>
    <member name="M:Mogre.Node.Rotate(Mogre.Quaternion)">
      <summary>Rotate the node around an aritrary axis using a Quarternion. </summary>
    </member>
    <member name="M:Mogre.Node.Rotate(Mogre.Quaternion,Mogre.Node+TransformSpace)">
      <summary>Rotate the node around an aritrary axis using a Quarternion. </summary>
    </member>
    <member name="M:Mogre.Node.Rotate(Mogre.Vector3,Mogre.Radian)">
      <summary>Rotate the node around an arbitrary axis. </summary>
    </member>
    <member name="M:Mogre.Node.Rotate(Mogre.Vector3,Mogre.Radian,Mogre.Node+TransformSpace)">
      <summary>Rotate the node around an arbitrary axis. </summary>
    </member>
    <member name="M:Mogre.Node.CreateChild(System.String)">
      <summary>Creates a new named Node as a child of this node. This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </summary>
    </member>
    <member name="M:Mogre.Node.CreateChild(System.String,Mogre.Vector3)">
      <summary>Creates a new named Node as a child of this node. This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
    </member>
    <member name="M:Mogre.Node.CreateChild(System.String,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates a new named Node as a child of this node. This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
      <param name="rotate">Initial rotation relative to parent </param>
    </member>
    <member name="M:Mogre.Node.CreateChild">
      <summary>Creates an unnamed new Node as a child of this node. </summary>
    </member>
    <member name="M:Mogre.Node.CreateChild(Mogre.Vector3)">
      <summary>Creates an unnamed new Node as a child of this node. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
    </member>
    <member name="M:Mogre.Node.CreateChild(Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates an unnamed new Node as a child of this node. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
      <param name="rotate">Initial rotation relative to parent </param>
    </member>
    <member name="M:Mogre.Node.AddChild(Mogre.Node)">
      <summary>Adds a (precreated) child scene node to this node. If it is attached to another node, it must be detached first. </summary>
      <param name="child">The Node which is to become a child node of this one </param>
    </member>
    <member name="M:Mogre.Node.NumChildren">
      <summary>Reports the number of child nodes under this one. </summary>
    </member>
    <member name="M:Mogre.Node.GetChild(System.String)">
      <summary>Gets a pointer to a child node. There is an alternate getChild method which returns a named child. </summary>
    </member>
    <member name="M:Mogre.Node.GetChild(System.UInt16)">
      <summary>Gets a pointer to a child node. There is an alternate getChild method which returns a named child. </summary>
    </member>
    <member name="M:Mogre.Node.GetChildIterator">
      <summary>Retrieves an iterator for efficiently looping through all children of this node. Using this is faster than repeatedly calling getChild if you want to go through all (or most of) the children of this node. Note that the returned iterator is only valid whilst no children are added or removed from this node. Thus you should not store this returned iterator for later use, nor should you add / remove children whilst iterating through it; store up changes for later. Note that calling methods on returned items in the iterator IS allowed and does not invalidate the iterator. </summary>
    </member>
    <member name="M:Mogre.Node.RemoveChild(System.String)">
      <summary>Drops the named child from this node. Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. </summary>
    </member>
    <member name="M:Mogre.Node.RemoveChild(Mogre.Node)">
      <summary>Drops the specified child from this node. Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </summary>
    </member>
    <member name="M:Mogre.Node.RemoveChild(System.UInt16)">
      <summary>Drops the specified child from this node. Does not delete the node, just detaches it from this parent, potentially to be reattached elsewhere. There is also an alternate version which drops a named child from this node. </summary>
    </member>
    <member name="M:Mogre.Node.RemoveAllChildren">
      <summary>Removes all child Nodes attached to this node. Does not delete the nodes, just detaches them from this parent, potentially to be reattached elsewhere. </summary>
    </member>
    <member name="M:Mogre.Node._setDerivedPosition(Mogre.Vector3)">
      <summary>Sets the final world position of the node directly. It's advisable to use the local setPosition if possible </summary>
    </member>
    <member name="M:Mogre.Node._setDerivedOrientation(Mogre.Quaternion)">
      <summary>Sets the final world orientation of the node directly. It's advisable to use the local setOrientation if possible, this simply does the conversion for you. </summary>
    </member>
    <member name="M:Mogre.Node._getDerivedOrientation">
      <summary>Gets the orientation of the node as derived from all parents. </summary>
    </member>
    <member name="M:Mogre.Node._getDerivedPosition">
      <summary>Gets the position of the node as derived from all parents. </summary>
    </member>
    <member name="M:Mogre.Node._getDerivedScale">
      <summary>Gets the scaling factor of the node as derived from all parents. </summary>
    </member>
    <member name="M:Mogre.Node._getFullTransform">
      <summary>Gets the full transformation matrix for this node. This method returns the full transformation matrix for this node, including the effect of any parent node transformations, provided they have been updated using the Node::_update method. This should only be called by a SceneManager which knows the derived transforms have been updated before calling this method. Applications using Ogre should just use the relative transforms. </summary>
    </member>
    <member name="M:Mogre.Node._update(System.Boolean,System.Boolean)">
      <summary>Internal method to update the Node. Updates this node and any relevant children to incorporate transforms etc. Don't call this yourself unless you are writing a SceneManager implementation. </summary>
      <param name="updateChildren">If true, the update cascades down to all children. Specify false if you wish to update children separately, e.g. because of a more selective SceneManager implementation. </param>
      <param name="parentHasChanged">This flag indicates that the parent xform has changed, so the child should retrieve the parent's xform and combine it with its own even if it hasn't changed itself. </param>
    </member>
    <member name="M:Mogre.Node.SetListener(Mogre.Node+IListener)">
      <summary>Sets a listener for this Node. Note for size and performance reasons only one listener per node is allowed. </summary>
    </member>
    <member name="M:Mogre.Node.GetListener">
      <summary>Gets the current listener for this Node. </summary>
    </member>
    <member name="M:Mogre.Node.SetInitialState">
      <summary>Sets the current transform of this node to be the 'initial state' ie that position / orientation / scale to be used as a basis for delta values used in keyframe animation. You never need to call this method unless you plan to animate this node. If you do plan to animate it, call this method once you've loaded the node with it's base state, ie the state on which all keyframes are based. If you never call this method, the initial state is the identity transform, ie do nothing. </summary>
    </member>
    <member name="M:Mogre.Node.ResetToInitialState">
      <summary>Resets the position / orientation / scale of this node to it's initial state, see setInitialState for more info. </summary>
    </member>
    <member name="M:Mogre.Node.ConvertWorldToLocalPosition(Mogre.Vector3)">
      <summary>Gets the local position, relative to this node, of the given world-space position </summary>
    </member>
    <member name="M:Mogre.Node.ConvertLocalToWorldPosition(Mogre.Vector3)">
      <summary>Gets the world position of a point in the node local space useful for simple transforms that don't require a child node. </summary>
    </member>
    <member name="M:Mogre.Node.ConvertWorldToLocalOrientation(Mogre.Quaternion)">
      <summary>Gets the local orientation, relative to this node, of the given world-space orientation </summary>
    </member>
    <member name="M:Mogre.Node.ConvertLocalToWorldOrientation(Mogre.Quaternion)">
      <summary>Gets the world orientation of an orientation in the node local space useful for simple transforms that don't require a child node. </summary>
    </member>
    <member name="M:Mogre.Node.GetSquaredViewDepth(Mogre.Camera)">
      <summary>Helper function, get the squared view depth. </summary>
    </member>
    <member name="M:Mogre.Node.NeedUpdate">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. </summary>
    </member>
    <member name="M:Mogre.Node.NeedUpdate(System.Boolean)">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. </summary>
      <param name="forceParentUpdate">Even if the node thinks it has already told it's parent, tell it anyway </param>
    </member>
    <member name="M:Mogre.Node.RequestUpdate(Mogre.Node)">
      <summary>Called by children to notify their parent that they need an update. </summary>
    </member>
    <member name="M:Mogre.Node.RequestUpdate(Mogre.Node,System.Boolean)">
      <summary>Called by children to notify their parent that they need an update. </summary>
      <param name="forceParentUpdate">Even if the node thinks it has already told it's parent, tell it anyway </param>
    </member>
    <member name="M:Mogre.Node.CancelUpdate(Mogre.Node)">
      <summary>Called by children to notify their parent that they no longer need an update. </summary>
    </member>
    <member name="M:Mogre.Node.QueueNeedUpdate(Mogre.Node)">
      <summary>Queue a 'needUpdate' call to a node safely. You can't call needUpdate() during the scene graph update, e.g. in response to a Node::Listener hook, because the graph is already being updated, and update flag changes cannot be made reliably in that context. Call this method if you need to queue a needUpdate call in this case. </summary>
    </member>
    <member name="M:Mogre.Node.ProcessQueuedUpdates">
      <summary>Process queued 'needUpdate' calls. </summary>
    </member>
    <member name="P:Mogre.Node.UserObjectBindings">
      <summary>Return an instance of user objects binding associated with this class. You can use it to associate one or more custom objects with this class instance. UserObjectBindings::setUserAny. </summary>
    </member>
    <member name="P:Mogre.Node.Position">
      <summary>Sets/Gets the position of the node relative to it's parent. </summary>
    </member>
    <member name="P:Mogre.Node.Parent">
      <summary>Gets this node's parent (NULL if this is the root). </summary>
    </member>
    <member name="P:Mogre.Node.Orientation">
      <summary>Sets/Returns a quaternion representing the nodes orientation. </summary>
    </member>
    <member name="P:Mogre.Node.Name">
      <summary>Returns the name of the node. </summary>
    </member>
    <member name="P:Mogre.Node.LocalAxes">
      <summary>Gets a matrix whose columns are the local axes based on the nodes orientation relative to it's parent. </summary>
    </member>
    <member name="P:Mogre.Node.InitialScale">
      <summary>Gets the initial position of this node, see setInitialState for more info. </summary>
    </member>
    <member name="P:Mogre.Node.InitialPosition">
      <summary>Gets the initial position of this node, see setInitialState for more info. Also resets the cumulative animation weight used for blending. </summary>
    </member>
    <member name="P:Mogre.Node.InitialOrientation">
      <summary>Gets the initial orientation of this node, see setInitialState for more info. </summary>
    </member>
    <member name="P:Mogre.Node.InheritScale">
      <summary>Sets/Returns true if this node is affected by scaling factors applied to the parent node. See setInheritScale for more info. </summary>
    </member>
    <member name="P:Mogre.Node.InheritOrientation">
      <summary>Sets/Returns true if this node is affected by orientation applied to the parent node. Orientations, unlike other transforms, are not always inherited by child nodes. Whether or not orientations affect the orientation of the child nodes depends on the setInheritOrientation option of the child. In some cases you want a orientating of a parent node to apply to a child node (e.g. where the child node is a part of the same object, so you want it to be the same relative orientation based on the parent's orientation), but not in other cases (e.g. where the child node is just for positioning another object, you want it to maintain it's own orientation). The default is to inherit as with other transforms. See setInheritOrientation for more info. </summary>
    </member>
    <member name="T:Mogre.Node+TransformSpace">
      <summary>Enumeration denoting the spaces which a transform can be relative to. </summary>
    </member>
    <member name="F:Mogre.Node+TransformSpace.TS_LOCAL">
      <summary>Transform is relative to the local space. </summary>
    </member>
    <member name="F:Mogre.Node+TransformSpace.TS_PARENT">
      <summary>Transform is relative to the space of the parent node. </summary>
    </member>
    <member name="F:Mogre.Node+TransformSpace.TS_WORLD">
      <summary>Transform is relative to world space. </summary>
    </member>
    <member name="T:Mogre.HardwareBuffer">
      <summary>Abstract class defining common features of hardware buffers. A 'hardware buffer' is any area of memory held outside of core system ram, and in our case refers mostly to video ram, although in theory this class could be used with other memory areas such as sound card memory, custom coprocessor memory etc. This reflects the fact that memory held outside of main system RAM must be interacted with in a more formal fashion in order to promote cooperative and optimal usage of the buffers between the various processing units which manipulate them. This abstract class defines the core interface which is common to all buffers, whether it be vertex buffers, index buffers, texture memory or framebuffer memory etc. Buffers have the ability to be 'shadowed' in system memory, this is because the kinds of access allowed on hardware buffers is not always as flexible as that allowed for areas of system memory - for example it is often either impossible, or extremely undesirable from a performance standpoint to read from a hardware buffer; when writing to hardware buffers, you should also write every byte and do it sequentially. In situations where this is too restrictive, it is possible to create a hardware, write-only buffer (the most efficient kind) and to back it with a system memory 'shadow' copy which can be read and updated arbitrarily. Ogre handles synchronising this buffer with the real hardware buffer (which should still be created with the HBU_DYNAMIC flag if you intend to update it very frequently). Whilst this approach does have it's own costs, such as increased memory overhead, these costs can often be outweighed by the performance benefits of using a more hardware efficient buffer. You should look for the 'useShadowBuffer' parameter on the creation methods used to create the buffer of the type you require (see HardwareBufferManager) to enable this feature. </summary>
    </member>
    <member name="M:Mogre.HardwareBuffer.Lock(Mogre.HardwareBuffer+LockOptions)">
      <summary>Lock the entire buffer for (potentially) reading / writing. Pointer to the locked memory </summary>
      <param name="options">Locking options </param>
    </member>
    <member name="M:Mogre.HardwareBuffer.Lock(System.UInt32,System.UInt32,Mogre.HardwareBuffer+LockOptions)">
      <summary>Lock the buffer for (potentially) reading / writing. Pointer to the locked memory </summary>
      <param name="offset">The byte offset from the start of the buffer to lock </param>
      <param name="length">The size of the area to lock, in bytes </param>
      <param name="options">Locking options </param>
    </member>
    <member name="M:Mogre.HardwareBuffer.Unlock">
      <summary>Releases the lock on this buffer. Locking and unlocking a buffer can, in some rare circumstances such as switching video modes whilst the buffer is locked, corrupt the contents of a buffer. This is pretty rare, but if it occurs, this method will throw an exception, meaning you must re-upload the data. Note that using the 'read' and 'write' forms of updating the buffer does not suffer from this problem, so if you want to be 100% sure your data will not be lost, use the 'read' and 'write' forms instead. </summary>
    </member>
    <member name="M:Mogre.HardwareBuffer.ReadData(System.UInt32,System.UInt32,System.Void*)">
      <summary>Reads data from the buffer and places it in the memory pointed to by pDest. </summary>
      <param name="offset">The byte offset from the start of the buffer to read </param>
      <param name="length">The size of the area to read, in bytes </param>
      <param name="pDest">The area of memory in which to place the data, must be large enough to accommodate the data! </param>
    </member>
    <member name="M:Mogre.HardwareBuffer.WriteData(System.UInt32,System.UInt32,System.Void*)">
      <summary>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. </summary>
      <param name="offset">The byte offset from the start of the buffer to start writing </param>
      <param name="length">The size of the data to write to, in bytes </param>
      <param name="pSource">The source of the data to be written </param>
    </member>
    <member name="M:Mogre.HardwareBuffer.WriteData(System.UInt32,System.UInt32,System.Void*,System.Boolean)">
      <summary>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. </summary>
      <param name="offset">The byte offset from the start of the buffer to start writing </param>
      <param name="length">The size of the data to write to, in bytes </param>
      <param name="pSource">The source of the data to be written </param>
      <param name="discardWholeBuffer">If true, this allows the driver to discard the entire buffer when writing, such that DMA stalls can be avoided; use if you can. </param>
    </member>
    <member name="M:Mogre.HardwareBuffer.CopyData(Mogre.HardwareBuffer)">
      <summary>Copy data from another buffer into this one. Note that the source buffer must not be created with the usage HBU_WRITE_ONLY otherwise this will fail. </summary>
      <param name="srcBuffer">The buffer from which to read the copied data </param>
    </member>
    <member name="M:Mogre.HardwareBuffer.CopyData(Mogre.HardwareBuffer,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Copy data from another buffer into this one. Note that the source buffer must not be created with the usage HBU_WRITE_ONLY otherwise this will fail. </summary>
      <param name="srcBuffer">The buffer from which to read the copied data </param>
      <param name="srcOffset">Offset in the source buffer at which to start reading </param>
      <param name="dstOffset">Offset in the destination buffer to start writing </param>
      <param name="length">Length of the data to copy, in bytes. </param>
    </member>
    <member name="M:Mogre.HardwareBuffer.CopyData(Mogre.HardwareBuffer,System.UInt32,System.UInt32,System.UInt32,System.Boolean)">
      <summary>Copy data from another buffer into this one. Note that the source buffer must not be created with the usage HBU_WRITE_ONLY otherwise this will fail. </summary>
      <param name="srcBuffer">The buffer from which to read the copied data </param>
      <param name="srcOffset">Offset in the source buffer at which to start reading </param>
      <param name="dstOffset">Offset in the destination buffer to start writing </param>
      <param name="length">Length of the data to copy, in bytes. </param>
      <param name="discardWholeBuffer">If true, will discard the entire contents of this buffer before copying </param>
    </member>
    <member name="M:Mogre.HardwareBuffer._updateFromShadow">
      <summary>Updates the real buffer from the shadow buffer, if required. </summary>
    </member>
    <member name="M:Mogre.HardwareBuffer.GetUsage">
      <summary>Returns the Usage flags with which this buffer was created. </summary>
    </member>
    <member name="M:Mogre.HardwareBuffer.SuppressHardwareUpdate(System.Boolean)">
      <summary>Pass true to suppress hardware upload of shadow buffer changes. </summary>
    </member>
    <member name="P:Mogre.HardwareBuffer.SizeInBytes">
      <summary>Returns the size of this buffer in bytes. </summary>
    </member>
    <member name="P:Mogre.HardwareBuffer.IsSystemMemory">
      <summary>Returns whether this buffer is held in system memory. </summary>
    </member>
    <member name="P:Mogre.HardwareBuffer.IsLocked">
      <summary>Returns whether or not this buffer is currently locked. </summary>
    </member>
    <member name="P:Mogre.HardwareBuffer.HasShadowBuffer">
      <summary>Returns whether this buffer has a system memory shadow for quicker reading. </summary>
    </member>
    <member name="T:Mogre.HardwareBuffer+Usage">
      <summary>Enums describing buffer usage; not mutually exclusive. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+Usage.HBU_STATIC">
      <summary>Static buffer which the application rarely modifies once created. Modifying the contents of this buffer will involve a performance hit. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+Usage.HBU_DYNAMIC">
      <summary>Indicates the application would like to modify this buffer with the CPU fairly often. Buffers created with this flag will typically end up in AGP memory rather than video memory. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+Usage.HBU_WRITE_ONLY">
      <summary>Indicates the application will never read the contents of the buffer back, it will only ever write data. Locking a buffer with this flag will ALWAYS return a pointer to new, blank memory rather than the memory associated with the contents of the buffer; this avoids DMA stalls because you can write to a new memory area while the previous one is being used. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+Usage.HBU_DISCARDABLE">
      <summary>Indicates that the application will be refilling the contents of the buffer regularly (not just updating, but generating the contents from scratch), and therefore does not mind if the contents of the buffer are lost somehow and need to be recreated. This allows and additional level of optimisation on the buffer. This option only really makes sense when combined with HBU_DYNAMIC_WRITE_ONLY. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+Usage.HBU_STATIC_WRITE_ONLY">
      <summary>Combination of HBU_STATIC and HBU_WRITE_ONLY. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+Usage.HBU_DYNAMIC_WRITE_ONLY">
      <summary>Combination of HBU_DYNAMIC and HBU_WRITE_ONLY. If you use this, strongly consider using HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE instead if you update the entire contents of the buffer very regularly. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+Usage.HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE">
      <summary>Combination of HBU_DYNAMIC, HBU_WRITE_ONLY and HBU_DISCARDABLE. </summary>
    </member>
    <member name="T:Mogre.HardwareBuffer+LockOptions">
      <summary>Locking options. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+LockOptions.HBL_NORMAL">
      <summary>Normal mode, ie allows read/write and contents are preserved. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+LockOptions.HBL_DISCARD">
      <summary>Discards the entire buffer while locking; this allows optimisation to be performed because synchronisation issues are relaxed. Only allowed on buffers created with the HBU_DYNAMIC flag. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+LockOptions.HBL_READ_ONLY">
      <summary>Lock the buffer for reading only. Not allowed in buffers which are created with HBU_WRITE_ONLY. Mandatory on static buffers, i.e. those created without the HBU_DYNAMIC flag. </summary>
    </member>
    <member name="F:Mogre.HardwareBuffer+LockOptions.HBL_NO_OVERWRITE">
      <summary>As HBL_NORMAL, except the application guarantees not to overwrite any region of the buffer which has already been used in this frame, can allow some optimisation on some APIs. </summary>
    </member>
    <member name="T:Mogre.HardwareVertexBuffer">
      <summary>Specialisation of HardwareBuffer for a vertex buffer. </summary>
    </member>
    <member name="P:Mogre.HardwareVertexBuffer.VertexSize">
      <summary>Gets the size in bytes of a single vertex in this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwareVertexBuffer.NumVertices">
      <summary>Get the number of vertices in this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwareVertexBuffer.Manager">
      <summary>Return the manager of this buffer, if any. </summary>
    </member>
    <member name="T:Mogre.HardwareVertexBufferSharedPtr">
      <summary>Shared pointer implementation used to share index buffers. </summary>
    </member>
    <member name="T:Mogre.VertexElement">
      <summary>This class declares the usage of a single vertex buffer as a component of a complete VertexDeclaration. Several vertex buffers can be used to supply the input geometry for a rendering operation, and in each case a vertex buffer can be used in different ways for different operations; the buffer itself does not define the semantics (position, normal etc), the VertexElement class does. </summary>
    </member>
    <member name="M:Mogre.VertexElement.GetTypeSize(Mogre.VertexElementType)">
      <summary>Utility method for helping to calculate offsets. </summary>
    </member>
    <member name="M:Mogre.VertexElement.GetTypeCount(Mogre.VertexElementType)">
      <summary>Utility method which returns the count of values in a given type. </summary>
    </member>
    <member name="M:Mogre.VertexElement.MultiplyTypeCount(Mogre.VertexElementType,System.UInt16)">
      <summary>Simple converter function which will turn a single-value type into a multi-value type based on a parameter. </summary>
    </member>
    <member name="M:Mogre.VertexElement.GetBaseType(Mogre.VertexElementType)">
      <summary>Simple converter function which will a type into it's single-value equivalent - makes switches on type easier. </summary>
    </member>
    <member name="M:Mogre.VertexElement.ConvertColourValue(Mogre.ColourValue,Mogre.VertexElementType)">
      <summary>Utility method for converting colour to a packed 32-bit colour type. </summary>
      <param name="src">source colour </param>
      <param name="dst">The destination type </param>
    </member>
    <member name="M:Mogre.VertexElement.ConvertColourValue(Mogre.VertexElementType,Mogre.VertexElementType,System.UInt32&amp;)">
      <summary>Utility method for converting colour from one packed 32-bit colour type to another. </summary>
      <param name="srcType">The source type </param>
      <param name="dstType">The destination type </param>
      <param name="ptr">Read / write value to change </param>
    </member>
    <member name="M:Mogre.VertexElement.BaseVertexPointerToElement(System.Void*,System.UInt16**)">
      <summary>Adjusts a pointer to the base of a vertex to point at this element. This variant is for void pointers, passed as a parameter because we can't rely on covariant return types. </summary>
      <param name="pBase">Pointer to the start of a vertex in this buffer. </param>
      <param name="pElem">Pointer to a pointer which will be set to the start of this element. </param>
    </member>
    <member name="M:Mogre.VertexElement.BaseVertexPointerToElement(System.Void*,System.Byte**)">
      <summary>Adjusts a pointer to the base of a vertex to point at this element. This variant is for void pointers, passed as a parameter because we can't rely on covariant return types. </summary>
      <param name="pBase">Pointer to the start of a vertex in this buffer. </param>
      <param name="pElem">Pointer to a pointer which will be set to the start of this element. </param>
    </member>
    <member name="M:Mogre.VertexElement.BaseVertexPointerToElement(System.Void*,System.UInt32**)">
      <summary>Adjusts a pointer to the base of a vertex to point at this element. This variant is for void pointers, passed as a parameter because we can't rely on covariant return types. </summary>
      <param name="pBase">Pointer to the start of a vertex in this buffer. </param>
      <param name="pElem">Pointer to a pointer which will be set to the start of this element. </param>
    </member>
    <member name="M:Mogre.VertexElement.BaseVertexPointerToElement(System.Void*,System.Single**)">
      <summary>Adjusts a pointer to the base of a vertex to point at this element. This variant is for void pointers, passed as a parameter because we can't rely on covariant return types. </summary>
      <param name="pBase">Pointer to the start of a vertex in this buffer. </param>
      <param name="pElem">Pointer to a pointer which will be set to the start of this element. </param>
    </member>
    <member name="M:Mogre.VertexElement.BaseVertexPointerToElement(System.Void*,System.Void**)">
      <summary>Adjusts a pointer to the base of a vertex to point at this element. This variant is for void pointers, passed as a parameter because we can't rely on covariant return types. </summary>
      <param name="pBase">Pointer to the start of a vertex in this buffer. </param>
      <param name="pElem">Pointer to a pointer which will be set to the start of this element. </param>
    </member>
    <member name="M:Mogre.VertexElement.#ctor(System.UInt16,System.UInt32,Mogre.VertexElementType,Mogre.VertexElementSemantic,System.UInt16)">
      <summary>Constructor, should not be called directly, call VertexDeclaration::addElement. </summary>
    </member>
    <member name="P:Mogre.VertexElement.BestColourVertexElementType">
      <summary>Utility method to get the most appropriate packed colour vertex element format. </summary>
    </member>
    <member name="P:Mogre.VertexElement.Size">
      <summary>Gets the size of this element in bytes. </summary>
    </member>
    <member name="P:Mogre.VertexElement.Index">
      <summary>Gets the index of this element, only applicable for repeating elements. </summary>
    </member>
    <member name="P:Mogre.VertexElement.Semantic">
      <summary>Gets the meaning of this element. </summary>
    </member>
    <member name="P:Mogre.VertexElement.Type">
      <summary>Gets the data format of this element. </summary>
    </member>
    <member name="P:Mogre.VertexElement.Offset">
      <summary>Gets the offset into the buffer where this element starts. </summary>
    </member>
    <member name="P:Mogre.VertexElement.Source">
      <summary>Gets the vertex buffer index from where this element draws it's values. </summary>
    </member>
    <member name="T:Mogre.VertexDeclaration">
      <summary>This class declares the format of a set of vertex inputs, which can be issued to the rendering API through a RenderOperation. You should be aware that the ordering and structure of the VertexDeclaration can be very important on DirectX with older cards,so if you want to maintain maximum compatibility with all render systems and all cards you should be careful to follow these rules:VertexElements should be added in the following order, and the order of the elements within a shared buffer should be as follows: position, blending weights, normals, diffuse colours, specular colours, texture coordinates (in order, with no gaps) You must not have unused gaps in your buffers which are not referenced by any VertexElementYou must not cause the buffer &amp; offset settings of 2 VertexElements to overlap 
Whilst GL and more modern graphics cards in D3D will allow you to defy these rules, sticking to them will ensure that your buffers have the maximum compatibility. Like the other classes in this functional area, these declarations should be created and destroyed using the HardwareBufferManager. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.GetElements">
      <summary>Gets read-only access to the list of vertex elements. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.GetElement(System.UInt16)">
      <summary>Get a single element. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.Sort">
      <summary>Sorts the elements in this list to be compatible with the maximum number of rendering APIs / graphics cards. Older graphics cards require vertex data to be presented in a more rigid way, as defined in the main documentation for this class. As well as the ordering being important, where shared source buffers are used, the declaration must list all the elements for each source in turn. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.CloseGapsInSource">
      <summary>Remove any gaps in the source buffer list used by this declaration. This is useful if you've modified a declaration and want to remove any gaps in the list of buffers being used. Note, however, that if this declaration is already being used with a VertexBufferBinding, you will need to alter that too. This method is mainly useful when reorganising buffers based on an altered declaration. This will cause the vertex declaration to be re-sorted. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.GetAutoOrganisedDeclaration(System.Boolean,System.Boolean)">
      <summary>Generates a new VertexDeclaration for optimal usage based on the current vertex declaration, which can be used with VertexData::reorganiseBuffers later if you wish, or simply used as a template. Different buffer organisations and buffer usages will be returned depending on the parameters passed to this method. </summary>
      <param name="skeletalAnimation">Whether this vertex data is going to be skeletally animated </param>
      <param name="vertexAnimation">Whether this vertex data is going to be vertex animated </param>
    </member>
    <member name="M:Mogre.VertexDeclaration.AddElement(System.UInt16,System.UInt32,Mogre.VertexElementType,Mogre.VertexElementSemantic)">
      <summary>Adds a new VertexElement to this declaration. This method adds a single element (positions, normals etc) to the end of the vertex declaration. Please read the information in VertexDeclaration about the importance of ordering and structure for compatibility with older D3D drivers. A reference to the VertexElement added. </summary>
      <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element. See VertexBufferBindingState for full information. </param>
      <param name="offset">The offset in bytes where this element is located in the buffer </param>
      <param name="theType">The data format of the element (3 floats, a colour etc) </param>
      <param name="semantic">The meaning of the data (position, normal, diffuse colour etc) </param>
    </member>
    <member name="M:Mogre.VertexDeclaration.AddElement(System.UInt16,System.UInt32,Mogre.VertexElementType,Mogre.VertexElementSemantic,System.UInt16)">
      <summary>Adds a new VertexElement to this declaration. This method adds a single element (positions, normals etc) to the end of the vertex declaration. Please read the information in VertexDeclaration about the importance of ordering and structure for compatibility with older D3D drivers. A reference to the VertexElement added. </summary>
      <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element. See VertexBufferBindingState for full information. </param>
      <param name="offset">The offset in bytes where this element is located in the buffer </param>
      <param name="theType">The data format of the element (3 floats, a colour etc) </param>
      <param name="semantic">The meaning of the data (position, normal, diffuse colour etc) </param>
      <param name="index">Optional index for multi-input elements like texture coordinates </param>
    </member>
    <member name="M:Mogre.VertexDeclaration.InsertElement(System.UInt16,System.UInt16,System.UInt32,Mogre.VertexElementType,Mogre.VertexElementSemantic)">
      <summary>Inserts a new VertexElement at a given position in this declaration. This method adds a single element (positions, normals etc) at a given position in this vertex declaration. Please read the information in VertexDeclaration about the importance of ordering and structure for compatibility with older D3D drivers. A reference to the VertexElement added. </summary>
      <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element. See VertexBufferBindingState for full information. </param>
      <param name="offset">The offset in bytes where this element is located in the buffer </param>
      <param name="theType">The data format of the element (3 floats, a colour etc) </param>
      <param name="semantic">The meaning of the data (position, normal, diffuse colour etc) </param>
    </member>
    <member name="M:Mogre.VertexDeclaration.InsertElement(System.UInt16,System.UInt16,System.UInt32,Mogre.VertexElementType,Mogre.VertexElementSemantic,System.UInt16)">
      <summary>Inserts a new VertexElement at a given position in this declaration. This method adds a single element (positions, normals etc) at a given position in this vertex declaration. Please read the information in VertexDeclaration about the importance of ordering and structure for compatibility with older D3D drivers. A reference to the VertexElement added. </summary>
      <param name="source">The binding index of HardwareVertexBuffer which will provide the source for this element. See VertexBufferBindingState for full information. </param>
      <param name="offset">The offset in bytes where this element is located in the buffer </param>
      <param name="theType">The data format of the element (3 floats, a colour etc) </param>
      <param name="semantic">The meaning of the data (position, normal, diffuse colour etc) </param>
      <param name="index">Optional index for multi-input elements like texture coordinates </param>
    </member>
    <member name="M:Mogre.VertexDeclaration.RemoveElement(Mogre.VertexElementSemantic)">
      <summary>Remove the element with the given semantic and usage index. In this case 'index' means the usage index for repeating elements such as texture coordinates. For other elements this will always be 0 and does not refer to the index in the vector. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.RemoveElement(Mogre.VertexElementSemantic,System.UInt16)">
      <summary>Remove the element with the given semantic and usage index. In this case 'index' means the usage index for repeating elements such as texture coordinates. For other elements this will always be 0 and does not refer to the index in the vector. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.RemoveElement(System.UInt16)">
      <summary>Remove the element at the given index from this declaration. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.RemoveAllElements">
      <summary>Remove all elements. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.ModifyElement(System.UInt16,System.UInt16,System.UInt32,Mogre.VertexElementType,Mogre.VertexElementSemantic)">
      <summary>Modify an element in-place, params as addElement. Please read the information in VertexDeclaration about the importance of ordering and structure for compatibility with older D3D drivers. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.ModifyElement(System.UInt16,System.UInt16,System.UInt32,Mogre.VertexElementType,Mogre.VertexElementSemantic,System.UInt16)">
      <summary>Modify an element in-place, params as addElement. Please read the information in VertexDeclaration about the importance of ordering and structure for compatibility with older D3D drivers. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.FindElementBySemantic(Mogre.VertexElementSemantic)">
      <summary>Finds a VertexElement with the given semantic, and index if there is more than one element with the same semantic. If the element is not found, this method returns null. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.FindElementBySemantic(Mogre.VertexElementSemantic,System.UInt16)">
      <summary>Finds a VertexElement with the given semantic, and index if there is more than one element with the same semantic. If the element is not found, this method returns null. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.FindElementsBySource(System.UInt16)">
      <summary>Gets a list of elements which use a given source. Note that the list of elements is returned by value therefore is separate from the declaration as soon as this method returns. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.GetVertexSize(System.UInt16)">
      <summary>Gets the vertex size defined by this declaration for a given source. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.Clone">
      <summary>Clones this declaration. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.Clone(Mogre.HardwareBufferManagerBase)">
      <summary>Clones this declaration. </summary>
      <param name="mgr">Optional HardwareBufferManager to use for creating the clone (if null, use the current default). </param>
    </member>
    <member name="M:Mogre.VertexDeclaration.VertexElementLess(Mogre.VertexElement,Mogre.VertexElement)">
      <summary>Sort routine for vertex elements. </summary>
    </member>
    <member name="M:Mogre.VertexDeclaration.#ctor">
      <summary>Standard constructor, not you should use HardwareBufferManager::createVertexDeclaration. </summary>
    </member>
    <member name="P:Mogre.VertexDeclaration.MaxSource">
      <summary>Gets the index of the highest source value referenced by this declaration. </summary>
    </member>
    <member name="P:Mogre.VertexDeclaration.ElementCount">
      <summary>Get the number of elements in the declaration. </summary>
    </member>
    <member name="T:Mogre.VertexBufferBinding">
      <summary>Records the state of all the vertex buffer bindings required to provide a vertex declaration with the input data it needs for the vertex elements. Why do we have this binding list rather than just have VertexElement referring to the vertex buffers direct? Well, in the underlying APIs, binding the vertex buffers to an index (or 'stream') is the way that vertex data is linked, so this structure better reflects the realities of that. In addition, by separating the vertex declaration from the list of vertex buffer bindings, it becomes possible to reuse bindings between declarations and vice versa, giving opportunities to reduce the state changes required to perform rendering. Like the other classes in this functional area, these binding maps should be created and destroyed using the HardwareBufferManager. </summary>
    </member>
    <member name="M:Mogre.VertexBufferBinding.SetBinding(System.UInt16,Mogre.HardwareVertexBufferSharedPtr)">
      <summary>Set a binding, associating a vertex buffer with a given index. If the index is already associated with a vertex buffer, the association will be replaced. This may cause the old buffer to be destroyed if nothing else is referring to it. You should assign bindings from 0 and not leave gaps, although you can bind them in any order. </summary>
    </member>
    <member name="M:Mogre.VertexBufferBinding.UnsetBinding(System.UInt16)">
      <summary>Removes an existing binding. </summary>
    </member>
    <member name="M:Mogre.VertexBufferBinding.UnsetAllBindings">
      <summary>Removes all the bindings. </summary>
    </member>
    <member name="M:Mogre.VertexBufferBinding.GetBindings">
      <summary>Gets a read-only version of the buffer bindings. </summary>
    </member>
    <member name="M:Mogre.VertexBufferBinding.GetBuffer(System.UInt16)">
      <summary>Gets the buffer bound to the given source index. </summary>
    </member>
    <member name="M:Mogre.VertexBufferBinding.IsBufferBound(System.UInt16)">
      <summary>Gets whether a buffer is bound to the given source index. </summary>
    </member>
    <member name="M:Mogre.VertexBufferBinding.CloseGaps(Mogre.VertexBufferBinding+BindingIndexMap)">
      <summary>Remove any gaps in the bindings. This is useful if you've removed vertex buffer from this vertex buffer bindings and want to remove any gaps in the bindings. Note, however, that if this bindings is already being used with a VertexDeclaration, you will need to alter that too. This method is mainly useful when reorganising buffers manually. </summary>
      <param name="bindingIndexMap">To be retrieve the binding index map that used to translation old index to new index; will be cleared by this method before fill-in. </param>
    </member>
    <member name="M:Mogre.VertexBufferBinding.#ctor">
      <summary>Constructor, should not be called direct, use HardwareBufferManager::createVertexBufferBinding. </summary>
    </member>
    <member name="P:Mogre.VertexBufferBinding.NextIndex">
      <summary>Gets the highest index which has already been set, plus 1. This is to assist in binding the vertex buffers such that there are not gaps in the list. </summary>
    </member>
    <member name="P:Mogre.VertexBufferBinding.LastBoundIndex">
      <summary>Gets the last bound index. </summary>
    </member>
    <member name="P:Mogre.VertexBufferBinding.HasGaps">
      <summary>Check whether any gaps in the bindings. </summary>
    </member>
    <member name="T:Mogre.VertexData">
      <summary>Summary class collecting together vertex source information. </summary>
    </member>
    <member name="M:Mogre.VertexData.Clone">
      <summary>Clones this vertex data, potentially including replicating any vertex buffers. The caller is expected to delete the returned pointer when ready </summary>
    </member>
    <member name="M:Mogre.VertexData.Clone(System.Boolean)">
      <summary>Clones this vertex data, potentially including replicating any vertex buffers. The caller is expected to delete the returned pointer when ready </summary>
      <param name="copyData">Whether to create new vertex buffers too or just reference the existing ones </param>
    </member>
    <member name="M:Mogre.VertexData.Clone(System.Boolean,Mogre.HardwareBufferManagerBase)">
      <summary>Clones this vertex data, potentially including replicating any vertex buffers. The caller is expected to delete the returned pointer when ready </summary>
      <param name="copyData">Whether to create new vertex buffers too or just reference the existing ones </param>
      <param name="mgr">If supplied, the buffer manager through which copies should be made </param>
    </member>
    <member name="M:Mogre.VertexData.PrepareForShadowVolume">
      <summary>Modifies the vertex data to be suitable for use for rendering shadow geometry. Preparing vertex data to generate a shadow volume involves firstly ensuring that the vertex buffer containing the positions is a standalone vertex buffer, with no other components in it. This method will therefore break apart any existing vertex buffers if position is sharing a vertex buffer. Secondly, it will double the size of this vertex buffer so that there are 2 copies of the position data for the mesh. The first half is used for the original, and the second half is used for the 'extruded' version. The vertex count used to render will remain the same though, so as not to add any overhead to regular rendering of the object. Both copies of the position are required in one buffer because shadow volumes stretch from the original mesh to the extruded version. It's important to appreciate that this method can fundamentally change the structure of your vertex buffers, although in reality they will be new buffers. As it happens, if other objects are using the original buffers then they will be unaffected because the reference counting will keep them intact. However, if you have made any assumptions about the structure of the vertex data in the buffers of this object, you may have to rethink them. </summary>
    </member>
    <member name="M:Mogre.VertexData.ReorganiseBuffers(Mogre.VertexDeclaration)">
      <summary>Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. </summary>
      <param name="newDeclaration">The vertex declaration which will be used for the reorganised buffer state. Note that the new declaration must not include any elements which do not already exist in the current declaration; you can drop elements by excluding them from the declaration if you wish, however. </param>
    </member>
    <member name="M:Mogre.VertexData.ReorganiseBuffers(Mogre.VertexDeclaration,Mogre.HardwareBufferManagerBase)">
      <summary>Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. This version of the method derives the buffer usages from the existing buffers, by using the 'most flexible' usage from the equivalent sources. </summary>
      <param name="newDeclaration">The vertex declaration which will be used for the reorganised buffer state. Note that the new delcaration must not include any elements which do not already exist in the current declaration; you can drop elements by excluding them from the declaration if you wish, however. </param>
      <param name="mgr">Optional pointer to the manager to use to create new declarations and buffers etc. If not supplied, the HardwareBufferManager singleton will be used </param>
    </member>
    <member name="M:Mogre.VertexData.ReorganiseBuffers(Mogre.VertexDeclaration,Mogre.Const_BufferUsageList)">
      <summary>Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. </summary>
      <param name="newDeclaration">The vertex declaration which will be used for the reorganised buffer state. Note that the new declaration must not include any elements which do not already exist in the current declaration; you can drop elements by excluding them from the declaration if you wish, however. </param>
    </member>
    <member name="M:Mogre.VertexData.ReorganiseBuffers(Mogre.VertexDeclaration,Mogre.Const_BufferUsageList,Mogre.HardwareBufferManagerBase)">
      <summary>Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. </summary>
      <param name="newDeclaration">The vertex declaration which will be used for the reorganised buffer state. Note that the new declaration must not include any elements which do not already exist in the current declaration; you can drop elements by excluding them from the declaration if you wish, however. </param>
      <param name="mgr">Optional pointer to the manager to use to create new declarations and buffers etc. If not supplied, the HardwareBufferManager singleton will be used </param>
    </member>
    <member name="M:Mogre.VertexData.CloseGapsInBindings">
      <summary>Remove any gaps in the vertex buffer bindings. This is useful if you've removed elements and buffers from this vertex data and want to remove any gaps in the vertex buffer bindings. This method is mainly useful when reorganising vertex data manually. This will cause binding index of the elements in the vertex declaration to be altered to new binding index. </summary>
    </member>
    <member name="M:Mogre.VertexData.RemoveUnusedBuffers">
      <summary>Remove all vertex buffers that never used by the vertex declaration. This is useful if you've removed elements from the vertex declaration and want to unreference buffers that never used any more. This method is mainly useful when reorganising vertex data manually. This also remove any gaps in the vertex buffer bindings. </summary>
    </member>
    <member name="M:Mogre.VertexData.ConvertPackedColour(Mogre.VertexElementType,Mogre.VertexElementType)">
      <summary>Convert all packed colour values (VET_COLOUR_*) in buffers used to another type. </summary>
      <param name="srcType">The source colour type to assume if the ambiguous VET_COLOUR is encountered. </param>
      <param name="destType">The destination colour type, must be VET_COLOUR_ABGR or VET_COLOUR_ARGB. </param>
    </member>
    <member name="M:Mogre.VertexData.AllocateHardwareAnimationElements(System.UInt16)">
      <summary>Allocate elements to serve a holder of morph / pose target data for hardware morphing / pose blending. This method will allocate the given number of 3D texture coordinate sets for use as a morph target or target pose offset (3D position). These elements will be saved in hwAnimationDataList. It will also assume that the source of these new elements will be new buffers which are not bound at this time, so will start the sources to 1 higher than the current highest binding source. The caller is expected to bind these new buffers when appropriate. For morph animation the original position buffer will be the 'from' keyframe data, whilst for pose animation it will be the original vertex data. </summary>
    </member>
    <member name="M:Mogre.VertexData.#ctor(Mogre.VertexDeclaration,Mogre.VertexBufferBinding)">
      <summary>Constructor. This constructor receives the VertexDeclaration and VertexBufferBinding from the caller, and as such does not arrange for their deletion afterwards, the caller remains responsible for that. </summary>
      <param name="dcl">The VertexDeclaration to use </param>
      <param name="bind">The VertexBufferBinding to use </param>
    </member>
    <member name="M:Mogre.VertexData.#ctor">
      <summary>Constructor. This constructor creates the VertexDeclaration and VertexBufferBinding automatically, and arranges for their deletion afterwards. </summary>
    </member>
    <member name="M:Mogre.VertexData.#ctor(Mogre.HardwareBufferManagerBase)">
      <summary>Constructor. This constructor creates the VertexDeclaration and VertexBufferBinding automatically, and arranges for their deletion afterwards. </summary>
      <param name="mgr">Optional HardwareBufferManager from which to create resources </param>
    </member>
    <member name="P:Mogre.VertexData.hardwareShadowVolWBuffer">
      <summary>Sets/Additional shadow volume vertex buffer storage. This additional buffer is only used where we have prepared this VertexData for use in shadow volume construction, and where the current render system supports vertex programs. This buffer contains the 'w' vertex position component which will be used by that program to differentiate between extruded and non-extruded vertices. This 'w' component cannot be included in the original position buffer because DirectX does not allow 4-component positions in the fixed-function pipeline, and the original position buffer must still be usable for fixed-function rendering. Note that we don't store any vertex declaration or vertex buffer binding here because this can be reused in the shadow algorithm. </summary>
    </member>
    <member name="P:Mogre.VertexData.hwAnimDataItemsUsed">
      <summary>Sets/Number of hardware animation data items used. </summary>
    </member>
    <member name="P:Mogre.VertexData.hwAnimationDataList">
      <summary>VertexElements used for hardware morph / pose animation. </summary>
    </member>
    <member name="P:Mogre.VertexData.vertexCount">
      <summary>Sets/The number of vertices used in this operation. </summary>
    </member>
    <member name="P:Mogre.VertexData.vertexStart">
      <summary>Sets/The base vertex index to start from. </summary>
    </member>
    <member name="P:Mogre.VertexData.mDeleteDclBinding">
      <summary>Sets/Whether this class should delete the declaration and binding. </summary>
    </member>
    <member name="P:Mogre.VertexData.vertexBufferBinding">
      <summary>Sets/The vertex buffer bindings to be used. Note that this is created for you on construction. </summary>
    </member>
    <member name="P:Mogre.VertexData.vertexDeclaration">
      <summary>Sets/Declaration of the vertex to be used in this operation. Note that this is created for you on construction. </summary>
    </member>
    <member name="T:Mogre.IndexData">
      <summary>Summary class collecting together index data source information. </summary>
    </member>
    <member name="M:Mogre.IndexData.Clone">
      <summary>Clones this index data, potentially including replicating the index buffer. The caller is expected to delete the returned pointer when finished </summary>
    </member>
    <member name="M:Mogre.IndexData.Clone(System.Boolean)">
      <summary>Clones this index data, potentially including replicating the index buffer. The caller is expected to delete the returned pointer when finished </summary>
      <param name="copyData">Whether to create new buffers too or just reference the existing ones </param>
    </member>
    <member name="M:Mogre.IndexData.Clone(System.Boolean,Mogre.HardwareBufferManagerBase)">
      <summary>Clones this index data, potentially including replicating the index buffer. The caller is expected to delete the returned pointer when finished </summary>
      <param name="copyData">Whether to create new buffers too or just reference the existing ones </param>
      <param name="mgr">If supplied, the buffer manager through which copies should be made </param>
    </member>
    <member name="M:Mogre.IndexData.OptimiseVertexCacheTriList">
      <summary>Re-order the indexes in this index data structure to be more vertex cache friendly; that is to re-use the same vertices as close together as possible. Can only be used for index data which consists of triangle lists. It would in fact be pointless to use it on triangle strips or fans in any case. </summary>
    </member>
    <member name="P:Mogre.IndexData.indexCount">
      <summary>Sets/The number of indexes to use from the buffer. </summary>
    </member>
    <member name="P:Mogre.IndexData.indexStart">
      <summary>Sets/index in the buffer to start from for this operation </summary>
    </member>
    <member name="P:Mogre.IndexData.indexBuffer">
      <summary>Sets/pointer to the HardwareIndexBuffer to use, must be specified if useIndexes = true </summary>
    </member>
    <member name="T:Mogre.BufferUsageList">
      <summary>Define a list of usage flags. </summary>
    </member>
    <member name="T:Mogre.Const_BufferUsageList">
      <summary>Define a list of usage flags. </summary>
    </member>
    <member name="T:Mogre.NameValuePairList">
      <summary>Name / value parameter pair (first = name, second = value). </summary>
    </member>
    <member name="T:Mogre.Const_NameValuePairList">
      <summary>Name / value parameter pair (first = name, second = value). </summary>
    </member>
    <member name="T:Mogre.AliasTextureNamePairList">
      <summary>Alias / Texture name pair (first = alias, second = texture name). </summary>
    </member>
    <member name="T:Mogre.Const_AliasTextureNamePairList">
      <summary>Alias / Texture name pair (first = alias, second = texture name). </summary>
    </member>
    <member name="T:Mogre.RenderWindowList">
      <summary>Render window container. </summary>
    </member>
    <member name="T:Mogre.Const_RenderWindowList">
      <summary>Render window container. </summary>
    </member>
    <member name="T:Mogre.ParamDictionary_NativePtr">
      <summary>Class to hold a dictionary of parameters for a single class. </summary>
    </member>
    <member name="M:Mogre.ParamDictionary_NativePtr.AddParameter(Mogre.ParameterDef_NativePtr,Mogre.ParamCommand)">
      <summary>Method for adding a parameter definition for this class. </summary>
      <param name="paramDef">A ParameterDef object defining the parameter </param>
      <param name="paramCmd">Pointer to a ParamCommand subclass to handle the getting / setting of this parameter. NB this class will not destroy this on shutdown, please ensure you do </param>
    </member>
    <member name="M:Mogre.ParamDictionary_NativePtr.GetParameters">
      <summary>Retrieves a list of parameters valid for this object. A reference to a static list of ParameterDef objects. </summary>
    </member>
    <member name="T:Mogre.ParameterDef_NativePtr">
      <summary>Definition of a parameter supported by a StringInterface class, for introspection. </summary>
    </member>
    <member name="T:Mogre.StringInterface">
      <summary>Class defining the common interface which classes can use to present a reflection-style, self-defining parameter set to callers. This class also holds a static map of class name to parameter dictionaries for each subclass to use. See ParamDictionary for details. In order to use this class, each subclass must call createParamDictionary in their constructors which will create a parameter dictionary for the class if it does not exist yet. </summary>
    </member>
    <member name="M:Mogre.StringInterface.GetParameters">
      <summary>Retrieves a list of parameters valid for this object. A reference to a static list of ParameterDef objects. </summary>
    </member>
    <member name="M:Mogre.StringInterface.SetParameter(System.String,System.String)">
      <summary>Generic parameter setting method. Call this method with the name of a parameter and a string version of the value to set. The implementor will convert the string to a native type internally. If in doubt, check the parameter definition in the list returned from StringInterface::getParameters. true if set was successful, false otherwise (NB no exceptions thrown - tolerant method) </summary>
      <param name="name">The name of the parameter to set </param>
      <param name="value">String value. Must be in the right format for the type specified in the parameter definition. See the StringConverter class for more information. </param>
    </member>
    <member name="M:Mogre.StringInterface.SetParameterList(Mogre.Const_NameValuePairList)">
      <summary>Generic multiple parameter setting method. Call this method with a list of name / value pairs to set. The implementor will convert the string to a native type internally. If in doubt, check the parameter definition in the list returned from StringInterface::getParameters. </summary>
      <param name="paramList">Name/value pair list </param>
    </member>
    <member name="M:Mogre.StringInterface.GetParameter(System.String)">
      <summary>Generic parameter retrieval method. Call this method with the name of a parameter to retrieve a string-format value of the parameter in question. If in doubt, check the parameter definition in the list returned from getParameters for the type of this parameter. If you like you can use StringConverter to convert this string back into a native type. String value of parameter, blank if not found </summary>
      <param name="name">The name of the parameter to get </param>
    </member>
    <member name="M:Mogre.StringInterface.CopyParametersTo(Mogre.IStringInterface)">
      <summary>Method for copying this object's parameters to another object. This method takes the values of all the object's parameters and tries to set the same values on the destination object. This provides a completely type independent way to copy parameters to other objects. Note that because of the String manipulation involved, this should not be regarded as an efficient process and should be saved for times outside of the rendering loop. Any unrecognised parameters will be ignored as with setParameter method. </summary>
      <param name="dest">Pointer to object to have it's parameters set the same as this object. </param>
    </member>
    <member name="M:Mogre.StringInterface.CleanupDictionary">
      <summary>Cleans up the static 'msDictionary' required to reset Ogre, otherwise the containers are left with invalid pointers, which will lead to a crash as soon as one of the ResourceManager implementers (e.g. MaterialManager) initializes. </summary>
    </member>
    <member name="P:Mogre.StringInterface.ParamDictionary">
      <summary>Retrieves the parameter dictionary for this class. Only valid to call this after createParamDictionary. Pointer to ParamDictionary shared by all instances of this class which you can add parameters to, retrieve parameters etc. </summary>
    </member>
    <member name="T:Mogre.Resource">
      <summary>Abstract class representing a loadable resource (e.g. textures, sounds etc) Resources are data objects that must be loaded and managed throughout an application. A resource might be a mesh, a texture, or any other piece of data - the key thing is that they must be identified by a name which is unique, must be loaded only once, must be managed efficiently in terms of retrieval, and they may also be unloadable to free memory up when they have not been used for a while and the memory budget is under stress. All Resource instances must be a member of a resource group; see ResourceGroupManager for full details. Subclasses must implement: A constructor, overriding the same parameters as the constructor defined by this class. Subclasses are not allowed to define constructors with other parameters; other settings must be settable through accessor methods before loading. The loadImpl() and unloadImpl() methods - mSize must be set after loadImpl()StringInterfaceParamCommand and ParamDictionary setups in order to allow setting of core parameters (prior to load) through a generic interface. </summary>
    </member>
    <member name="M:Mogre.Resource.Prepare">
      <summary>Prepares the resource for load, if it is not already. One can call prepare() before load(), but this is not required as load() will call prepare() itself, if needed. When OGRE_THREAD_SUPPORT==1 both load() and prepare() are thread-safe. When OGRE_THREAD_SUPPORT==2 however, only prepare() is thread-safe. The reason for this function is to allow a background thread to do some of the loading work, without requiring the whole render system to be thread-safe. The background thread would call prepare() while the main render loop would later call load(). So long as prepare() remains thread-safe, subclasses can arbitrarily split the work of loading a resource between load() and prepare(). It is best to try and do as much work in prepare(), however, since this will leave less work for the main render thread to do and thus increase FPS. </summary>
    </member>
    <member name="M:Mogre.Resource.Prepare(System.Boolean)">
      <summary>Prepares the resource for load, if it is not already. One can call prepare() before load(), but this is not required as load() will call prepare() itself, if needed. When OGRE_THREAD_SUPPORT==1 both load() and prepare() are thread-safe. When OGRE_THREAD_SUPPORT==2 however, only prepare() is thread-safe. The reason for this function is to allow a background thread to do some of the loading work, without requiring the whole render system to be thread-safe. The background thread would call prepare() while the main render loop would later call load(). So long as prepare() remains thread-safe, subclasses can arbitrarily split the work of loading a resource between load() and prepare(). It is best to try and do as much work in prepare(), however, since this will leave less work for the main render thread to do and thus increase FPS. </summary>
      <param name="backgroundThread">Whether this is occurring in a background thread </param>
    </member>
    <member name="M:Mogre.Resource.Load">
      <summary>Loads the resource, if it is not already. If the resource is loaded from a file, loading is automatic. If not, if for example this resource gained it's data from procedural calls rather than loading from a file, then this resource will not reload on it's own. </summary>
    </member>
    <member name="M:Mogre.Resource.Load(System.Boolean)">
      <summary>Loads the resource, if it is not already. If the resource is loaded from a file, loading is automatic. If not, if for example this resource gained it's data from procedural calls rather than loading from a file, then this resource will not reload on it's own. </summary>
      <param name="backgroundThread">Indicates whether the caller of this method is the background resource loading thread. </param>
    </member>
    <member name="M:Mogre.Resource.Reload">
      <summary>Reloads the resource, if it is already loaded. Calls unload() and then load() again, if the resource is already loaded. If it is not loaded already, then nothing happens. </summary>
    </member>
    <member name="M:Mogre.Resource.Unload">
      <summary>Unloads the resource; this is not permanent, the resource can be reloaded later if required. </summary>
    </member>
    <member name="M:Mogre.Resource.Touch">
      <summary>'Touches' the resource to indicate it has been used. </summary>
    </member>
    <member name="M:Mogre.Resource.GetLoadingState">
      <summary>Returns the current loading state. </summary>
    </member>
    <member name="M:Mogre.Resource.SetBackgroundLoaded(System.Boolean)">
      <summary>Tells the resource whether it is background loaded or not. Resource::isBackgroundLoaded . Note that calling this only defers the normal on-demand loading behaviour of a resource, it does not actually set up a thread to make sure the resource gets loaded in the background. You should use ResourceBackgroundLoadingQueue to manage the actual loading (which will call this method itself). </summary>
    </member>
    <member name="M:Mogre.Resource.EscalateLoading">
      <summary>Escalates the loading of a background loaded resource. If a resource is set to load in the background, but something needs it before it's been loaded, there could be a problem. If the user of this resource really can't wait, they can escalate the loading which basically pulls the loading into the current thread immediately. If the resource is already being loaded but just hasn't quite finished then this method will simply wait until the background load is complete. </summary>
    </member>
    <member name="M:Mogre.Resource.ChangeGroupOwnership(System.String)">
      <summary>Change the resource group ownership of a Resource. This method is generally reserved for internal use, although if you really know what you're doing you can use it to move this resource from one group to another. </summary>
      <param name="newGroup">Name of the new group </param>
    </member>
    <member name="M:Mogre.Resource._notifyOrigin(System.String)">
      <summary>Notify this resource of it's origin. </summary>
    </member>
    <member name="M:Mogre.Resource._dirtyState">
      <summary>Manually mark the state of this resource as having been changed. You only need to call this from outside if you explicitly want derived objects to think this object has changed.getStateCount. </summary>
    </member>
    <member name="M:Mogre.Resource._fireLoadingComplete(System.Boolean)">
      <summary>Firing of loading complete event You should call this from the thread that runs the main frame loop to avoid having to make the receivers of this event thread-safe. If you use Ogre's built in frame loop you don't need to call this yourself. </summary>
      <param name="wasBackgroundLoaded">Whether this was a background loaded event </param>
    </member>
    <member name="M:Mogre.Resource._firePreparingComplete(System.Boolean)">
      <summary>Firing of preparing complete event You should call this from the thread that runs the main frame loop to avoid having to make the receivers of this event thread-safe. If you use Ogre's built in frame loop you don't need to call this yourself. </summary>
      <param name="wasBackgroundLoaded">Whether this was a background loaded event </param>
    </member>
    <member name="M:Mogre.Resource._fireUnloadingComplete">
      <summary>Firing of unloading complete event You should call this from the thread that runs the main frame loop to avoid having to make the receivers of this event thread-safe. If you use Ogre's built in frame loop you don't need to call this yourself. </summary>
    </member>
    <member name="P:Mogre.Resource.StateCount">
      <summary>Returns the number of times this resource has changed state, which generally means the number of times it has been loaded. Objects that build derived data based on the resource can check this value against a copy they kept last time they built this derived data, in order to know whether it needs rebuilding. This is a nice way of monitoring changes without having a tightly-bound callback. </summary>
    </member>
    <member name="P:Mogre.Resource.Size">
      <summary>Retrieves info about the size of the resource. </summary>
    </member>
    <member name="P:Mogre.Resource.Origin">
      <summary>Get the origin of this resource, e.g. a script file name. This property will only contain something if the creator of this resource chose to populate it. Script loaders are advised to populate it. </summary>
    </member>
    <member name="P:Mogre.Resource.Name">
      <summary>Gets resource name. </summary>
    </member>
    <member name="P:Mogre.Resource.IsReloadable">
      <summary>Returns true if the Resource is reloadable, false otherwise. </summary>
    </member>
    <member name="P:Mogre.Resource.IsPrepared">
      <summary>Returns true if the Resource has been prepared, false otherwise. </summary>
    </member>
    <member name="P:Mogre.Resource.IsManuallyLoaded">
      <summary>Is this resource manually loaded? </summary>
    </member>
    <member name="P:Mogre.Resource.IsLoading">
      <summary>Returns whether the resource is currently in the process of background loading. </summary>
    </member>
    <member name="P:Mogre.Resource.IsLoaded">
      <summary>Returns true if the Resource has been loaded, false otherwise. </summary>
    </member>
    <member name="P:Mogre.Resource.IsBackgroundLoaded">
      <summary>Returns whether this Resource has been earmarked for background loading. This option only makes sense when you have built Ogre with thread support (OGRE_THREAD_SUPPORT). If a resource has been marked for background loading, then it won't load on demand like normal when load() is called. Instead, it will ignore request to load() except if the caller indicates it is the background loader. Any other users of this resource should check isLoaded(), and if that returns false, don't use the resource and come back later. </summary>
    </member>
    <member name="P:Mogre.Resource.Group">
      <summary>Gets the group which this resource is a member of. </summary>
    </member>
    <member name="P:Mogre.Resource.Creator">
      <summary>Gets the manager which created this resource. </summary>
    </member>
    <member name="E:Mogre.Resource.UnloadingComplete">
      <summary>Called whenever the resource has been unloaded. </summary>
    </member>
    <member name="E:Mogre.Resource.PreparingComplete">
      <summary>called whenever the resource finishes preparing (paging into memory). If a Resource has been marked as background loaded (Resource::setBackgroundLoaded) the call does not itself occur in the thread which is doing the preparing; when preparing is complete a response indicator is placed with the ResourceGroupManager, which will then be sent back to the listener as part of the application's primary frame loop thread. </summary>
    </member>
    <member name="E:Mogre.Resource.LoadingComplete">
      <summary>Called whenever the resource finishes loading. If a Resource has been marked as background loaded (Resource::setBackgroundLoaded), the call does not itself occur in the thread which is doing the loading; when loading is complete a response indicator is placed with the ResourceGroupManager, which will then be sent back to the listener as part of the application's primary frame loop thread. </summary>
    </member>
    <member name="E:Mogre.Resource.BackgroundPreparingComplete">
      <summary>Callback to indicate that background preparing has completed. </summary>
    </member>
    <member name="E:Mogre.Resource.BackgroundLoadingComplete">
      <summary>Callback to indicate that background loading has completed. </summary>
    </member>
    <member name="T:Mogre.Resource+LoadingState">
      <summary>Enum identifying the loading state of the resource. </summary>
    </member>
    <member name="F:Mogre.Resource+LoadingState.LOADSTATE_UNLOADED">
      <summary>Not loaded. </summary>
    </member>
    <member name="F:Mogre.Resource+LoadingState.LOADSTATE_LOADING">
      <summary>Loading is in progress. </summary>
    </member>
    <member name="F:Mogre.Resource+LoadingState.LOADSTATE_LOADED">
      <summary>Fully loaded. </summary>
    </member>
    <member name="F:Mogre.Resource+LoadingState.LOADSTATE_UNLOADING">
      <summary>Currently unloading. </summary>
    </member>
    <member name="F:Mogre.Resource+LoadingState.LOADSTATE_PREPARED">
      <summary>Fully prepared. </summary>
    </member>
    <member name="F:Mogre.Resource+LoadingState.LOADSTATE_PREPARING">
      <summary>Preparing is in progress. </summary>
    </member>
    <member name="T:Mogre.ManualResourceLoader">
      <summary>Interface describing a manual resource loader. Resources are usually loaded from files; however in some cases you want to be able to set the data up manually instead. This provides some problems, such as how to reload a Resource if it becomes unloaded for some reason, either because of memory constraints, or because a device fails and some or all of the data is lost. This interface should be implemented by all classes which wish to provide manual data to a resource. They provide a pointer to themselves when defining the resource (via the appropriate ResourceManager), and will be called when the Resource tries to load. They should implement the loadResource method such that the Resource is in the end set up exactly as if it had loaded from a file, although the implementations will likely differ between subclasses of Resource, which is why no generic algorithm can be stated here. The loader must remain valid for the entire life of the resource, so that if need be it can be called upon to re-load the resource at any time. </summary>
    </member>
    <member name="M:Mogre.ManualResourceLoader.PrepareResource(Mogre.Resource)">
      <summary>Called when a resource wishes to load. Note that this could get called in a background thread even in just a semithreaded ogre (OGRE_THREAD_SUPPORT==2). Thus, you must not access the rendersystem from this callback. Do that stuff in loadResource. </summary>
      <param name="resource">The resource which wishes to load </param>
    </member>
    <member name="M:Mogre.ManualResourceLoader.LoadResource(Mogre.Resource)">
      <summary>Called when a resource wishes to prepare. </summary>
      <param name="resource">The resource which wishes to prepare </param>
    </member>
    <member name="T:Mogre.ResourcePtr">
      <summary>Shared pointer to a Resource. This shared pointer allows many references to a resource to be held, and when the final reference is removed, the resource will be destroyed. Note that the ResourceManager which created this Resource will be holding at least one reference, so this resource will not get destroyed until someone removes the resource from the manager - this at least gives you strong control over when resources are freed. But the nature of the shared pointer means that if anyone refers to the removed resource in the meantime, the resource will remain valid. You may well see references to ResourcePtr (i.e. ResourcePtr&amp;) being passed around internally within Ogre. These are 'weak references' ie they do not increment the reference count on the Resource. This is done for efficiency in temporary operations that shouldn't need to incur the overhead of maintaining the reference count; however we don't recommend you do it yourself since these references are not guaranteed to remain valid. </summary>
    </member>
    <member name="T:Mogre.LinkedSkeletonAnimationSource_NativePtr">
      <summary>Link to another skeleton to share animations. </summary>
    </member>
    <member name="T:Mogre.Skeleton">
      <summary>A collection of Bone objects used to animate a skinned mesh. Skeletal animation works by having a collection of 'bones' which are actually just joints with a position and orientation, arranged in a tree structure. For example, the wrist joint is a child of the elbow joint, which in turn is a child of the shoulder joint. Rotating the shoulder automatically moves the elbow and wrist as well due to this hierarchy. So how does this animate a mesh? Well every vertex in a mesh is assigned to one or more bones which affects it's position when the bone is moved. If a vertex is assigned to more than one bone, then weights must be assigned to determine how much each bone affects the vertex (actually a weight of 1.0 is used for single bone assignments). Weighted vertex assignments are especially useful around the joints themselves to avoid 'pinching' of the mesh in this region. Therefore by moving the skeleton using preset animations, we can animate the mesh. The advantage of using skeletal animation is that you store less animation data, especially as vertex counts increase. In addition, you are able to blend multiple animations together (e.g. walking and looking around, running and shooting) and provide smooth transitions between animations without incurring as much of an overhead as would be involved if you did this on the core vertex data. Skeleton definitions are loaded from datafiles, namely the .skeleton file format. They are loaded on demand, especially when referenced by a Mesh. </summary>
    </member>
    <member name="M:Mogre.Skeleton.CreateBone(System.String,System.UInt16)">
      <summary>Creates a brand new Bone owned by this Skeleton. This method creates an unattached new Bone for this skeleton and assigns it a specific name and handle. Unless this is to be a root bone (there may be more than one of these), you must attach it to another Bone in the skeleton using addChild for it to be any use. For this reason you will likely be better off creating child bones using the Bone::createChild method instead, once you have created the root bone. </summary>
      <param name="name">The name to give to this new bone - must be unique within this skeleton. </param>
      <param name="handle">The handle to give to this new bone - must be unique within this skeleton. </param>
    </member>
    <member name="M:Mogre.Skeleton.CreateBone(System.String)">
      <summary>Creates a brand new Bone owned by this Skeleton. This method creates an unattached new Bone for this skeleton and assigns it a specific name.Unless this is to be a root bone (there may be more than one of these), you must attach it to another Bone in the skeleton using addChild for it to be any use. For this reason you will likely be better off creating child bones using the Bone::createChild method instead, once you have created the root bone. </summary>
      <param name="name">The name to give to this new bone - must be unique within this skeleton. Note that the way OGRE looks up bones is via a numeric handle, so if you name a Bone this way it will be given an automatic sequential handle. The name is just for your convenience, although it is recommended that you only use the handle to retrieve the bone in performance-critical code. </param>
    </member>
    <member name="M:Mogre.Skeleton.CreateBone(System.UInt16)">
      <summary>Creates a brand new Bone owned by this Skeleton. This method creates an unattached new Bone for this skeleton and assigns it a specific handle. Unless this is to be a root bone (there may be more than one of these), you must attach it to another Bone in the skeleton using addChild for it to be any use. For this reason you will likely be better off creating child bones using the Bone::createChild method instead, once you have created a root bone. </summary>
      <param name="handle">The handle to give to this new bone - must be unique within this skeleton. You should also ensure that all bone handles are eventually contiguous (this is to simplify their compilation into an indexed array of transformation matrices). For this reason it is advised that you use the simpler createBone method which automatically assigns a sequential handle starting from 0. </param>
    </member>
    <member name="M:Mogre.Skeleton.CreateBone">
      <summary>Creates a brand new Bone owned by this Skeleton. This method creates an unattached new Bone for this skeleton. Unless this is to be a root bone (there may be more than one of these), you must attach it to another Bone in the skeleton using addChild for it to be any use. For this reason you will likely be better off creating child bones using the Bone::createChild method instead, once you have created the root bone. Note that this method automatically generates a handle for the bone, which you can retrieve using Bone::getHandle. If you wish the new Bone to have a specific handle, use the alternate form of this method which takes a handle as a parameter, although you should note the restrictions. </summary>
    </member>
    <member name="M:Mogre.Skeleton.GetRootBoneIterator">
      <summary>Get an iterator over the root bones in the skeleton, ie those with no parents. </summary>
    </member>
    <member name="M:Mogre.Skeleton.GetBoneIterator">
      <summary>Get an iterator over all the bones in the skeleton. </summary>
    </member>
    <member name="M:Mogre.Skeleton.GetBone(System.String)">
      <summary>Gets a bone by it's handle. </summary>
    </member>
    <member name="M:Mogre.Skeleton.GetBone(System.UInt16)">
      <summary>Gets a bone by it's handle. </summary>
    </member>
    <member name="M:Mogre.Skeleton.HasBone(System.String)">
      <summary>Returns whether this skeleton contains the named bone. </summary>
    </member>
    <member name="M:Mogre.Skeleton.SetBindingPose">
      <summary>Sets the current position / orientation to be the 'binding pose' i.e. the layout in which bones were originally bound to a mesh. </summary>
    </member>
    <member name="M:Mogre.Skeleton.Reset">
      <summary>Resets the position and orientation of all bones in this skeleton to their original binding position. A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this position during animation. This method returns all the bones to their original position and orientation. </summary>
    </member>
    <member name="M:Mogre.Skeleton.Reset(System.Boolean)">
      <summary>Resets the position and orientation of all bones in this skeleton to their original binding position. A skeleton is bound to a mesh in a binding pose. Bone positions are then modified from this position during animation. This method returns all the bones to their original position and orientation. </summary>
      <param name="resetManualBones">If set to true, causes the state of manual bones to be reset too, which is normally not done to allow the manual state to persist even when keyframe animation is applied. </param>
    </member>
    <member name="M:Mogre.Skeleton.CreateAnimation(System.String,System.Single)">
      <summary>Creates a new Animation object for animating this skeleton. </summary>
      <param name="name">The name of this animation </param>
      <param name="length">The length of the animation in seconds </param>
    </member>
    <member name="M:Mogre.Skeleton.GetAnimation(System.UInt16)">
      <summary>Returns the named Animation object. Will pick up animations in linked skeletons (addLinkedSkeletonAnimationSource). </summary>
    </member>
    <member name="M:Mogre.Skeleton.GetAnimation(System.String)">
      <summary>Returns the named Animation object. Will pick up animations in linked skeletons (addLinkedSkeletonAnimationSource). </summary>
      <param name="name">The name of the animation </param>
    </member>
    <member name="M:Mogre.Skeleton.GetAnimation(System.String,Mogre.LinkedSkeletonAnimationSource_NativePtr&amp;)">
      <summary>Returns the named Animation object. Will pick up animations in linked skeletons (addLinkedSkeletonAnimationSource). </summary>
      <param name="name">The name of the animation </param>
      <param name="linker">Optional pointer to a pointer to the linked skeleton animation where this is coming from. </param>
    </member>
    <member name="M:Mogre.Skeleton._getAnimationImpl(System.String)">
      <summary>Internal accessor for animations (returns null if animation does not exist). </summary>
    </member>
    <member name="M:Mogre.Skeleton._getAnimationImpl(System.String,Mogre.LinkedSkeletonAnimationSource_NativePtr&amp;)">
      <summary>Internal accessor for animations (returns null if animation does not exist). </summary>
    </member>
    <member name="M:Mogre.Skeleton.HasAnimation(System.String)">
      <summary>Returns whether this skeleton contains the named animation. </summary>
    </member>
    <member name="M:Mogre.Skeleton.RemoveAnimation(System.String)">
      <summary>Removes an Animation from this skeleton. </summary>
    </member>
    <member name="M:Mogre.Skeleton.SetAnimationState(Mogre.AnimationStateSet)">
      <summary>Changes the state of the skeleton to reflect the application of the passed in collection of animations. Animating a skeleton involves both interpolating between keyframes of a specific animation, and blending between the animations themselves. Calling this method sets the state of the skeleton so that it reflects the combination of all the passed in animations, at the time index specified for each, using the weights specified. Note that the weights between animations do not have to sum to 1.0, because some animations may affect only subsets of the skeleton. If the weights exceed 1.0 for the same area of the skeleton, the movement will just be exaggerated. </summary>
    </member>
    <member name="M:Mogre.Skeleton._initAnimationState(Mogre.AnimationStateSet)">
      <summary>Initialise an animation set suitable for use with this skeleton. Only recommended for use inside the engine, not by applications. </summary>
    </member>
    <member name="M:Mogre.Skeleton._refreshAnimationState(Mogre.AnimationStateSet)">
      <summary>Refresh an animation set suitable for use with this skeleton. Only recommended for use inside the engine, not by applications. </summary>
    </member>
    <member name="M:Mogre.Skeleton._getBoneMatrices(Mogre.Matrix4+NativeValue*)">
      <summary>Populates the passed in array with the bone matrices based on the current position. Internal use only. The array pointed to by the passed in pointer must be at least as large as the number of bones. Assumes animation has already been updated. </summary>
    </member>
    <member name="M:Mogre.Skeleton._updateTransforms">
      <summary>Updates all the derived transforms in the skeleton. </summary>
    </member>
    <member name="M:Mogre.Skeleton.OptimiseAllAnimations">
      <summary>Optimise all of this skeleton's animations. Animation::optimise</summary>
    </member>
    <member name="M:Mogre.Skeleton.OptimiseAllAnimations(System.Boolean)">
      <summary>Optimise all of this skeleton's animations. Animation::optimise</summary>
      <param name="preservingIdentityNodeTracks">If true, don't destroy identity node tracks. </param>
    </member>
    <member name="M:Mogre.Skeleton.AddLinkedSkeletonAnimationSource(System.String)">
      <summary>Allows you to use the animations from another Skeleton object to animate this skeleton. If you have skeletons of identical structure (that means identically named bones with identical handles, and with the same hierarchy), but slightly different proportions or binding poses, you can re-use animations from one in the other. Because animations are actually stored as changes to bones from their bind positions, it's possible to use the same animation data for different skeletons, provided the skeletal structure matches and the 'deltas' stored in the keyframes apply equally well to the other skeletons bind position (so they must be roughly similar, but don't have to be identical). You can use the 'scale' option to adjust the translation and scale keyframes where there are large differences in size between the skeletons. This method takes a skeleton name, rather than a more specific animation name, for two reasons; firstly it allows some validation of compatibility of skeletal structure, and secondly skeletons are the unit of loading. Linking a skeleton to another in this way means that the linkee will be prevented from being destroyed until the linker is destroyed.
You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's animations, and SkeletonB uses SkeletonA's animations. This is because it would set up a circular dependency which would prevent proper unloading - make one of the skeletons the 'master' in this case. </summary>
      <param name="skelName">Name of the skeleton to link animations from. This skeleton will be loaded immediately if this skeleton is already loaded, otherwise it will be loaded when this skeleton is. </param>
    </member>
    <member name="M:Mogre.Skeleton.AddLinkedSkeletonAnimationSource(System.String,System.Single)">
      <summary>Allows you to use the animations from another Skeleton object to animate this skeleton. If you have skeletons of identical structure (that means identically named bones with identical handles, and with the same hierarchy), but slightly different proportions or binding poses, you can re-use animations from one in the other. Because animations are actually stored as changes to bones from their bind positions, it's possible to use the same animation data for different skeletons, provided the skeletal structure matches and the 'deltas' stored in the keyframes apply equally well to the other skeletons bind position (so they must be roughly similar, but don't have to be identical). You can use the 'scale' option to adjust the translation and scale keyframes where there are large differences in size between the skeletons. This method takes a skeleton name, rather than a more specific animation name, for two reasons; firstly it allows some validation of compatibility of skeletal structure, and secondly skeletons are the unit of loading. Linking a skeleton to another in this way means that the linkee will be prevented from being destroyed until the linker is destroyed.
You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's animations, and SkeletonB uses SkeletonA's animations. This is because it would set up a circular dependency which would prevent proper unloading - make one of the skeletons the 'master' in this case. </summary>
      <param name="skelName">Name of the skeleton to link animations from. This skeleton will be loaded immediately if this skeleton is already loaded, otherwise it will be loaded when this skeleton is. </param>
      <param name="scale">A scale factor to apply to translation and scaling elements of the keyframes in the other skeleton when applying the animations to this one. Compensates for skeleton size differences. </param>
    </member>
    <member name="M:Mogre.Skeleton.RemoveAllLinkedSkeletonAnimationSources">
      <summary>Remove all links to other skeletons for the purposes of sharing animation. </summary>
    </member>
    <member name="M:Mogre.Skeleton.GetLinkedSkeletonAnimationSourceIterator">
      <summary>Get an iterator over the linked skeletons used as animation sources. </summary>
    </member>
    <member name="M:Mogre.Skeleton._notifyManualBonesDirty">
      <summary>Internal method for marking the manual bones as dirty. </summary>
    </member>
    <member name="M:Mogre.Skeleton._notifyManualBoneStateChange(Mogre.Bone)">
      <summary>Internal method for notifying that a bone is manual. </summary>
    </member>
    <member name="M:Mogre.Skeleton._mergeSkeletonAnimations(Mogre.Skeleton,Mogre.Skeleton+Const_BoneHandleMap)">
      <summary>Merge animations from another Skeleton object into this skeleton. This function allow merge two structures compatible skeletons. The 'compatible' here means identically bones will have same hierarchy, but skeletons are not necessary to have same number of bones (if number bones of source skeleton's more than this skeleton, they will copied as is, except that duplicate names are unallowed; and in the case of bones missing in source skeleton, nothing happen for those bones). There are also unnecessary to have same binding poses, this function will adjust keyframes of the source skeleton to match this skeleton automatically. It's useful for export skeleton animations seperately. i.e. export mesh and 'master' skeleton at the same time, and then other animations will export seperately (even if used completely difference binding pose), finally, merge seperately exported animations into 'master' skeleton. _buildMapBoneByHandle, _buildMapBoneByName) animationsA list name of animations to merge, if empty, all animations of source skeleton are used to merge. Note that the animation names must not presented in this skeleton, and will NOT pick up animations in linked skeletons (addLinkedSkeletonAnimationSource). </summary>
      <param name="source">Pointer to source skeleton. It'll keep unmodified. </param>
      <param name="boneHandleMap">A map to translate identically bone's handle from source skeleton to this skeleton. If mapped bone handle doesn't exists in this skeleton, it'll created. You can populate bone handle map manually, or use predefined functions build bone handle map for you. (</param>
    </member>
    <member name="M:Mogre.Skeleton._mergeSkeletonAnimations(Mogre.Skeleton,Mogre.Skeleton+Const_BoneHandleMap,Mogre.Const_StringVector)">
      <summary>Merge animations from another Skeleton object into this skeleton. This function allow merge two structures compatible skeletons. The 'compatible' here means identically bones will have same hierarchy, but skeletons are not necessary to have same number of bones (if number bones of source skeleton's more than this skeleton, they will copied as is, except that duplicate names are unallowed; and in the case of bones missing in source skeleton, nothing happen for those bones). There are also unnecessary to have same binding poses, this function will adjust keyframes of the source skeleton to match this skeleton automatically. It's useful for export skeleton animations seperately. i.e. export mesh and 'master' skeleton at the same time, and then other animations will export seperately (even if used completely difference binding pose), finally, merge seperately exported animations into 'master' skeleton. _buildMapBoneByHandle, _buildMapBoneByName) animationsA list name of animations to merge, if empty, all animations of source skeleton are used to merge. Note that the animation names must not presented in this skeleton, and will NOT pick up animations in linked skeletons (addLinkedSkeletonAnimationSource). </summary>
      <param name="source">Pointer to source skeleton. It'll keep unmodified. </param>
      <param name="boneHandleMap">A map to translate identically bone's handle from source skeleton to this skeleton. If mapped bone handle doesn't exists in this skeleton, it'll created. You can populate bone handle map manually, or use predefined functions build bone handle map for you. (</param>
    </member>
    <member name="M:Mogre.Skeleton._buildMapBoneByHandle(Mogre.Skeleton,Mogre.Skeleton+BoneHandleMap)">
      <summary>Build the bone handle map to use with Skeleton::_mergeSkeletonAnimations. Identically bones are determine by handle. </summary>
    </member>
    <member name="M:Mogre.Skeleton._buildMapBoneByName(Mogre.Skeleton,Mogre.Skeleton+BoneHandleMap)">
      <summary>Build the bone handle map to use with Skeleton::_mergeSkeletonAnimations. Identically bones are determine by name. </summary>
    </member>
    <member name="M:Mogre.Skeleton.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String)">
      <summary>Constructor, don't call directly, use SkeletonManager. On creation, a Skeleton has a no bones, you should create them and link them together appropriately. </summary>
    </member>
    <member name="M:Mogre.Skeleton.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean)">
      <summary>Constructor, don't call directly, use SkeletonManager. On creation, a Skeleton has a no bones, you should create them and link them together appropriately. </summary>
    </member>
    <member name="M:Mogre.Skeleton.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Constructor, don't call directly, use SkeletonManager. On creation, a Skeleton has a no bones, you should create them and link them together appropriately. </summary>
    </member>
    <member name="P:Mogre.Skeleton.RootBone">
      <summary>Gets the root bone of the skeleton: deprecated in favour of getRootBoneIterator. The system derives the root bone the first time you ask for it. The root bone is the only bone in the skeleton which has no parent. The system locates it by taking the first bone in the list and going up the bone tree until there are no more parents, and saves this top bone as the root. If you are building the skeleton manually using createBone then you must ensure there is only one bone which is not a child of another bone, otherwise your skeleton will not work properly. If you use createBone only once, and then use Bone::createChild from then on, then inherently the first bone you create will by default be the root. </summary>
    </member>
    <member name="P:Mogre.Skeleton.NumBones">
      <summary>Returns the number of bones in this skeleton. </summary>
    </member>
    <member name="P:Mogre.Skeleton.NumAnimations">
      <summary>Gets the number of animations on this skeleton. </summary>
    </member>
    <member name="P:Mogre.Skeleton.ManualBonesDirty">
      <summary>Have manual bones been modified since the skeleton was last updated? </summary>
    </member>
    <member name="P:Mogre.Skeleton.HasManualBones">
      <summary>Are there any manually controlled bones? </summary>
    </member>
    <member name="P:Mogre.Skeleton.BlendMode">
      <summary>Sets/Gets the animation blending mode which this skeleton will use. </summary>
    </member>
    <member name="T:Mogre.SkeletonPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to SkeletonPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.Serializer">
      <summary>Generic class for serialising data to / from binary stream-based files. This class provides a number of useful methods for exporting / importing data from stream-oriented binary files (e.g. .mesh and .skeleton). </summary>
    </member>
    <member name="T:Mogre.Serializer+Endian">
      <summary>The endianness of written files. </summary>
    </member>
    <member name="F:Mogre.Serializer+Endian.ENDIAN_NATIVE">
      <summary>Use the platform native endian. </summary>
    </member>
    <member name="F:Mogre.Serializer+Endian.ENDIAN_BIG">
      <summary>Use big endian (0x1000 is serialised as 0x10 0x00). </summary>
    </member>
    <member name="F:Mogre.Serializer+Endian.ENDIAN_LITTLE">
      <summary>Use little endian (0x1000 is serialised as 0x00 0x10). </summary>
    </member>
    <member name="T:Mogre.GpuConstantDefinition_NativePtr">
      <summary>Information about predefined program constants. Only available for high-level programs but is referenced generically by GpuProgramParameters. </summary>
    </member>
    <member name="P:Mogre.GpuConstantDefinition_NativePtr.variability">
      <summary>Sets/How this parameter varies (bitwise combination of GpuProgramVariability). </summary>
    </member>
    <member name="P:Mogre.GpuConstantDefinition_NativePtr.arraySize">
      <summary>Sets/Length of array. </summary>
    </member>
    <member name="P:Mogre.GpuConstantDefinition_NativePtr.elementSize">
      <summary>Sets/Number of raw buffer slots per element (some programs pack each array element to float4, some do not) </summary>
    </member>
    <member name="P:Mogre.GpuConstantDefinition_NativePtr.logicalIndex">
      <summary>Sets/Logical index - used to communicate this constant to the rendersystem. </summary>
    </member>
    <member name="P:Mogre.GpuConstantDefinition_NativePtr.physicalIndex">
      <summary>Sets/Physical start index in buffer (either float or int buffer). </summary>
    </member>
    <member name="P:Mogre.GpuConstantDefinition_NativePtr.constType">
      <summary>Sets/Data type. </summary>
    </member>
    <member name="T:Mogre.GpuNamedConstants">
      <summary>Struct collecting together the information for named constants. </summary>
    </member>
    <member name="M:Mogre.GpuNamedConstants.GenerateConstantDefinitionArrayEntries(System.String,Mogre.GpuConstantDefinition_NativePtr)">
      <summary>Generate additional constant entries for arrays based on a base definition. Array uniforms will be added just with their base name with no array suffix. This method will add named entries for array suffixes too so individual array entries can be addressed. Note that we only individually index array elements if the array size is up to 16 entries in size. Anything larger than that only gets a [0] entry as well as the main entry, to save cluttering up the name map. After all, you can address the larger arrays in a bulk fashion much more easily anyway. </summary>
    </member>
    <member name="M:Mogre.GpuNamedConstants.Save(System.String)">
      <summary>Saves constant definitions to a file, compatible with GpuProgram::setManualNamedConstantsFile. GpuProgram::setManualNamedConstantsFile</summary>
    </member>
    <member name="M:Mogre.GpuNamedConstants.Load(Mogre.DataStreamPtr)">
      <summary>Loads constant definitions from a stream, compatible with GpuProgram::setManualNamedConstantsFile. GpuProgram::setManualNamedConstantsFile</summary>
    </member>
    <member name="P:Mogre.GpuNamedConstants.map">
      <summary>Map of parameter names to GpuConstantDefinition. </summary>
    </member>
    <member name="P:Mogre.GpuNamedConstants.intBufferSize">
      <summary>Sets/Total size of the int buffer required. </summary>
    </member>
    <member name="P:Mogre.GpuNamedConstants.floatBufferSize">
      <summary>Sets/Total size of the float buffer required. </summary>
    </member>
    <member name="T:Mogre.GpuNamedConstantsSerializer">
      <summary>Simple class for loading / saving GpuNamedConstants. </summary>
    </member>
    <member name="T:Mogre.GpuLogicalBufferStruct">
      <summary>Container struct to allow params to safely &amp; update shared list of logical buffer assignments. </summary>
    </member>
    <member name="P:Mogre.GpuLogicalBufferStruct.bufferSize">
      <summary>Sets/Shortcut to know the buffer size needs. </summary>
    </member>
    <member name="T:Mogre.GpuSharedParameters">
      <summary>A group of manually updated parameters that are shared between many parameter sets. Sometimes you want to set some common parameters across many otherwise different parameter sets, and keep them all in sync together. This class allows you to define a set of parameters that you can share across many parameter sets and have the parameters that match automatically be pulled from the shared set, rather than you having to set them on all the parameter sets individually. Parameters in a shared set are matched up with instances in a GpuProgramParameters structure by matching names. It is up to you to define the named parameters that a shared set contains, and ensuring the definition matches. Shared parameter sets can be named, and looked up using the GpuProgramManager. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.AddConstantDefinition(System.String,Mogre.GpuConstantType)">
      <summary>Add a new constant definition to this shared set of parameters. Unlike GpuProgramParameters, where the parameter list is defined by the program being compiled, this shared parameter set is defined by the user. Only parameters which have been predefined here may be later updated. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.AddConstantDefinition(System.String,Mogre.GpuConstantType,System.UInt32)">
      <summary>Add a new constant definition to this shared set of parameters. Unlike GpuProgramParameters, where the parameter list is defined by the program being compiled, this shared parameter set is defined by the user. Only parameters which have been predefined here may be later updated. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.RemoveConstantDefinition(System.String)">
      <summary>Remove a constant definition from this shared set of parameters. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.RemoveAllConstantDefinitions">
      <summary>Remove a constant definition from this shared set of parameters. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters._markDirty">
      <summary>Mark the shared set as being dirty (values modified). You do not need to call this yourself, set is marked as dirty whenever setNamedConstant or (non const) getFloatPointer et al are called. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.GetConstantDefinitionIterator">
      <summary>Gets an iterator over the named GpuConstantDefinition instances as defined by the user. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.GetConstantDefinition(System.String)">
      <summary>Get a specific GpuConstantDefinition for a named parameter. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,System.Int32*,System.UInt32)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,Mogre.ColourValue)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,System.Double*,System.UInt32)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,System.Single*,System.UInt32)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,Mogre.Matrix4+NativeValue*,System.UInt32)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,Mogre.Matrix4)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,Mogre.Vector3)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,Mogre.Vector4)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,System.Int32)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.SetNamedConstant(System.String,System.Single)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). nameThe name of the parameter valThe value to set</summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.GetFloatPointer(System.UInt32)">
      <summary>Get a pointer to the 'nth' item in the float buffer. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParameters.GetIntPointer(System.UInt32)">
      <summary>Get a pointer to the 'nth' item in the int buffer. </summary>
    </member>
    <member name="P:Mogre.GpuSharedParameters.Version">
      <summary>Get the version number of this shared parameter set, can be used to identify when changes have occurred. </summary>
    </member>
    <member name="P:Mogre.GpuSharedParameters.Name">
      <summary>Get the name of this shared parameter set. </summary>
    </member>
    <member name="P:Mogre.GpuSharedParameters.FrameLastUpdated">
      <summary>Get the frame in which this shared parameter set was last updated. </summary>
    </member>
    <member name="P:Mogre.GpuSharedParameters.ConstantDefinitions">
      <summary>Get the full list of GpuConstantDefinition instances. </summary>
    </member>
    <member name="T:Mogre.GpuSharedParametersUsage">
      <summary>This class records the usage of a set of shared parameters in a concrete set of GpuProgramParameters. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParametersUsage._copySharedParamsToTargetParams">
      <summary>Update the target parameters by copying the data from the shared parameters. This method may not actually be called if the RenderSystem supports using shared parameters directly in their own shared buffer; in which case the values should not be copied out of the shared area into the individual parameter set, but bound separately. </summary>
    </member>
    <member name="M:Mogre.GpuSharedParametersUsage.#ctor(Mogre.GpuSharedParametersPtr,Mogre.GpuProgramParameters)">
      <summary>Construct usage. </summary>
    </member>
    <member name="P:Mogre.GpuSharedParametersUsage.Name">
      <summary>Get the name of the shared parameter set. </summary>
    </member>
    <member name="T:Mogre.GpuProgramParameters">
      <summary>Collects together the program parameters used for a GpuProgram. Gpu program state includes constant parameters used by the program, and bindings to render system state which is propagated into the constants by the engine automatically if requested. GpuProgramParameters objects should be created through the GpuProgram and may be shared between multiple Pass instances. For this reason they are managed using a shared pointer, which will ensure they are automatically deleted when no Pass is using them anymore. High-level programs use named parameters (uniforms), low-level programs use indexed constants. This class supports both, but you can tell whether named constants are supported by calling hasNamedParameters(). There are references in the documentation below to 'logical' and 'physical' indexes; logical indexes are the indexes used by low-level programs and represent indexes into an array of float4's, some of which may be settable, some of which may be predefined constants in the program. We only store those constants which have actually been set, therefore our buffer could have gaps if we used the logical indexes in our own buffers. So instead we map these logical indexes to physical indexes in our buffer. When using high-level programs, logical indexes don't necessarily exist, although they might if the high-level program has a direct, exposed mapping from parameter names to logical indexes. In addition, high-level languages may or may not pack arrays of elements that are smaller than float4 (e.g. float2/vec2) contiguously. This kind of information is held in the ConstantDefinition structure which is only populated for high-level programs. You don't have to worry about any of this unless you intend to read parameters back from this structure rather than just setting them. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._setNamedConstants(Mogre.GpuNamedConstantsPtr)">
      <summary>Internal method for providing a link to a name-&gt;definition map for parameters. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._setLogicalIndexes(Mogre.GpuLogicalBufferStructPtr,Mogre.GpuLogicalBufferStructPtr)">
      <summary>Internal method for providing a link to a logical index-&gt;physical index map for parameters. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,System.Int32*,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. </summary>
      <param name="index">The logical constant index at which to start placing parameters (each constant is a 4D float) </param>
      <param name="val">Pointer to the values to write, must contain 4*count floats </param>
      <param name="count">The number of groups of 4 floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,Mogre.ColourValue)">
      <summary>Sets a ColourValue parameter to the program. </summary>
      <param name="index">The logical constant index at which to place the parameter (each constant is a 4D float) </param>
      <param name="colour">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,System.Double*,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. </summary>
      <param name="index">The logical constant index at which to start placing parameters (each constant is a 4D float) </param>
      <param name="val">Pointer to the values to write, must contain 4*count floats </param>
      <param name="count">The number of groups of 4 floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,System.Single*,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. </summary>
      <param name="index">The logical constant index at which to start placing parameters (each constant is a 4D float) </param>
      <param name="val">Pointer to the values to write, must contain 4*count floats </param>
      <param name="count">The number of groups of 4 floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,Mogre.Matrix4+NativeValue*,System.UInt32)">
      <summary>Sets a list of Matrix4 parameters to the program. </summary>
      <param name="index">The logical constant index at which to start placing the parameter (each constant is a 4D float). NB since a Matrix4 is 16 floats long, so each entry will take up 4 indexes. </param>
      <param name="m">Pointer to an array of matrices to set </param>
      <param name="numEntries">Number of Matrix4 entries </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,Mogre.Matrix4)">
      <summary>Sets a Matrix4 parameter to the program. </summary>
      <param name="index">The logical constant index at which to place the parameter (each constant is a 4D float). NB since a Matrix4 is 16 floats long, this parameter will take up 4 indexes. </param>
      <param name="m">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,Mogre.Vector3)">
      <summary>Sets a 4-element floating-point parameter to the program. </summary>
      <param name="index">The logical constant index at which to place the parameter (each constant is a 4D float) </param>
      <param name="vec">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,System.Single)">
      <summary>Sets a single floating-point parameter to the program. This is actually equivalent to calling setConstant(index Vector4(val, 0, 0, 0)) since all constants are 4D. </summary>
      <param name="index">The logical constant index at which to place the parameter (each constant is a 4D float) </param>
      <param name="val">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstant(System.UInt32,Mogre.Vector4)">
      <summary>Sets a 4-element floating-point parameter to the program. </summary>
      <param name="index">The logical constant index at which to place the parameter (each constant is a 4D float) </param>
      <param name="vec">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstants(System.UInt32,System.Int32*,System.UInt32)">
      <summary>Write a series of floating point values into the underlying float constant buffer at the given physical index. </summary>
      <param name="physicalIndex">The buffer position to start writing </param>
      <param name="val">Pointer to a list of values to write </param>
      <param name="count">The number of floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstants(System.UInt32,System.Double*,System.UInt32)">
      <summary>Write a series of floating point values into the underlying float constant buffer at the given physical index. </summary>
      <param name="physicalIndex">The buffer position to start writing </param>
      <param name="val">Pointer to a list of values to write </param>
      <param name="count">The number of floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstants(System.UInt32,System.Single*,System.UInt32)">
      <summary>Write a series of floating point values into the underlying float constant buffer at the given physical index. </summary>
      <param name="physicalIndex">The buffer position to start writing </param>
      <param name="val">Pointer to a list of values to write </param>
      <param name="count">The number of floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._readRawConstants(System.UInt32,System.UInt32,System.Int32&amp;)">
      <summary>Read a series of floating point values from the underlying float constant buffer at the given physical index. </summary>
      <param name="physicalIndex">The buffer position to start reading </param>
      <param name="count">The number of floats to read </param>
      <param name="dest">Pointer to a buffer to receive the values </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._readRawConstants(System.UInt32,System.UInt32,System.Single&amp;)">
      <summary>Read a series of floating point values from the underlying float constant buffer at the given physical index. </summary>
      <param name="physicalIndex">The buffer position to start reading </param>
      <param name="count">The number of floats to read </param>
      <param name="dest">Pointer to a buffer to receive the values </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,Mogre.ColourValue)">
      <summary>Write a ColourValue parameter to the program. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="colour">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,Mogre.ColourValue,System.UInt32)">
      <summary>Write a ColourValue parameter to the program. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="colour">The value to set </param>
      <param name="count">The number of floats to write; if for example the uniform constant 'slot' is smaller than a Vector4</param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,Mogre.Matrix4+NativeValue*,System.UInt32)">
      <summary>Write a list of Matrix4 parameters to the program. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="numEntries">Number of Matrix4 entries </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,Mogre.Matrix4,System.UInt32)">
      <summary>Write a Matrix4 parameter to the program. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="m">The value to set </param>
      <param name="elementCount">actual element count used with shader </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,Mogre.Vector3)">
      <summary>Write a 4-element floating-point parameter to the program directly to the underlying constants buffer. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="vec">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,System.Int32)">
      <summary>Write a single floating-point parameter to the program. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="val">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,System.Single)">
      <summary>Write a single floating-point parameter to the program. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="val">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,Mogre.Vector4)">
      <summary>Write a 4-element floating-point parameter to the program directly to the underlying constants buffer. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="vec">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._writeRawConstant(System.UInt32,Mogre.Vector4,System.UInt32)">
      <summary>Write a 4-element floating-point parameter to the program directly to the underlying constants buffer. You can use these methods if you have already derived the physical constant buffer location, for a slight speed improvement over using the named / logical index versions. </summary>
      <param name="physicalIndex">The physical buffer index at which to place the parameter </param>
      <param name="vec">The value to set </param>
      <param name="count">The number of floats to write; if for example the uniform constant 'slot' is smaller than a Vector4</param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetConstantDefinitionIterator">
      <summary>Gets an iterator over the named GpuConstantDefinition instances as defined by the program for which these parameters exist. Only available if this parameters object has named parameters. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetConstantDefinition(System.String)">
      <summary>Get a specific GpuConstantDefinition for a named parameter. Only available if this parameters object has named parameters. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetFloatLogicalBufferStruct">
      <summary>Get the current list of mappings from low-level logical param indexes to physical buffer locations in the float buffer. Only applicable to low-level programs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetFloatLogicalIndexForPhysicalIndex(System.UInt32)">
      <summary>Retrieves the logical index relating to a physical index in the float buffer, for programs which support that (low-level programs and high-level programs which use logical parameter indexes). std::numeric_limits&lt;size_t&gt;::max() if not found </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetIntLogicalIndexForPhysicalIndex(System.UInt32)">
      <summary>Retrieves the logical index relating to a physical index in the int buffer, for programs which support that (low-level programs and high-level programs which use logical parameter indexes). std::numeric_limits&lt;size_t&gt;::max() if not found </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetIntLogicalBufferStruct">
      <summary>Get the current list of mappings from low-level logical param indexes to physical buffer locations in the integer buffer. Only applicable to low-level programs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetFloatConstantList">
      <summary>Get a reference to the list of float constants. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetFloatPointer(System.UInt32)">
      <summary>Get a pointer to the 'nth' item in the float buffer. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetIntConstantList">
      <summary>Get a reference to the list of int constants. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetIntPointer(System.UInt32)">
      <summary>Get a pointer to the 'nth' item in the int buffer. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetAutoConstantList">
      <summary>Get a reference to the list of auto constant bindings. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetAutoConstant(System.UInt32,Mogre.GpuProgramParameters+AutoConstantType,System.UInt16,System.UInt16)">
      <summary>Sets up a constant which will automatically be updated by the system. Vertex and fragment programs often need parameters which are to do with the current render state, or particular values which may very well change over time, and often between objects which are being rendered. This feature allows you to set up a certain number of predefined parameter mappings that are kept up to date for you. </summary>
      <param name="index">The location in the constant list to place this updated constant every time it is changed. Note that because of the nature of the types, we know how big the parameter details will be so you don't need to set that like you do for manual constants. </param>
      <param name="acType">The type of automatic constant to set </param>
      <param name="extraInfo1">The first extra parameter required by the auto constant type </param>
      <param name="extraInfo2">The first extra parameter required by the auto constant type </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetAutoConstant(System.UInt32,Mogre.GpuProgramParameters+AutoConstantType)">
      <summary>Sets up a constant which will automatically be updated by the system. Vertex and fragment programs often need parameters which are to do with the current render state, or particular values which may very well change over time, and often between objects which are being rendered. This feature allows you to set up a certain number of predefined parameter mappings that are kept up to date for you. </summary>
      <param name="index">The location in the constant list to place this updated constant every time it is changed. Note that because of the nature of the types, we know how big the parameter details will be so you don't need to set that like you do for manual constants. </param>
      <param name="acType">The type of automatic constant to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetAutoConstant(System.UInt32,Mogre.GpuProgramParameters+AutoConstantType,System.UInt32)">
      <summary>Sets up a constant which will automatically be updated by the system. Vertex and fragment programs often need parameters which are to do with the current render state, or particular values which may very well change over time, and often between objects which are being rendered. This feature allows you to set up a certain number of predefined parameter mappings that are kept up to date for you. </summary>
      <param name="index">The location in the constant list to place this updated constant every time it is changed. Note that because of the nature of the types, we know how big the parameter details will be so you don't need to set that like you do for manual constants. </param>
      <param name="acType">The type of automatic constant to set </param>
      <param name="extraInfo">If the constant type needs more information (like a light index) put it here. </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._setRawAutoConstant(System.UInt32,Mogre.GpuProgramParameters+AutoConstantType,System.UInt32,System.UInt16)">
      <summary>As setAutoConstant, but sets up the auto constant directly against a physical buffer index. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._setRawAutoConstant(System.UInt32,Mogre.GpuProgramParameters+AutoConstantType,System.UInt32,System.UInt16,System.UInt32)">
      <summary>As setAutoConstant, but sets up the auto constant directly against a physical buffer index. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._setRawAutoConstantReal(System.UInt32,Mogre.GpuProgramParameters+AutoConstantType,System.Single,System.UInt16)">
      <summary>As setAutoConstantReal, but sets up the auto constant directly against a physical buffer index. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._setRawAutoConstantReal(System.UInt32,Mogre.GpuProgramParameters+AutoConstantType,System.Single,System.UInt16,System.UInt32)">
      <summary>As setAutoConstantReal, but sets up the auto constant directly against a physical buffer index. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.ClearAutoConstant(System.UInt32)">
      <summary>Unbind an auto constant so that the constant is manually controlled again. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetConstantFromTime(System.UInt32,System.Single)">
      <summary>Sets a named parameter up to track a derivation of the current time. </summary>
      <param name="index">The index of the parameter </param>
      <param name="factor">The amount by which to scale the time value </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.ClearAutoConstants">
      <summary>Clears all the existing automatic constants. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetAutoConstantIterator">
      <summary>Gets an iterator over the automatic constant bindings currently in place. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetAutoConstantEntry(System.UInt32)">
      <summary>Gets a specific Auto Constant entry if index is in valid range otherwise returns a NULL </summary>
      <param name="index">which entry is to be retrieved </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.FindFloatAutoConstantEntry(System.UInt32)">
      <summary>Finds an auto constant that's affecting a given logical parameter index for floating-point values. Only applicable for low-level programs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.FindIntAutoConstantEntry(System.UInt32)">
      <summary>Finds an auto constant that's affecting a given logical parameter index for integer values. Only applicable for low-level programs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.FindAutoConstantEntry(System.String)">
      <summary>Finds an auto constant that's affecting a given named parameter index. Only applicable to high-level programs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._findRawAutoConstantEntryFloat(System.UInt32)">
      <summary>Finds an auto constant that's affecting a given physical position in the floating-point buffer </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._findRawAutoConstantEntryInt(System.UInt32)">
      <summary>Finds an auto constant that's affecting a given physical position in the integer buffer </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetIgnoreMissingParams(System.Boolean)">
      <summary>Tells the program whether to ignore missing parameters or not. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Int32*,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. Some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. The 'multiple' parameter allows you to control that although you should only change it if you know your chosen language supports that (at the time of writing, only GLSL allows constants which are not a multiple of 4). This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">Pointer to the values to write </param>
      <param name="count">The number of 'multiples' of floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Int32*,System.UInt32,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. Some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. The 'multiple' parameter allows you to control that although you should only change it if you know your chosen language supports that (at the time of writing, only GLSL allows constants which are not a multiple of 4). This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">Pointer to the values to write </param>
      <param name="count">The number of 'multiples' of floats to write </param>
      <param name="multiple">The number of raw entries in each element to write, the default is 4 so count = 1 would write 4 floats. </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,Mogre.ColourValue)">
      <summary>Sets a ColourValue parameter to the program. </summary>
      <param name="name">The name of the parameter </param>
      <param name="colour">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Double*,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. Some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. The 'multiple' parameter allows you to control that although you should only change it if you know your chosen language supports that (at the time of writing, only GLSL allows constants which are not a multiple of 4). This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">Pointer to the values to write </param>
      <param name="count">The number of 'multiples' of floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Double*,System.UInt32,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. Some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. The 'multiple' parameter allows you to control that although you should only change it if you know your chosen language supports that (at the time of writing, only GLSL allows constants which are not a multiple of 4). This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">Pointer to the values to write </param>
      <param name="count">The number of 'multiples' of floats to write </param>
      <param name="multiple">The number of raw entries in each element to write, the default is 4 so count = 1 would write 4 floats. </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Single*,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. Some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. The 'multiple' parameter allows you to control that although you should only change it if you know your chosen language supports that (at the time of writing, only GLSL allows constants which are not a multiple of 4). This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">Pointer to the values to write </param>
      <param name="count">The number of 'multiples' of floats to write </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Single*,System.UInt32,System.UInt32)">
      <summary>Sets a multiple value constant floating-point parameter to the program. Some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. The 'multiple' parameter allows you to control that although you should only change it if you know your chosen language supports that (at the time of writing, only GLSL allows constants which are not a multiple of 4). This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">Pointer to the values to write </param>
      <param name="count">The number of 'multiples' of floats to write </param>
      <param name="multiple">The number of raw entries in each element to write, the default is 4 so count = 1 would write 4 floats. </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,Mogre.Matrix4+NativeValue*,System.UInt32)">
      <summary>Sets a list of Matrix4 parameters to the program. </summary>
      <param name="name">The name of the parameter; this must be the first index of an array, for examples 'matrices[0]' NB since a Matrix4 is 16 floats long, so each entry will take up 4 indexes. </param>
      <param name="m">Pointer to an array of matrices to set </param>
      <param name="numEntries">Number of Matrix4 entries </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,Mogre.Matrix4)">
      <summary>Sets a Matrix4 parameter to the program. </summary>
      <param name="name">The name of the parameter </param>
      <param name="m">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,Mogre.Vector3)">
      <summary>Sets a Vector4 parameter to the program. </summary>
      <param name="name">The name of the parameter </param>
      <param name="vec">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,Mogre.Vector4)">
      <summary>Sets a Vector4 parameter to the program. </summary>
      <param name="name">The name of the parameter </param>
      <param name="vec">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Int32)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstant(System.String,System.Single)">
      <summary>Sets a single value constant floating-point parameter to the program. Different types of GPU programs support different types of constant parameters. For example, it's relatively common to find that vertex programs only support floating point constants, and that fragment programs only support integer (fixed point) parameters. This can vary depending on the program version supported by the graphics card being used. You should consult the documentation for the type of low level program you are using, or alternatively use the methods provided on RenderSystemCapabilities to determine the options. Another possible limitation is that some systems only allow constants to be set on certain boundaries, e.g. in sets of 4 values for example. Again, see RenderSystemCapabilities for full details. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="val">The value to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedAutoConstant(System.String,Mogre.GpuProgramParameters+AutoConstantType,System.UInt16,System.UInt16)">
      <summary>Sets up a constant which will automatically be updated by the system. Vertex and fragment programs often need parameters which are to do with the current render state, or particular values which may very well change over time, and often between objects which are being rendered. This feature allows you to set up a certain number of predefined parameter mappings that are kept up to date for you. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="acType">The type of automatic constant to set </param>
      <param name="extraInfo1">The first extra info required by this auto constant type </param>
      <param name="extraInfo2">The first extra info required by this auto constant type </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedAutoConstant(System.String,Mogre.GpuProgramParameters+AutoConstantType)">
      <summary>Sets up a constant which will automatically be updated by the system. Vertex and fragment programs often need parameters which are to do with the current render state, or particular values which may very well change over time, and often between objects which are being rendered. This feature allows you to set up a certain number of predefined parameter mappings that are kept up to date for you. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="acType">The type of automatic constant to set </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedAutoConstant(System.String,Mogre.GpuProgramParameters+AutoConstantType,System.UInt32)">
      <summary>Sets up a constant which will automatically be updated by the system. Vertex and fragment programs often need parameters which are to do with the current render state, or particular values which may very well change over time, and often between objects which are being rendered. This feature allows you to set up a certain number of predefined parameter mappings that are kept up to date for you. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="acType">The type of automatic constant to set </param>
      <param name="extraInfo">If the constant type needs more information (like a light index) put it here. </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.SetNamedConstantFromTime(System.String,System.Single)">
      <summary>Sets a named parameter up to track a derivation of the current time. This named option will only work if you are using a parameters object created from a high-level program (HighLevelGpuProgram). </summary>
      <param name="name">The name of the parameter </param>
      <param name="factor">The amount by which to scale the time value </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.ClearNamedAutoConstant(System.String)">
      <summary>Unbind an auto constant so that the constant is manually controlled again. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._findNamedConstantDefinition(System.String)">
      <summary>Find a constant definition for a named parameter. This method returns null if the named parameter did not exist, unlike getConstantDefinition which is more strict; unless you set the last parameter to true. </summary>
      <param name="name">The name to look up </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._findNamedConstantDefinition(System.String,System.Boolean)">
      <summary>Find a constant definition for a named parameter. This method returns null if the named parameter did not exist, unlike getConstantDefinition which is more strict; unless you set the last parameter to true. </summary>
      <param name="name">The name to look up </param>
      <param name="throwExceptionIfMissing">If set to true, failure to find an entry will throw an exception. </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._getFloatConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)">
      <summary>Gets the physical buffer index associated with a logical float constant index. Only applicable to low-level programs. </summary>
      <param name="logicalIndex">The logical parameter index </param>
      <param name="requestedSize">The requested size - pass 0 to ignore missing entries and return std::numeric_limits&lt;size_t&gt;::max() </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters._getIntConstantPhysicalIndex(System.UInt32,System.UInt32,System.UInt16)">
      <summary>Gets the physical buffer index associated with a logical int constant index. Only applicable to low-level programs. </summary>
      <param name="logicalIndex">The logical parameter index </param>
      <param name="requestedSize">The requested size - pass 0 to ignore missing entries and return std::numeric_limits&lt;size_t&gt;::max() </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.CopyConstantsFrom(Mogre.GpuProgramParameters)">
      <summary>Copies the values of all constants (including auto constants) from another GpuProgramParameters object. This copes the internal storage of the paarameters object and therefore can only be used for parameters objects created from the same GpuProgram. To merge parameters that match from different programs, use copyMatchingNamedConstantsFrom. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.CopyMatchingNamedConstantsFrom(Mogre.GpuProgramParameters)">
      <summary>Copies the values of all matching named constants (including auto constants) from another GpuProgramParameters object. This method iterates over the named constants in another parameters object and copies across the values where they match. This method is safe to use when the 2 parameters objects came from different programs, but only works for named parameters. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.IncPassIterationNumber">
      <summary>increments the multipass number entry by 1 if it exists </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.AddSharedParameters(System.String)">
      <summary>Use a set of shared parameters in this parameters object. Allows you to use a set of shared parameters to automatically update this parameter set. </summary>
      <param name="sharedParamsName">The name of a shared parameter set as defined in GpuProgramManager</param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.AddSharedParameters(Mogre.GpuSharedParametersPtr)">
      <summary>Use a set of shared parameters in this parameters object. Allows you to use a set of shared parameters to automatically update this parameter set. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.IsUsingSharedParameters(System.String)">
      <summary>Returns whether this parameter set is using the named shared parameter set. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.RemoveSharedParameters(System.String)">
      <summary>Stop using the named shared parameter set. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.RemoveAllSharedParameters">
      <summary>Stop using all shared parameter sets. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetSharedParameters">
      <summary>Get the list of shared parameter sets. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters._copySharedParams">
      <summary>Update the parameters by copying the data from the shared parameters. This method may not actually be called if the RenderSystem supports using shared parameters directly in their own shared buffer; in which case the values should not be copied out of the shared area into the individual parameter set, but bound separately. </summary>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetAutoConstantDefinition(System.UInt32)">
      <summary>gets the auto constant definition using an index into the auto constant definition array. If the index is out of bounds then NULL is returned; </summary>
      <param name="idx">The auto constant index </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.GetAutoConstantDefinition(System.String)">
      <summary>gets the auto constant definition associated with name if found else returns NULL </summary>
      <param name="name">The name of the auto constant </param>
    </member>
    <member name="M:Mogre.GpuProgramParameters.#ctor(Mogre.GpuProgramParameters)">
      <summary>Copy constructor. </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.TransposeMatrices">
      <summary>Sets/Gets whether or not matrices are to be transposed when set. </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.PassIterationNumberIndex">
      <summary>Get the physical buffer index of the pass iteration number constant </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.NumAutoConstantDefinitions">
      <summary>Returns the number of auto constant definitions </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.HasPassIterationNumber">
      <summary>Does this parameters object have a pass iteration number constant? </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.HasNamedParameters">
      <summary>Does this parameter set include named parameters? </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.HasLogicalIndexedParameters">
      <summary>Does this parameter set include logically indexed parameters? Not mutually exclusive with hasNamedParameters since some high-level programs still use logical indexes to set the parameters on the rendersystem. </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.HasAutoConstants">
      <summary>Returns true if this instance has any automatic constants. </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.ConstantDefinitions">
      <summary>Get the full list of GpuConstantDefinition instances. Only available if this parameters object has named parameters. </summary>
    </member>
    <member name="P:Mogre.GpuProgramParameters.AutoConstantCount">
      <summary>Gets the number of int constants that have been set. </summary>
    </member>
    <member name="T:Mogre.GpuProgramParameters+AutoConstantType">
      <summary>Defines the types of automatically updated values that may be bound to GpuProgram parameters, or used to modify parameters on a per-object basis. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_WORLD_MATRIX">
      <summary>The current world matrix. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_WORLD_MATRIX">
      <summary>The current world matrix, inverted. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TRANSPOSE_WORLD_MATRIX">
      <summary>Provides transpose of world matrix. Equivalent to RenderMonkey's "WorldTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_TRANSPOSE_WORLD_MATRIX">
      <summary>The current world matrix, inverted &amp; transposed. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_WORLD_MATRIX_ARRAY_3x4">
      <summary>The current array of world matrices, as a 3x4 matrix, used for blending. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_WORLD_MATRIX_ARRAY">
      <summary>The current array of world matrices, used for blending. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEW_MATRIX">
      <summary>The current view matrix. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_VIEW_MATRIX">
      <summary>The current view matrix, inverted. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TRANSPOSE_VIEW_MATRIX">
      <summary>Provides transpose of view matrix. Equivalent to RenderMonkey's "ViewTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_TRANSPOSE_VIEW_MATRIX">
      <summary>Provides inverse transpose of view matrix. Equivalent to RenderMonkey's "ViewInverseTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_PROJECTION_MATRIX">
      <summary>The current projection matrix. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_PROJECTION_MATRIX">
      <summary>Provides inverse of projection matrix. Equivalent to RenderMonkey's "ProjectionInverse". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TRANSPOSE_PROJECTION_MATRIX">
      <summary>Provides transpose of projection matrix. Equivalent to RenderMonkey's "ProjectionTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX">
      <summary>Provides inverse transpose of projection matrix. Equivalent to RenderMonkey's "ProjectionInverseTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEWPROJ_MATRIX">
      <summary>The current view &amp; projection matrices concatenated. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_VIEWPROJ_MATRIX">
      <summary>Provides inverse of concatenated view and projection matrices. Equivalent to RenderMonkey's "ViewProjectionInverse". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TRANSPOSE_VIEWPROJ_MATRIX">
      <summary>Provides transpose of concatenated view and projection matrices. Equivalent to RenderMonkey's "ViewProjectionTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX">
      <summary>Provides inverse transpose of concatenated view and projection matrices. Equivalent to RenderMonkey's "ViewProjectionInverseTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_WORLDVIEW_MATRIX">
      <summary>The current world &amp; view matrices concatenated. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_WORLDVIEW_MATRIX">
      <summary>The current world &amp; view matrices concatenated, then inverted. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TRANSPOSE_WORLDVIEW_MATRIX">
      <summary>Provides transpose of concatenated world and view matrices. Equivalent to RenderMonkey's "WorldViewTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX">
      <summary>The current world &amp; view matrices concatenated, then inverted &amp; transposed. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_WORLDVIEWPROJ_MATRIX">
      <summary>The current world, view &amp; projection matrices concatenated. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_WORLDVIEWPROJ_MATRIX">
      <summary>Provides inverse of concatenated world, view and projection matrices. Equivalent to RenderMonkey's "WorldViewProjectionInverse". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX">
      <summary>Provides transpose of concatenated world, view and projection matrices. Equivalent to RenderMonkey's "WorldViewProjectionTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX">
      <summary>Provides inverse transpose of concatenated world, view and projection matrices. Equivalent to RenderMonkey's "WorldViewProjectionInverseTranspose". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_RENDER_TARGET_FLIPPING">
      <summary>render target related values </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VERTEX_WINDING">
      <summary>-1 if the winding has been inverted (e.g. for reflections), +1 otherwise. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_FOG_COLOUR">
      <summary>Fog colour. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_FOG_PARAMS">
      <summary>Fog params: density, linear start, linear end, 1/(end-start). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SURFACE_AMBIENT_COLOUR">
      <summary>Surface ambient colour, as set in Pass::setAmbient. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SURFACE_DIFFUSE_COLOUR">
      <summary>Surface diffuse colour, as set in Pass::setDiffuse. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SURFACE_SPECULAR_COLOUR">
      <summary>Surface specular colour, as set in Pass::setSpecular. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SURFACE_EMISSIVE_COLOUR">
      <summary>Surface emissive colour, as set in Pass::setSelfIllumination. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SURFACE_SHININESS">
      <summary>Surface shininess, as set in Pass::setShininess. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_COUNT">
      <summary>The number of active light sources (better than gl_MaxLights). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_AMBIENT_LIGHT_COLOUR">
      <summary>The ambient light colour set in the scene. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIFFUSE_COLOUR">
      <summary>Light diffuse colour (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_SPECULAR_COLOUR">
      <summary>Light specular colour (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_ATTENUATION">
      <summary>Light attenuation parameters, Vector4(range, constant, linear, quadric). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SPOTLIGHT_PARAMS">
      <summary>Spotlight parameters, Vector4(innerFactor, outerFactor, falloff, isSpot) innerFactor and outerFactor are cos(angle/2) The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights. Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POSITION">
      <summary>A light position in world space (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POSITION_OBJECT_SPACE">
      <summary>A light position in object space (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POSITION_VIEW_SPACE">
      <summary>A light position in view space (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIRECTION">
      <summary>A light direction in world space (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIRECTION_OBJECT_SPACE">
      <summary>A light direction in object space (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIRECTION_VIEW_SPACE">
      <summary>A light direction in view space (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DISTANCE_OBJECT_SPACE">
      <summary>The distance of the light from the center of the object a useful approximation as an alternative to per-vertex distance calculations. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POWER_SCALE">
      <summary>Light power level, a single scalar as set in Light::setPowerScale (index determined by setAutoConstant call) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED">
      <summary>Light diffuse colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED">
      <summary>Light specular colour pre-scaled by Light::setPowerScale (index determined by setAutoConstant call). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIFFUSE_COLOUR_ARRAY">
      <summary>Array of light diffuse colours (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_SPECULAR_COLOUR_ARRAY">
      <summary>Array of light specular colours (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY">
      <summary>Array of light diffuse colours scaled by light power (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY">
      <summary>Array of light specular colours scaled by light power (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_ATTENUATION_ARRAY">
      <summary>Array of light attenuation parameters, Vector4(range, constant, linear, quadric) (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POSITION_ARRAY">
      <summary>Array of light positions in world space (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY">
      <summary>Array of light positions in object space (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY">
      <summary>Array of light positions in view space (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIRECTION_ARRAY">
      <summary>Array of light directions in world space (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY">
      <summary>Array of light directions in object space (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY">
      <summary>Array of light directions in view space (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY">
      <summary>Array of distances of the lights from the center of the object a useful approximation as an alternative to per-vertex distance calculations. (count set by extra param) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_POWER_SCALE_ARRAY">
      <summary>Array of light power levels, a single scalar as set in Light::setPowerScale (count set by extra param) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SPOTLIGHT_PARAMS_ARRAY">
      <summary>Spotlight parameters array of Vector4(innerFactor, outerFactor, falloff, isSpot) innerFactor and outerFactor are cos(angle/2) The isSpot parameter is 0.0f for non-spotlights, 1.0f for spotlights. Also for non-spotlights the inner and outer factors are 1 and nearly 1 respectively. (count set by extra param) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_DERIVED_AMBIENT_LIGHT_COLOUR">
      <summary>The derived ambient light colour, with 'r', 'g', 'b' components filled with product of surface ambient colour and ambient light colour, respectively, and 'a' component filled with surface ambient alpha component. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_DERIVED_SCENE_COLOUR">
      <summary>The derived scene colour, with 'r', 'g' and 'b' components filled with sum of derived ambient light colour and surface emissive colour, respectively, and 'a' component filled with surface diffuse alpha component. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_DERIVED_LIGHT_DIFFUSE_COLOUR">
      <summary>The derived light diffuse colour (index determined by setAutoConstant call), with 'r', 'g' and 'b' components filled with product of surface diffuse colour, light power scale and light diffuse colour, respectively, and 'a' component filled with surface diffuse alpha component. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_DERIVED_LIGHT_SPECULAR_COLOUR">
      <summary>The derived light specular colour (index determined by setAutoConstant call), with 'r', 'g' and 'b' components filled with product of surface specular colour and light specular colour, respectively, and 'a' component filled with surface specular alpha component. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY">
      <summary>Array of derived light diffuse colours (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY">
      <summary>Array of derived light specular colours (count set by extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_NUMBER">
      <summary>The absolute light number of a local light index. Each pass may have a number of lights passed to it, and each of these lights will have an index in the overall light list, which will differ from the local light index due to factors like setStartLight and setIteratePerLight. This binding provides the global light index for a local index. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_CASTS_SHADOWS">
      <summary>Returns (int) 1 if the given light casts shadows, 0 otherwise (index set in extra param). </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SHADOW_EXTRUSION_DISTANCE">
      <summary>The distance a shadow volume should be extruded when using finite extrusion programs. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_CAMERA_POSITION">
      <summary>The current camera's position in world space. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_CAMERA_POSITION_OBJECT_SPACE">
      <summary>The current camera's position in object space. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TEXTURE_VIEWPROJ_MATRIX">
      <summary>The view/projection matrix of the assigned texture projection frustum. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY">
      <summary>Array of view/projection matrices of the first n texture projection frustums. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TEXTURE_WORLDVIEWPROJ_MATRIX">
      <summary>The view/projection matrix of the assigned texture projection frustum, combined with the current world matrix </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY">
      <summary>Array of world/view/projection matrices of the first n texture projection frustums. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SPOTLIGHT_VIEWPROJ_MATRIX">
      <summary>The view/projection matrix of a given spotlight. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX">
      <summary>The view/projection matrix of a given spotlight projection frustum, combined with the current world matrix </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_CUSTOM">
      <summary>A custom parameter which will come from the renderable, using 'data' as the identifier. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TIME">
      <summary>provides current elapsed time </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TIME_0_X">
      <summary>Single float value, which repeats itself based on given as parameter "cycle time". Equivalent to RenderMonkey's "Time0_X". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_COSTIME_0_X">
      <summary>Cosine of "Time0_X". Equivalent to RenderMonkey's "CosTime0_X". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SINTIME_0_X">
      <summary>Sine of "Time0_X". Equivalent to RenderMonkey's "SinTime0_X". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TANTIME_0_X">
      <summary>Tangent of "Time0_X". Equivalent to RenderMonkey's "TanTime0_X". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TIME_0_X_PACKED">
      <summary>Vector of "Time0_X", "SinTime0_X", "CosTime0_X", "TanTime0_X". Equivalent to RenderMonkey's "Time0_X_Packed". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TIME_0_1">
      <summary>Single float value, which represents scaled time value [0..1], which repeats itself based on given as parameter "cycle time". Equivalent to RenderMonkey's "Time0_1". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_COSTIME_0_1">
      <summary>Cosine of "Time0_1". Equivalent to RenderMonkey's "CosTime0_1". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SINTIME_0_1">
      <summary>Sine of "Time0_1". Equivalent to RenderMonkey's "SinTime0_1". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TANTIME_0_1">
      <summary>Tangent of "Time0_1". Equivalent to RenderMonkey's "TanTime0_1". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TIME_0_1_PACKED">
      <summary>Vector of "Time0_1", "SinTime0_1", "CosTime0_1", "TanTime0_1". Equivalent to RenderMonkey's "Time0_1_Packed". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TIME_0_2PI">
      <summary>Single float value, which represents scaled time value [0..2*Pi], which repeats itself based on given as parameter "cycle time". Equivalent to RenderMonkey's "Time0_2PI". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_COSTIME_0_2PI">
      <summary>Cosine of "Time0_2PI". Equivalent to RenderMonkey's "CosTime0_2PI". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SINTIME_0_2PI">
      <summary>Sine of "Time0_2PI". Equivalent to RenderMonkey's "SinTime0_2PI". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TANTIME_0_2PI">
      <summary>Tangent of "Time0_2PI". Equivalent to RenderMonkey's "TanTime0_2PI". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TIME_0_2PI_PACKED">
      <summary>Vector of "Time0_2PI", "SinTime0_2PI", "CosTime0_2PI", "TanTime0_2PI". Equivalent to RenderMonkey's "Time0_2PI_Packed". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_FRAME_TIME">
      <summary>provides the scaled frame time, returned as a floating point value. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_FPS">
      <summary>provides the calculated frames per second, returned as a floating point value. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEWPORT_WIDTH">
      <summary>viewport-related values </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEWPORT_HEIGHT">
      <summary>Current viewport height (in pixels) as floating point value. Equivalent to RenderMonkey's "ViewportHeight". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_VIEWPORT_WIDTH">
      <summary>This variable represents 1.0/ViewportWidth. Equivalent to RenderMonkey's "ViewportWidthInverse". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_VIEWPORT_HEIGHT">
      <summary>This variable represents 1.0/ViewportHeight. Equivalent to RenderMonkey's "ViewportHeightInverse". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEWPORT_SIZE">
      <summary>Packed of "ViewportWidth", "ViewportHeight", "ViewportWidthInverse", "ViewportHeightInverse". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEW_DIRECTION">
      <summary>view parameters </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEW_SIDE_VECTOR">
      <summary>This variable provides the view side vector (world space). Equivalent to RenderMonkey's "ViewSideVector". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_VIEW_UP_VECTOR">
      <summary>This variable provides the view up vector (world space). Equivalent to RenderMonkey's "ViewUpVector". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_FOV">
      <summary>This variable provides the field of view as a floating point value. Equivalent to RenderMonkey's "FOV". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_NEAR_CLIP_DISTANCE">
      <summary>This variable provides the near clip distance as a floating point value. Equivalent to RenderMonkey's "NearClipPlane". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_FAR_CLIP_DISTANCE">
      <summary>This variable provides the far clip distance as a floating point value. Equivalent to RenderMonkey's "FarClipPlane". </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_PASS_NUMBER">
      <summary>provides the pass index number within the technique of the active materil. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_PASS_ITERATION_NUMBER">
      <summary>provides the current iteration number of the pass. The iteration number is the number of times the current render operation has been drawn for the active pass. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_ANIMATION_PARAMETRIC">
      <summary>Provides a parametric animation value [0..1], only available where the renderable specifically implements it. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TEXEL_OFFSETS">
      <summary>Provides the texel offsets required by this rendersystem to map texels to pixels. Packed as float4(absoluteHorizontalOffset, absoluteVerticalOffset, horizontalOffset / viewportWidth, verticalOffset / viewportHeight) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SCENE_DEPTH_RANGE">
      <summary>Provides information about the depth range of the scene as viewed from the current camera. Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SHADOW_SCENE_DEPTH_RANGE">
      <summary>Provides information about the depth range of the scene as viewed from a given shadow camera. Requires an index parameter which maps to a light index relative to the current light list. Passed as float4(minDepth, maxDepth, depthRange, 1 / depthRange) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_SHADOW_COLOUR">
      <summary>Provides the fixed shadow colour as configured via SceneManager::setShadowColour; useful for integrated modulative shadows. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TEXTURE_SIZE">
      <summary>Provides texture size of the texture unit (index determined by setAutoConstant call). Packed as float4(width, height, depth, 1) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_INVERSE_TEXTURE_SIZE">
      <summary>Provides inverse texture size of the texture unit (index determined by setAutoConstant call). Packed as float4(1 / width, 1 / height, 1 / depth, 1) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_PACKED_TEXTURE_SIZE">
      <summary>Provides packed texture size of the texture unit (index determined by setAutoConstant call). Packed as float4(width, height, 1 / width, 1 / height) </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_TEXTURE_MATRIX">
      <summary>Provides the current transform matrix of the texture unit (index determined by setAutoConstant call), as seen by the fixed-function pipeline. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LOD_CAMERA_POSITION">
      <summary>Provides the position of the LOD camera in world space, allowing you to perform separate LOD calculations in shaders independent of the rendering camera. If there is no separate LOD camera then this is the real camera position. See Camera::setLodCamera. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LOD_CAMERA_POSITION_OBJECT_SPACE">
      <summary>Provides the position of the LOD camera in object space, allowing you to perform separate LOD calculations in shaders independent of the rendering camera. If there is no separate LOD camera then this is the real camera position. See Camera::setLodCamera. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+AutoConstantType.ACT_LIGHT_CUSTOM">
      <summary>Binds custom per-light constants to the shaders. </summary>
    </member>
    <member name="T:Mogre.GpuProgramParameters+ACDataType">
      <summary>Defines the type of the extra data item used by the auto constant. </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+ACDataType.ACDT_NONE">
      <summary>no data is required </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+ACDataType.ACDT_INT">
      <summary>the auto constant requires data of type int </summary>
    </member>
    <member name="F:Mogre.GpuProgramParameters+ACDataType.ACDT_REAL">
      <summary>the auto constant requires data of type real </summary>
    </member>
    <member name="T:Mogre.GpuProgramParameters+ElementType">
      <summary>Defines the base element type of the auto constant </summary>
    </member>
    <member name="T:Mogre.FloatConstantList">
      <summary>Definition of container that holds the current float constants. Not necessarily in direct index order to constant indexes, logical to physical index map is derived from GpuProgram</summary>
    </member>
    <member name="T:Mogre.Const_FloatConstantList">
      <summary>Definition of container that holds the current float constants. Not necessarily in direct index order to constant indexes, logical to physical index map is derived from GpuProgram</summary>
    </member>
    <member name="T:Mogre.IntConstantList">
      <summary>Definition of container that holds the current float constants. Not necessarily in direct index order to constant indexes, logical to physical index map is derived from GpuProgram</summary>
    </member>
    <member name="T:Mogre.Const_IntConstantList">
      <summary>Definition of container that holds the current float constants. Not necessarily in direct index order to constant indexes, logical to physical index map is derived from GpuProgram</summary>
    </member>
    <member name="T:Mogre.GpuSharedParametersPtr">
      <summary>Shared pointer used to hold references to GpuProgramParameters instances. </summary>
    </member>
    <member name="T:Mogre.GpuProgramParametersSharedPtr">
      <summary>Shared pointer used to hold references to GpuProgramParameters instances. </summary>
    </member>
    <member name="T:Mogre.Renderable">
      <summary>Abstract class defining the interface all renderable objects must implement. This interface abstracts renderable discrete objects which will be queued in the render pipeline, grouped by material. Classes implementing this interface must be based on a single material, a single world matrix (or a collection of world matrices which are blended by weights), and must be renderable via a single render operation. Note that deciding whether to put these objects in the rendering pipeline is done from the more specific classes e.g. entities. Only once it is decided that the specific class is to be rendered is the abstract version created (could be more than one per visible object) and pushed onto the rendering queue. </summary>
    </member>
    <member name="M:Mogre.Renderable.GetMaterial">
      <summary>Retrieves a weak reference to the material this renderable object uses. Note that the Renderable also has the option to override the getTechnique method to specify a particular Technique to use instead of the best one available. </summary>
    </member>
    <member name="M:Mogre.Renderable.GetRenderOperation(Mogre.RenderOperation)">
      <summary>Gets the render operation required to send this object to the frame buffer. </summary>
    </member>
    <member name="M:Mogre.Renderable.PreRender(Mogre.SceneManager,Mogre.RenderSystem)">
      <summary>Called just prior to the Renderable being rendered. OGRE is a queued renderer, so the actual render commands are executed at a later time than the point at which an object is discovered to be visible. This allows ordering &amp; grouping of renders without the discovery process having to be aware of it. It also means OGRE uses declarative render information rather than immediate mode rendering - this is very useful in that certain effects and processes can automatically be applied to a wide range of scenes, but the downside is that special cases are more difficult to handle, because there is not the declared state to cope with it. This method allows a Renderable to do something special at the actual point of rendering if it wishes to. When this method is called, all the material render state as declared by this Renderable has already been set, all that is left to do is to bind the buffers and perform the render. The Renderable may modify render state itself if it wants to (and restore it in the postRender call) before the automated render happens, or by returning 'false' from this method can actually suppress the automatic render and perform one of its own. true if the automatic render should proceed, false to skip it on the assumption that the Renderable has done it manually. </summary>
    </member>
    <member name="M:Mogre.Renderable.PostRender(Mogre.SceneManager,Mogre.RenderSystem)">
      <summary>Called immediately after the Renderable has been rendered. </summary>
    </member>
    <member name="M:Mogre.Renderable.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>Gets the world transform matrix / matrices for this renderable object. If the object has any derived transforms, these are expected to be up to date as long as all the SceneNode structures have been updated before this is called. This method will populate xform with 1 matrix if it does not use vertex blending. If it does use vertex blending it will fill the passed in pointer with an array of matrices, the length being the value returned from getNumWorldTransforms. Internal Ogre never supports non-affine matrix for world transform matrix/matrices, the behavior is undefined if returns non-affine matrix here.Matrix4::isAffine. </summary>
    </member>
    <member name="M:Mogre.Renderable.GetSquaredViewDepth(Mogre.Camera)">
      <summary>Returns the camera-relative squared depth of this renderable. Used to sort transparent objects. Squared depth is used rather than actual depth to avoid having to perform a square root on the result. </summary>
    </member>
    <member name="M:Mogre.Renderable.GetLights">
      <summary>Gets a list of lights, ordered relative to how close they are to this renderable. Directional lights, which have no position, will always be first on this list. </summary>
    </member>
    <member name="M:Mogre.Renderable.SetCustomParameter(System.UInt32,Mogre.Vector4)">
      <summary>Sets a custom parameter for this Renderable, which may be used to drive calculations for this specific Renderable, like GPU program parameters. Calling this method simply associates a numeric index with a 4-dimensional value for this specific Renderable. This is most useful if the material which this Renderable uses a vertex or fragment program, and has an ACT_CUSTOM parameter entry. This parameter entry can refer to the index you specify as part of this call, thereby mapping a custom parameter for this renderable to a program parameter. </summary>
      <param name="index">The index with which to associate the value. Note that this does not have to start at 0, and can include gaps. It also has no direct correlation with a GPU program parameter index - the mapping between the two is performed by the ACT_CUSTOM entry, if that is used. </param>
      <param name="value">The value to associate. </param>
    </member>
    <member name="M:Mogre.Renderable.GetCustomParameter(System.UInt32)">
      <summary>Gets the custom value associated with this Renderable at the given index. </summary>
    </member>
    <member name="M:Mogre.Renderable._updateCustomGpuParameter(Mogre.GpuProgramParameters+AutoConstantEntry_NativePtr,Mogre.GpuProgramParameters)">
      <summary>Update a custom GpuProgramParameters constant which is derived from information only this Renderable knows. This method allows a Renderable to map in a custom GPU program parameter based on it's own data. This is represented by a GPU auto parameter of ACT_CUSTOM, and to allow there to be more than one of these per Renderable, the 'data' field on the auto parameter will identify which parameter is being updated. The implementation of this method must identify the parameter being updated, and call a 'setConstant' method on the passed in GpuProgramParameters object, using the details provided in the incoming auto constant setting to identify the index at which to set the parameter. You do not need to override this method if you're using the standard sets of data associated with the Renderable as provided by setCustomParameter and getCustomParameter. By default, the implementation will map from the value indexed by the 'constantEntry.data' parameter to a value previously set by setCustomParameter. But custom Renderables are free to override this if they want, in any case. </summary>
      <param name="constantEntry">The auto constant entry referring to the parameter being updated </param>
      <param name="params">The parameters object which this method should call to set the updated parameters. </param>
    </member>
    <member name="P:Mogre.Renderable.UserObjectBindings">
      <summary>Return an instance of user objects binding associated with this class. You can use it to associate one or more custom objects with this class instance. UserObjectBindings::setUserAny. </summary>
    </member>
    <member name="P:Mogre.Renderable.UseIdentityView">
      <summary>Sets/Returns whether or not to use an 'identity' view. Usually Renderable objects will use a view matrix as determined by the active camera. However, if they want they can cancel this out and use an identity matrix, which means all geometry is assumed to be relative to camera space already. Useful for overlay rendering. Normal renderables need not change this. Renderable::setUseIdentityView</summary>
    </member>
    <member name="P:Mogre.Renderable.UseIdentityProjection">
      <summary>Sets/Returns whether or not to use an 'identity' projection. Usually Renderable objects will use a projection matrix as determined by the active camera. However, if they want they can cancel this out and use an identity projection, which effectively projects in 2D using a {-1, 1} view space. Useful for overlay rendering. Normal renderables need not change this. Renderable::setUseIdentityProjection</summary>
    </member>
    <member name="P:Mogre.Renderable.Technique">
      <summary>Retrieves a pointer to the MaterialTechnique this renderable object uses. This is to allow Renderables to use a chosen Technique if they wish, otherwise they will use the best Technique available for the Material they are using. </summary>
    </member>
    <member name="P:Mogre.Renderable.PolygonModeOverrideable">
      <summary>Sets/Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting. </summary>
    </member>
    <member name="P:Mogre.Renderable.NumWorldTransforms">
      <summary>Returns the number of world transform matrices this renderable requires. When a renderable uses vertex blending, it uses multiple world matrices instead of a single one. Each vertex sent to the pipeline can reference one or more matrices in this list with given weights. If a renderable does not use vertex blending this method returns 1, which is the default for simplicity. </summary>
    </member>
    <member name="P:Mogre.Renderable.CastsShadows">
      <summary>Method which reports whether this renderable would normally cast a shadow. Subclasses should override this if they could have been used to generate a shadow. </summary>
    </member>
    <member name="T:Mogre.ShadowRenderable">
      <summary>Class which represents the renderable aspects of a set of shadow volume faces. Note that for casters comprised of more than one set of vertex buffers (e.g. SubMeshes each using their own geometry), it will take more than one ShadowRenderable to render the shadow volume. Therefore for shadow caster geometry, it is best to stick to one set of vertex buffers (not necessarily one buffer, but the positions for the entire geometry should come from one buffer if possible) </summary>
    </member>
    <member name="M:Mogre.ShadowRenderable.SetMaterial(Mogre.MaterialPtr)">
      <summary>Set the material to be used by the shadow, should be set by the caller before adding to a render queue </summary>
    </member>
    <member name="M:Mogre.ShadowRenderable.GetMaterial">
      <summary>Overridden from Renderable. </summary>
    </member>
    <member name="M:Mogre.ShadowRenderable.GetRenderOperation(Mogre.RenderOperation)">
      <summary>Overridden from Renderable. </summary>
    </member>
    <member name="M:Mogre.ShadowRenderable.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>Overridden from Renderable. </summary>
    </member>
    <member name="M:Mogre.ShadowRenderable.GetSquaredViewDepth(Mogre.Camera)">
      <summary>Overridden from Renderable. </summary>
    </member>
    <member name="M:Mogre.ShadowRenderable.GetLights">
      <summary>Overridden from Renderable. </summary>
    </member>
    <member name="P:Mogre.ShadowRenderable.RenderOperationForUpdate">
      <summary>Get the internal render operation for set up. </summary>
    </member>
    <member name="P:Mogre.ShadowRenderable.LightCapRenderable">
      <summary>Get the light cap version of this renderable. </summary>
    </member>
    <member name="P:Mogre.ShadowRenderable.IsVisible">
      <summary>Should this ShadowRenderable be treated as visible? </summary>
    </member>
    <member name="P:Mogre.ShadowRenderable.IsLightCapSeparate">
      <summary>Does this renderable require a separate light cap? If possible, the light cap (when required) should be contained in the usual geometry of the shadow renderable. However, if for some reason the normal depth function (less than) could cause artefacts, then a separate light cap with a depth function of 'always fail' can be used instead. The primary example of this is when there are floating point inaccuracies caused by calculating the shadow geometry separately from the real geometry. </summary>
    </member>
    <member name="T:Mogre.ShadowCaster">
      <summary>This class defines the interface that must be implemented by shadow casters. </summary>
    </member>
    <member name="M:Mogre.ShadowCaster.GetWorldBoundingBox">
      <summary>Get the world bounding box of the caster. </summary>
    </member>
    <member name="M:Mogre.ShadowCaster.GetWorldBoundingBox(System.Boolean)">
      <summary>Get the world bounding box of the caster. </summary>
    </member>
    <member name="M:Mogre.ShadowCaster.GetDarkCapBounds(Mogre.Light,System.Single)">
      <summary>Gets the world space bounding box of the dark cap, as extruded using the light provided </summary>
    </member>
    <member name="M:Mogre.ShadowCaster.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Gets an iterator over the renderables required to render the shadow volume. Shadowable geometry should ideally be designed such that there is only one ShadowRenderable required to render the the shadow; however this is not a necessary limitation and it can be exceeded if required. </summary>
      <param name="shadowTechnique">The technique being used to generate the shadow </param>
      <param name="light">The light to generate the shadow from </param>
      <param name="indexBuffer">The index buffer to build the renderables into, the current contents are assumed to be disposable. </param>
      <param name="extrudeVertices">If true, this means this class should extrude the vertices of the back of the volume in software. If false, it will not be done (a vertex program is assumed). </param>
      <param name="extrusionDistance">The distance to extrude the shadow volume </param>
    </member>
    <member name="M:Mogre.ShadowCaster.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Gets an iterator over the renderables required to render the shadow volume. Shadowable geometry should ideally be designed such that there is only one ShadowRenderable required to render the the shadow; however this is not a necessary limitation and it can be exceeded if required. </summary>
      <param name="shadowTechnique">The technique being used to generate the shadow </param>
      <param name="light">The light to generate the shadow from </param>
      <param name="indexBuffer">The index buffer to build the renderables into, the current contents are assumed to be disposable. </param>
      <param name="extrudeVertices">If true, this means this class should extrude the vertices of the back of the volume in software. If false, it will not be done (a vertex program is assumed). </param>
      <param name="extrusionDistance">The distance to extrude the shadow volume </param>
      <param name="flags">Technique-specific flags, see ShadowRenderableFlags </param>
    </member>
    <member name="M:Mogre.ShadowCaster.GetPointExtrusionDistance(Mogre.Light)">
      <summary>Get the distance to extrude for a point/spot light </summary>
    </member>
    <member name="M:Mogre.ShadowCaster.ExtrudeVertices(Mogre.HardwareVertexBufferSharedPtr,System.UInt32,Mogre.Vector4,System.Single)">
      <summary>Utility method for extruding vertices based on a light. Unfortunately, because D3D cannot handle homogeneous (4D) position coordinates in the fixed-function pipeline (GL can, but we have to be cross-API), when we extrude in software we cannot extrude to infinity the way we do in the vertex program (by setting w to 0.0f). Therefore we extrude by a fixed distance, which may cause some problems with larger scenes. Luckily better hardware (ie vertex programs) can fix this. </summary>
      <param name="vertexBuffer">The vertex buffer containing ONLY xyz position values, which must be originalVertexCount * 2 * 3 floats long. </param>
      <param name="originalVertexCount">The count of the original number of vertices, i.e. the number in the mesh, not counting the doubling which has already been done (by VertexData::prepareForShadowVolume) to provide the extruded area of the buffer. </param>
      <param name="lightPos">4D light position in object space, when w=0.0f this represents a directional light </param>
      <param name="extrudeDist">The distance to extrude </param>
    </member>
    <member name="P:Mogre.ShadowCaster.LightCapBounds">
      <summary>Gets the world space bounding box of the light cap </summary>
    </member>
    <member name="P:Mogre.ShadowCaster.HasEdgeList">
      <summary>Returns whether the object has a valid edge list. </summary>
    </member>
    <member name="P:Mogre.ShadowCaster.EdgeList">
      <summary>Returns details of the edges which might be used to determine a silhouette. </summary>
    </member>
    <member name="P:Mogre.ShadowCaster.CastShadows">
      <summary>Returns whether or not this object currently casts a shadow. </summary>
    </member>
    <member name="T:Mogre.MovableObject">
      <summary>Abstract class defining a movable object in a scene. Instances of this class are discrete, relatively small, movable objects which are attached to SceneNode objects to define their position. </summary>
    </member>
    <member name="M:Mogre.MovableObject._notifyCreator(Mogre.MovableObjectFactory)">
      <summary>Notify the object of it's creator (internal use only) </summary>
    </member>
    <member name="M:Mogre.MovableObject._getCreator">
      <summary>Get the creator of this object, if any (internal use only) </summary>
    </member>
    <member name="M:Mogre.MovableObject._notifyManager(Mogre.SceneManager)">
      <summary>Notify the object of it's manager (internal use only) </summary>
    </member>
    <member name="M:Mogre.MovableObject._getManager">
      <summary>Get the manager of this object, if any (internal use only) </summary>
    </member>
    <member name="M:Mogre.MovableObject._notifyAttached(Mogre.Node)">
      <summary>Internal method called to notify the object that it has been attached to a node. </summary>
    </member>
    <member name="M:Mogre.MovableObject._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Internal method called to notify the object that it has been attached to a node. </summary>
    </member>
    <member name="M:Mogre.MovableObject.DetachFromParent">
      <summary>Detaches an object from a parent SceneNode or TagPoint, if attached. </summary>
    </member>
    <member name="M:Mogre.MovableObject._notifyMoved">
      <summary>Internal method called to notify the object that it has been moved. </summary>
    </member>
    <member name="M:Mogre.MovableObject._notifyCurrentCamera(Mogre.Camera)">
      <summary>Internal method to notify the object of the camera to be used for the next rendering operation. Certain objects may want to do specific processing based on the camera position. This method notifies them in case they wish to do this. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetWorldBoundingBox">
      <summary>Retrieves the axis-aligned bounding box for this object in world coordinates. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetWorldBoundingBox(System.Boolean)">
      <summary>Retrieves the axis-aligned bounding box for this object in world coordinates. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetWorldBoundingSphere">
      <summary>Retrieves the worldspace bounding sphere for this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetWorldBoundingSphere(System.Boolean)">
      <summary>Retrieves the worldspace bounding sphere for this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Internal method by which the movable object must add Renderable subclass instances to the rendering queue. The engine will call this method when this object is to be rendered. The object must then create one or more Renderable subclass instances which it places on the passed in Queue for rendering. </summary>
    </member>
    <member name="M:Mogre.MovableObject.IsVisible">
      <summary>Returns whether or not this object is supposed to be visible or not. Takes into account both upper rendering distance and visible flag. </summary>
    </member>
    <member name="M:Mogre.MovableObject.SetRenderQueueGroupAndPriority(System.Byte,System.UInt16)">
      <summary>Sets the render queue group and group priority this entity will be rendered through. Render queues are grouped to allow you to more tightly control the ordering of rendered objects. Within a single render group there another type of grouping called priority which allows further control. If you do not call this method, all Entity objects default to the default queue and priority (RenderQueue::getDefaultQueueGroup, RenderQueue::getDefaultRenderablePriority), which is fine for most objects. You may want to alter this if you want this entity to always appear in front of other objects, e.g. for a 3D menu system or such. See RenderQueue for more details. </summary>
      <param name="queueID">Enumerated value of the queue group to use. See the enum RenderQueueGroupID for what kind of values can be used here. </param>
      <param name="priority">The priority within a group to use. </param>
    </member>
    <member name="M:Mogre.MovableObject._getParentNodeFullTransform">
      <summary>return the full transformation of the parent sceneNode or the attachingPoint node </summary>
    </member>
    <member name="M:Mogre.MovableObject.AddQueryFlags(System.UInt32)">
      <summary>As setQueryFlags, except the flags passed as parameters are appended to the existing flags on this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject.RemoveQueryFlags(System.UInt32)">
      <summary>As setQueryFlags, except the flags passed as parameters are removed from the existing flags on this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject.AddVisibilityFlags(System.UInt32)">
      <summary>As setVisibilityFlags, except the flags passed as parameters are appended to the existing flags on this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject.RemoveVisibilityFlags(System.UInt32)">
      <summary>As setVisibilityFlags, except the flags passed as parameters are removed from the existing flags on this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject.SetListener(Mogre.MovableObject+IListener)">
      <summary>Sets a listener for this object. Note for size and performance reasons only one listener per object is allowed. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetListener">
      <summary>Gets the current listener for this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject.QueryLights">
      <summary>Gets a list of lights, ordered relative to how close they are to this movable object. By default, this method gives the listener a chance to populate light list first, if there is no listener or Listener::objectQueryLights returns NULL, it'll query the light list from parent entity if it is present, or returns SceneNode::findLights if it has parent scene node, otherwise it just returns an empty list. The object internally caches the light list, so it will recalculate it only when object is moved, or lights that affect the frustum have been changed (SceneManager::_getLightsDirtyCounter), but if listener exists, it will be called each time, so the listener should implement their own cache mechanism to optimise performance. This method can be useful when implementing Renderable::getLights in case the renderable is a part of the movable. The list of lights use to lighting this object. </summary>
    </member>
    <member name="M:Mogre.MovableObject._getLightList">
      <summary>Returns a pointer to the current list of lights for this object. You should not modify this list outside of MovableObject::Listener::objectQueryLights (say if you want to use it to implement this method, and use the pointer as a return value) and for reading it's only accurate as at the last frame. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Define a default implementation of method from ShadowCaster which implements no shadows. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Define a default implementation of method from ShadowCaster which implements no shadows. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetDarkCapBounds(Mogre.Light,System.Single)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetPointExtrusionDistance(Mogre.Light)">
      <summary>Get the distance to extrude for a point/spot light </summary>
    </member>
    <member name="M:Mogre.MovableObject.SetDebugDisplayEnabled(System.Boolean)">
      <summary>Sets whether or not the debug display of this object is enabled. Some objects aren't visible themselves but it can be useful to display a debug representation of them. Or, objects may have an additional debug display on top of their regular display. This option enables / disables that debug display. Objects that are not visible never display debug geometry regardless of this setting. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetWorldBoundingBox">
      <summary>Retrieves the axis-aligned bounding box for this object in world coordinates. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetWorldBoundingBox(System.Boolean)">
      <summary>Retrieves the axis-aligned bounding box for this object in world coordinates. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetDarkCapBounds(Mogre.Light,System.Single)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Define a default implementation of method from ShadowCaster which implements no shadows. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Define a default implementation of method from ShadowCaster which implements no shadows. </summary>
    </member>
    <member name="M:Mogre.MovableObject.GetPointExtrusionDistance(Mogre.Light)">
      <summary>Get the distance to extrude for a point/spot light </summary>
    </member>
    <member name="P:Mogre.MovableObject.Visible">
      <summary>Sets/Gets this object whether to be visible or not, if it has a renderable component. Returns the value set by MovableObject::setVisible only. </summary>
    </member>
    <member name="P:Mogre.MovableObject.VisibilityFlags">
      <summary>Sets/Returns the visibility flags relevant for this object. </summary>
    </member>
    <member name="P:Mogre.MovableObject.UserObjectBindings">
      <summary>Return an instance of user objects binding associated with this class. You can use it to associate one or more custom objects with this class instance. UserObjectBindings::setUserAny. </summary>
    </member>
    <member name="P:Mogre.MovableObject.TypeFlags">
      <summary>Get the 'type flags' for this MovableObject. A type flag identifies the type of the MovableObject as a bitpattern. This is used for categorical inclusion / exclusion in SceneQuery objects. By default, this method returns all ones for objects not created by a MovableObjectFactory (hence always including them); otherwise it returns the value assigned to the MovableObjectFactory. Custom objects which don't use MovableObjectFactory will need to override this if they want to be included in queries. </summary>
    </member>
    <member name="P:Mogre.MovableObject.RenderQueueGroup">
      <summary>Sets/Gets the queue group for this entity, see setRenderQueueGroup for full details. </summary>
    </member>
    <member name="P:Mogre.MovableObject.RenderingDistance">
      <summary>Sets/Gets the distance at which batches are no longer rendered. </summary>
    </member>
    <member name="P:Mogre.MovableObject.ReceivesShadows">
      <summary>Returns whether the Material of any Renderable that this MovableObject will add to the render queue will receive shadows. </summary>
    </member>
    <member name="P:Mogre.MovableObject.QueryFlags">
      <summary>Sets/Returns the query flags relevant for this object. </summary>
    </member>
    <member name="P:Mogre.MovableObject.ParentSceneNode">
      <summary>Returns the scene node to which this object is attached. A MovableObject may be attached to either a SceneNode or to a TagPoint, the latter case if it's attached to a bone on an animated entity. This method will return the scene node of the parent entity if the latter is true. </summary>
    </member>
    <member name="P:Mogre.MovableObject.ParentNode">
      <summary>Returns the node to which this object is attached. A MovableObject may be attached to either a SceneNode or to a TagPoint, the latter case if it's attached to a bone on an animated entity. Both are Node subclasses so this method will return either. </summary>
    </member>
    <member name="P:Mogre.MovableObject.Name">
      <summary>Returns the name of this object. </summary>
    </member>
    <member name="P:Mogre.MovableObject.MovableType">
      <summary>Returns the type name of this object. </summary>
    </member>
    <member name="P:Mogre.MovableObject.LightMask">
      <summary>Sets/Get a bitwise mask which will filter the lights affecting this object By default, this mask is fully set meaning all lights will affect this object </summary>
    </member>
    <member name="P:Mogre.MovableObject.LightCapBounds">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="P:Mogre.MovableObject.IsParentTagPoint">
      <summary>Gets whether the parent node is a TagPoint (or a SceneNode). </summary>
    </member>
    <member name="P:Mogre.MovableObject.IsInScene">
      <summary>Returns true if this object is attached to a SceneNode or TagPoint, and this SceneNode / TagPoint is currently in an active part of the scene graph. </summary>
    </member>
    <member name="P:Mogre.MovableObject.IsDebugDisplayEnabled">
      <summary>Gets whether debug display of this object is enabled. </summary>
    </member>
    <member name="P:Mogre.MovableObject.IsAttached">
      <summary>Returns true if this object is attached to a SceneNode or TagPoint. </summary>
    </member>
    <member name="P:Mogre.MovableObject.HasEdgeList">
      <summary>Define a default implementation of method from ShadowCaster which implements no shadows. </summary>
    </member>
    <member name="P:Mogre.MovableObject.EdgeList">
      <summary>Define a default implementation of method from ShadowCaster which implements no shadows. </summary>
    </member>
    <member name="P:Mogre.MovableObject.DefaultVisibilityFlags">
      <summary>Sets/Get the default visibility flags for all future MovableObject instances. </summary>
    </member>
    <member name="P:Mogre.MovableObject.DefaultQueryFlags">
      <summary>Sets/Get the default query flags for all future MovableObject instances. </summary>
    </member>
    <member name="P:Mogre.MovableObject.CastShadows">
      <summary>Sets/Returns whether shadow casting is enabled for this object. </summary>
    </member>
    <member name="P:Mogre.MovableObject.BoundingRadius">
      <summary>Retrieves the radius of the origin-centered bounding sphere for this object. </summary>
    </member>
    <member name="P:Mogre.MovableObject.BoundingBox">
      <summary>Retrieves the local axis-aligned bounding box for this object. This bounding box is in local coordinates. </summary>
    </member>
    <member name="T:Mogre.MovableObjectFactory">
      <summary>Interface definition for a factory class which produces a certain kind of MovableObject, and can be registered with Root in order to allow all clients to produce new instances of this object, integrated with the standard Ogre processing. </summary>
    </member>
    <member name="M:Mogre.MovableObjectFactory.CreateInstance(System.String,Mogre.SceneManager)">
      <summary>Create a new instance of the object. </summary>
      <param name="name">The name of the new object </param>
      <param name="manager">The SceneManager instance that will be holding the instance once created. </param>
    </member>
    <member name="M:Mogre.MovableObjectFactory.CreateInstance(System.String,Mogre.SceneManager,Mogre.Const_NameValuePairList)">
      <summary>Create a new instance of the object. </summary>
      <param name="name">The name of the new object </param>
      <param name="manager">The SceneManager instance that will be holding the instance once created. </param>
      <param name="params">Name/value pair list of additional parameters required to construct the object (defined per subtype). Optional. </param>
    </member>
    <member name="M:Mogre.MovableObjectFactory.DestroyInstance(Mogre.MovableObject)">
      <summary>Destroy an instance of the object </summary>
    </member>
    <member name="M:Mogre.MovableObjectFactory.RequestTypeFlags">
      <summary>Does this factory require the allocation of a 'type flag', used to selectively include / exclude this type from scene queries? The default implementation here is to return 'false', ie not to request a unique type mask from Root. For objects that never need to be excluded in SceneQuery results, that's fine, since the default implementation of MovableObject::getTypeFlags is to return all ones, hence matching any query type mask. However, if you want the objects created by this factory to be filterable by queries using a broad type, you have to give them a (preferably unique) type mask - and given that you don't know what other MovableObject types are registered, Root will allocate you one. </summary>
    </member>
    <member name="M:Mogre.MovableObjectFactory._notifyTypeFlags(System.UInt32)">
      <summary>Notify this factory of the type mask to apply. This should normally only be called by Root in response to a 'true' result from requestTypeMask. However, you can actually use it yourself if you're careful; for example to assign the same mask to a number of different types of object, should you always wish them to be treated the same in queries. </summary>
    </member>
    <member name="P:Mogre.MovableObjectFactory.TypeFlags">
      <summary>Gets the type flag for this factory. A type flag is like a query flag, except that it applies to all instances of a certain type of object. </summary>
    </member>
    <member name="P:Mogre.MovableObjectFactory.Type">
      <summary>Get the type of the object to be created. </summary>
    </member>
    <member name="T:Mogre.Entity">
      <summary>Defines an instance of a discrete, movable object based on a Mesh. Ogre generally divides renderable objects into 2 groups, discrete (separate) and relatively small objects which move around the world, and large, sprawling geometry which makes up generally immovable scenery, aka 'level geometry'. The Mesh and SubMesh classes deal with the definition of the geometry used by discrete movable objects. Entities are actual instances of objects based on this geometry in the world. Therefore there is usually a single set Mesh for a car, but there may be multiple entities based on it in the world. Entities are able to override aspects of the Mesh it is defined by, such as changing material properties per instance (so you can have many cars using the same geometry but different textures for example). Because a Mesh is split into SubMeshes for this purpose, the Entity class is a grouping class (much like the Mesh class) and much of the detail regarding individual changes is kept in the SubEntity class. There is a 1:1 relationship between SubEntity instances and the SubMesh instances associated with the Mesh the Entity is based on. Entity and SubEntity classes are never created directly. Use the createEntity method of the SceneManager (passing a model name) to create one. Entities are included in the scene by associating them with a SceneNode, using the attachEntity method. See the SceneNode class for full information. No functions were declared virtual to improve performance. </summary>
    </member>
    <member name="M:Mogre.Entity.GetMesh">
      <summary>Gets the Mesh that this Entity is based on. </summary>
    </member>
    <member name="M:Mogre.Entity.GetSubEntity(System.String)">
      <summary>Gets a pointer to a SubEntity, ie a part of an Entity. </summary>
    </member>
    <member name="M:Mogre.Entity.GetSubEntity(System.UInt32)">
      <summary>Gets a pointer to a SubEntity, ie a part of an Entity. </summary>
    </member>
    <member name="M:Mogre.Entity.Clone(System.String)">
      <summary>Clones this entity and returns a pointer to the clone. Useful method for duplicating an entity. The new entity must be given a unique name, and is not attached to the scene in any way so must be attached to a SceneNode to be visible (exactly as entities returned from SceneManager::createEntity). </summary>
      <param name="newName">Name for the new entity. </param>
    </member>
    <member name="M:Mogre.Entity.SetMaterialName(System.String)">
      <summary>Sets the material to use for the whole of this entity. This is a shortcut method to set all the materials for all subentities of this entity. Only use this method is you want to set the same material for all subentities or if you know there is only one. Otherwise call getSubEntity() and call the same method on the individual SubEntity. </summary>
    </member>
    <member name="M:Mogre.Entity.SetMaterialName(System.String,System.String)">
      <summary>Sets the material to use for the whole of this entity. This is a shortcut method to set all the materials for all subentities of this entity. Only use this method is you want to set the same material for all subentities or if you know there is only one. Otherwise call getSubEntity() and call the same method on the individual SubEntity. </summary>
    </member>
    <member name="M:Mogre.Entity.SetMaterial(Mogre.MaterialPtr)">
      <summary>Sets the material to use for the whole of this entity. This is a shortcut method to set all the materials for all subentities of this entity. Only use this method is you want to set the same material for all subentities or if you know there is only one. Otherwise call getSubEntity() and call the same method on the individual SubEntity. </summary>
    </member>
    <member name="M:Mogre.Entity._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden - see MovableObject. </summary>
    </member>
    <member name="M:Mogre.Entity.SetRenderQueueGroupAndPriority(System.Byte,System.UInt16)">
      <summary>Overridden - see MovableObject. </summary>
    </member>
    <member name="M:Mogre.Entity._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden - see MovableObject. </summary>
    </member>
    <member name="M:Mogre.Entity.GetAnimationState(System.String)">
      <summary>For entities based on animated meshes, gets the AnimationState object for a single animation. You animate an entity by updating the animation state objects. Each of these represents the current state of each animation available to the entity. The AnimationState objects are initialised from the Mesh object. </summary>
    </member>
    <member name="M:Mogre.Entity.GetManualLodLevel(System.UInt32)">
      <summary>Gets a pointer to the entity representing the numbered manual level of detail. The zero-based index never includes the original entity, unlike Mesh::getLodLevel. </summary>
    </member>
    <member name="M:Mogre.Entity.SetMeshLodBias(System.Single)">
      <summary>Sets a level-of-detail bias for the mesh detail of this entity. Level of detail reduction is normally applied automatically based on the Mesh settings. However, it is possible to influence this behaviour for this entity by adjusting the LOD bias. This 'nudges' the mesh level of detail used for this entity up or down depending on your requirements. You might want to use this if there was a particularly important entity in your scene which you wanted to detail better than the others, such as a player model. There are three parameters to this method; the first is a factor to apply; it defaults to 1.0 (no change), by increasing this to say 2.0, this model would take twice as long to reduce in detail, whilst at 0.5 this entity would use lower detail versions twice as quickly. The other 2 parameters are hard limits which let you set the maximum and minimum level-of-detail version to use, after all other calculations have been made. This lets you say that this entity should never be simplified, or that it can only use LODs below a certain level even when right next to the camera. </summary>
      <param name="factor">Proportional factor to apply to the distance at which LOD is changed. Higher values increase the distance at which higher LODs are displayed (2.0 is twice the normal distance, 0.5 is half). </param>
    </member>
    <member name="M:Mogre.Entity.SetMeshLodBias(System.Single,System.UInt16)">
      <summary>Sets a level-of-detail bias for the mesh detail of this entity. Level of detail reduction is normally applied automatically based on the Mesh settings. However, it is possible to influence this behaviour for this entity by adjusting the LOD bias. This 'nudges' the mesh level of detail used for this entity up or down depending on your requirements. You might want to use this if there was a particularly important entity in your scene which you wanted to detail better than the others, such as a player model. There are three parameters to this method; the first is a factor to apply; it defaults to 1.0 (no change), by increasing this to say 2.0, this model would take twice as long to reduce in detail, whilst at 0.5 this entity would use lower detail versions twice as quickly. The other 2 parameters are hard limits which let you set the maximum and minimum level-of-detail version to use, after all other calculations have been made. This lets you say that this entity should never be simplified, or that it can only use LODs below a certain level even when right next to the camera. </summary>
      <param name="factor">Proportional factor to apply to the distance at which LOD is changed. Higher values increase the distance at which higher LODs are displayed (2.0 is twice the normal distance, 0.5 is half). </param>
      <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower indexes are higher detail: index 0 is the original full detail model). </param>
    </member>
    <member name="M:Mogre.Entity.SetMeshLodBias(System.Single,System.UInt16,System.UInt16)">
      <summary>Sets a level-of-detail bias for the mesh detail of this entity. Level of detail reduction is normally applied automatically based on the Mesh settings. However, it is possible to influence this behaviour for this entity by adjusting the LOD bias. This 'nudges' the mesh level of detail used for this entity up or down depending on your requirements. You might want to use this if there was a particularly important entity in your scene which you wanted to detail better than the others, such as a player model. There are three parameters to this method; the first is a factor to apply; it defaults to 1.0 (no change), by increasing this to say 2.0, this model would take twice as long to reduce in detail, whilst at 0.5 this entity would use lower detail versions twice as quickly. The other 2 parameters are hard limits which let you set the maximum and minimum level-of-detail version to use, after all other calculations have been made. This lets you say that this entity should never be simplified, or that it can only use LODs below a certain level even when right next to the camera. </summary>
      <param name="factor">Proportional factor to apply to the distance at which LOD is changed. Higher values increase the distance at which higher LODs are displayed (2.0 is twice the normal distance, 0.5 is half). </param>
      <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower indexes are higher detail: index 0 is the original full detail model). </param>
      <param name="minDetailIndex">The index of the minimum LOD this entity is allowed to use (higher indexes are lower detail). Use something like 99 if you want unlimited LODs (the actual LOD will be limited by the number in the Mesh) </param>
    </member>
    <member name="M:Mogre.Entity.SetMaterialLodBias(System.Single)">
      <summary>Sets a level-of-detail bias for the material detail of this entity. Level of detail reduction is normally applied automatically based on the Material settings. However, it is possible to influence this behaviour for this entity by adjusting the LOD bias. This 'nudges' the material level of detail used for this entity up or down depending on your requirements. You might want to use this if there was a particularly important entity in your scene which you wanted to detail better than the others, such as a player model. There are three parameters to this method; the first is a factor to apply; it defaults to 1.0 (no change), by increasing this to say 2.0, this entity would take twice as long to use a lower detail material, whilst at 0.5 this entity would use lower detail versions twice as quickly. The other 2 parameters are hard limits which let you set the maximum and minimum level-of-detail index to use, after all other calculations have been made. This lets you say that this entity should never be simplified, or that it can only use LODs below a certain level even when right next to the camera. </summary>
      <param name="factor">Proportional factor to apply to the distance at which LOD is changed. Higher values increase the distance at which higher LODs are displayed (2.0 is twice the normal distance, 0.5 is half). </param>
    </member>
    <member name="M:Mogre.Entity.SetMaterialLodBias(System.Single,System.UInt16)">
      <summary>Sets a level-of-detail bias for the material detail of this entity. Level of detail reduction is normally applied automatically based on the Material settings. However, it is possible to influence this behaviour for this entity by adjusting the LOD bias. This 'nudges' the material level of detail used for this entity up or down depending on your requirements. You might want to use this if there was a particularly important entity in your scene which you wanted to detail better than the others, such as a player model. There are three parameters to this method; the first is a factor to apply; it defaults to 1.0 (no change), by increasing this to say 2.0, this entity would take twice as long to use a lower detail material, whilst at 0.5 this entity would use lower detail versions twice as quickly. The other 2 parameters are hard limits which let you set the maximum and minimum level-of-detail index to use, after all other calculations have been made. This lets you say that this entity should never be simplified, or that it can only use LODs below a certain level even when right next to the camera. </summary>
      <param name="factor">Proportional factor to apply to the distance at which LOD is changed. Higher values increase the distance at which higher LODs are displayed (2.0 is twice the normal distance, 0.5 is half). </param>
      <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower indexes are higher detail: index 0 is the original full detail model). </param>
    </member>
    <member name="M:Mogre.Entity.SetMaterialLodBias(System.Single,System.UInt16,System.UInt16)">
      <summary>Sets a level-of-detail bias for the material detail of this entity. Level of detail reduction is normally applied automatically based on the Material settings. However, it is possible to influence this behaviour for this entity by adjusting the LOD bias. This 'nudges' the material level of detail used for this entity up or down depending on your requirements. You might want to use this if there was a particularly important entity in your scene which you wanted to detail better than the others, such as a player model. There are three parameters to this method; the first is a factor to apply; it defaults to 1.0 (no change), by increasing this to say 2.0, this entity would take twice as long to use a lower detail material, whilst at 0.5 this entity would use lower detail versions twice as quickly. The other 2 parameters are hard limits which let you set the maximum and minimum level-of-detail index to use, after all other calculations have been made. This lets you say that this entity should never be simplified, or that it can only use LODs below a certain level even when right next to the camera. </summary>
      <param name="factor">Proportional factor to apply to the distance at which LOD is changed. Higher values increase the distance at which higher LODs are displayed (2.0 is twice the normal distance, 0.5 is half). </param>
      <param name="maxDetailIndex">The index of the maximum LOD this entity is allowed to use (lower indexes are higher detail: index 0 is the original full detail model). </param>
      <param name="minDetailIndex">The index of the minimum LOD this entity is allowed to use (higher indexes are lower detail. Use something like 99 if you want unlimited LODs (the actual LOD will be limited by the number of lod indexes used in the Material) </param>
    </member>
    <member name="M:Mogre.Entity.SetPolygonModeOverrideable(System.Boolean)">
      <summary>Sets whether the polygon mode of this entire entity may be overridden by the camera detail settings. </summary>
    </member>
    <member name="M:Mogre.Entity.AttachObjectToBone(System.String,Mogre.MovableObject)">
      <summary>Attaches another object to a certain bone of the skeleton which this entity uses. This method can be used to attach another object to an animated part of this entity, by attaching it to a bone in the skeleton (with an offset if required). As this entity is animated, the attached object will move relative to the bone to which it is attached. An exception is thrown if the movable object is already attached to the bone, another bone or scenenode. If the entity has no skeleton or the bone name cannot be found then an exception is thrown. The TagPoint to which the object has been attached </summary>
      <param name="boneName">The name of the bone (in the skeleton) to attach this object </param>
      <param name="pMovable">Pointer to the object to attach </param>
    </member>
    <member name="M:Mogre.Entity.AttachObjectToBone(System.String,Mogre.MovableObject,Mogre.Quaternion)">
      <summary>Attaches another object to a certain bone of the skeleton which this entity uses. This method can be used to attach another object to an animated part of this entity, by attaching it to a bone in the skeleton (with an offset if required). As this entity is animated, the attached object will move relative to the bone to which it is attached. An exception is thrown if the movable object is already attached to the bone, another bone or scenenode. If the entity has no skeleton or the bone name cannot be found then an exception is thrown. The TagPoint to which the object has been attached </summary>
      <param name="boneName">The name of the bone (in the skeleton) to attach this object </param>
      <param name="pMovable">Pointer to the object to attach </param>
      <param name="offsetOrientation">An adjustment to the orientation of the attached object, relative to the bone. </param>
    </member>
    <member name="M:Mogre.Entity.AttachObjectToBone(System.String,Mogre.MovableObject,Mogre.Quaternion,Mogre.Vector3)">
      <summary>Attaches another object to a certain bone of the skeleton which this entity uses. This method can be used to attach another object to an animated part of this entity, by attaching it to a bone in the skeleton (with an offset if required). As this entity is animated, the attached object will move relative to the bone to which it is attached. An exception is thrown if the movable object is already attached to the bone, another bone or scenenode. If the entity has no skeleton or the bone name cannot be found then an exception is thrown. The TagPoint to which the object has been attached </summary>
      <param name="boneName">The name of the bone (in the skeleton) to attach this object </param>
      <param name="pMovable">Pointer to the object to attach </param>
      <param name="offsetOrientation">An adjustment to the orientation of the attached object, relative to the bone. </param>
      <param name="offsetPosition">An adjustment to the position of the attached object, relative to the bone. </param>
    </member>
    <member name="M:Mogre.Entity.DetachObjectFromBone(Mogre.MovableObject)">
      <summary>Detaches an object by pointer. Use this method to destroy a MovableObject which is attached to a bone of belonging this entity. But sometimes the object may be not in the child object list because it is a lod entity, this method can safely detect and ignore in this case and won't raise an exception. </summary>
    </member>
    <member name="M:Mogre.Entity.DetachObjectFromBone(System.String)">
      <summary>Detach a MovableObject previously attached using attachObjectToBone. If the movable object name is not found then an exception is raised. </summary>
      <param name="movableName">is the name of the movable object to be detached. </param>
    </member>
    <member name="M:Mogre.Entity.DetachAllObjectsFromBone">
      <summary>Detach all MovableObjects previously attached using attachObjectToBone. </summary>
    </member>
    <member name="M:Mogre.Entity.GetAttachedObjectIterator">
      <summary>Gets an iterator to the list of objects attached to bones on this entity. </summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingBox">
      <summary>MovableObject::getWorldBoundingBox</summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingBox(System.Boolean)">
      <summary>MovableObject::getWorldBoundingBox</summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingSphere">
      <summary>MovableObject::getWorldBoundingSphere</summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingSphere(System.Boolean)">
      <summary>MovableObject::getWorldBoundingSphere</summary>
    </member>
    <member name="M:Mogre.Entity.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="M:Mogre.Entity.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="M:Mogre.Entity._getBoneMatrices">
      <summary>Internal method for retrieving bone matrix information. </summary>
    </member>
    <member name="M:Mogre.Entity._getNumBoneMatrices">
      <summary>Internal method for retrieving bone matrix information. </summary>
    </member>
    <member name="M:Mogre.Entity._notifyAttached(Mogre.Node)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Entity._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Entity.AddSoftwareAnimationRequest(System.Boolean)">
      <summary>Add a request for software animation Tells the entity to perform animation calculations for skeletal/vertex animations in software, regardless of the current setting of isHardwareAnimationEnabled(). Software animation will be performed any time one or more requests have been made. If 'normalsAlso' is 'true', then the entity will also do software blending on normal vectors, in addition to positions. This advanced method useful for situations in which access to actual mesh vertices is required, such as accurate collision detection or certain advanced shading techniques. When software animation is no longer needed, the caller of this method should always remove the request by calling removeSoftwareAnimationRequest(), passing the same value for 'normalsAlso'. </summary>
    </member>
    <member name="M:Mogre.Entity.RemoveSoftwareAnimationRequest(System.Boolean)">
      <summary>Removes a request for software animation Calling this decrements the entity's internal counter of the number of requests for software animation. If the counter is already zero then calling this method throws an exception. The 'normalsAlso' flag if set to 'true' will also decrement the internal counter of number of requests for software animation of normals. </summary>
    </member>
    <member name="M:Mogre.Entity.ShareSkeletonInstanceWith(Mogre.Entity)">
      <summary>Shares the SkeletonInstance with the supplied entity. Note that in order for this to work, both entities must have the same Skeleton. </summary>
    </member>
    <member name="M:Mogre.Entity.StopSharingSkeletonInstance">
      <summary>Stops sharing the SkeletonInstance with other entities. </summary>
    </member>
    <member name="M:Mogre.Entity.SharesSkeletonInstance">
      <summary>Returns whether this entity shares it's SkeltonInstance with other entity instances. </summary>
    </member>
    <member name="M:Mogre.Entity.GetSkeletonInstanceSharingSet">
      <summary>Returns a pointer to the set of entities which share a SkeletonInstance. If this instance does not share it's SkeletonInstance with other instances NULL will be returned </summary>
    </member>
    <member name="M:Mogre.Entity.RefreshAvailableAnimationState">
      <summary>Updates the internal animation state set to include the latest available animations from the attached skeleton. Use this method if you manually add animations to a skeleton, or have linked the skeleton to another for animation purposes since creating this entity. If you have called getAnimationState prior to calling this method, the pointers will still remain valid. </summary>
    </member>
    <member name="M:Mogre.Entity._updateAnimation">
      <summary>Advanced method to perform all the updates required for an animated entity. You don't normally need to call this, but it's here in case you wish to manually update the animation of an Entity at a specific point in time. Animation will not be updated more than once a frame no matter how many times you call this method. </summary>
    </member>
    <member name="M:Mogre.Entity._isAnimated">
      <summary>Tests if any animation applied to this entity. An entity is animated if any animation state is enabled, or any manual bone applied to the skeleton. </summary>
    </member>
    <member name="M:Mogre.Entity._isSkeletonAnimated">
      <summary>Tests if skeleton was animated. </summary>
    </member>
    <member name="M:Mogre.Entity._getSkelAnimVertexData">
      <summary>Advanced method to get the temporarily blended skeletal vertex information for entities which are software skinned. Internal engine will eliminate software animation if possible, this information is unreliable unless added request for software animation via addSoftwareAnimationRequest. The positions/normals of the returned vertex data is in object space. </summary>
    </member>
    <member name="M:Mogre.Entity._getSoftwareVertexAnimVertexData">
      <summary>Advanced method to get the temporarily blended software vertex animation information Internal engine will eliminate software animation if possible, this information is unreliable unless added request for software animation via addSoftwareAnimationRequest. The positions/normals of the returned vertex data is in object space. </summary>
    </member>
    <member name="M:Mogre.Entity._getHardwareVertexAnimVertexData">
      <summary>Advanced method to get the hardware morph vertex information The positions/normals of the returned vertex data is in object space. </summary>
    </member>
    <member name="M:Mogre.Entity.ChooseVertexDataForBinding(System.Boolean)">
      <summary>Choose which vertex data to bind to the renderer. </summary>
    </member>
    <member name="M:Mogre.Entity._getBuffersMarkedForAnimation">
      <summary>Are buffers already marked as vertex animated? </summary>
    </member>
    <member name="M:Mogre.Entity._markBuffersUsedForAnimation">
      <summary>Mark just this vertex data as animated. </summary>
    </member>
    <member name="M:Mogre.Entity._initialise">
      <summary>Try to initialise the Entity from the underlying resources. This method builds the internal structures of the Entity based on it resources (Mesh, Skeleton). This may or may not succeed if the resources it references have been earmarked for background loading, so you should check isInitialised afterwards to see if it was sucessful. </summary>
    </member>
    <member name="M:Mogre.Entity._initialise(System.Boolean)">
      <summary>Try to initialise the Entity from the underlying resources. This method builds the internal structures of the Entity based on it resources (Mesh, Skeleton). This may or may not succeed if the resources it references have been earmarked for background loading, so you should check isInitialised afterwards to see if it was sucessful. </summary>
      <param name="forceReinitialise">If true, this forces the Entity to tear down it's internal structures and try to rebuild them. Useful if you changed the content of a Mesh or Skeleton at runtime. </param>
    </member>
    <member name="M:Mogre.Entity._deinitialise">
      <summary>Tear down the internal structures of this Entity, rendering it uninitialised. </summary>
    </member>
    <member name="M:Mogre.Entity.BackgroundLoadingComplete(Mogre.Resource)">
      <summary>Resource::Listener hook to notify Entity that a delay-loaded Mesh is complete. </summary>
    </member>
    <member name="M:Mogre.Entity._getMeshLodFactorTransformed">
      <summary>Get the lod strategy transformation of the mesh lod factor. </summary>
    </member>
    <member name="M:Mogre.Entity._notifyAttached(Mogre.Node)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Entity._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Entity._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden - see MovableObject. </summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingBox">
      <summary>MovableObject::getWorldBoundingBox</summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingBox(System.Boolean)">
      <summary>MovableObject::getWorldBoundingBox</summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingSphere">
      <summary>MovableObject::getWorldBoundingSphere</summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingSphere(System.Boolean)">
      <summary>MovableObject::getWorldBoundingSphere</summary>
    </member>
    <member name="M:Mogre.Entity._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden - see MovableObject. </summary>
    </member>
    <member name="M:Mogre.Entity.SetRenderQueueGroupAndPriority(System.Byte,System.UInt16)">
      <summary>Overridden - see MovableObject. </summary>
    </member>
    <member name="M:Mogre.Entity.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="M:Mogre.Entity.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingBox">
      <summary>MovableObject::getWorldBoundingBox</summary>
    </member>
    <member name="M:Mogre.Entity.GetWorldBoundingBox(System.Boolean)">
      <summary>MovableObject::getWorldBoundingBox</summary>
    </member>
    <member name="M:Mogre.Entity.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="M:Mogre.Entity.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="P:Mogre.Entity.VertexDataForBinding">
      <summary>Retrieve the VertexData which should be used for GPU binding. </summary>
    </member>
    <member name="P:Mogre.Entity.TypeFlags">
      <summary>Override to return specific type flag. </summary>
    </member>
    <member name="P:Mogre.Entity.SoftwareAnimationRequests">
      <summary>Returns the number of requests that have been made for software animation If non-zero then software animation will be performed in updateAnimation regardless of the current setting of isHardwareAnimationEnabled or any internal optimise for eliminate software animation. Requests for software animation are made by calling the addSoftwareAnimationRequest() method. </summary>
    </member>
    <member name="P:Mogre.Entity.SoftwareAnimationNormalsRequests">
      <summary>Returns the number of requests that have been made for software animation of normals If non-zero, and getSoftwareAnimationRequests() also returns non-zero, then software animation of normals will be performed in updateAnimation regardless of the current setting of isHardwareAnimationEnabled or any internal optimise for eliminate software animation. Currently it is not possible to force software animation of only normals. Consequently this value is always less than or equal to that returned by getSoftwareAnimationRequests(). Requests for software animation of normals are made by calling the addSoftwareAnimationRequest() method with 'true' as the parameter. </summary>
    </member>
    <member name="P:Mogre.Entity.SkipAnimationStateUpdate">
      <summary>Sets/Entity's skeleton's AnimationState will not be automatically updated when set to true. Useful if you wish to handle AnimationState updates manually. </summary>
    </member>
    <member name="P:Mogre.Entity.Skeleton">
      <summary>Get this Entity's personal skeleton instance. </summary>
    </member>
    <member name="P:Mogre.Entity.NumSubEntities">
      <summary>Retrieves the number of SubEntity objects making up this entity. </summary>
    </member>
    <member name="P:Mogre.Entity.NumManualLodLevels">
      <summary>Returns the number of manual levels of detail that this entity supports. This number never includes the original entity, it is difference with Mesh::getNumLodLevels. </summary>
    </member>
    <member name="P:Mogre.Entity.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Entity.IsInitialised">
      <summary>Has this Entity been initialised yet? If this returns false, it means this Entity hasn't been completely constructed yet from the underlying resources (Mesh, Skeleton), which probably means they were delay-loaded and aren't available yet. This Entity won't render until it has been successfully initialised, nor will many of the manipulation methods function. </summary>
    </member>
    <member name="P:Mogre.Entity.IsHardwareAnimationEnabled">
      <summary>Returns whether or not hardware animation is enabled. Because fixed-function indexed vertex blending is rarely supported by existing graphics cards, hardware animation can only be done if the vertex programs in the materials used to render an entity support it. Therefore, this method will only return true if all the materials assigned to this entity have vertex programs assigned, and all those vertex programs must support 'includes_morph_animation true' if using morph animation, 'includes_pose_animation true' if using pose animation and 'includes_skeletal_animation true' if using skeletal animation. </summary>
    </member>
    <member name="P:Mogre.Entity.HasVertexAnimation">
      <summary>Returns whether or not this entity is either morph or pose animated. </summary>
    </member>
    <member name="P:Mogre.Entity.HasSkeleton">
      <summary>Returns whether or not this entity is skeletally animated. </summary>
    </member>
    <member name="P:Mogre.Entity.HasEdgeList">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="P:Mogre.Entity.EdgeList">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="P:Mogre.Entity.DisplaySkeleton">
      <summary>Sets/Returns whether or not the entity is currently displaying its skeleton. </summary>
    </member>
    <member name="P:Mogre.Entity.CurrentLodIndex">
      <summary>Returns the current LOD used to render </summary>
    </member>
    <member name="P:Mogre.Entity.ChildObjectsBoundingBox">
      <summary>merge all the child object Bounds a return it </summary>
    </member>
    <member name="P:Mogre.Entity.BoundingRadius">
      <summary>MovableObject::getBoundingRadius</summary>
    </member>
    <member name="P:Mogre.Entity.BoundingBox">
      <summary>Overridden - see MovableObject. </summary>
    </member>
    <member name="P:Mogre.Entity.AllAnimationStates">
      <summary>For entities based on animated meshes, gets the AnimationState objects for all animations. In case the entity is animated, this functions returns the pointer to a AnimationStateSet containing all animations of the entries. If the entity is not animated, it returns 0. You animate an entity by updating the animation state objects. Each of these represents the current state of each animation available to the entity. The AnimationState objects are initialised from the Mesh object. </summary>
    </member>
    <member name="T:Mogre.Entity+VertexDataBindChoice">
      <summary>Identify which vertex data we should be sending to the renderer. </summary>
    </member>
    <member name="T:Mogre.EntityFactory">
      <summary>Factory object for creating Entity instances </summary>
    </member>
    <member name="T:Mogre.VertexAnimationType">
      <summary>Type of vertex animation. Vertex animation comes in 2 types, morph and pose. The reason for the 2 types is that we have 2 different potential goals - to encapsulate a complete, flowing morph animation with multiple keyframes (a typical animation, but implemented by having snapshots of the vertex data at each keyframe), or to represent a single pose change, for example a facial expression. Whilst both could in fact be implemented using the same system, we choose to separate them since the requirements and limitations of each are quite different. Morph animation is a simple approach where we have a whole series of snapshots of vertex data which must be interpolated, e.g. a running animation implemented as morph targets. Because this is based on simple snapshots, it's quite fast to use when animating an entire mesh because it's a simple linear change between keyframes. However, this simplistic approach does not support blending between multiple morph animations. If you need animation blending, you are advised to use skeletal animation for full-mesh animation, and pose animation for animation of subsets of meshes or where skeletal animation doesn't fit - for example facial animation. For animating in a vertex shader, morph animation is quite simple and just requires the 2 vertex buffers (one the original position buffer) of absolute position data, and an interpolation factor. Each track in a morph animation refrences a unique set of vertex data. Pose animation is more complex. Like morph animation each track references a single unique set of vertex data, but unlike morph animation, each keyframe references 1 or more 'poses', each with an influence level. A pose is a series of offsets to the base vertex data, and may be sparse - ie it may not reference every vertex. Because they're offsets, they can be blended - both within a track and between animations. This set of features is very well suited to facial animation. For example, let's say you modelled a face (one set of vertex data), and defined a set of poses which represented the various phonetic positions of the face. You could then define an animation called 'SayHello', containing a single track which referenced the face vertex data, and which included a series of keyframes, each of which referenced one or more of the facial positions at different influence levels - the combination of which over time made the face form the shapes required to say the word 'hello'. Since the poses are only stored once, but can be referenced may times in many animations, this is a very powerful way to build up a speech system. The downside of pose animation is that it can be more difficult to set up. Also, since it uses more buffers (one for the base data, and one for each active pose), if you're animating in hardware using vertex shaders you need to keep an eye on how many poses you're blending at once. You define a maximum supported number in your vertex program definition, see the includes_pose_animation material script entry. So, by partitioning the vertex animation approaches into 2, we keep the simple morph technique easy to use, whilst still allowing all the powerful techniques to be used. Note that morph animation cannot be blended with other types of vertex animation (pose animation or other morph animation); pose animation can be blended with other pose animation though, and both types can be combined with skeletal animation. Also note that all morph animation can be expressed as pose animation, but not vice versa. </summary>
    </member>
    <member name="F:Mogre.VertexAnimationType.VAT_NONE">
      <summary>No animation. </summary>
    </member>
    <member name="F:Mogre.VertexAnimationType.VAT_MORPH">
      <summary>Morph animation is made up of many interpolated snapshot keyframes. </summary>
    </member>
    <member name="F:Mogre.VertexAnimationType.VAT_POSE">
      <summary>Pose animation is made up of a single delta pose keyframe. </summary>
    </member>
    <member name="T:Mogre.VertexElementType">
      <summary>Vertex element type, used to identify the base types of the vertex contents. </summary>
    </member>
    <member name="F:Mogre.VertexElementType.VET_COLOUR">
      <summary>alias to more specific colour type - use the current rendersystem's colour packing </summary>
    </member>
    <member name="F:Mogre.VertexElementType.VET_COLOUR_ARGB">
      <summary>D3D style compact colour. </summary>
    </member>
    <member name="F:Mogre.VertexElementType.VET_COLOUR_ABGR">
      <summary>GL style compact colour. </summary>
    </member>
    <member name="T:Mogre.VertexElementSemantic">
      <summary>Vertex element semantics, used to identify the meaning of vertex buffer contents. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_POSITION">
      <summary>Position, 3 reals per vertex. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_BLEND_WEIGHTS">
      <summary>Blending weights. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_BLEND_INDICES">
      <summary>Blending indices. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_NORMAL">
      <summary>Normal, 3 reals per vertex. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_DIFFUSE">
      <summary>Diffuse colours. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_SPECULAR">
      <summary>Specular colours. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_TEXTURE_COORDINATES">
      <summary>Texture coordinates. </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_BINORMAL">
      <summary>Binormal (Y axis if normal is Z). </summary>
    </member>
    <member name="F:Mogre.VertexElementSemantic.VES_TANGENT">
      <summary>Tangent (X axis if normal is Z). </summary>
    </member>
    <member name="T:Mogre.ClipResult">
      <summary>Generic result of clipping. </summary>
    </member>
    <member name="F:Mogre.ClipResult.CLIPPED_NONE">
      <summary>Nothing was clipped. </summary>
    </member>
    <member name="F:Mogre.ClipResult.CLIPPED_SOME">
      <summary>Partially clipped. </summary>
    </member>
    <member name="F:Mogre.ClipResult.CLIPPED_ALL">
      <summary>Everything was clipped away. </summary>
    </member>
    <member name="T:Mogre.FrameBufferType">
      <summary>Defines the frame buffer types. </summary>
    </member>
    <member name="T:Mogre.SortMode">
      <summary>Sort mode for billboard-set and particle-system </summary>
    </member>
    <member name="F:Mogre.SortMode.SM_DIRECTION">
      <summary>Sort by direction of the camera </summary>
    </member>
    <member name="F:Mogre.SortMode.SM_DISTANCE">
      <summary>Sort by distance from the camera </summary>
    </member>
    <member name="T:Mogre.ShadowTechnique">
      <summary>An enumeration of broad shadow techniques </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWTYPE_NONE">
      <summary>No shadows </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWDETAILTYPE_ADDITIVE">
      <summary>Mask for additive shadows (not for direct use, use SHADOWTYPE_ enum instead) </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWDETAILTYPE_MODULATIVE">
      <summary>Mask for modulative shadows (not for direct use, use SHADOWTYPE_ enum instead) </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWDETAILTYPE_INTEGRATED">
      <summary>Mask for integrated shadows (not for direct use, use SHADOWTYPE_ enum instead) </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWDETAILTYPE_STENCIL">
      <summary>Mask for stencil shadows (not for direct use, use SHADOWTYPE_ enum instead) </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWDETAILTYPE_TEXTURE">
      <summary>Mask for texture shadows (not for direct use, use SHADOWTYPE_ enum instead) </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWTYPE_STENCIL_MODULATIVE">
      <summary>Stencil shadow technique which renders all shadow volumes as a modulation after all the non-transparent areas have been rendered. This technique is considerably less fillrate intensive than the additive stencil shadow approach when there are multiple lights, but is not an accurate model. </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWTYPE_STENCIL_ADDITIVE">
      <summary>Stencil shadow technique which renders each light as a separate additive pass to the scene. This technique can be very fillrate intensive because it requires at least 2 passes of the entire scene, more if there are multiple lights. However, it is a more accurate model than the modulative stencil approach and this is especially apparent when using coloured lights or bump mapping. </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWTYPE_TEXTURE_MODULATIVE">
      <summary>Texture-based shadow technique which involves a monochrome render-to-texture of the shadow caster and a projection of that texture onto the shadow receivers as a modulative pass. </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWTYPE_TEXTURE_ADDITIVE">
      <summary>Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projection of that texture onto the shadow receivers, built up per light as additive passes. This technique can be very fillrate intensive because it requires numLights + 2 passes of the entire scene. However, it is a more accurate model than the modulative approach and this is especially apparent when using coloured lights or bump mapping. </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED">
      <summary>Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projection of that texture on to the shadow receivers, with the usage of those shadow textures completely controlled by the materials of the receivers. This technique is easily the most flexible of all techniques because the material author is in complete control over how the shadows are combined with regular rendering. It can perform shadows as accurately as SHADOWTYPE_TEXTURE_ADDITIVE but more efficiently because it requires less passes. However it also requires more expertise to use, and in almost all cases, shader capable hardware to really use to the full. The 'additive' part of this mode means that the colour of the rendered shadow texture is by default plain black. It does not mean it does the adding on your receivers automatically though, how you use that result is up to you. </summary>
    </member>
    <member name="F:Mogre.ShadowTechnique.SHADOWTYPE_TEXTURE_MODULATIVE_INTEGRATED">
      <summary>Texture-based shadow technique which involves a render-to-texture of the shadow caster and a projection of that texture on to the shadow receivers, with the usage of those shadow textures completely controlled by the materials of the receivers. This technique is easily the most flexible of all techniques because the material author is in complete control over how the shadows are combined with regular rendering. It can perform shadows as accurately as SHADOWTYPE_TEXTURE_ADDITIVE but more efficiently because it requires less passes. However it also requires more expertise to use, and in almost all cases, shader capable hardware to really use to the full. The 'modulative' part of this mode means that the colour of the rendered shadow texture is by default the 'shadow colour'. It does not mean it modulates on your receivers automatically though, how you use that result is up to you. </summary>
    </member>
    <member name="T:Mogre.PolygonMode">
      <summary>The polygon mode to use when rasterising. </summary>
    </member>
    <member name="F:Mogre.PolygonMode.PM_POINTS">
      <summary>Only points are rendered. </summary>
    </member>
    <member name="F:Mogre.PolygonMode.PM_WIREFRAME">
      <summary>Wireframe models are rendered. </summary>
    </member>
    <member name="F:Mogre.PolygonMode.PM_SOLID">
      <summary>Solid polygons are rendered. </summary>
    </member>
    <member name="T:Mogre.WaveformType">
      <summary>Enumerates the wave types usable with the Ogre engine. </summary>
    </member>
    <member name="F:Mogre.WaveformType.WFT_SINE">
      <summary>Standard sine wave which smoothly changes from low to high and back again. </summary>
    </member>
    <member name="F:Mogre.WaveformType.WFT_TRIANGLE">
      <summary>An angular wave with a constant increase / decrease speed with pointed peaks. </summary>
    </member>
    <member name="F:Mogre.WaveformType.WFT_SQUARE">
      <summary>Half of the time is spent at the min, half at the max with instant transition between. </summary>
    </member>
    <member name="F:Mogre.WaveformType.WFT_SAWTOOTH">
      <summary>Gradual steady increase from min to max over the period with an instant return to min at the end. </summary>
    </member>
    <member name="F:Mogre.WaveformType.WFT_INVERSE_SAWTOOTH">
      <summary>Gradual steady decrease from max to min over the period, with an instant return to max at the end. </summary>
    </member>
    <member name="F:Mogre.WaveformType.WFT_PWM">
      <summary>Pulse Width Modulation. Works like WFT_SQUARE, except the high to low transition is controlled by duty cycle. With a duty cycle of 50% (0.5) will give the same output as WFT_SQUARE. </summary>
    </member>
    <member name="T:Mogre.ManualCullingMode">
      <summary>Manual culling modes based on vertex normals. This setting applies to how the software culls triangles before sending them to the hardware API. This culling mode is used by scene managers which choose to implement it - normally those which deal with large amounts of fixed world geometry which is often planar (software culling movable variable geometry is expensive). </summary>
    </member>
    <member name="F:Mogre.ManualCullingMode.MANUAL_CULL_NONE">
      <summary>No culling so everything is sent to the hardware. </summary>
    </member>
    <member name="F:Mogre.ManualCullingMode.MANUAL_CULL_BACK">
      <summary>Cull triangles whose normal is pointing away from the camera (default). </summary>
    </member>
    <member name="F:Mogre.ManualCullingMode.MANUAL_CULL_FRONT">
      <summary>Cull triangles whose normal is pointing towards the camera. </summary>
    </member>
    <member name="T:Mogre.CullingMode">
      <summary>Hardware culling modes based on vertex winding. This setting applies to how the hardware API culls triangles it is sent. </summary>
    </member>
    <member name="F:Mogre.CullingMode.CULL_NONE">
      <summary>Hardware never culls triangles and renders everything it receives. </summary>
    </member>
    <member name="F:Mogre.CullingMode.CULL_CLOCKWISE">
      <summary>Hardware culls triangles whose vertices are listed clockwise in the view (default). </summary>
    </member>
    <member name="F:Mogre.CullingMode.CULL_ANTICLOCKWISE">
      <summary>Hardware culls triangles whose vertices are listed anticlockwise in the view. </summary>
    </member>
    <member name="T:Mogre.FogMode">
      <summary>Fog modes. </summary>
    </member>
    <member name="F:Mogre.FogMode.FOG_NONE">
      <summary>No fog. Duh. </summary>
    </member>
    <member name="F:Mogre.FogMode.FOG_EXP">
      <summary>Fog density increases exponentially from the camera (fog = 1/e^(distance * density)). </summary>
    </member>
    <member name="F:Mogre.FogMode.FOG_EXP2">
      <summary>Fog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2). </summary>
    </member>
    <member name="F:Mogre.FogMode.FOG_LINEAR">
      <summary>Fog density increases linearly between the start and end distances. </summary>
    </member>
    <member name="T:Mogre.ShadeOptions">
      <summary>Light shading modes. </summary>
    </member>
    <member name="T:Mogre.FilterOptions">
      <summary>Filtering options for textures / mipmaps. </summary>
    </member>
    <member name="F:Mogre.FilterOptions.FO_NONE">
      <summary>No filtering, used for FILT_MIP to turn off mipmapping. </summary>
    </member>
    <member name="F:Mogre.FilterOptions.FO_POINT">
      <summary>Use the closest pixel. </summary>
    </member>
    <member name="F:Mogre.FilterOptions.FO_LINEAR">
      <summary>Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP. </summary>
    </member>
    <member name="F:Mogre.FilterOptions.FO_ANISOTROPIC">
      <summary>Similar to FO_LINEAR, but compensates for the angle of the texture plane. </summary>
    </member>
    <member name="F:Mogre.FilterType.FT_MIN">
      <summary>The filter used when shrinking a texture. </summary>
    </member>
    <member name="F:Mogre.FilterType.FT_MAG">
      <summary>The filter used when magnifying a texture. </summary>
    </member>
    <member name="F:Mogre.FilterType.FT_MIP">
      <summary>The filter used when determining the mipmap. </summary>
    </member>
    <member name="T:Mogre.CompareFunction">
      <summary>Comparison functions used for the depth/stencil buffer operations and others. </summary>
    </member>
    <member name="T:Mogre.TextureFilterOptions">
      <summary>High-level filtering options providing shortcuts to settings the minification, magnification and mip filters. </summary>
    </member>
    <member name="F:Mogre.TextureFilterOptions.TFO_NONE">
      <summary>Equal to: min=FO_POINT, mag=FO_POINT, mip=FO_NONE. </summary>
    </member>
    <member name="F:Mogre.TextureFilterOptions.TFO_BILINEAR">
      <summary>Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_POINT. </summary>
    </member>
    <member name="F:Mogre.TextureFilterOptions.TFO_TRILINEAR">
      <summary>Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_LINEAR. </summary>
    </member>
    <member name="F:Mogre.TextureFilterOptions.TFO_ANISOTROPIC">
      <summary>Equal to: min=FO_ANISOTROPIC, max=FO_ANISOTROPIC, mip=FO_LINEAR. </summary>
    </member>
    <member name="T:Mogre.ParameterType">
      <summary>List of parameter types available. </summary>
    </member>
    <member name="F:Mogre.SkeletonAnimationBlendMode.ANIMBLEND_AVERAGE">
      <summary>Animations are applied by calculating a weighted average of all animations. </summary>
    </member>
    <member name="F:Mogre.SkeletonAnimationBlendMode.ANIMBLEND_CUMULATIVE">
      <summary>Animations are applied by calculating a weighted cumulative total. </summary>
    </member>
    <member name="T:Mogre.GpuParamVariability">
      <summary>The variability of a GPU parameter, as derived from auto-params targetting it. These values must be powers of two since they are used in masks. </summary>
    </member>
    <member name="F:Mogre.GpuParamVariability.GPV_GLOBAL">
      <summary>No variation except by manual setting - the default. </summary>
    </member>
    <member name="F:Mogre.GpuParamVariability.GPV_PER_OBJECT">
      <summary>Varies per object (based on an auto param usually), but not per light setup. </summary>
    </member>
    <member name="F:Mogre.GpuParamVariability.GPV_LIGHTS">
      <summary>Varies with light setup. </summary>
    </member>
    <member name="F:Mogre.GpuParamVariability.GPV_PASS_ITERATION_NUMBER">
      <summary>Varies with pass iteration number. </summary>
    </member>
    <member name="F:Mogre.GpuParamVariability.GPV_ALL">
      <summary>Full mask (16-bit). </summary>
    </member>
    <member name="T:Mogre.GpuConstantType">
      <summary>Enumeration of the types of constant we may encounter in programs. Low-level programs, by definition, will always use either float4 or int4 constant types since that is the fundamental underlying type in assembler. </summary>
    </member>
    <member name="T:Mogre.ShadowRenderableFlags">
      <summary>A set of flags that can be used to influence ShadowRenderable creation. </summary>
    </member>
    <member name="F:Mogre.ShadowRenderableFlags.SRF_INCLUDE_LIGHT_CAP">
      <summary>For shadow volume techniques only, generate a light cap on the volume. </summary>
    </member>
    <member name="F:Mogre.ShadowRenderableFlags.SRF_INCLUDE_DARK_CAP">
      <summary>For shadow volume techniques only, generate a dark cap on the volume. </summary>
    </member>
    <member name="F:Mogre.ShadowRenderableFlags.SRF_EXTRUDE_TO_INFINITY">
      <summary>For shadow volume techniques only, indicates volume is extruded to infinity. </summary>
    </member>
    <member name="T:Mogre.KeyFrame">
      <summary>A key frame in an animation sequence defined by an AnimationTrack. This class can be used as a basis for all kinds of key frames. The unifying principle is that multiple KeyFrames define an animation sequence, with the exact state of the animation being an interpolation between these key frames. </summary>
    </member>
    <member name="M:Mogre.KeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.KeyFrame.#ctor(Mogre.AnimationTrack,System.Single)">
      <summary>Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. </summary>
    </member>
    <member name="P:Mogre.KeyFrame.Time">
      <summary>Gets the time of this keyframe in the animation sequence. </summary>
    </member>
    <member name="T:Mogre.NumericKeyFrame">
      <summary>Specialised KeyFrame which stores any numeric value. </summary>
    </member>
    <member name="M:Mogre.NumericKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.NumericKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.NumericKeyFrame.#ctor(Mogre.AnimationTrack,System.Single)">
      <summary>Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. </summary>
    </member>
    <member name="T:Mogre.TransformKeyFrame">
      <summary>Specialised KeyFrame which stores a full transform. </summary>
    </member>
    <member name="M:Mogre.TransformKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.TransformKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.TransformKeyFrame.#ctor(Mogre.AnimationTrack,System.Single)">
      <summary>Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. </summary>
    </member>
    <member name="P:Mogre.TransformKeyFrame.Translate">
      <summary>Sets/Gets the translation applied by this keyframe. </summary>
    </member>
    <member name="P:Mogre.TransformKeyFrame.Scale">
      <summary>Sets/Gets the scaling factor applied by this keyframe. </summary>
    </member>
    <member name="P:Mogre.TransformKeyFrame.Rotation">
      <summary>Sets/Gets the rotation applied by this keyframe. </summary>
    </member>
    <member name="T:Mogre.VertexMorphKeyFrame">
      <summary>Specialised KeyFrame which stores absolute vertex positions for a complete buffer, designed to be interpolated with other keys in the same track. </summary>
    </member>
    <member name="M:Mogre.VertexMorphKeyFrame.SetVertexBuffer(Mogre.HardwareVertexBufferSharedPtr)">
      <summary>Sets the vertex buffer containing the source positions for this keyframe. We assume that positions are the first 3 float elements in this buffer, although we don't necessarily assume they're the only ones in there. </summary>
      <param name="buf">Vertex buffer link; will not be modified so can be shared read-only data </param>
    </member>
    <member name="M:Mogre.VertexMorphKeyFrame.GetVertexBuffer">
      <summary>Gets the vertex buffer containing positions for this keyframe. </summary>
    </member>
    <member name="M:Mogre.VertexMorphKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.VertexMorphKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.VertexMorphKeyFrame.#ctor(Mogre.AnimationTrack,System.Single)">
      <summary>Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. </summary>
    </member>
    <member name="T:Mogre.VertexPoseKeyFrame">
      <summary>Specialised KeyFrame which references a Mesh::Pose at a certain influence level, which stores offsets for a subset of the vertices in a buffer to provide a blendable pose. </summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame.AddPoseReference(System.UInt16,System.Single)">
      <summary>Add a new pose reference. PoseRef</summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame.UpdatePoseReference(System.UInt16,System.Single)">
      <summary>Update the influence of a pose reference. PoseRef</summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame.RemovePoseReference(System.UInt16)">
      <summary>Remove reference to a given pose. </summary>
      <param name="poseIndex">The pose index (not the index of the reference) </param>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame.RemoveAllPoseReferences">
      <summary>Remove all pose references. </summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame.GetPoseReferences">
      <summary>Get a const reference to the list of pose references. </summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame.GetPoseReferenceIterator">
      <summary>Get an iterator over the pose references. </summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame._clone(Mogre.AnimationTrack)">
      <summary>Clone a keyframe (internal use only) </summary>
    </member>
    <member name="M:Mogre.VertexPoseKeyFrame.#ctor(Mogre.AnimationTrack,System.Single)">
      <summary>Default constructor, you should not call this but use AnimationTrack::createKeyFrame instead. </summary>
    </member>
    <member name="T:Mogre.FileInfo_NativePtr">
      <summary>Information about a file/directory within the archive will be returned using a FileInfo struct. Archive</summary>
    </member>
    <member name="P:Mogre.FileInfo_NativePtr.uncompressedSize">
      <summary>Sets/Uncompressed size. </summary>
    </member>
    <member name="P:Mogre.FileInfo_NativePtr.compressedSize">
      <summary>Sets/Compressed size. </summary>
    </member>
    <member name="P:Mogre.FileInfo_NativePtr.basename">
      <summary>Sets/Base filename. </summary>
    </member>
    <member name="P:Mogre.FileInfo_NativePtr.path">
      <summary>Sets/Path name; separated by '/' and ending with '/'. </summary>
    </member>
    <member name="P:Mogre.FileInfo_NativePtr.filename">
      <summary>Sets/The file's fully qualified name. </summary>
    </member>
    <member name="P:Mogre.FileInfo_NativePtr.archive">
      <summary>Sets/The archive in which the file has been found (for info when performing multi-Archive searches, note you should still open through ResourceGroupManager) </summary>
    </member>
    <member name="T:Mogre.Archive">
      <summary>Archive-handling class. An archive is a generic term for a container of files. This may be a filesystem folder, it may be a compressed archive, it may even be a remote location shared on the web. This class is designed to be subclassed to provide access to a range of file locations. Instances of this class are never constructed or even handled by end-user applications. They are constructed by custom ArchiveFactory classes, which plugins can register new instances of using ArchiveManager. End-user applications will typically use ResourceManager or ResourceGroupManager to manage resources at a higher level, rather than reading files directly through this class. Doing it this way allows you to benefit from OGRE's automatic searching of multiple file locations for the resources you are looking for. </summary>
    </member>
    <member name="M:Mogre.Archive.Load">
      <summary>Loads the archive. This initializes all the internal data of the class. Do not call this function directly, it is meant to be used only by the ArchiveManager class. </summary>
    </member>
    <member name="M:Mogre.Archive.Unload">
      <summary>Unloads the archive. Do not call this function directly, it is meant to be used only by the ArchiveManager class. </summary>
    </member>
    <member name="M:Mogre.Archive.Open(System.String)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer. </summary>
      <param name="filename">The fully qualified name of the file </param>
    </member>
    <member name="M:Mogre.Archive.Open(System.String,System.Boolean)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer. </summary>
      <param name="filename">The fully qualified name of the file </param>
      <param name="readOnly">Whether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) </param>
    </member>
    <member name="M:Mogre.Archive.Create(System.String)">
      <summary>Create a new file (or overwrite one already there). If the archive is read-only then this method will fail. A shared pointer to a DataStream which can be used to read / write the file. </summary>
      <param name="filename">The fully qualified name of the file </param>
    </member>
    <member name="M:Mogre.Archive.Remove(System.String)">
      <summary>Delete a named file. Not possible on read-only archives </summary>
      <param name="filename">The fully qualified name of the file </param>
    </member>
    <member name="M:Mogre.Archive.List">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
    </member>
    <member name="M:Mogre.Archive.List(System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
    </member>
    <member name="M:Mogre.Archive.List(System.Boolean,System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
      <param name="dirs">Set to true if you want the directories to be listed instead of files </param>
    </member>
    <member name="M:Mogre.Archive.ListFileInfo">
      <summary>List all files in the archive with accompanying information. A list of structures detailing quite a lot of information about all the files in the archive. </summary>
    </member>
    <member name="M:Mogre.Archive.ListFileInfo(System.Boolean)">
      <summary>List all files in the archive with accompanying information. A list of structures detailing quite a lot of information about all the files in the archive. </summary>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
    </member>
    <member name="M:Mogre.Archive.ListFileInfo(System.Boolean,System.Boolean)">
      <summary>List all files in the archive with accompanying information. A list of structures detailing quite a lot of information about all the files in the archive. </summary>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
      <param name="dirs">Set to true if you want the directories to be listed instead of files </param>
    </member>
    <member name="M:Mogre.Archive.Find(System.String)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
    </member>
    <member name="M:Mogre.Archive.Find(System.String,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
    </member>
    <member name="M:Mogre.Archive.Find(System.String,System.Boolean,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
      <param name="dirs">Set to true if you want the directories to be listed instead of files </param>
    </member>
    <member name="M:Mogre.Archive.Exists(System.String)">
      <summary>Find out if the named file exists (note: fully qualified filename required) </summary>
    </member>
    <member name="M:Mogre.Archive.GetModifiedTime(System.String)">
      <summary>Retrieve the modification time of a given file </summary>
    </member>
    <member name="M:Mogre.Archive.FindFileInfo(System.String)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. A list of file information structures for all files matching the criteria. </summary>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
    </member>
    <member name="M:Mogre.Archive.FindFileInfo(System.String,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. A list of file information structures for all files matching the criteria. </summary>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
    </member>
    <member name="M:Mogre.Archive.FindFileInfo(System.String,System.Boolean,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. A list of file information structures for all files matching the criteria. </summary>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
      <param name="recursive">Whether all paths of the archive are searched (if the archive has a concept of that) </param>
      <param name="dirs">Set to true if you want the directories to be listed instead of files </param>
    </member>
    <member name="P:Mogre.Archive.Type">
      <summary>Return the type code of this Archive. </summary>
    </member>
    <member name="P:Mogre.Archive.Name">
      <summary>Get the name of this archive. </summary>
    </member>
    <member name="P:Mogre.Archive.IsReadOnly">
      <summary>Reports whether this Archive is read-only, or whether the contents can be updated. </summary>
    </member>
    <member name="P:Mogre.Archive.IsCaseSensitive">
      <summary>Returns whether this archive is case sensitive in the way it matches files. </summary>
    </member>
    <member name="T:Mogre.ArchiveManager">
      <summary>This class manages the available ArchiveFactory plugins. </summary>
    </member>
    <member name="M:Mogre.ArchiveManager.Load(System.String,System.String)">
      <summary>Opens an archive for file reading. The archives are created using class factories within extension libraries. If the function succeeds, a valid pointer to an Archive object is returned. If the function fails, an exception is thrown. </summary>
      <param name="filename">The filename that will be opened </param>
    </member>
    <member name="M:Mogre.ArchiveManager.Unload(System.String)">
      <summary>Unloads an archive by name. You must ensure that this archive is not being used before removing it. </summary>
    </member>
    <member name="M:Mogre.ArchiveManager.Unload(Mogre.Archive)">
      <summary>Unloads an archive. You must ensure that this archive is not being used before removing it. </summary>
    </member>
    <member name="M:Mogre.ArchiveManager.GetArchiveIterator">
      <summary>Get an iterator over the Archives in this Manager. </summary>
    </member>
    <member name="M:Mogre.ArchiveManager.#ctor">
      <summary>Default constructor - should never get called by a client app. </summary>
    </member>
    <member name="P:Mogre.ArchiveManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.Billboard">
      <summary>A billboard is a primitive which always faces the camera in every frame. Billboards can be used for special effects or some other trickery which requires the triangles to always facing the camera no matter where it is. Ogre groups billboards into sets for efficiency, so you should never create a billboard on it's own (it's ok to have a set of one if you need it). Billboards have their geometry generated every frame depending on where the camera is. It is most beneficial for all billboards in a set to be identically sized since Ogre can take advantage of this and save some calculations - useful when you have sets of hundreds of billboards as is possible with special effects. You can deviate from this if you wish (example: a smoke effect would probably have smoke puffs expanding as they rise, so each billboard will legitimately have it's own size) but be aware the extra overhead this brings and try to avoid it if you can. Billboards are just the mechanism for rendering a range of effects such as particles. It is other classes which use billboards to create their individual effects, so the methods here are quite generic. BillboardSet</summary>
    </member>
    <member name="M:Mogre.Billboard.SetPosition(System.Single,System.Single,System.Single)">
      <summary>Set the position of the billboard. This position is relative to a point on the quad which is the billboard. Depending on the BillboardSet, this may be the center of the quad, the top-left etc. See BillboardSet::setBillboardOrigin for more info. </summary>
    </member>
    <member name="M:Mogre.Billboard.SetDimensions(System.Single,System.Single)">
      <summary>Sets the width and height for this billboard. Note that it is most efficient for every billboard in a BillboardSet to have the same dimensions. If you choose to alter the dimensions of an individual billboard the set will be less efficient. Do not call this method unless you really need to have different billboard dimensions within the same set. Otherwise just call the BillboardSet::setDefaultDimensions method instead. </summary>
    </member>
    <member name="M:Mogre.Billboard.ResetDimensions">
      <summary>Resets this Billboard to use the parent BillboardSet's dimensions instead of it's own. </summary>
    </member>
    <member name="M:Mogre.Billboard._notifyOwner(Mogre.BillboardSet)">
      <summary>Internal method for notifying the billboard of it's owner. </summary>
    </member>
    <member name="M:Mogre.Billboard.SetTexcoordRect(System.Single,System.Single,System.Single,System.Single)">
      <summary>setTexcoordRect() sets the individual texture coordinate rect of this billboard will use when rendering. The parent billboard set may contain more than one, in which case a billboard can be textured with different pieces of a larger texture sheet very efficiently. </summary>
    </member>
    <member name="M:Mogre.Billboard.#ctor(Mogre.Vector3,Mogre.BillboardSet)">
      <summary>Normal constructor as called by BillboardSet. </summary>
    </member>
    <member name="M:Mogre.Billboard.#ctor(Mogre.Vector3,Mogre.BillboardSet,Mogre.ColourValue)">
      <summary>Normal constructor as called by BillboardSet. </summary>
    </member>
    <member name="M:Mogre.Billboard.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.Billboard.TexcoordRect">
      <summary>Sets/getTexcoordRect() returns the previous value set by setTexcoordRect(). This value is useful only when isUseTexcoordRect return true. </summary>
    </member>
    <member name="P:Mogre.Billboard.TexcoordIndex">
      <summary>Sets/getTexcoordIndex() returns the previous value set by setTexcoordIndex(). The default value is 0, which is always a valid texture coordinate set. This value is useful only when isUseTexcoordRect return false. </summary>
    </member>
    <member name="P:Mogre.Billboard.Rotation">
      <summary>Sets/Get the rotation of the billboard. This rotation is relative to the center of the billboard. </summary>
    </member>
    <member name="P:Mogre.Billboard.Position">
      <summary>Sets/Get the position of the billboard. This position is relative to a point on the quad which is the billboard. Depending on the BillboardSet, this may be the center of the quad, the top-left etc. See BillboardSet::setBillboardOrigin for more info. </summary>
    </member>
    <member name="P:Mogre.Billboard.OwnWidth">
      <summary>Retrieves the billboard's personal width, if hasOwnDimensions is true. </summary>
    </member>
    <member name="P:Mogre.Billboard.OwnHeight">
      <summary>Retrieves the billboard's personal width, if hasOwnDimensions is true. </summary>
    </member>
    <member name="P:Mogre.Billboard.IsUseTexcoordRect">
      <summary>Returns true if this billboard use individual texture coordinate rect (i.e. if the Billboard::setTexcoordRect method has been called for this instance), or returns false if use texture coordinates defined in the parent BillboardSet's texture coordinates array (i.e. if the Billboard::setTexcoordIndex method has been called for this instance). Billboard::setTexcoordIndex()Billboard::setTexcoordRect()</summary>
    </member>
    <member name="P:Mogre.Billboard.HasOwnDimensions">
      <summary>Returns true if this billboard deviates from the BillboardSet's default dimensions (i.e. if the Billboard::setDimensions method has been called for this instance). Billboard::setDimensions</summary>
    </member>
    <member name="P:Mogre.Billboard.Colour">
      <summary>Sets/Gets the colour of this billboard. </summary>
    </member>
    <member name="T:Mogre.BillboardSet">
      <summary>A collection of billboards (faces which are always facing the given direction) with the same (default) dimensions, material and which are fairly close proximity to each other. Billboards are rectangles made up of 2 tris which are always facing the given direction. They are typically used for special effects like particles. This class collects together a set of billboards with the same (default) dimensions, material and relative locality in order to process them more efficiently. The entire set of billboards will be culled as a whole (by default, although this can be changed if you want a large set of billboards which are spread out and you want them culled individually), individual Billboards have locations which are relative to the set (which itself derives it's position from the SceneNode it is attached to since it is a MoveableObject), they will be rendered as a single rendering operation, and some calculations will be sped up by the fact that they use the same dimensions so some workings can be reused. A BillboardSet can be created using the SceneManager::createBillboardSet method. They can also be used internally by other classes to create effects. Billboard bounds are only automatically calculated when you create them. If you modify the position of a billboard you may need to call _updateBounds if the billboard moves outside the original bounds. Similarly, the bounds do no shrink when you remove a billboard, if you want them to call _updateBounds, but note this requires a potentially expensive examination of every billboard in the set. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.CreateBillboard(System.Single,System.Single,System.Single)">
      <summary>Creates a new billboard and adds it to this set. Behaviour once the billboard pool has been exhausted depends on the BillboardSet::setAutoextendPool option. On success, a pointer to a newly created Billboard is returned. On failure (i.e. no more space and can't autoextend), NULL is returned. BillboardSet::setAutoextend</summary>
      <param name="x" />
      <param name="y" />
      <param name="z">The position of the new billboard relative to the center of the set </param>
    </member>
    <member name="M:Mogre.BillboardSet.CreateBillboard(System.Single,System.Single,System.Single,Mogre.ColourValue)">
      <summary>Creates a new billboard and adds it to this set. Behaviour once the billboard pool has been exhausted depends on the BillboardSet::setAutoextendPool option. On success, a pointer to a newly created Billboard is returned. On failure (i.e. no more space and can't autoextend), NULL is returned. BillboardSet::setAutoextend</summary>
      <param name="x" />
      <param name="y" />
      <param name="z">The position of the new billboard relative to the center of the set </param>
      <param name="colour">Optional base colour of the billboard. </param>
    </member>
    <member name="M:Mogre.BillboardSet.CreateBillboard(Mogre.Vector3)">
      <summary>Creates a new billboard and adds it to this set. Behaviour once the billboard pool has been exhausted depends on the BillboardSet::setAutoextendPool option. On success, a pointer to a newly created Billboard is returned. On failiure (i.e. no more space and can't autoextend), NULL is returned. BillboardSet::setAutoextend</summary>
      <param name="position">The position of the new billboard realtive to the certer of the set </param>
    </member>
    <member name="M:Mogre.BillboardSet.CreateBillboard(Mogre.Vector3,Mogre.ColourValue)">
      <summary>Creates a new billboard and adds it to this set. Behaviour once the billboard pool has been exhausted depends on the BillboardSet::setAutoextendPool option. On success, a pointer to a newly created Billboard is returned. On failiure (i.e. no more space and can't autoextend), NULL is returned. BillboardSet::setAutoextend</summary>
      <param name="position">The position of the new billboard realtive to the certer of the set </param>
      <param name="colour">Optional base colour of the billboard. </param>
    </member>
    <member name="M:Mogre.BillboardSet.SetPoolSize(System.UInt32)">
      <summary>Adjusts the size of the pool of billboards available in this set. See the BillboardSet::setAutoextend method for full details of the billboard pool. This method adjusts the preallocated size of the pool. If you try to reduce the size of the pool, the set has the option of ignoring you if too many billboards are already in use. Bear in mind that calling this method will incur significant construction / destruction calls so should be avoided in time-critical code. The same goes for auto-extension, try to avoid it by estimating the pool size correctly up-front. </summary>
      <param name="size">The new size for the pool. </param>
    </member>
    <member name="M:Mogre.BillboardSet.Clear">
      <summary>Empties this set of all billboards. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.GetBillboard(System.UInt32)">
      <summary>Returns a pointer to the billboard at the supplied index. This method requires linear time since the billboard list is a linked list. On success, a valid pointer to the requested billboard is returned. On failure, NULL is returned. </summary>
      <param name="index">The index of the billboard that is requested. </param>
    </member>
    <member name="M:Mogre.BillboardSet.RemoveBillboard(Mogre.Billboard)">
      <summary>Removes a billboard from the set. This version is more efficient than removing by index. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.RemoveBillboard(System.UInt32)">
      <summary>Removes the billboard at the supplied index. This method requires linear time since the billboard list is a linked list. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.SetDefaultDimensions(System.Single,System.Single)">
      <summary>Sets the default dimensions of the billboards in this set. All billboards in a set are created with these default dimensions. The set will render most efficiently if all the billboards in the set are the default size. It is possible to alter the size of individual billboards at the expense of extra calculation. See the Billboard class for more info. </summary>
      <param name="width">The new default width for the billboards in this set. </param>
      <param name="height">The new default height for the billboards in this set. </param>
    </member>
    <member name="M:Mogre.BillboardSet.SetMaterialName(System.String)">
      <summary>Sets the name of the material to be used for this billboard set. </summary>
      <param name="name">The new name of the material to use for this set. </param>
    </member>
    <member name="M:Mogre.BillboardSet.SetMaterialName(System.String,System.String)">
      <summary>Sets the name of the material to be used for this billboard set. </summary>
      <param name="name">The new name of the material to use for this set. </param>
    </member>
    <member name="M:Mogre.BillboardSet._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.BillboardSet.BeginBillboards">
      <summary>Begin injection of billboard data; applicable when constructing the BillboardSet for external data use. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.BeginBillboards(System.UInt32)">
      <summary>Begin injection of billboard data; applicable when constructing the BillboardSet for external data use. </summary>
      <param name="numBillboards">If you know the number of billboards you will be issuing, state it here to make the update more efficient. </param>
    </member>
    <member name="M:Mogre.BillboardSet.InjectBillboard(Mogre.Billboard)">
      <summary>Define a billboard. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.EndBillboards">
      <summary>Finish defining billboards. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.SetBounds(Mogre.AxisAlignedBox,System.Single)">
      <summary>Set the bounds of the BillboardSet. You may need to call this if you're injecting billboards manually, and you're relying on the BillboardSet to determine culling. </summary>
    </member>
    <member name="M:Mogre.BillboardSet._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.BillboardSet.GetMaterial">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.BillboardSet.GetRenderOperation(Mogre.RenderOperation)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.BillboardSet.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.BillboardSet._notifyBillboardResized">
      <summary>Internal callback used by Billboards to notify their parent that they have been resized. </summary>
    </member>
    <member name="M:Mogre.BillboardSet._notifyBillboardRotated">
      <summary>Internal callback used by Billboards to notify their parent that they have been rotated.. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.GetSquaredViewDepth(Mogre.Camera)">
      <summary>Overridden, see Renderable</summary>
    </member>
    <member name="M:Mogre.BillboardSet._updateBounds">
      <summary>Update the bounds of the billboardset </summary>
    </member>
    <member name="M:Mogre.BillboardSet.GetLights">
      <summary>Gets a list of lights, ordered relative to how close they are to this renderable. Directional lights, which have no position, will always be first on this list.</summary>
    </member>
    <member name="M:Mogre.BillboardSet._sortBillboards(Mogre.Camera)">
      <summary>Sort the billboard set. Only called when enabled via setSortingEnabled </summary>
    </member>
    <member name="M:Mogre.BillboardSet._getSortMode">
      <summary>Gets the sort mode of this billboard set </summary>
    </member>
    <member name="M:Mogre.BillboardSet.SetBillboardsInWorldSpace(System.Boolean)">
      <summary>Sets whether billboards should be treated as being in world space. This is most useful when you are driving the billboard set from an external data source. </summary>
    </member>
    <member name="M:Mogre.BillboardSet.SetTextureCoords(Mogre.FloatRect*,System.UInt16)">
      <summary>BillboardSet can use custom texture coordinates for various billboards. This is useful for selecting one of many particle images out of a tiled texture sheet, or doing flipbook animation within a single texture. The generic functionality is setTextureCoords(), which will copy the texture coordinate rects you supply into internal storage for the billboard set. If your texture sheet is a square grid, you can also use setTextureStacksAndSlices() for more convenience, which will construct the set of texture coordinates for you. When a Billboard is created, it can be assigned a texture coordinate set from within the sets you specify (that set can also be re-specified later). When drawn, the billboard will use those texture coordinates, rather than the full 0-1 range. Set 'coords' to 0 and/or 'numCoords' to 0 to reset the texture coord rects to the initial set of a single rectangle spanning 0 through 1 in both U and V (i e, the entire texture). BillboardSet::setTextureStacksAndSlices()Billboard::setTexcoordIndex()</summary>
      <param name="coords">is a vector of texture coordinates (in UV space) to choose from for each billboard created in the set. </param>
      <param name="numCoords">is how many such coordinate rectangles there are to choose from. </param>
    </member>
    <member name="M:Mogre.BillboardSet.SetTextureStacksAndSlices(System.Byte,System.Byte)">
      <summary>setTextureStacksAndSlices() will generate texture coordinate rects as if the texture for the billboard set contained 'stacks' rows of 'slices' images each, all equal size. Thus, if the texture size is 512x512 and 'stacks' is 4 and 'slices' is 8, each sub-rectangle of the texture would be 128 texels tall and 64 texels wide. This function is short-hand for creating a regular set and calling setTextureCoords() yourself. The numbering used for Billboard::setTexcoordIndex() counts first across, then down, so top-left is 0, the one to the right of that is 1, and the lower-right is stacks*slices-1. BillboardSet::setTextureCoords()</summary>
    </member>
    <member name="M:Mogre.BillboardSet.GetTextureCoords(System.UInt16&amp;)">
      <summary>getTextureCoords() returns the current texture coordinate rects in effect. By default, there is only one texture coordinate rect in the set, spanning the entire texture from 0 through 1 in each direction. BillboardSet::setTextureCoords()</summary>
    </member>
    <member name="M:Mogre.BillboardSet.SetPointRenderingEnabled(System.Boolean)">
      <summary>Set whether or not the BillboardSet will use point rendering rather than manually generated quads. By default a billboardset is rendered by generating geometry for a textured quad in memory, taking into account the size and orientation settings, and uploading it to the video card. The alternative is to use hardware point rendering, which means that only one position needs to be sent per billboard rather than 4 and the hardware sorts out how this is rendered based on the render state. Using point rendering is faster than generating quads manually, but is more restrictive. The following restrictions apply: Only the BBT_POINT type is supported Size and appearance of each billboard is controlled by the material (Pass::setPointSize, Pass::setPointSizeAttenuation, Pass::setPointSpritesEnabled) Per-billboard size is not supported (stems from the above) Per-billboard rotation is not supported, this can only be controlled through texture unit rotation Only BBO_CENTER origin is supported Per-billboard texture coordinates are not supportedYou will almost certainly want to enable in your material pass both point attenuation and point sprites if you use this option. </summary>
      <param name="enabled">True to enable point rendering, false otherwise </param>
    </member>
    <member name="M:Mogre.BillboardSet.NotifyBillboardDataChanged">
      <summary>When billboard set is not auto updating its GPU buffer, the user is responsible to inform it about any billboard changes in order to reflect them at the rendering stage. Calling this method will cause GPU buffers update in the next render queue update. </summary>
    </member>
    <member name="M:Mogre.BillboardSet._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.BillboardSet._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.BillboardSet.#ctor(System.String)">
      <summary>Usual constructor - this is called by the SceneManager. BillboardSet::setAutoextend</summary>
      <param name="name">The name to give the billboard set (must be unique) </param>
    </member>
    <member name="M:Mogre.BillboardSet.#ctor(System.String,System.UInt32)">
      <summary>Usual constructor - this is called by the SceneManager. BillboardSet::setAutoextend</summary>
      <param name="name">The name to give the billboard set (must be unique) </param>
      <param name="poolSize">The initial size of the billboard pool. Estimate of the number of billboards which will be required, and pass it using this parameter. The set will preallocate this number to avoid memory fragmentation. The default behaviour once this pool has run out is to double it. </param>
    </member>
    <member name="M:Mogre.BillboardSet.#ctor(System.String,System.UInt32,System.Boolean)">
      <summary>Usual constructor - this is called by the SceneManager. BillboardSet::setAutoextend</summary>
      <param name="name">The name to give the billboard set (must be unique) </param>
      <param name="poolSize">The initial size of the billboard pool. Estimate of the number of billboards which will be required, and pass it using this parameter. The set will preallocate this number to avoid memory fragmentation. The default behaviour once this pool has run out is to double it. </param>
      <param name="externalDataSource">If true, the source of data for drawing the billboards will not be the internal billboard list, but external data. When driving the billboard from external data, you must call _notifyCurrentCamera to reorient the billboards, setPoolSize to set the maximum billboards you want to use, beginBillboards to start the update, and injectBillboard per billboard, followed by endBillboards. </param>
    </member>
    <member name="P:Mogre.BillboardSet.UseAccurateFacing">
      <summary>Sets/Gets whether or not billboards use an 'accurate' facing model based on the vector from each billboard to the camera, rather than an optimised version using just the camera direction. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.TypeFlags">
      <summary>Override to return specific type flag. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.SortingEnabled">
      <summary>Sets/Returns true if sorting of billboards is enabled based on their distance from the camera BillboardSet::setSortingEnabled</summary>
    </member>
    <member name="P:Mogre.BillboardSet.PoolSize">
      <summary>Returns the current size of the billboard pool. The current size of the billboard pool. BillboardSet::setAutoextend</summary>
    </member>
    <member name="P:Mogre.BillboardSet.NumBillboards">
      <summary>Returns the number of active billboards which currently make up this set. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.BillboardSet.MaterialName">
      <summary>Sets the name of the material to be used for this billboard set. The name of the material that is used for this set. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.IsPointRenderingEnabled">
      <summary>Returns whether point rendering is enabled. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.DefaultWidth">
      <summary>Sets/See setDefaultDimensions - this gets 1 component individually. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.DefaultHeight">
      <summary>Sets/See setDefaultDimensions - this gets 1 component individually. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.CullIndividually">
      <summary>Sets/Returns whether or not billboards in this are tested individually for culling. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.CommonUpVector">
      <summary>Sets/Gets the common up-vector for all billboards (BBT_PERPENDICULAR_SELF and BBT_PERPENDICULAR_COMMON) </summary>
    </member>
    <member name="P:Mogre.BillboardSet.CommonDirection">
      <summary>Sets/Gets the common direction for all billboards (BBT_ORIENTED_COMMON) </summary>
    </member>
    <member name="P:Mogre.BillboardSet.BoundingRadius">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="P:Mogre.BillboardSet.BoundingBox">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="P:Mogre.BillboardSet.BillboardType">
      <summary>Sets/Returns the billboard type in use. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.BillboardRotationType">
      <summary>Sets/Sets billboard rotation type. A member of the BillboardRotationType enum specifying the rotation type for all the billboards in this set. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.BillboardOrigin">
      <summary>Sets/Gets the point which acts as the origin point for all billboards in this set. A member of the BillboardOrigin enum specifying the origin for all the billboards in this set. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.AutoUpdate">
      <summary>Sets/Return the auto update state of this billboard set. </summary>
    </member>
    <member name="P:Mogre.BillboardSet.Autoextend">
      <summary>Sets/Returns true if the billboard pool automatically extends. BillboardSet::setAutoextend</summary>
    </member>
    <member name="T:Mogre.BillboardSetFactory">
      <summary>Factory object for creating BillboardSet instances </summary>
    </member>
    <member name="T:Mogre.BillboardType">
      <summary>The type of billboard to use. </summary>
    </member>
    <member name="F:Mogre.BillboardType.BBT_POINT">
      <summary>Standard point billboard (default), always faces the camera completely and is always upright. </summary>
    </member>
    <member name="F:Mogre.BillboardType.BBT_ORIENTED_COMMON">
      <summary>Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera. </summary>
    </member>
    <member name="F:Mogre.BillboardType.BBT_ORIENTED_SELF">
      <summary>Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera. </summary>
    </member>
    <member name="F:Mogre.BillboardType.BBT_PERPENDICULAR_COMMON">
      <summary>Billboards are perpendicular to a shared direction vector (used as Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor. </summary>
    </member>
    <member name="F:Mogre.BillboardType.BBT_PERPENDICULAR_SELF">
      <summary>Billboards are perpendicular to their own direction vector (their own Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor. </summary>
    </member>
    <member name="T:Mogre.BillboardRotationType">
      <summary>The rotation type of billboard. </summary>
    </member>
    <member name="F:Mogre.BillboardRotationType.BBR_VERTEX">
      <summary>Rotate the billboard's vertices around their facing direction. </summary>
    </member>
    <member name="F:Mogre.BillboardRotationType.BBR_TEXCOORD">
      <summary>Rotate the billboard's texture coordinates. </summary>
    </member>
    <member name="T:Mogre.BillboardOrigin">
      <summary>Enum covering what exactly a billboard's position means (center, top-left etc). BillboardSet::setBillboardOrigin</summary>
    </member>
    <member name="T:Mogre.BillboardChain">
      <summary>Allows the rendering of a chain of connected billboards. A billboard chain operates much like a traditional billboard, i.e. its segments always face the camera; the difference being that instead of a set of disconnected quads, the elements in this class are connected together in a chain which must always stay in a continuous strip. This kind of effect is useful for creating effects such as trails, beams, lightning effects, etc. A single instance of this class can actually render multiple separate chain segments in a single render operation, provided they all use the same material. To clarify the terminology: a 'segment' is a separate sub-part of the chain with its own start and end (called the 'head' and the 'tail'. An 'element' is a single position / colour / texcoord entry in a segment. You can add items to the head of a chain, and remove them from the tail, very efficiently. Each segment has a max size, and if adding an element to the segment would exceed this size, the tail element is automatically removed and re-used as the new item on the head. This class has no auto-updating features to do things like alter the colour of the elements or to automatically add / remove elements over time - you have to do all this yourself as a user of the class. Subclasses can however be used to provide this kind of behaviour automatically.RibbonTrail</summary>
    </member>
    <member name="M:Mogre.BillboardChain.SetOtherTextureCoordRange(System.Single,System.Single)">
      <summary>Set the range of the texture coordinates generated across the width of the chain elements. </summary>
      <param name="start">Start coordinate, default 0.0 </param>
      <param name="end">End coordinate, default 1.0 </param>
    </member>
    <member name="M:Mogre.BillboardChain.AddChainElement(System.UInt32,Mogre.BillboardChain+Element_NativePtr)">
      <summary>Add an element to the 'head' of a chain. If this causes the number of elements to exceed the maximum elements per chain, the last element in the chain (the 'tail') will be removed to allow the additional element to be added. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="billboardChainElement">The details to add </param>
    </member>
    <member name="M:Mogre.BillboardChain.RemoveChainElement(System.UInt32)">
      <summary>Remove an element from the 'tail' of a chain. </summary>
      <param name="chainIndex">The index of the chain </param>
    </member>
    <member name="M:Mogre.BillboardChain.UpdateChainElement(System.UInt32,System.UInt32,Mogre.BillboardChain+Element_NativePtr)">
      <summary>Update the details of an existing chain element. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="elementIndex">The element index within the chain, measured from the 'head' of the chain </param>
      <param name="billboardChainElement">The details to set </param>
    </member>
    <member name="M:Mogre.BillboardChain.GetChainElement(System.UInt32,System.UInt32)">
      <summary>Get the detail of a chain element. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="elementIndex">The element index within the chain, measured from the 'head' of the chain </param>
    </member>
    <member name="M:Mogre.BillboardChain.GetNumChainElements(System.UInt32)">
      <summary>Returns the number of chain elements. </summary>
    </member>
    <member name="M:Mogre.BillboardChain.ClearChain(System.UInt32)">
      <summary>Remove all elements of a given chain (but leave the chain intact). </summary>
    </member>
    <member name="M:Mogre.BillboardChain.ClearAllChains">
      <summary>Remove all elements from all chains (but leave the chains themselves intact). </summary>
    </member>
    <member name="M:Mogre.BillboardChain.SetMaterialName(System.String)">
      <summary>Set the material name to use for rendering. </summary>
    </member>
    <member name="M:Mogre.BillboardChain.SetMaterialName(System.String,System.String)">
      <summary>Set the material name to use for rendering. </summary>
    </member>
    <member name="M:Mogre.BillboardChain.#ctor(System.String)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
    </member>
    <member name="M:Mogre.BillboardChain.#ctor(System.String,System.UInt32)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
    </member>
    <member name="M:Mogre.BillboardChain.#ctor(System.String,System.UInt32,System.UInt32)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
      <param name="numberOfChains">The number of separate chain segments contained in this object </param>
    </member>
    <member name="M:Mogre.BillboardChain.#ctor(System.String,System.UInt32,System.UInt32,System.Boolean)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
      <param name="numberOfChains">The number of separate chain segments contained in this object </param>
      <param name="useTextureCoords">If true, use texture coordinates from the chain elements </param>
    </member>
    <member name="M:Mogre.BillboardChain.#ctor(System.String,System.UInt32,System.UInt32,System.Boolean,System.Boolean)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
      <param name="numberOfChains">The number of separate chain segments contained in this object </param>
      <param name="useTextureCoords">If true, use texture coordinates from the chain elements </param>
    </member>
    <member name="M:Mogre.BillboardChain.#ctor(System.String,System.UInt32,System.UInt32,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
      <param name="numberOfChains">The number of separate chain segments contained in this object </param>
      <param name="useTextureCoords">If true, use texture coordinates from the chain elements </param>
      <param name="dynamic">If true, buffers are created with the intention of being updated </param>
    </member>
    <member name="P:Mogre.BillboardChain.UseVertexColours">
      <summary>Sets/Gets whether vertex colour information should be included in the final buffers generated. </summary>
    </member>
    <member name="P:Mogre.BillboardChain.UseTextureCoords">
      <summary>Sets/Gets whether texture coordinate information should be included in the final buffers generated. </summary>
    </member>
    <member name="P:Mogre.BillboardChain.TextureCoordDirection">
      <summary>Sets/Gets the direction in which texture coords specified on each element are deemed to run. </summary>
    </member>
    <member name="P:Mogre.BillboardChain.OtherTextureCoordRange">
      <summary>Get the range of the texture coordinates generated across the width of the chain elements. </summary>
    </member>
    <member name="P:Mogre.BillboardChain.NumberOfChains">
      <summary>Sets/Get the number of chain segments (this class can render multiple chains at once using the same material). </summary>
    </member>
    <member name="P:Mogre.BillboardChain.MaxChainElements">
      <summary>Sets/Get the maximum number of chain elements per chain </summary>
    </member>
    <member name="P:Mogre.BillboardChain.MaterialName">
      <summary>Get the material name in use. </summary>
    </member>
    <member name="P:Mogre.BillboardChain.Dynamic">
      <summary>Sets/Gets whether or not the buffers created for this object are suitable for dynamic alteration. </summary>
    </member>
    <member name="T:Mogre.BillboardChain+TexCoordDirection">
      <summary>The direction in which texture coordinates from elements of the chain are used. </summary>
    </member>
    <member name="F:Mogre.BillboardChain+TexCoordDirection.TCD_U">
      <summary>Tex coord in elements is treated as the 'u' texture coordinate. </summary>
    </member>
    <member name="F:Mogre.BillboardChain+TexCoordDirection.TCD_V">
      <summary>Tex coord in elements is treated as the 'v' texture coordinate. </summary>
    </member>
    <member name="T:Mogre.BillboardChainFactory">
      <summary>Factory object for creating BillboardChain instances </summary>
    </member>
    <member name="T:Mogre.Frustum">
      <summary>A frustum represents a pyramid, capped at the near and far end which is used to represent either a visible area or a projection area. Can be used for a number of applications. </summary>
    </member>
    <member name="M:Mogre.Frustum.SetFrustumOffset">
      <summary>Sets frustum offsets, used in stereo rendering. You can set both horizontal and vertical plane offsets of "eye"; in stereo rendering frustum is moved in horizontal plane. To be able to render from two "eyes" you'll need two cameras rendering on two RenderTargets. The frustum offsets is in world coordinates, and default to (0, 0) - no offsets. </summary>
    </member>
    <member name="M:Mogre.Frustum.SetFrustumOffset(System.Single)">
      <summary>Sets frustum offsets, used in stereo rendering. You can set both horizontal and vertical plane offsets of "eye"; in stereo rendering frustum is moved in horizontal plane. To be able to render from two "eyes" you'll need two cameras rendering on two RenderTargets. The frustum offsets is in world coordinates, and default to (0, 0) - no offsets. </summary>
    </member>
    <member name="M:Mogre.Frustum.SetFrustumOffset(System.Single,System.Single)">
      <summary>Sets frustum offsets, used in stereo rendering. You can set both horizontal and vertical plane offsets of "eye"; in stereo rendering frustum is moved in horizontal plane. To be able to render from two "eyes" you'll need two cameras rendering on two RenderTargets. The frustum offsets is in world coordinates, and default to (0, 0) - no offsets. </summary>
    </member>
    <member name="M:Mogre.Frustum.SetFrustumExtents(System.Single,System.Single,System.Single,System.Single)">
      <summary>Manually set the extents of the frustum. </summary>
      <param name="left">The position where the side clip planes intersect the near clip plane, in eye space </param>
    </member>
    <member name="M:Mogre.Frustum.ResetFrustumExtents">
      <summary>Reset the frustum extents to be automatically derived from other params. </summary>
    </member>
    <member name="M:Mogre.Frustum.GetFrustumExtents(System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;)">
      <summary>Get the extents of the frustum in view space. </summary>
    </member>
    <member name="M:Mogre.Frustum.CalcViewMatrixRelative(Mogre.Vector3,Mogre.Matrix4)">
      <summary>Calculate a view matrix for this frustum, relative to a potentially dynamic point. Mainly for use by OGRE internally when using camera-relative rendering for frustums that are not the centre (e.g. texture projection) </summary>
    </member>
    <member name="M:Mogre.Frustum.SetCustomViewMatrix(System.Boolean)">
      <summary>Set whether to use a custom view matrix on this frustum. This is an advanced method which allows you to manually set the view matrix on this frustum, rather than having it calculate itself based on it's position and orientation. After enabling a custom view matrix, the frustum will no longer update on its own based on position / orientation changes. You are completely responsible for keeping the view matrix up to date. The custom matrix will be returned from getViewMatrix. Frustum::setCustomProjectionMatrix, Matrix4::isAffine</summary>
      <param name="enable">If true, the custom view matrix passed as the second parameter will be used in preference to an auto calculated one. If false, the frustum will revert to auto calculating the view matrix. </param>
    </member>
    <member name="M:Mogre.Frustum.SetCustomViewMatrix(System.Boolean,Mogre.Matrix4)">
      <summary>Set whether to use a custom view matrix on this frustum. This is an advanced method which allows you to manually set the view matrix on this frustum, rather than having it calculate itself based on it's position and orientation. After enabling a custom view matrix, the frustum will no longer update on its own based on position / orientation changes. You are completely responsible for keeping the view matrix up to date. The custom matrix will be returned from getViewMatrix. Frustum::setCustomProjectionMatrix, Matrix4::isAffine</summary>
      <param name="enable">If true, the custom view matrix passed as the second parameter will be used in preference to an auto calculated one. If false, the frustum will revert to auto calculating the view matrix. </param>
      <param name="viewMatrix">The custom view matrix to use, the matrix must be an affine matrix. </param>
    </member>
    <member name="M:Mogre.Frustum.SetCustomProjectionMatrix(System.Boolean)">
      <summary>Set whether to use a custom projection matrix on this frustum. This is an advanced method which allows you to manually set the projection matrix on this frustum, rather than having it calculate itself based on it's position and orientation. After enabling a custom projection matrix, the frustum will no longer update on its own based on field of view and near / far distance changes. You are completely responsible for keeping the projection matrix up to date if those values change. The custom matrix will be returned from getProjectionMatrix and derivative functions. Frustum::setCustomViewMatrix</summary>
      <param name="enable">If true, the custom projection matrix passed as the second parameter will be used in preference to an auto calculated one. If false, the frustum will revert to auto calculating the projection matrix. </param>
    </member>
    <member name="M:Mogre.Frustum.SetCustomProjectionMatrix(System.Boolean,Mogre.Matrix4)">
      <summary>Set whether to use a custom projection matrix on this frustum. This is an advanced method which allows you to manually set the projection matrix on this frustum, rather than having it calculate itself based on it's position and orientation. After enabling a custom projection matrix, the frustum will no longer update on its own based on field of view and near / far distance changes. You are completely responsible for keeping the projection matrix up to date if those values change. The custom matrix will be returned from getProjectionMatrix and derivative functions. Frustum::setCustomViewMatrix</summary>
      <param name="enable">If true, the custom projection matrix passed as the second parameter will be used in preference to an auto calculated one. If false, the frustum will revert to auto calculating the projection matrix. </param>
      <param name="projectionMatrix">The custom view matrix to use </param>
    </member>
    <member name="M:Mogre.Frustum.GetFrustumPlane(System.UInt16)">
      <summary>Retrieves a specified plane of the frustum (world space). Gets a reference to one of the planes which make up the frustum frustum, e.g. for clipping purposes. </summary>
    </member>
    <member name="M:Mogre.Frustum.IsVisible(Mogre.Vector3)">
      <summary>Tests whether the given vertex is visible in the Frustum. If the box was visible, true is returned. Otherwise, false is returned. </summary>
      <param name="vert">Vertex to be checked (world space) </param>
    </member>
    <member name="M:Mogre.Frustum.IsVisible(Mogre.Vector3,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given vertex is visible in the Frustum. If the box was visible, true is returned. Otherwise, false is returned. </summary>
      <param name="vert">Vertex to be checked (world space) </param>
      <param name="culledBy">Optional pointer to an int which will be filled by the plane number which culled the box if the result was false; </param>
    </member>
    <member name="M:Mogre.Frustum.IsVisible(Mogre.Sphere)">
      <summary>Tests whether the given container is visible in the Frustum. If the box was visible, true is returned. Otherwise, false is returned. </summary>
      <param name="bound">Bounding box to be checked (world space) </param>
    </member>
    <member name="M:Mogre.Frustum.IsVisible(Mogre.Sphere,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. If the box was visible, true is returned. Otherwise, false is returned. </summary>
      <param name="bound">Bounding box to be checked (world space) </param>
      <param name="culledBy">Optional pointer to an int which will be filled by the plane number which culled the box if the result was false; </param>
    </member>
    <member name="M:Mogre.Frustum.IsVisible(Mogre.AxisAlignedBox)">
      <summary>Tests whether the given container is visible in the Frustum. If the box was visible, true is returned. Otherwise, false is returned. </summary>
      <param name="bound">Bounding box to be checked (world space) </param>
    </member>
    <member name="M:Mogre.Frustum.IsVisible(Mogre.AxisAlignedBox,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. If the box was visible, true is returned. Otherwise, false is returned. </summary>
      <param name="bound">Bounding box to be checked (world space) </param>
      <param name="culledBy">Optional pointer to an int which will be filled by the plane number which culled the box if the result was false; </param>
    </member>
    <member name="M:Mogre.Frustum._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Frustum._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Frustum.GetMaterial">
      <summary>Overridden from Renderable</summary>
    </member>
    <member name="M:Mogre.Frustum.GetRenderOperation(Mogre.RenderOperation)">
      <summary>Overridden from Renderable</summary>
    </member>
    <member name="M:Mogre.Frustum.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>Overridden from Renderable</summary>
    </member>
    <member name="M:Mogre.Frustum.GetSquaredViewDepth(Mogre.Camera)">
      <summary>Overridden from Renderable</summary>
    </member>
    <member name="M:Mogre.Frustum.GetLights">
      <summary>Overridden from Renderable</summary>
    </member>
    <member name="M:Mogre.Frustum.SetOrthoWindow(System.Single,System.Single)">
      <summary>Sets the orthographic window settings, for use with orthographic rendering only. Calling this method will recalculate the aspect ratio, use setOrthoWindowHeight or setOrthoWindowWidth alone if you wish to preserve the aspect ratio but just fit one or other dimension to a particular size. </summary>
      <param name="w">The dimensions of the view window in world units </param>
    </member>
    <member name="M:Mogre.Frustum.EnableReflection(Mogre.MovablePlane)">
      <summary>Modifies this frustum so it always renders from the reflection of itself through the plane specified. This is obviously useful for performing planar reflections. </summary>
    </member>
    <member name="M:Mogre.Frustum.EnableReflection(Mogre.Plane)">
      <summary>Modifies this frustum so it always renders from the reflection of itself through the plane specified. This is obviously useful for performing planar reflections. </summary>
    </member>
    <member name="M:Mogre.Frustum.DisableReflection">
      <summary>Disables reflection modification previously turned on with enableReflection </summary>
    </member>
    <member name="M:Mogre.Frustum.ProjectSphere(Mogre.Sphere,System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;)">
      <summary>Project a sphere onto the near plane and get the bounding rectangle. true if the sphere was projected to a subset of the near plane, false if the entire near plane was contained </summary>
      <param name="sphere">The world-space sphere to project </param>
      <param name="left">Pointers to destination values, these will be completed with the normalised device coordinates (in the range {-1,1}) </param>
    </member>
    <member name="M:Mogre.Frustum.EnableCustomNearClipPlane(Mogre.Plane)">
      <summary>Links the frustum to a custom near clip plane, which can be used to clip geometry in a custom manner without using user clip planes. There are several applications for clipping a scene arbitrarily by a single plane; the most common is when rendering a reflection to a texture, and you only want to render geometry that is above the water plane (to do otherwise results in artefacts). Whilst it is possible to use user clip planes, they are not supported on all cards, and sometimes are not hardware accelerated when they are available. Instead, where a single clip plane is involved, this technique uses a 'fudging' of the near clip plane, which is available and fast on all hardware, to perform as the arbitrary clip plane. This does change the shape of the frustum, leading to some depth buffer loss of precision, but for many of the uses of this technique that is not an issue. This version of the method links to a plane, rather than requiring a by-value plane definition, and therefore you can make changes to the plane (e.g. by moving / rotating the node it is attached to) and they will automatically affect this object. This technique only works for perspective projection. </summary>
      <param name="plane">The plane to link to to perform the clipping. This plane must continue to exist while the camera is linked to it; do not destroy it before the frustum. </param>
    </member>
    <member name="M:Mogre.Frustum.EnableCustomNearClipPlane(Mogre.MovablePlane)">
      <summary>Links the frustum to a custom near clip plane, which can be used to clip geometry in a custom manner without using user clip planes. There are several applications for clipping a scene arbitrarily by a single plane; the most common is when rendering a reflection to a texture, and you only want to render geometry that is above the water plane (to do otherwise results in artefacts). Whilst it is possible to use user clip planes, they are not supported on all cards, and sometimes are not hardware accelerated when they are available. Instead, where a single clip plane is involved, this technique uses a 'fudging' of the near clip plane, which is available and fast on all hardware, to perform as the arbitrary clip plane. This does change the shape of the frustum, leading to some depth buffer loss of precision, but for many of the uses of this technique that is not an issue. This version of the method links to a plane, rather than requiring a by-value plane definition, and therefore you can make changes to the plane (e.g. by moving / rotating the node it is attached to) and they will automatically affect this object. This technique only works for perspective projection. </summary>
      <param name="plane">The plane to link to to perform the clipping. This plane must continue to exist while the camera is linked to it; do not destroy it before the frustum. </param>
    </member>
    <member name="M:Mogre.Frustum.DisableCustomNearClipPlane">
      <summary>Disables any custom near clip plane. </summary>
    </member>
    <member name="M:Mogre.Frustum._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Frustum._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Frustum.IsVisible">
      <summary>Tests whether the given container is visible in the Frustum. If the box was visible, true is returned. Otherwise, false is returned. </summary>
    </member>
    <member name="P:Mogre.Frustum.WorldSpaceCorners">
      <summary>Gets the world space corners of the frustum. The corners are ordered as follows: top-right near, top-left near, bottom-left near, bottom-right near, top-right far, top-left far, bottom-left far, bottom-right far. </summary>
    </member>
    <member name="P:Mogre.Frustum.ViewMatrix">
      <summary>Gets the view matrix for this frustum. Mainly for use by OGRE internally. </summary>
    </member>
    <member name="P:Mogre.Frustum.TypeFlags">
      <summary>Overridden from MovableObject::getTypeFlags. </summary>
    </member>
    <member name="P:Mogre.Frustum.ReflectionPlane">
      <summary>Returns the reflection plane of the frustum if appropriate. </summary>
    </member>
    <member name="P:Mogre.Frustum.ReflectionMatrix">
      <summary>Returns the reflection matrix of the frustum if appropriate. </summary>
    </member>
    <member name="P:Mogre.Frustum.ProjectionType">
      <summary>Sets/Retrieves info on the type of projection used (orthographic or perspective). </summary>
    </member>
    <member name="P:Mogre.Frustum.ProjectionMatrixWithRSDepth">
      <summary>Gets the depth-adjusted projection matrix for the current rendersystem, but one which still conforms to right-hand rules. This differs from the rendering-API dependent getProjectionMatrix in that it always returns a right-handed projection matrix result no matter what rendering API is being used - this is required for vertex and fragment programs for example. However, the resulting depth range may still vary between render systems since D3D uses [0,1] and GL uses [-1,1], and the range must be kept the same between programmable and fixed-function pipelines. </summary>
    </member>
    <member name="P:Mogre.Frustum.ProjectionMatrixRS">
      <summary>Gets the projection matrix for this frustum adjusted for the current rendersystem specifics (may be right or left-handed, depth range may vary). This method retrieves the rendering-API dependent version of the projection matrix. If you want a 'typical' projection matrix then use getProjectionMatrix. </summary>
    </member>
    <member name="P:Mogre.Frustum.ProjectionMatrix">
      <summary>Gets the normal projection matrix for this frustum, ie the projection matrix which conforms to standard right-handed rules and uses depth range [-1,+1]. This differs from the rendering-API dependent getProjectionMatrixRS in that it always returns a right-handed projection matrix with depth range [-1,+1], result no matter what rendering API is being used - this is required for some uniform algebra for example. </summary>
    </member>
    <member name="P:Mogre.Frustum.PositionForViewUpdate">
      <summary>Get the derived position of this frustum. </summary>
    </member>
    <member name="P:Mogre.Frustum.PlaneBoundedVolume">
      <summary>Gets a world-space list of planes enclosing the frustum. </summary>
    </member>
    <member name="P:Mogre.Frustum.OrthoWindowWidth">
      <summary>Sets/Gets the orthographic window width, for use with orthographic rendering only. This is calculated from the orthographic height and the aspect ratio </summary>
    </member>
    <member name="P:Mogre.Frustum.OrthoWindowHeight">
      <summary>Sets/Gets the orthographic window height, for use with orthographic rendering only. </summary>
    </member>
    <member name="P:Mogre.Frustum.OrientationMode">
      <summary>Sets/Get the orientation mode of the frustum. Getting the orientation of a frustum is only supported on iPhone at this time. An exception is thrown on other platforms. </summary>
    </member>
    <member name="P:Mogre.Frustum.OrientationForViewUpdate">
      <summary>Get the derived orientation of this frustum. </summary>
    </member>
    <member name="P:Mogre.Frustum.NearClipDistance">
      <summary>Sets/Sets the position of the near clipping plane. </summary>
    </member>
    <member name="P:Mogre.Frustum.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Frustum.IsReflected">
      <summary>Returns whether this frustum is being reflected. </summary>
    </member>
    <member name="P:Mogre.Frustum.IsCustomViewMatrixEnabled">
      <summary>Returns whether a custom view matrix is in use. </summary>
    </member>
    <member name="P:Mogre.Frustum.IsCustomProjectionMatrixEnabled">
      <summary>Returns whether a custom projection matrix is in use. </summary>
    </member>
    <member name="P:Mogre.Frustum.IsCustomNearClipPlaneEnabled">
      <summary>Is a custom near clip plane in use? </summary>
    </member>
    <member name="P:Mogre.Frustum.FrustumPlanes">
      <summary>Retrieves the clipping planes of the frustum (world space). The clipping planes are ordered as declared in enumerate constants FrustumPlane. </summary>
    </member>
    <member name="P:Mogre.Frustum.FrustumOffset">
      <summary>Sets/Retrieves the frustum offsets. </summary>
    </member>
    <member name="P:Mogre.Frustum.FOVy">
      <summary>Sets/Retrieves the frustums Y-dimension Field Of View (FOV). </summary>
    </member>
    <member name="P:Mogre.Frustum.FocalLength">
      <summary>Sets/Returns focal length of frustum. </summary>
    </member>
    <member name="P:Mogre.Frustum.FarClipDistance">
      <summary>Sets/Retrieves the distance from the frustum to the far clipping plane. </summary>
    </member>
    <member name="P:Mogre.Frustum.BoundingRadius">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Frustum.BoundingBox">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Frustum.AspectRatio">
      <summary>Sets/Retreives the current aspect ratio. </summary>
    </member>
    <member name="P:Mogre.Frustum.INFINITE_FAR_PLANE_ADJUST">
      <summary>Small constant used to reduce far plane projection to avoid inaccuracies. </summary>
    </member>
    <member name="T:Mogre.Camera">
      <summary>A viewpoint from which the scene will be rendered. OGRE renders scenes from a camera viewpoint into a buffer of some sort, normally a window or a texture (a subclass of RenderTarget). OGRE cameras support both perspective projection (the default, meaning objects get smaller the further away they are) and orthographic projection (blueprint-style, no decrease in size with distance). Each camera carries with it a style of rendering, e.g. full textured, flat shaded, wireframe), field of view, rendering distances etc, allowing you to use OGRE to create complex multi-window views if required. In addition, more than one camera can point at a single render target if required, each rendering to a subset of the target, allowing split screen and picture-in-picture views. Cameras maintain their own aspect ratios, field of view, and frustum, and project co-ordinates into a space measured from -1 to 1 in x and y, and 0 to 1 in z. At render time, the camera will be rendering to a Viewport which will translate these parametric co-ordinates into real screen co-ordinates. Obviously it is advisable that the viewport has the same aspect ratio as the camera to avoid distortion (unless you want it!). Note that a Camera can be attached to a SceneNode, using the method SceneNode::attachObject. If this is done the Camera will combine it's own position/orientation settings with it's parent SceneNode. This is useful for implementing more complex Camera / object relationships i.e. having a camera attached to a world object. </summary>
    </member>
    <member name="M:Mogre.Camera.SetPosition(System.Single,System.Single,System.Single)">
      <summary>Sets the camera's position. </summary>
    </member>
    <member name="M:Mogre.Camera.Move(Mogre.Vector3)">
      <summary>Moves the camera's position by the vector offset provided along world axes. </summary>
    </member>
    <member name="M:Mogre.Camera.MoveRelative(Mogre.Vector3)">
      <summary>Moves the camera's position by the vector offset provided along it's own axes (relative to orientation). </summary>
    </member>
    <member name="M:Mogre.Camera.SetDirection(System.Single,System.Single,System.Single)">
      <summary>Sets the camera's direction vector. Note that the 'up' vector for the camera will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). </summary>
    </member>
    <member name="M:Mogre.Camera.LookAt(System.Single,System.Single,System.Single)">
      <summary>Points the camera at a location in worldspace. This is a helper method to automatically generate the direction vector for the camera, based on it's current position and the supplied look-at point. </summary>
      <param name="x" />
      <param name="y" />
      <param name="z">Co-ordinates of the point to look at. </param>
    </member>
    <member name="M:Mogre.Camera.LookAt(Mogre.Vector3)">
      <summary>Points the camera at a location in worldspace. This is a helper method to automatically generate the direction vector for the camera, based on it's current position and the supplied look-at point. </summary>
      <param name="targetPoint">A vector specifying the look at point. </param>
    </member>
    <member name="M:Mogre.Camera.Roll(Mogre.Radian)">
      <summary>Rolls the camera anticlockwise, around its local z axis. </summary>
    </member>
    <member name="M:Mogre.Camera.Yaw(Mogre.Radian)">
      <summary>Rotates the camera anticlockwise around it's local y axis. </summary>
    </member>
    <member name="M:Mogre.Camera.Pitch(Mogre.Radian)">
      <summary>Pitches the camera up/down anticlockwise around it's local z axis. </summary>
    </member>
    <member name="M:Mogre.Camera.Rotate(Mogre.Quaternion)">
      <summary>Rotate the camera around an arbitrary axis using a Quaternion. </summary>
    </member>
    <member name="M:Mogre.Camera.Rotate(Mogre.Vector3,Mogre.Radian)">
      <summary>Rotate the camera around an arbitrary axis. </summary>
    </member>
    <member name="M:Mogre.Camera.SetFixedYawAxis(System.Boolean)">
      <summary>Tells the camera whether to yaw around it's own local Y axis or a fixed axis of choice. This method allows you to change the yaw behaviour of the cameraby default, the camera yaws around a fixed Y axis. This is often what you want - for example if you're making a first-person shooter, you really don't want the yaw axis to reflect the local camera Y, because this would mean a different yaw axis if the player is looking upwards rather than when they are looking straight ahead. You can change this behaviour by calling this method, which you will want to do if you are making a completely free camera like the kind used in a flight simulator. </summary>
      <param name="useFixed">If true, the axis passed in the second parameter will always be the yaw axis no matter what the camera orientation. If false, the camera yaws around the local Y. </param>
    </member>
    <member name="M:Mogre.Camera.SetFixedYawAxis(System.Boolean,Mogre.Vector3)">
      <summary>Tells the camera whether to yaw around it's own local Y axis or a fixed axis of choice. This method allows you to change the yaw behaviour of the cameraby default, the camera yaws around a fixed Y axis. This is often what you want - for example if you're making a first-person shooter, you really don't want the yaw axis to reflect the local camera Y, because this would mean a different yaw axis if the player is looking upwards rather than when they are looking straight ahead. You can change this behaviour by calling this method, which you will want to do if you are making a completely free camera like the kind used in a flight simulator. </summary>
      <param name="useFixed">If true, the axis passed in the second parameter will always be the yaw axis no matter what the camera orientation. If false, the camera yaws around the local Y. </param>
      <param name="fixedAxis">The axis to use if the first parameter is true. </param>
    </member>
    <member name="M:Mogre.Camera._renderScene(Mogre.Viewport,System.Boolean)">
      <summary>Tells the Camera to contact the SceneManager to render from it's viewpoint. </summary>
      <param name="vp">The viewport to render to </param>
      <param name="includeOverlays">Whether or not any overlay objects should be included </param>
    </member>
    <member name="M:Mogre.Camera._notifyRenderedFaces(System.UInt32)">
      <summary>Internal method to notify camera of the visible faces in the last render. </summary>
    </member>
    <member name="M:Mogre.Camera._notifyRenderedBatches(System.UInt32)">
      <summary>Internal method to notify camera of the visible batches in the last render. </summary>
    </member>
    <member name="M:Mogre.Camera._getNumRenderedFaces">
      <summary>Internal method to retrieve the number of visible faces in the last render. </summary>
    </member>
    <member name="M:Mogre.Camera._getNumRenderedBatches">
      <summary>Internal method to retrieve the number of visible batches in the last render. </summary>
    </member>
    <member name="M:Mogre.Camera.SetAutoTracking(System.Boolean)">
      <summary>Enables / disables automatic tracking of a SceneNode. If you enable auto-tracking, this Camera will automatically rotate to look at the target SceneNode every frame, no matter how it or SceneNode move. This is handy if you want a Camera to be focused on a single object or group of objects. Note that by default the Camera looks at the origin of the SceneNode, if you want to tweak this, e.g. if the object which is attached to this target node is quite big and you want to point the camera at a specific point on it, provide a vector in the 'offset' parameter and the camera's target point will be adjusted. </summary>
      <param name="enabled">If true, the Camera will track the SceneNode supplied as the next parameter (cannot be null). If false the camera will cease tracking and will remain in it's current orientation. </param>
    </member>
    <member name="M:Mogre.Camera.SetAutoTracking(System.Boolean,Mogre.SceneNode)">
      <summary>Enables / disables automatic tracking of a SceneNode. If you enable auto-tracking, this Camera will automatically rotate to look at the target SceneNode every frame, no matter how it or SceneNode move. This is handy if you want a Camera to be focused on a single object or group of objects. Note that by default the Camera looks at the origin of the SceneNode, if you want to tweak this, e.g. if the object which is attached to this target node is quite big and you want to point the camera at a specific point on it, provide a vector in the 'offset' parameter and the camera's target point will be adjusted. </summary>
      <param name="enabled">If true, the Camera will track the SceneNode supplied as the next parameter (cannot be null). If false the camera will cease tracking and will remain in it's current orientation. </param>
      <param name="target">Pointer to the SceneNode which this Camera will track. Make sure you don't delete this SceneNode before turning off tracking (e.g. SceneManager::clearScene will delete it so be careful of this). Can be null if and only if the enabled param is false. </param>
    </member>
    <member name="M:Mogre.Camera.SetAutoTracking(System.Boolean,Mogre.SceneNode,Mogre.Vector3)">
      <summary>Enables / disables automatic tracking of a SceneNode. If you enable auto-tracking, this Camera will automatically rotate to look at the target SceneNode every frame, no matter how it or SceneNode move. This is handy if you want a Camera to be focused on a single object or group of objects. Note that by default the Camera looks at the origin of the SceneNode, if you want to tweak this, e.g. if the object which is attached to this target node is quite big and you want to point the camera at a specific point on it, provide a vector in the 'offset' parameter and the camera's target point will be adjusted. </summary>
      <param name="enabled">If true, the Camera will track the SceneNode supplied as the next parameter (cannot be null). If false the camera will cease tracking and will remain in it's current orientation. </param>
      <param name="target">Pointer to the SceneNode which this Camera will track. Make sure you don't delete this SceneNode before turning off tracking (e.g. SceneManager::clearScene will delete it so be careful of this). Can be null if and only if the enabled param is false. </param>
      <param name="offset">If supplied, the camera targets this point in local space of the target node instead of the origin of the target node. Good for fine tuning the look at point. </param>
    </member>
    <member name="M:Mogre.Camera.GetCameraToViewportRay(System.Single,System.Single,Mogre.Ray*)">
      <summary>Gets a world space ray as cast from the camera through a viewport position. </summary>
      <param name="screenx">The x and y position at which the ray should intersect the viewport, in normalised screen coordinates [0,1] </param>
      <param name="outRay">Ray instance to populate with result </param>
    </member>
    <member name="M:Mogre.Camera.GetCameraToViewportRay(System.Single,System.Single)">
      <summary>Gets a world space ray as cast from the camera through a viewport position. </summary>
      <param name="screenx">The x and y position at which the ray should intersect the viewport, in normalised screen coordinates [0,1] </param>
    </member>
    <member name="M:Mogre.Camera.GetCameraToViewportBoxVolume(System.Single,System.Single,System.Single,System.Single,Mogre.PlaneBoundedVolume)">
      <summary>Gets a world-space list of planes enclosing a volume based on a viewport rectangle. Can be useful for populating a PlaneBoundedVolumeListSceneQuery, e.g. for a rubber-band selection. </summary>
      <param name="screenLeft">The bounds of the on-screen rectangle, expressed in normalised screen coordinates [0,1] </param>
      <param name="outVolume">The plane list to populate with the result </param>
    </member>
    <member name="M:Mogre.Camera.GetCameraToViewportBoxVolume(System.Single,System.Single,System.Single,System.Single,Mogre.PlaneBoundedVolume,System.Boolean)">
      <summary>Gets a world-space list of planes enclosing a volume based on a viewport rectangle. Can be useful for populating a PlaneBoundedVolumeListSceneQuery, e.g. for a rubber-band selection. </summary>
      <param name="screenLeft">The bounds of the on-screen rectangle, expressed in normalised screen coordinates [0,1] </param>
      <param name="outVolume">The plane list to populate with the result </param>
      <param name="includeFarPlane">If true, the volume is truncated by the camera far plane, by default it is left open-ended </param>
    </member>
    <member name="M:Mogre.Camera.GetCameraToViewportBoxVolume(System.Single,System.Single,System.Single,System.Single)">
      <summary>Gets a world-space list of planes enclosing a volume based on a viewport rectangle. Can be useful for populating a PlaneBoundedVolumeListSceneQuery, e.g. for a rubber-band selection. </summary>
      <param name="screenLeft">The bounds of the on-screen rectangle, expressed in normalised screen coordinates [0,1] </param>
    </member>
    <member name="M:Mogre.Camera.GetCameraToViewportBoxVolume(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>Gets a world-space list of planes enclosing a volume based on a viewport rectangle. Can be useful for populating a PlaneBoundedVolumeListSceneQuery, e.g. for a rubber-band selection. </summary>
      <param name="screenLeft">The bounds of the on-screen rectangle, expressed in normalised screen coordinates [0,1] </param>
      <param name="includeFarPlane">If true, the volume is truncated by the camera far plane, by default it is left open-ended </param>
    </member>
    <member name="M:Mogre.Camera._getLodBiasInverse">
      <summary>Internal method for OGRE to use for LOD calculations. </summary>
    </member>
    <member name="M:Mogre.Camera._autoTrack">
      <summary>Internal method used by OGRE to update auto-tracking cameras. </summary>
    </member>
    <member name="M:Mogre.Camera.SetWindow(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the viewing window inside of viewport. This method can be used to set a subset of the viewport as the rendering target. </summary>
      <param name="Left">Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 0). </param>
      <param name="Top">Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 0). </param>
      <param name="Right">Relative to Viewport - 0 corresponds to left edge, 1 - to right edge (default - 1). </param>
      <param name="Bottom">Relative to Viewport - 0 corresponds to top edge, 1 - to bottom edge (default - 1). </param>
    </member>
    <member name="M:Mogre.Camera.ResetWindow">
      <summary>Cancel view window. </summary>
    </member>
    <member name="M:Mogre.Camera.GetWindowPlanes">
      <summary>Gets the window clip planes, only applicable if isWindowSet == true. </summary>
    </member>
    <member name="M:Mogre.Camera._notifyViewport(Mogre.Viewport)">
      <summary>Notifies this camera that a viewport is using it. </summary>
    </member>
    <member name="M:Mogre.Camera.ForwardIntersect(Mogre.Plane,Mogre.Vector4[]&amp;)">
      <summary>Forward projects frustum rays to find forward intersection with plane. Forward projection may lead to intersections at infinity. </summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Vector3)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Vector3,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Sphere)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Sphere,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.AxisAlignedBox)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.AxisAlignedBox,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.GetFrustumPlane(System.UInt16)">
      <summary>Retrieves a specified plane of the frustum (world space). Gets a reference to one of the planes which make up the frustum frustum, e.g. for clipping purposes.</summary>
    </member>
    <member name="M:Mogre.Camera.ProjectSphere(Mogre.Sphere,System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;)">
      <summary>Project a sphere onto the near plane and get the bounding rectangle. sphereThe world-space sphere to project radiusRadius of the sphere lefttoprightbottomPointers to destination values, these will be completed with the normalised device coordinates (in the range {-1,1}) true if the sphere was projected to a subset of the near plane, false if the entire near plane was contained</summary>
    </member>
    <member name="M:Mogre.Camera.GetViewMatrix(System.Boolean)">
      <summary>Gets the view matrix for this frustum. Mainly for use by OGRE internally.</summary>
    </member>
    <member name="M:Mogre.Camera.SynchroniseBaseSettingsWith(Mogre.Camera)">
      <summary>Synchronise core camera settings with another. Copies the position, orientation, clip distances, projection type, FOV, focal length and aspect ratio from another camera. Other settings like query flags, reflection etc are preserved. </summary>
    </member>
    <member name="M:Mogre.Camera.GetFrustumPlane(System.UInt16)">
      <summary>Retrieves a specified plane of the frustum (world space). Gets a reference to one of the planes which make up the frustum frustum, e.g. for clipping purposes.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Vector3)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Vector3,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Sphere)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.Sphere,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.AxisAlignedBox)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible(Mogre.AxisAlignedBox,Mogre.FrustumPlane&amp;)">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.ProjectSphere(Mogre.Sphere,System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;)">
      <summary>Project a sphere onto the near plane and get the bounding rectangle. sphereThe world-space sphere to project radiusRadius of the sphere lefttoprightbottomPointers to destination values, these will be completed with the normalised device coordinates (in the range {-1,1}) true if the sphere was projected to a subset of the near plane, false if the entire near plane was contained</summary>
    </member>
    <member name="M:Mogre.Camera.IsVisible">
      <summary>Tests whether the given container is visible in the Frustum. boundBounding box to be checked (world space) culledByOptional pointer to an int which will be filled by the plane number which culled the box if the result was false; If the box was visible, true is returned. Otherwise, false is returned.</summary>
    </member>
    <member name="M:Mogre.Camera.#ctor(System.String,Mogre.SceneManager)">
      <summary>Standard constructor. </summary>
    </member>
    <member name="P:Mogre.Camera.WorldSpaceCorners">
      <summary>Gets the world space corners of the frustum. The corners are ordered as follows: top-right near, top-left near, bottom-left near, bottom-right near, top-right far, top-left far, bottom-left far, bottom-right far.</summary>
    </member>
    <member name="P:Mogre.Camera.Viewport">
      <summary>Get the last viewport which was attached to this camera. This is not guaranteed to be the only viewport which is using this camera, just the last once which was created referring to it. </summary>
    </member>
    <member name="P:Mogre.Camera.ViewMatrix">
      <summary>Gets the view matrix for this frustum. Mainly for use by OGRE internally.</summary>
    </member>
    <member name="P:Mogre.Camera.UseRenderingDistance">
      <summary>Sets/Get whether this camera should use the 'rendering distance' on objects to exclude distant objects from the final image. </summary>
    </member>
    <member name="P:Mogre.Camera.Up">
      <summary>Gets the camera's up vector. </summary>
    </member>
    <member name="P:Mogre.Camera.SceneManager">
      <summary>Returns a pointer to the SceneManager this camera is rendering through. </summary>
    </member>
    <member name="P:Mogre.Camera.Right">
      <summary>Gets the camera's right vector. </summary>
    </member>
    <member name="P:Mogre.Camera.RealUp">
      <summary>Gets the real world up vector of the camera, including any rotation inherited from a node attachment. </summary>
    </member>
    <member name="P:Mogre.Camera.RealRight">
      <summary>Gets the real world right vector of the camera, including any rotation inherited from a node attachment. </summary>
    </member>
    <member name="P:Mogre.Camera.RealPosition">
      <summary>Gets the real world position of the camera, including any translation inherited from a node attachment. </summary>
    </member>
    <member name="P:Mogre.Camera.RealOrientation">
      <summary>Gets the real world orientation of the camera, including any rotation inherited from a node attachment </summary>
    </member>
    <member name="P:Mogre.Camera.RealDirection">
      <summary>Gets the real world direction vector of the camera, including any rotation inherited from a node attachment. </summary>
    </member>
    <member name="P:Mogre.Camera.PositionForViewUpdate">
      <summary>Get the derived position of this frustum. </summary>
    </member>
    <member name="P:Mogre.Camera.Position">
      <summary>Sets/Retrieves the camera's position. </summary>
    </member>
    <member name="P:Mogre.Camera.PolygonMode">
      <summary>Sets/Retrieves the level of detail that the camera will render. </summary>
    </member>
    <member name="P:Mogre.Camera.OrientationForViewUpdate">
      <summary>Get the derived orientation of this frustum. </summary>
    </member>
    <member name="P:Mogre.Camera.Orientation">
      <summary>Sets/Returns the camera's current orientation. </summary>
    </member>
    <member name="P:Mogre.Camera.NearClipDistance">
      <summary>Sets/Sets the position of the near clipping plane.</summary>
    </member>
    <member name="P:Mogre.Camera.Name">
      <summary>Gets the camera's name. </summary>
    </member>
    <member name="P:Mogre.Camera.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Camera.LodCamera">
      <summary>Sets/Get a pointer to the camera which should be used to determine LOD settings. If setLodCamera hasn't been called with a different camera, this method will return 'this'. </summary>
    </member>
    <member name="P:Mogre.Camera.LodBias">
      <summary>Sets/Returns the level-of-detail bias factor currently applied to this camera. See Camera::setLodBias for more details. </summary>
    </member>
    <member name="P:Mogre.Camera.IsWindowSet">
      <summary>Returns if a viewport window is being used. </summary>
    </member>
    <member name="P:Mogre.Camera.FarClipDistance">
      <summary>Sets/Retrieves the distance from the frustum to the far clipping plane.</summary>
    </member>
    <member name="P:Mogre.Camera.DerivedUp">
      <summary>Gets the derived up vector of the camera, including any rotation inherited from a node attachment and reflection matrix. </summary>
    </member>
    <member name="P:Mogre.Camera.DerivedRight">
      <summary>Gets the derived right vector of the camera, including any rotation inherited from a node attachment and reflection matrix. </summary>
    </member>
    <member name="P:Mogre.Camera.DerivedPosition">
      <summary>Gets the derived position of the camera, including any translation inherited from a node attachment and reflection matrix. </summary>
    </member>
    <member name="P:Mogre.Camera.DerivedOrientation">
      <summary>Gets the derived orientation of the camera, including any rotation inherited from a node attachment and reflection matrix. </summary>
    </member>
    <member name="P:Mogre.Camera.DerivedDirection">
      <summary>Gets the derived direction vector of the camera, including any rotation inherited from a node attachment and reflection matrix. </summary>
    </member>
    <member name="P:Mogre.Camera.CullingFrustum">
      <summary>Sets/Returns the custom culling frustum in use. </summary>
    </member>
    <member name="P:Mogre.Camera.BoundingRadius">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Camera.AutoTrackTarget">
      <summary>Get the auto tracking target for this camera, if any. </summary>
    </member>
    <member name="P:Mogre.Camera.AutoTrackOffset">
      <summary>Get the auto tracking offset for this camera, if it is auto tracking. </summary>
    </member>
    <member name="P:Mogre.Camera.AutoAspectRatio">
      <summary>Sets/Retrieves if AutoAspectRatio is currently set or not </summary>
    </member>
    <member name="T:Mogre.LayerBlendModeEx_NativePtr">
      <summary>Class which manages blending of both colour and alpha components. This class is a utility class used by both TextureUnitState and RenderSystem to wrap up the details of a blending operation. This blending operation could be used for blending colour or alpha in a texture layer. This class is really only for use by OGRE, since apps can deal with blending modes through the TextureUnitState class methods setColourOperation and setAlphaOperation. It's worth noting that these operations are for blending between texture layers and not between rendered objects and the existing scene. If you wish to make an object blend with others in the scene, e.g. to make transparent objects etc, use the Material::setSceneBlending method. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.factor">
      <summary>Sets/Manual blending factor. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.alphaArg2">
      <summary>Sets/Manual alpha value for manual source2. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.alphaArg1">
      <summary>Sets/Manual alpha value for manual source1. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.colourArg2">
      <summary>Sets/Manual colour value for manual source2. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.colourArg1">
      <summary>Sets/Manual colour value for manual source1. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.source2">
      <summary>Sets/The second source of colour/alpha. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.source1">
      <summary>Sets/The first source of colour/alpha. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.operation">
      <summary>Sets/The operation to be applied. </summary>
    </member>
    <member name="P:Mogre.LayerBlendModeEx_NativePtr.blendType">
      <summary>Sets/The type of blending (colour or alpha). </summary>
    </member>
    <member name="T:Mogre.Material">
      <summary>Class encapsulates rendering properties of an object. Ogre's material class encapsulates ALL aspects of the visual appearance, of an object. It also includes other flags which might not be traditionally thought of as material properties such as culling modes and depth buffer settings, but these affect the appearance of the rendered object and are convenient to attach to the material since it keeps all the settings in one place. This is different to Direct3D which treats a material as just the colour components (diffuse, specular) and not texture maps etc. An OgreMaterial can be thought of as equivalent to a 'Shader'. A Material can be rendered in multiple different ways depending on the hardware available. You may configure a Material to use high-complexity fragment shaders, but these won't work on every card; therefore a Technique is an approach to creating the visual effect you are looking for. You are advised to create fallback techniques with lower hardware requirements if you decide to use advanced features. In addition, you also might want lower-detail techniques for distant geometry. Each technique can be made up of multiple passes. A fixed-function pass may combine multiple texture layers using multitexrtuing, but Ogre can break that into multiple passes automatically if the active card cannot handle that many simultaneous textures. Programmable passes, however, cannot be split down automatically, so if the active graphics card cannot handle the technique which contains these passes, OGRE will try to find another technique which the card can do. If, at the end of the day, the card cannot handle any of the techniques which are listed for the material, the engine will render the geometry plain white, which should alert you to the problem. Ogre comes configured with a number of default settings for a newly created material. These can be changed if you wish by retrieving the default material settings through SceneManager::getDefaultMaterialSettings. Any changes you make to the Material returned from this method will apply to any materials created from this point onward. </summary>
    </member>
    <member name="M:Mogre.Material.CreateTechnique">
      <summary>Creates a new Technique for this Material. A Technique is a single way of rendering geometry in order to achieve the effect you are intending in a material. There are many reason why you would want more than one - the main one being to handle variable graphics card abilities; you might have one technique which is impressive but only runs on 4th-generation graphics cards, for example. In this case you will want to create at least one fallback Technique. OGRE will work out which Techniques a card can support and pick the best one. If multiple Techniques are available, the order in which they are created is important - the engine will consider lower-indexed Techniques to be preferable to higher-indexed Techniques, ie when asked for the 'best' technique it will return the first one in the technique list which is supported by the hardware. </summary>
    </member>
    <member name="M:Mogre.Material.GetTechnique(System.String)">
      <summary>searches for the named technique. Return 0 if technique with name is not found </summary>
    </member>
    <member name="M:Mogre.Material.GetTechnique(System.UInt16)">
      <summary>Gets the indexed technique. </summary>
    </member>
    <member name="M:Mogre.Material.RemoveTechnique(System.UInt16)">
      <summary>Removes the technique at the given index. </summary>
    </member>
    <member name="M:Mogre.Material.RemoveAllTechniques">
      <summary>Removes all the techniques in this Material. </summary>
    </member>
    <member name="M:Mogre.Material.GetTechniqueIterator">
      <summary>Get an iterator over the Techniques in this Material. </summary>
    </member>
    <member name="M:Mogre.Material.GetSupportedTechniqueIterator">
      <summary>Gets an iterator over all the Techniques which are supported by the current card. The supported technique list is only available after this material has been compiled, which typically happens on loading the material. Therefore, if this method returns an empty list, try calling Material::load. </summary>
    </member>
    <member name="M:Mogre.Material.GetSupportedTechnique(System.UInt16)">
      <summary>Gets the indexed supported technique. </summary>
    </member>
    <member name="M:Mogre.Material.GetNumLodLevels(System.String)">
      <summary>Gets the number of levels-of-detail this material has in the given scheme, based on Technique::setLodIndex. Note that this will not be up to date until the material has been compiled. </summary>
    </member>
    <member name="M:Mogre.Material.GetNumLodLevels(System.UInt16)">
      <summary>Gets the number of levels-of-detail this material has in the given scheme, based on Technique::setLodIndex. Note that this will not be up to date until the material has been compiled. </summary>
    </member>
    <member name="M:Mogre.Material.GetBestTechnique">
      <summary>Gets the best supported technique. This method returns the lowest-index supported Technique in this material (since lower-indexed Techniques are considered to be better than higher-indexed ones). The best supported technique is only available after this material has been compiled, which typically happens on loading the material. Therefore, if this method returns NULL, try calling Material::load. </summary>
    </member>
    <member name="M:Mogre.Material.GetBestTechnique(System.UInt16)">
      <summary>Gets the best supported technique. This method returns the lowest-index supported Technique in this material (since lower-indexed Techniques are considered to be better than higher-indexed ones). The best supported technique is only available after this material has been compiled, which typically happens on loading the material. Therefore, if this method returns NULL, try calling Material::load. </summary>
      <param name="lodIndex">The material lod index to use </param>
    </member>
    <member name="M:Mogre.Material.GetBestTechnique(System.UInt16,Mogre.IRenderable)">
      <summary>Gets the best supported technique. This method returns the lowest-index supported Technique in this material (since lower-indexed Techniques are considered to be better than higher-indexed ones). The best supported technique is only available after this material has been compiled, which typically happens on loading the material. Therefore, if this method returns NULL, try calling Material::load. </summary>
      <param name="lodIndex">The material lod index to use </param>
      <param name="rend">Optional parameter specifying the Renderable that is requesting this technique. Only used if no valid technique for the active material scheme is found, at which point it is passed to MaterialManager::Listener::handleSchemeNotFound as information. </param>
    </member>
    <member name="M:Mogre.Material.Clone(System.String)">
      <summary>Creates a new copy of this material with the same settings but a new name. </summary>
      <param name="newName">The name for the cloned material </param>
    </member>
    <member name="M:Mogre.Material.Clone(System.String,System.Boolean)">
      <summary>Creates a new copy of this material with the same settings but a new name. </summary>
      <param name="newName">The name for the cloned material </param>
      <param name="changeGroup">If true, the resource group of the clone is changed </param>
    </member>
    <member name="M:Mogre.Material.Clone(System.String,System.Boolean,System.String)">
      <summary>Creates a new copy of this material with the same settings but a new name. </summary>
      <param name="newName">The name for the cloned material </param>
      <param name="changeGroup">If true, the resource group of the clone is changed </param>
      <param name="newGroup">Only required if changeGroup is true; the new group to assign </param>
    </member>
    <member name="M:Mogre.Material.CopyDetailsTo(Mogre.MaterialPtr)">
      <summary>Copies the details of this material into another, preserving the target's handle and name (unlike operator=) but copying everything else. </summary>
      <param name="mat">Weak reference to material which will receive this material's settings. </param>
    </member>
    <member name="M:Mogre.Material.Compile">
      <summary>'Compiles' this Material. Compiling a material involves determining which Techniques are supported on the card on which OGRE is currently running, and for fixed-function Passes within those Techniques, splitting the passes down where they contain more TextureUnitState instances than the current card has texture units. This process is automatically done when the Material is loaded, but may be repeated if you make some procedural changes. </summary>
    </member>
    <member name="M:Mogre.Material.Compile(System.Boolean)">
      <summary>'Compiles' this Material. Compiling a material involves determining which Techniques are supported on the card on which OGRE is currently running, and for fixed-function Passes within those Techniques, splitting the passes down where they contain more TextureUnitState instances than the current card has texture units. This process is automatically done when the Material is loaded, but may be repeated if you make some procedural changes. </summary>
      <param name="autoManageTextureUnits">If true, when a fixed function pass has too many TextureUnitState entries than the card has texture units, the Pass in question will be split into more than one Pass in order to emulate the Pass. If you set this to false and this situation arises, an Exception will be thrown. </param>
    </member>
    <member name="M:Mogre.Material.SetPointSize(System.Single)">
      <summary>Sets the point size properties for every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setPointSize</summary>
    </member>
    <member name="M:Mogre.Material.SetAmbient(Mogre.ColourValue)">
      <summary>Sets the ambient colour reflectance properties for every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setAmbient</summary>
    </member>
    <member name="M:Mogre.Material.SetAmbient(System.Single,System.Single,System.Single)">
      <summary>Sets the ambient colour reflectance properties for every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setAmbient</summary>
    </member>
    <member name="M:Mogre.Material.SetDiffuse(Mogre.ColourValue)">
      <summary>Sets the diffuse colour reflectance properties of every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setDiffuse</summary>
    </member>
    <member name="M:Mogre.Material.SetDiffuse(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the diffuse colour reflectance properties of every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setDiffuse</summary>
    </member>
    <member name="M:Mogre.Material.SetSpecular(Mogre.ColourValue)">
      <summary>Sets the specular colour reflectance properties of every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSpecular</summary>
    </member>
    <member name="M:Mogre.Material.SetSpecular(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the specular colour reflectance properties of every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSpecular</summary>
    </member>
    <member name="M:Mogre.Material.SetShininess(System.Single)">
      <summary>Sets the shininess properties of every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setShininess</summary>
    </member>
    <member name="M:Mogre.Material.SetSelfIllumination(Mogre.ColourValue)">
      <summary>Sets the amount of self-illumination of every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSelfIllumination</summary>
    </member>
    <member name="M:Mogre.Material.SetSelfIllumination(System.Single,System.Single,System.Single)">
      <summary>Sets the amount of self-illumination of every Pass in every Technique. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSelfIllumination</summary>
    </member>
    <member name="M:Mogre.Material.SetDepthCheckEnabled(System.Boolean)">
      <summary>Sets whether or not each Pass renders with depth-buffer checking on or not. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setDepthCheckEnabled</summary>
    </member>
    <member name="M:Mogre.Material.SetDepthWriteEnabled(System.Boolean)">
      <summary>Sets whether or not each Pass renders with depth-buffer writing on or not. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setDepthWriteEnabled</summary>
    </member>
    <member name="M:Mogre.Material.SetDepthFunction(Mogre.CompareFunction)">
      <summary>Sets the function used to compare depth values when depth checking is on. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setDepthFunction</summary>
    </member>
    <member name="M:Mogre.Material.SetColourWriteEnabled(System.Boolean)">
      <summary>Sets whether or not colour buffer writing is enabled for each Pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setColourWriteEnabled</summary>
    </member>
    <member name="M:Mogre.Material.SetCullingMode(Mogre.CullingMode)">
      <summary>Sets the culling mode for each pass based on the 'vertex winding'. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setCullingMode</summary>
    </member>
    <member name="M:Mogre.Material.SetManualCullingMode(Mogre.ManualCullingMode)">
      <summary>Sets the manual culling mode, performed by CPU rather than hardware. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setManualCullingMode</summary>
    </member>
    <member name="M:Mogre.Material.SetLightingEnabled(System.Boolean)">
      <summary>Sets whether or not dynamic lighting is enabled for every Pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setLightingEnabled</summary>
    </member>
    <member name="M:Mogre.Material.SetShadingMode(Mogre.ShadeOptions)">
      <summary>Sets the type of light shading required This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setShadingMode</summary>
    </member>
    <member name="M:Mogre.Material.SetFog(System.Boolean)">
      <summary>Sets the fogging mode applied to each pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Material.SetFog(System.Boolean,Mogre.FogMode)">
      <summary>Sets the fogging mode applied to each pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Material.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue)">
      <summary>Sets the fogging mode applied to each pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Material.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single)">
      <summary>Sets the fogging mode applied to each pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Material.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to each pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Material.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to each pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Material.SetDepthBias(System.Single,System.Single)">
      <summary>Sets the depth bias to be used for each Pass. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setDepthBias</summary>
    </member>
    <member name="M:Mogre.Material.SetTextureFiltering(Mogre.TextureFilterOptions)">
      <summary>Set texture filtering for every texture unit in every Technique and PassThis property has been moved to the TextureUnitState class, which is accessible via the Technique and Pass. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the Technique, Pass and TextureUnitState instances and set the property there. TextureUnitState::setTextureFiltering</summary>
    </member>
    <member name="M:Mogre.Material.SetTextureAnisotropy(System.Int32)">
      <summary>Sets the anisotropy level to be used for all textures. This property has been moved to the TextureUnitState class, which is accessible via the Technique and Pass. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the Technique, Pass and TextureUnitState instances and set the property there. TextureUnitState::setTextureAnisotropy</summary>
    </member>
    <member name="M:Mogre.Material.SetSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Allows very fine control of blending every Pass with the existing contents of the scene. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSceneBlending</summary>
    </member>
    <member name="M:Mogre.Material.SetSceneBlending(Mogre.SceneBlendType)">
      <summary>Sets the kind of blending every pass has with the existing contents of the scene. This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSceneBlending</summary>
    </member>
    <member name="M:Mogre.Material.SetSeparateSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Allows very fine control of blending every Pass with the existing contents of the scene, using individual factors for color and alpha channels This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSeparateSceneBlending</summary>
    </member>
    <member name="M:Mogre.Material.SetSeparateSceneBlending(Mogre.SceneBlendType,Mogre.SceneBlendType)">
      <summary>Sets the kind of blending every pass has with the existing contents of the scene, using individual factors for color and alpha channels This property has been moved to the Pass class, which is accessible via the Technique. For simplicity, this method allows you to set these properties for every current Technique, and for every current Pass within those Techniques. If you need more precision, retrieve the Technique and Pass instances and set the property there. Pass::setSeparateSceneBlending</summary>
    </member>
    <member name="M:Mogre.Material._notifyNeedsRecompile">
      <summary>Tells the material that it needs recompilation. </summary>
    </member>
    <member name="M:Mogre.Material.SetLodLevels(Mogre.Material+Const_LodValueList)">
      <summary>Sets the distance at which level-of-detail (LOD) levels come into effect. You should only use this if you have assigned LOD indexes to the Technique instances attached to this Material. If you have done so, you should call this method to determine the distance at which the lowe levels of detail kick in. The decision about what distance is actually used is a combination of this and the LOD bias applied to both the current Camera and the current Entity. </summary>
      <param name="lodValues">A vector of Reals which indicate the lod value at which to switch to lower details. They are listed in LOD index order, starting at index 1 (ie the first level down from the highest level 0, which automatically applies from a value of 0). These are 'user values', before being potentially transformed by the strategy, so for the distance strategy this is an unsquared distance for example. </param>
    </member>
    <member name="M:Mogre.Material.GetLodValueIterator">
      <summary>Gets an iterator over the list of values at which each LOD comes into effect. Note that the iterator returned from this method is not totally analogous to the one passed in by calling setLodLevels - the list includes a zero entry at the start (since the highest LOD starts at value 0). Also, the values returned are after being transformed by LodStrategy::transformUserValue. </summary>
    </member>
    <member name="M:Mogre.Material.GetLodIndex(System.Single)">
      <summary>Gets the LOD index to use at the given value. The value passed in is the 'transformed' value. If you are dealing with an original source value (e.g. distance), use LodStrategy::transformUserValue to turn this into a lookup value. </summary>
    </member>
    <member name="M:Mogre.Material.Touch">
      <summary>'Touches' the resource to indicate it has been used.</summary>
    </member>
    <member name="M:Mogre.Material.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. All techniques, passes, and Texture Unit States within the material are checked. If matching texture aliases are found then true is returned.</summary>
    </member>
    <member name="M:Mogre.Material.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList,System.Boolean)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. All techniques, passes, and Texture Unit States within the material are checked. If matching texture aliases are found then true is returned.</summary>
    </member>
    <member name="M:Mogre.Material.Touch">
      <summary>'Touches' the resource to indicate it has been used.</summary>
    </member>
    <member name="M:Mogre.Material.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String)">
      <summary>Constructor - use resource manager's create method rather than this. </summary>
    </member>
    <member name="M:Mogre.Material.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean)">
      <summary>Constructor - use resource manager's create method rather than this. </summary>
    </member>
    <member name="M:Mogre.Material.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Constructor - use resource manager's create method rather than this. </summary>
    </member>
    <member name="P:Mogre.Material.UnsupportedTechniquesExplanation">
      <summary>Gets a string explaining why any techniques are not supported. </summary>
    </member>
    <member name="P:Mogre.Material.TransparencyCastsShadows">
      <summary>Sets/Returns whether or not objects using this material be classified as opaque to the shadow caster system. </summary>
    </member>
    <member name="P:Mogre.Material.ReceiveShadows">
      <summary>Sets/Returns whether or not objects using this material will receive shadows. </summary>
    </member>
    <member name="P:Mogre.Material.NumTechniques">
      <summary>Retrieves the number of techniques. </summary>
    </member>
    <member name="P:Mogre.Material.NumSupportedTechniques">
      <summary>Retrieves the number of supported techniques. </summary>
    </member>
    <member name="P:Mogre.Material.LodStrategy">
      <summary>Sets/Get lod strategy used by this material. </summary>
    </member>
    <member name="P:Mogre.Material.IsTransparent">
      <summary>Determines if the material has any transparency with the rest of the scene (derived from whether any Techniques say they involve transparency). </summary>
    </member>
    <member name="P:Mogre.Material.CompilationRequired">
      <summary>Gets the compilation status of the material. True if the material needs recompilation. </summary>
    </member>
    <member name="T:Mogre.MaterialPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to MaterialPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.RenderQueueListener">
      <summary>Abstract interface which classes must implement if they wish to receive events from the render queue. The OGRE render queue is divided into several queue groups, as defined by uint8. A class may implement this interface, and register itself as a listener by calling SceneManager::addRenderQueueListener. After doing so, the class will receive an event before and after each queue group is sent to the rendering system. The event listeners have an option to make a queue either be skipped, or to repeat. Note that if multiple listeners are registered, the one registered last has the final say, although options set by previous listeners will not be changed if the latest does not express a preference. </summary>
    </member>
    <member name="T:Mogre.ShadowTextureConfig">
      <summary>Structure containing the configuration for one shadow texture. </summary>
    </member>
    <member name="T:Mogre.ShadowTextureManager">
      <summary>Class to manage the available shadow textures which may be shared between many SceneManager instances if formats agree. The management of the list of shadow textures has been separated out into a dedicated class to enable the clean management of shadow textures across many scene manager instances. Where multiple scene managers are used with shadow textures, the configuration of those shadows may or may not be consistent - if it is, it is good to centrally manage the textures so that creation and destruction responsibility is clear. </summary>
    </member>
    <member name="M:Mogre.ShadowTextureManager.GetShadowTextures(Mogre.Const_ShadowTextureConfigList,Mogre.ShadowTextureList)">
      <summary>Populate an incoming list with shadow texture references as requested in the configuration list. </summary>
    </member>
    <member name="M:Mogre.ShadowTextureManager.GetNullShadowTexture(Mogre.PixelFormat)">
      <summary>Get an appropriately defined 'null' texture, i.e. one which will always result in no shadows. </summary>
    </member>
    <member name="M:Mogre.ShadowTextureManager.ClearUnused">
      <summary>Remove any shadow textures that are no longer being referenced. This should be called fairly regularly since references may take a little while to disappear in some cases (if referenced by materials) </summary>
    </member>
    <member name="M:Mogre.ShadowTextureManager.Clear">
      <summary>Dereference all the shadow textures kept in this class and remove them from TextureManager; note that it is up to the SceneManagers to clear their local references. </summary>
    </member>
    <member name="P:Mogre.ShadowTextureManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.Light">
      <summary>Representation of a dynamic light source in the scene. Lights are added to the scene like any other object. They contain various parameters like type, position, attenuation (how light intensity fades with distance), colour etc. The defaults when a light is created is pure white diffuse light, with no attenuation (does not decrease with distance) and a range of 1000 world units. Lights are created by using the SceneManager::createLight method. They can subsequently be added to a SceneNode if required to allow them to move relative to a node in the scene. A light attached to a SceneNode is assumed to have a base position of (0,0,0) and a direction of (0,0,1) before modification by the SceneNode's own orientation. If not attached to a SceneNode, the light's position and direction is as set using setPosition and setDirection. Remember also that dynamic lights rely on modifying the colour of vertices based on the position of the light compared to an object's vertex normals. Dynamic lighting will only look good if the object being lit has a fair level of tessellation and the normals are properly set. This is particularly true for the spotlight which will only look right on highly tessellated models. In the future OGRE may be extended for certain scene types so an alternative to the standard dynamic lighting may be used, such as dynamic lightmaps. </summary>
    </member>
    <member name="M:Mogre.Light._calcTempSquareDist(Mogre.Vector3)">
      <summary>internal method for calculating current squared distance from some world position </summary>
    </member>
    <member name="M:Mogre.Light.SetDiffuseColour(System.Single,System.Single,System.Single)">
      <summary>Sets the colour of the diffuse light given off by this source. Material objects have ambient, diffuse and specular values which indicate how much of each type of light an object reflects. This value denotes the amount and colour of this type of light the light exudes into the scene. The actual appearance of objects is a combination of the two. Diffuse light simulates the typical light emanating from light sources and affects the base colour of objects together with ambient light. </summary>
    </member>
    <member name="M:Mogre.Light.SetSpecularColour(System.Single,System.Single,System.Single)">
      <summary>Sets the colour of the specular light given off by this source. Material objects have ambient, diffuse and specular values which indicate how much of each type of light an object reflects. This value denotes the amount and colour of this type of light the light exudes into the scene. The actual appearance of objects is a combination of the two. Specular light affects the appearance of shiny highlights on objects, and is also dependent on the 'shininess' Material value. </summary>
    </member>
    <member name="M:Mogre.Light.SetAttenuation(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the attenuation parameters of the light source i.e. how it diminishes with distance. Lights normally get fainter the further they are away. Also, each light is given a maximum range beyond which it cannot affect any objects. Light attenuation is not applicable to directional lights since they have an infinite range and constant intensity. This follows a standard attenuation approach - see any good 3D text for the details of what they mean since i don't have room here! </summary>
      <param name="range">The absolute upper range of the light in world units </param>
      <param name="constant">The constant factor in the attenuation formula: 1.0 means never attenuate, 0.0 is complete attenuation </param>
      <param name="linear">The linear factor in the attenuation formula: 1 means attenuate evenly over the distance </param>
      <param name="quadratic">The quadratic factor in the attenuation formula: adds a curvature to the attenuation formula. </param>
    </member>
    <member name="M:Mogre.Light.SetPosition(System.Single,System.Single,System.Single)">
      <summary>Sets the position of the light. Applicable to point lights and spotlights only. This will be overridden if the light is attached to a SceneNode. </summary>
    </member>
    <member name="M:Mogre.Light.SetDirection(System.Single,System.Single,System.Single)">
      <summary>Sets the direction in which a light points. Applicable only to the spotlight and directional light types. This will be overridden if the light is attached to a SceneNode. </summary>
    </member>
    <member name="M:Mogre.Light.SetSpotlightRange(Mogre.Radian,Mogre.Radian)">
      <summary>Sets the range of a spotlight, i.e. the angle of the inner and outer cones and the rate of falloff between them. </summary>
      <param name="innerAngle">Angle covered by the bright inner cone  The inner cone applicable only to Direct3D, it'll always treat as zero in OpenGL. </param>
      <param name="outerAngle">Angle covered by the outer cone </param>
    </member>
    <member name="M:Mogre.Light.SetSpotlightRange(Mogre.Radian,Mogre.Radian,System.Single)">
      <summary>Sets the range of a spotlight, i.e. the angle of the inner and outer cones and the rate of falloff between them. </summary>
      <param name="innerAngle">Angle covered by the bright inner cone  The inner cone applicable only to Direct3D, it'll always treat as zero in OpenGL. </param>
      <param name="outerAngle">Angle covered by the outer cone </param>
      <param name="falloff">The rate of falloff between the inner and outer cones. 1.0 means a linear falloff, less means slower falloff, higher means faster falloff. </param>
    </member>
    <member name="M:Mogre.Light._notifyAttached(Mogre.Node)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light._notifyMoved">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light.GetDerivedPosition">
      <summary>Retrieves the position of the light including any transform from nodes it is attached to. </summary>
    </member>
    <member name="M:Mogre.Light.GetDerivedPosition(System.Boolean)">
      <summary>Retrieves the position of the light including any transform from nodes it is attached to. </summary>
      <param name="cameraRelativeIfSet">If set to true, returns data in camera-relative units if that's been set up (render use) </param>
    </member>
    <member name="M:Mogre.Light.GetAs4DVector">
      <summary>Gets the details of this light as a 4D vector. Getting details of a light as a 4D vector can be useful for doing general calculations between different light types; for example the vector can represent both position lights (w=1.0f) and directional lights (w=0.0f) and be used in the same calculations. </summary>
    </member>
    <member name="M:Mogre.Light.GetAs4DVector(System.Boolean)">
      <summary>Gets the details of this light as a 4D vector. Getting details of a light as a 4D vector can be useful for doing general calculations between different light types; for example the vector can represent both position lights (w=1.0f) and directional lights (w=0.0f) and be used in the same calculations. </summary>
      <param name="cameraRelativeIfSet">If set to true, returns data in camera-relative units if that's been set up (render use) </param>
    </member>
    <member name="M:Mogre.Light._getNearClipVolume(Mogre.Camera)">
      <summary>Internal method for calculating the 'near clip volume', which is the volume formed between the near clip rectangle of the camera and the light. This volume is a pyramid for a point/spot light and a cuboid for a directional light. It can used to detect whether an object could be casting a shadow on the viewport. Note that the reference returned is to a shared volume which will be reused across calls to this method. </summary>
    </member>
    <member name="M:Mogre.Light._getFrustumClipVolumes(Mogre.Camera)">
      <summary>Internal method for calculating the clip volumes outside of the frustum which can be used to determine which objects are casting shadow on the frustum as a whole. Each of the volumes is a pyramid for a point/spot light and a cuboid for a directional light. </summary>
    </member>
    <member name="M:Mogre.Light.CreateAnimableValue(System.String)">
      <summary>Create a reference-counted AnimableValuePtr for the named value. You can use the returned object to animate a value on this object, using AnimationTrack. Subclasses must override this if they wish to support animation of their values.</summary>
    </member>
    <member name="M:Mogre.Light.SetCustomShadowCameraSetup(Mogre.ShadowCameraSetupPtr)">
      <summary>Set this light to use a custom shadow camera when rendering texture shadows. This changes the shadow camera setup for just this light, you can set the shadow camera setup globally using SceneManager::setShadowCameraSetupShadowCameraSetup</summary>
    </member>
    <member name="M:Mogre.Light.ResetCustomShadowCameraSetup">
      <summary>Reset the shadow camera setup to the default. ShadowCameraSetup</summary>
    </member>
    <member name="M:Mogre.Light.GetCustomShadowCameraSetup">
      <summary>return a pointer to the custom shadow camera setup (null means use SceneManager global version). </summary>
    </member>
    <member name="M:Mogre.Light._getIndexInFrame">
      <summary>Gets the index at which this light is in the current render. Lights will be present in the in a list for every renderable, detected and sorted appropriately, and sometimes it's useful to know what position in that list a given light occupies. This can vary from frame to frame (and object to object) so you should not use this value unless you're sure the context is correct. </summary>
    </member>
    <member name="M:Mogre.Light.ResetShadowFarDistance">
      <summary>Tells the light to use the shadow far distance of the SceneManager</summary>
    </member>
    <member name="M:Mogre.Light._deriveShadowNearClipDistance(Mogre.Camera)">
      <summary>Derive a shadow camera near distance from either the light, or from the main camera if the light doesn't have its own setting. </summary>
    </member>
    <member name="M:Mogre.Light._deriveShadowFarClipDistance(Mogre.Camera)">
      <summary>Derive a shadow camera far distance from either the light, or from the main camera if the light doesn't have its own setting. </summary>
    </member>
    <member name="M:Mogre.Light._setCameraRelative(Mogre.Camera)">
      <summary>Set the camera which this light should be relative to, for camera-relative rendering. </summary>
    </member>
    <member name="M:Mogre.Light.SetCustomParameter(System.UInt16,Mogre.Vector4)">
      <summary>Sets a custom parameter for this Light, which may be used to drive calculations for this specific Renderable, like GPU program parameters. Calling this method simply associates a numeric index with a 4-dimensional value for this specific Light. This is most useful if the material which this Renderable uses a vertex or fragment program, and has an ACT_LIGHT_CUSTOM parameter entry. This parameter entry can refer to the index you specify as part of this call, thereby mapping a custom parameter for this renderable to a program parameter. </summary>
      <param name="index">The index with which to associate the value. Note that this does not have to start at 0, and can include gaps. It also has no direct correlation with a GPU program parameter index - the mapping between the two is performed by the ACT_LIGHT_CUSTOM entry, if that is used. </param>
      <param name="value">The value to associate. </param>
    </member>
    <member name="M:Mogre.Light.GetCustomParameter(System.UInt16)">
      <summary>Gets the custom value associated with this Light at the given index. </summary>
    </member>
    <member name="M:Mogre.Light._updateCustomGpuParameter(System.UInt16,Mogre.GpuProgramParameters+AutoConstantEntry_NativePtr,Mogre.GpuProgramParameters)">
      <summary>Update a custom GpuProgramParameters constant which is derived from information only this Light knows. This method allows a Light to map in a custom GPU program parameter based on it's own data. This is represented by a GPU auto parameter of ACT_LIGHT_CUSTOM, and to allow there to be more than one of these per Light, the 'data' field on the auto parameter will identify which parameter is being updated and on which light. The implementation of this method must identify the parameter being updated, and call a 'setConstant' method on the passed in GpuProgramParameters object. You do not need to override this method if you're using the standard sets of data associated with the Renderable as provided by setCustomParameter and getCustomParameter. By default, the implementation will map from the value indexed by the 'constantEntry.data' parameter to a value previously set by setCustomParameter. But custom Renderables are free to override this if they want, in any case. </summary>
      <param name="paramIndex">The index of the constant being updated </param>
      <param name="constantEntry">The auto constant entry from the program parameters </param>
      <param name="params">The parameters object which this method should call to set the updated parameters. </param>
    </member>
    <member name="M:Mogre.Light._notifyAttached(Mogre.Node)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light._notifyMoved">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="M:Mogre.Light.#ctor(System.String)">
      <summary>Normal constructor. Should not be called directly, but rather the SceneManager::createLight method should be used. </summary>
    </member>
    <member name="M:Mogre.Light.#ctor">
      <summary>Default constructor (for Python mainly). </summary>
    </member>
    <member name="P:Mogre.Light.TypeFlags">
      <summary>Override to return specific type flag. </summary>
    </member>
    <member name="P:Mogre.Light.Type">
      <summary>Sets/Returns the light type. </summary>
    </member>
    <member name="P:Mogre.Light.SpotlightOuterAngle">
      <summary>Sets/Returns the angle covered by the spotlights outer cone. </summary>
    </member>
    <member name="P:Mogre.Light.SpotlightInnerAngle">
      <summary>Sets/Returns the angle covered by the spotlights inner cone. </summary>
    </member>
    <member name="P:Mogre.Light.SpotlightFalloff">
      <summary>Sets/Returns the falloff between the inner and outer cones of the spotlight. </summary>
    </member>
    <member name="P:Mogre.Light.SpecularColour">
      <summary>Sets/Returns the colour of specular light given off by this light source. </summary>
    </member>
    <member name="P:Mogre.Light.ShadowNearClipDistance">
      <summary>Sets/Get the near clip plane distance to be used by the shadow camera, if this light casts texture shadows. May be zero if the light doesn't have it's own near distance set; use _deriveShadowNearDistance for a version guaranteed to give a result. </summary>
    </member>
    <member name="P:Mogre.Light.ShadowFarDistance">
      <summary>Sets/Gets the maximum distance away from the camera that shadows by this light will be visible. </summary>
    </member>
    <member name="P:Mogre.Light.ShadowFarClipDistance">
      <summary>Sets/Get the far clip plane distance to be used by the shadow camera, if this light casts texture shadows. May be zero if the light doesn't have it's own far distance set; use _deriveShadowfarDistance for a version guaranteed to give a result. </summary>
    </member>
    <member name="P:Mogre.Light.PowerScale">
      <summary>Sets/Set the scaling factor which indicates the relative power of a light. </summary>
    </member>
    <member name="P:Mogre.Light.Position">
      <summary>Sets/Returns the position of the light. Applicable to point lights and spotlights only. </summary>
    </member>
    <member name="P:Mogre.Light.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Light.Direction">
      <summary>Sets/Returns the light's direction. Applicable only to the spotlight and directional light types. </summary>
    </member>
    <member name="P:Mogre.Light.DiffuseColour">
      <summary>Sets/Returns the colour of the diffuse light given off by this light source (see setDiffuseColour for more info). </summary>
    </member>
    <member name="P:Mogre.Light.DerivedDirection">
      <summary>Retrieves the direction of the light including any transform from nodes it is attached to. </summary>
    </member>
    <member name="P:Mogre.Light.BoundingRadius">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Light.BoundingBox">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.Light.AttenuationRange">
      <summary>Returns the absolute upper range of the light. </summary>
    </member>
    <member name="P:Mogre.Light.AttenuationQuadric">
      <summary>Returns the quadric factor in the attenuation formula. </summary>
    </member>
    <member name="P:Mogre.Light.AttenuationLinear">
      <summary>Returns the linear factor in the attenuation formula. </summary>
    </member>
    <member name="P:Mogre.Light.AttenuationConstant">
      <summary>Returns the constant factor in the attenuation formula. </summary>
    </member>
    <member name="P:Mogre.Light.tempSquareDist">
      <summary>Sets/Temp tag used for sorting. </summary>
    </member>
    <member name="T:Mogre.Light+LightTypes">
      <summary>Defines the type of light. </summary>
    </member>
    <member name="F:Mogre.Light+LightTypes.LT_POINT">
      <summary>Point light sources give off light equally in all directions, so require only position not direction. </summary>
    </member>
    <member name="F:Mogre.Light+LightTypes.LT_DIRECTIONAL">
      <summary>Directional lights simulate parallel light beams from a distant source, hence have direction but no position. </summary>
    </member>
    <member name="F:Mogre.Light+LightTypes.LT_SPOTLIGHT">
      <summary>Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. </summary>
    </member>
    <member name="T:Mogre.LightFactory">
      <summary>Factory object for creating Light instances </summary>
    </member>
    <member name="T:Mogre.RenderablePass_NativePtr">
      <summary>Struct associating a single Pass with a single Renderable. This is used to for objects sorted by depth and thus not grouped by pass. </summary>
    </member>
    <member name="P:Mogre.RenderablePass_NativePtr.pass">
      <summary>Pointer to the Pass. </summary>
    </member>
    <member name="P:Mogre.RenderablePass_NativePtr.renderable">
      <summary>Pointer to the Renderable details. </summary>
    </member>
    <member name="T:Mogre.QueuedRenderableVisitor">
      <summary>Visitor interface for items in a QueuedRenderableCollection. Those wishing to iterate over the items in a QueuedRenderableCollection should implement this visitor pattern, since internal organisation of the collection depends on the sorting method in use. </summary>
    </member>
    <member name="M:Mogre.QueuedRenderableVisitor.Visit(Mogre.IRenderable)">
      <summary>Visit method called once per Renderable on a grouped collection. If this method is called, the RenderablePass visit method will not be called for this collection. </summary>
    </member>
    <member name="M:Mogre.QueuedRenderableVisitor.Visit(Mogre.RenderablePass_NativePtr)">
      <summary>Called when visiting a RenderablePass, i.e. items in a sorted collection where items are not grouped by pass. If this is called, neither of the other 2 visit methods will be called. </summary>
    </member>
    <member name="T:Mogre.QueuedRenderableCollection">
      <summary>Lowest level collection of renderables. To iterate over items in this collection, you must call the accept method and supply a QueuedRenderableVisitor. The order of the iteration, and whether that iteration is over a RenderablePass list or a 2-level grouped list which causes a visit call at the Pass level, and a call for each Renderable underneath. </summary>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.Clear">
      <summary>Empty the collection. </summary>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.RemovePassGroup(Mogre.Pass)">
      <summary>Remove the group entry (if any) for a given Pass. To be used when a pass is destroyed, such that any grouping level for it becomes useless. </summary>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.ResetOrganisationModes">
      <summary>Reset the organisation modes required for this collection. You can only do this when the collection is empty. OrganisationMode</summary>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.AddOrganisationMode(Mogre.QueuedRenderableCollection+OrganisationMode)">
      <summary>Add a required sorting / grouping mode to this collection when next used. You can only do this when the collection is empty. OrganisationMode</summary>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.AddRenderable(Mogre.Pass,Mogre.IRenderable)">
      <summary>Add a renderable to the collection using a given pass. </summary>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.Sort(Mogre.Camera)">
      <summary>Perform any sorting that is required on this collection. </summary>
      <param name="cam">The camera </param>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.AcceptVisitor(Mogre.IQueuedRenderableVisitor,Mogre.QueuedRenderableCollection+OrganisationMode)">
      <summary>Accept a visitor over the collection contents. </summary>
      <param name="visitor">Visitor class which should be called back </param>
      <param name="om">The organisation mode which you want to iterate over. Note that this must have been included in an addOrganisationMode call before any renderables were added. </param>
    </member>
    <member name="M:Mogre.QueuedRenderableCollection.Merge(Mogre.QueuedRenderableCollection)">
      <summary>Merge renderable collection. </summary>
    </member>
    <member name="T:Mogre.QueuedRenderableCollection+OrganisationMode">
      <summary>Organisation modes required for this collection. This affects the internal placement of the items added to this collection; if only one type of sorting / grouping is to be required, then renderables can be stored only once, whilst if multiple types are going to be needed then internally there will be multiple organisations. Changing the organisation needs to be done when the collection is empty. </summary>
    </member>
    <member name="F:Mogre.QueuedRenderableCollection+OrganisationMode.OM_PASS_GROUP">
      <summary>Group by pass. </summary>
    </member>
    <member name="F:Mogre.QueuedRenderableCollection+OrganisationMode.OM_SORT_DESCENDING">
      <summary>Sort descending camera distance. </summary>
    </member>
    <member name="F:Mogre.QueuedRenderableCollection+OrganisationMode.OM_SORT_ASCENDING">
      <summary>Sort ascending camera distance Note value overlaps with descending since both use same sort </summary>
    </member>
    <member name="T:Mogre.RenderPriorityGroup">
      <summary>Collection of renderables by priority. This class simply groups renderables for rendering. All the renderables contained in this class are destined for the same RenderQueueGroup (coarse groupings like those between the main scene and overlays) and have the same priority (fine groupings for detailed overlap control). This class can order solid renderables by a number of criteria; it can optimise them into groups based on pass to reduce render state changes, or can sort them by ascending or descending view depth. Transparent objects are always ordered by descending depth. To iterate over items in the collections held by this object you should retrieve the collection in use (e.g. solids, solids with no shadows, transparents) and use the accept() method, providing a class implementing QueuedRenderableVisitor. </summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.ResetOrganisationModes">
      <summary>Reset the organisation modes required for the solids in this group. You can only do this when the group is empty, i.e. after clearing the queue. QueuedRenderableCollection::OrganisationMode</summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.AddOrganisationMode(Mogre.QueuedRenderableCollection+OrganisationMode)">
      <summary>Add a required sorting / grouping mode for the solids in this group. You can only do this when the group is empty, i.e. after clearing the queue. QueuedRenderableCollection::OrganisationMode</summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.DefaultOrganisationMode">
      <summary>Set the sorting / grouping mode for the solids in this group to the default. You can only do this when the group is empty, i.e. after clearing the queue. QueuedRenderableCollection::OrganisationMode</summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.AddRenderable(Mogre.IRenderable,Mogre.Technique)">
      <summary>Add a renderable to this group. </summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.Sort(Mogre.Camera)">
      <summary>Sorts the objects which have been added to the queue; transparent objects by their depth in relation to the passed in Camera. </summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.Clear">
      <summary>Clears this group of renderables. </summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.SetSplitPassesByLightingType(System.Boolean)">
      <summary>Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.SetSplitNoShadowPasses(System.Boolean)">
      <summary>Sets whether or not passes which have shadow receive disabled should be separated. </summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.SetShadowCastersCannotBeReceivers(System.Boolean)">
      <summary>Sets whether or not objects which cast shadows should be treated as never receiving shadows. </summary>
    </member>
    <member name="M:Mogre.RenderPriorityGroup.Merge(Mogre.RenderPriorityGroup)">
      <summary>Merge group of renderables. </summary>
    </member>
    <member name="P:Mogre.RenderPriorityGroup.TransparentsUnsorted">
      <summary>Get the collection of transparent objects currently queued </summary>
    </member>
    <member name="P:Mogre.RenderPriorityGroup.Transparents">
      <summary>Get the collection of transparent objects currently queued </summary>
    </member>
    <member name="P:Mogre.RenderPriorityGroup.SolidsNoShadowReceive">
      <summary>Get the collection of solids for which shadow receipt is disabled (only applicable when shadows are enabled). </summary>
    </member>
    <member name="P:Mogre.RenderPriorityGroup.SolidsDiffuseSpecular">
      <summary>Get the collection of solids currently queued per light (only applicable in additive shadow modes). </summary>
    </member>
    <member name="P:Mogre.RenderPriorityGroup.SolidsDecal">
      <summary>Get the collection of solids currently queued for decal passes (only applicable in additive shadow modes). </summary>
    </member>
    <member name="P:Mogre.RenderPriorityGroup.SolidsBasic">
      <summary>Get the collection of basic solids currently queued, this includes all solids when there are no shadows, or all solids which have shadow receiving enabled when using modulative shadows, or all ambient passes of solids which have shadow receive enabled for additive shadows. </summary>
    </member>
    <member name="T:Mogre.RenderQueueGroup">
      <summary>A grouping level underneath RenderQueue which groups renderables to be issued at coarsely the same time to the renderer. Each instance of this class itself hold RenderPriorityGroup instances, which are the groupings of renderables by priority for fine control of ordering (not required for most instances). </summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.GetIterator">
      <summary>Get an iterator for browsing through child contents. </summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.AddRenderable(Mogre.IRenderable,Mogre.Technique,System.UInt16)">
      <summary>Add a renderable to this group, with the given priority. </summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.Clear">
      <summary>Clears this group of renderables. </summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.Clear(System.Boolean)">
      <summary>Clears this group of renderables. </summary>
      <param name="destroy">If false, doesn't delete any priority groups, just empties them. Saves on memory deallocations since the chances are roughly the same kinds of renderables are going to be sent to the queue again next time. If true, completely destroys. </param>
    </member>
    <member name="M:Mogre.RenderQueueGroup.SetSplitPassesByLightingType(System.Boolean)">
      <summary>Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.SetSplitNoShadowPasses(System.Boolean)">
      <summary>Sets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used. </summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.SetShadowCastersCannotBeReceivers(System.Boolean)">
      <summary>Sets whether or not objects which cast shadows should be treated as never receiving shadows. </summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.ResetOrganisationModes">
      <summary>Reset the organisation modes required for the solids in this group. You can only do this when the group is empty, ie after clearing the queue. QueuedRenderableCollection::OrganisationMode</summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.AddOrganisationMode(Mogre.QueuedRenderableCollection+OrganisationMode)">
      <summary>Add a required sorting / grouping mode for the solids in this group. You can only do this when the group is empty, ie after clearing the queue. QueuedRenderableCollection::OrganisationMode</summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.DefaultOrganisationMode">
      <summary>Setthe sorting / grouping mode for the solids in this group to the default. You can only do this when the group is empty, ie after clearing the queue. QueuedRenderableCollection::OrganisationMode</summary>
    </member>
    <member name="M:Mogre.RenderQueueGroup.Merge(Mogre.RenderQueueGroup)">
      <summary>Merge group of renderables. </summary>
    </member>
    <member name="P:Mogre.RenderQueueGroup.ShadowsEnabled">
      <summary>Sets/Are shadows enabled for this queue? </summary>
    </member>
    <member name="T:Mogre.EntityMaterialLodChangedEvent_NativePtr">
      <summary>Struct containing information about a material lod change event for entities. </summary>
    </member>
    <member name="P:Mogre.EntityMaterialLodChangedEvent_NativePtr.newLodIndex">
      <summary>New level of detail index. </summary>
    </member>
    <member name="P:Mogre.EntityMaterialLodChangedEvent_NativePtr.previousLodIndex">
      <summary>Previous level of detail index. </summary>
    </member>
    <member name="P:Mogre.EntityMaterialLodChangedEvent_NativePtr.lodValue">
      <summary>Lod value as determined by lod strategy. </summary>
    </member>
    <member name="P:Mogre.EntityMaterialLodChangedEvent_NativePtr.camera">
      <summary>The camera with respect to which the level of detail has changed. </summary>
    </member>
    <member name="P:Mogre.EntityMaterialLodChangedEvent_NativePtr.subEntity">
      <summary>The sub-entity whose material's level of detail has changed. </summary>
    </member>
    <member name="T:Mogre.EntityMeshLodChangedEvent_NativePtr">
      <summary>Struct containing information about a mesh lod change event for entities. </summary>
    </member>
    <member name="P:Mogre.EntityMeshLodChangedEvent_NativePtr.newLodIndex">
      <summary>New level of detail index. </summary>
    </member>
    <member name="P:Mogre.EntityMeshLodChangedEvent_NativePtr.previousLodIndex">
      <summary>Previous level of detail index. </summary>
    </member>
    <member name="P:Mogre.EntityMeshLodChangedEvent_NativePtr.lodValue">
      <summary>Lod value as determined by lod strategy. </summary>
    </member>
    <member name="P:Mogre.EntityMeshLodChangedEvent_NativePtr.camera">
      <summary>The camera with respect to which the level of detail has changed. </summary>
    </member>
    <member name="P:Mogre.EntityMeshLodChangedEvent_NativePtr.entity">
      <summary>The entity whose level of detail has changed. </summary>
    </member>
    <member name="T:Mogre.MovableObjectLodChangedEvent_NativePtr">
      <summary>Struct containing information about a lod change event for movable objects. </summary>
    </member>
    <member name="P:Mogre.MovableObjectLodChangedEvent_NativePtr.camera">
      <summary>The camera with respect to which the level of detail has changed. </summary>
    </member>
    <member name="P:Mogre.MovableObjectLodChangedEvent_NativePtr.movableObject">
      <summary>The movable object whose level of detail has changed. </summary>
    </member>
    <member name="T:Mogre.LodListener">
      <summary>A interface class defining a listener which can be used to receive notifications of lod events. A 'listener' is an interface designed to be called back when particular events are called. This class defines the interface relating to lod events. In order to receive notifications of lod events, you should create a subclass of LodListener and override the methods for which you would like to customise the resulting processing. You should then call SceneManager::addLodListener passing an instance of this class. There is no limit to the number of lod listeners you can register, allowing you to register multiple listeners for different purposes.
For some uses, it may be advantageous to also subclass RenderQueueListener as this interface makes available information regarding render queue invocations.</summary>
    </member>
    <member name="M:Mogre.LodListener.PrequeueMovableObjectLodChanged(Mogre.MovableObjectLodChangedEvent_NativePtr)">
      <summary>Called before a movable object's lod has changed. Do not change the Ogre state from this method, instead return true and perform changes in postqueueMovableObjectLodChanged. True to indicate the event should be queued and postqueueMovableObjectLodChanged called after rendering is complete. </summary>
    </member>
    <member name="M:Mogre.LodListener.PostqueueMovableObjectLodChanged(Mogre.MovableObjectLodChangedEvent_NativePtr)">
      <summary>Called after a movable object's lod has changed. May be called even if not requested from prequeueMovableObjectLodChanged as only one event queue is maintained per SceneManger instance. </summary>
    </member>
    <member name="M:Mogre.LodListener.PrequeueEntityMeshLodChanged(Mogre.EntityMeshLodChangedEvent_NativePtr)">
      <summary>Called before an entity's mesh lod has changed. Do not change the Ogre state from this method, instead return true and perform changes in postqueueEntityMeshLodChanged.
It is possible to change the event notification and even alter the newLodIndex field (possibly to prevent the lod from changing, or to skip an index). True to indicate the event should be queued and postqueueEntityMeshLodChanged called after rendering is complete. </summary>
    </member>
    <member name="M:Mogre.LodListener.PostqueueEntityMeshLodChanged(Mogre.EntityMeshLodChangedEvent_NativePtr)">
      <summary>Called after an entity's mesh lod has changed. May be called even if not requested from prequeueEntityMeshLodChanged as only one event queue is maintained per SceneManger instance. </summary>
    </member>
    <member name="M:Mogre.LodListener.PrequeueEntityMaterialLodChanged(Mogre.EntityMaterialLodChangedEvent_NativePtr)">
      <summary>Called before an entity's material lod has changed. Do not change the Ogre state from this method, instead return true and perform changes in postqueueMaterialLodChanged.
It is possible to change the event notification and even alter the newLodIndex field (possibly to prevent the lod from changing, or to skip an index). True to indicate the event should be queued and postqueueMaterialLodChanged called after rendering is complete. </summary>
    </member>
    <member name="M:Mogre.LodListener.PostqueueEntityMaterialLodChanged(Mogre.EntityMaterialLodChangedEvent_NativePtr)">
      <summary>Called after an entity's material lod has changed. May be called even if not requested from prequeueEntityMaterialLodChanged as only one event queue is maintained per SceneManger instance. </summary>
    </member>
    <member name="T:Mogre.SceneQuery">
      <summary>A class for performing queries on a scene. This is an abstract class for performing a query on a scene, i.e. to retrieve a list of objects and/or world geometry sections which are potentially intersecting a given region. Note the use of the word 'potentially': the results of a scene query are generated based on bounding volumes, and as such are not correct at a triangle level; the user of the SceneQuery is expected to filter the results further if greater accuracy is required. Different SceneManagers will implement these queries in different ways to exploit their particular scene organisation, and thus will provide their own concrete subclasses. In fact, these subclasses will be derived from subclasses of this class rather than directly because there will be region-type classes in between. These queries could have just been implemented as methods on the SceneManager, however, they are wrapped up as objects to allow 'compilation' of queries if deemed appropriate by the implementation; i.e. each concrete subclass may precalculate information (such as fixed scene partitions involved in the query) to speed up the repeated use of the query. You should never try to create a SceneQuery object yourself, they should be created using the SceneManager interfaces for the type of query required, e.g. SceneManager::createSphereSceneQuery. </summary>
    </member>
    <member name="M:Mogre.SceneQuery.SetWorldFragmentType(Mogre.SceneQuery+WorldFragmentType)">
      <summary>Tells the query what kind of world geometry to return from queries; often the full renderable geometry is not what is needed. The application receiving the world geometry is expected to know what to do with it; inevitably this means that the application must have knowledge of at least some of the structures used by the custom SceneManager. The default setting is WFT_NONE. </summary>
    </member>
    <member name="M:Mogre.SceneQuery.GetWorldFragmentType">
      <summary>Gets the current world fragment types to be returned from the query. </summary>
    </member>
    <member name="M:Mogre.SceneQuery.#ctor(Mogre.SceneManager)">
      <summary>Standard constructor, should be called by SceneManager. </summary>
    </member>
    <member name="P:Mogre.SceneQuery.QueryTypeMask">
      <summary>Sets/Returns the current mask for this query. </summary>
    </member>
    <member name="P:Mogre.SceneQuery.QueryMask">
      <summary>Sets/Returns the current mask for this query. </summary>
    </member>
    <member name="T:Mogre.SceneQuery+WorldFragmentType">
      <summary>This type can be used by collaborating applications &amp; SceneManagers to agree on the type of world geometry to be returned from queries. Not all these types will be supported by all SceneManagers; once the application has decided which SceneManager specialisation to use, it is expected that it will know which type of world geometry abstraction is available to it. </summary>
    </member>
    <member name="F:Mogre.SceneQuery+WorldFragmentType.WFT_NONE">
      <summary>Return no world geometry hits at all. </summary>
    </member>
    <member name="F:Mogre.SceneQuery+WorldFragmentType.WFT_PLANE_BOUNDED_REGION">
      <summary>Return pointers to convex plane-bounded regions. </summary>
    </member>
    <member name="F:Mogre.SceneQuery+WorldFragmentType.WFT_SINGLE_INTERSECTION">
      <summary>Return a single intersection point (typically RaySceneQuery only). </summary>
    </member>
    <member name="F:Mogre.SceneQuery+WorldFragmentType.WFT_CUSTOM_GEOMETRY">
      <summary>Custom geometry as defined by the SceneManager. </summary>
    </member>
    <member name="F:Mogre.SceneQuery+WorldFragmentType.WFT_RENDER_OPERATION">
      <summary>General RenderOperation structure. </summary>
    </member>
    <member name="T:Mogre.SceneQueryListener">
      <summary>This optional class allows you to receive per-result callbacks from SceneQuery executions instead of a single set of consolidated results. You should override this with your own subclass. Note that certain query classes may refine this listener interface. </summary>
    </member>
    <member name="M:Mogre.SceneQueryListener.QueryResult(Mogre.SceneQuery+WorldFragment)">
      <summary>Called when a WorldFragment is returned by a query. The implementor should return 'true' to continue returning objects, or 'false' to abandon any further results from this query. </summary>
    </member>
    <member name="M:Mogre.SceneQueryListener.QueryResult(Mogre.MovableObject)">
      <summary>Called when a MovableObject is returned by a query. The implementor should return 'true' to continue returning objects, or 'false' to abandon any further results from this query. </summary>
    </member>
    <member name="T:Mogre.SceneQueryResult">
      <summary>Holds the results of a scene query. </summary>
    </member>
    <member name="P:Mogre.SceneQueryResult.worldFragments">
      <summary>List of world fragments. </summary>
    </member>
    <member name="P:Mogre.SceneQueryResult.movables">
      <summary>List of movable objects in the query (entities, particle systems etc). </summary>
    </member>
    <member name="T:Mogre.RegionSceneQuery">
      <summary>Abstract class defining a query which returns single results from a region. This class is simply a generalisation of the subtypes of query that return a set of individual results in a region. See the SceneQuery class for abstract information, and subclasses for the detail of each query type. </summary>
    </member>
    <member name="M:Mogre.RegionSceneQuery.Execute(Mogre.ISceneQueryListener)">
      <summary>Executes the query and returns each match through a listener interface. Note that this method does not store the results of the query internally so does not update the 'last result' value. This means that this version of execute is more lightweight and therefore more efficient than the version which returns the results as a collection. </summary>
    </member>
    <member name="M:Mogre.RegionSceneQuery.Execute">
      <summary>Executes the query, returning the results back in one list. This method executes the scene query as configured, gathers the results into one structure and returns a reference to that structure. These results will also persist in this query object until the next query is executed, or clearResults() is called. An more lightweight version of this method that returns results through a listener is also available. </summary>
    </member>
    <member name="M:Mogre.RegionSceneQuery.ClearResults">
      <summary>Clears the results of the last query execution. You only need to call this if you specifically want to free up the memory used by this object to hold the last query results. This object clears the results itself when executing and when destroying itself. </summary>
    </member>
    <member name="M:Mogre.RegionSceneQuery.QueryResult(Mogre.SceneQuery+WorldFragment)">
      <summary>Self-callback in order to deal with execute which returns collection. </summary>
    </member>
    <member name="M:Mogre.RegionSceneQuery.QueryResult(Mogre.MovableObject)">
      <summary>Self-callback in order to deal with execute which returns collection. </summary>
    </member>
    <member name="P:Mogre.RegionSceneQuery.LastResults">
      <summary>Gets the results of the last query that was run using this object, provided the query was executed using the collection-returning version of execute. </summary>
    </member>
    <member name="T:Mogre.AxisAlignedBoxSceneQuery">
      <summary>Specialises the SceneQuery class for querying within an axis aligned box. </summary>
    </member>
    <member name="P:Mogre.AxisAlignedBoxSceneQuery.Box">
      <summary>Sets/Gets the box which is being used for this query. </summary>
    </member>
    <member name="T:Mogre.SphereSceneQuery">
      <summary>Specialises the SceneQuery class for querying within a sphere. </summary>
    </member>
    <member name="P:Mogre.SphereSceneQuery.Sphere">
      <summary>Sets/Gets the sphere which is being used for this query. </summary>
    </member>
    <member name="T:Mogre.PlaneBoundedVolumeListSceneQuery">
      <summary>Specialises the SceneQuery class for querying within a plane-bounded volume. </summary>
    </member>
    <member name="M:Mogre.PlaneBoundedVolumeListSceneQuery.SetVolumes(Mogre.Const_PlaneBoundedVolumeList)">
      <summary>Sets the volume which is to be used for this query. </summary>
    </member>
    <member name="M:Mogre.PlaneBoundedVolumeListSceneQuery.GetVolumes">
      <summary>Gets the volume which is being used for this query. </summary>
    </member>
    <member name="T:Mogre.RaySceneQueryListener">
      <summary>Alternative listener class for dealing with RaySceneQuery. Because the RaySceneQuery returns results in an extra bit of information, namely distance, the listener interface must be customised from the standard SceneQueryListener. </summary>
    </member>
    <member name="M:Mogre.RaySceneQueryListener.QueryResult(Mogre.SceneQuery+WorldFragment,System.Single)">
      <summary>Called when a world fragment is intersected by the ray. As with SceneQueryListener, the implementor of this method should return 'true' if further results are required, or 'false' to abandon any further results from the current query. </summary>
    </member>
    <member name="M:Mogre.RaySceneQueryListener.QueryResult(Mogre.MovableObject,System.Single)">
      <summary>Called when a movable objects intersects the ray. As with SceneQueryListener, the implementor of this method should return 'true' if further results are required, or 'false' to abandon any further results from the current query. </summary>
    </member>
    <member name="T:Mogre.RaySceneQueryResultEntry">
      <summary>This struct allows a single comparison of result data no matter what the type </summary>
    </member>
    <member name="P:Mogre.RaySceneQueryResultEntry.worldFragment">
      <summary>Sets/The world fragment, or NULL if this is not a fragment result. </summary>
    </member>
    <member name="P:Mogre.RaySceneQueryResultEntry.movable">
      <summary>Sets/The movable, or NULL if this is not a movable result. </summary>
    </member>
    <member name="P:Mogre.RaySceneQueryResultEntry.distance">
      <summary>Sets/Distance along the ray. </summary>
    </member>
    <member name="T:Mogre.RaySceneQuery">
      <summary>Specialises the SceneQuery class for querying along a ray. </summary>
    </member>
    <member name="M:Mogre.RaySceneQuery.SetSortByDistance(System.Boolean)">
      <summary>Sets whether the results of this query will be sorted by distance along the ray. Often you want to know what was the first object a ray intersected with, and this method allows you to ask the query to sort the results so that the nearest results are listed first. Note that because the query returns results based on bounding volumes, the ray may not actually intersect the detail of the objects returned from the query, just their bounding volumes. For this reason the caller is advised to use more detailed intersection tests on the results if a more accurate result is required; OGRE uses bounds checking in order to give the most speedy results since not all applications need extreme accuracy. </summary>
      <param name="sort">If true, results will be sorted. </param>
    </member>
    <member name="M:Mogre.RaySceneQuery.SetSortByDistance(System.Boolean,System.UInt16)">
      <summary>Sets whether the results of this query will be sorted by distance along the ray. Often you want to know what was the first object a ray intersected with, and this method allows you to ask the query to sort the results so that the nearest results are listed first. Note that because the query returns results based on bounding volumes, the ray may not actually intersect the detail of the objects returned from the query, just their bounding volumes. For this reason the caller is advised to use more detailed intersection tests on the results if a more accurate result is required; OGRE uses bounds checking in order to give the most speedy results since not all applications need extreme accuracy. </summary>
      <param name="sort">If true, results will be sorted. </param>
      <param name="maxresults">If sorting is enabled, this value can be used to constrain the maximum number of results that are returned. Please note (as above) that the use of bounding volumes mean that accuracy is not guaranteed; if in doubt, allow more results and filter them in more detail. 0 means unlimited results. </param>
    </member>
    <member name="M:Mogre.RaySceneQuery.Execute(Mogre.IRaySceneQueryListener)">
      <summary>Executes the query and returns each match through a listener interface. Note that this method does not store the results of the query internally so does not update the 'last result' value. This means that this version of execute is more lightweight and therefore more efficient than the version which returns the results as a collection. </summary>
    </member>
    <member name="M:Mogre.RaySceneQuery.Execute">
      <summary>Executes the query, returning the results back in one list. This method executes the scene query as configured, gathers the results into one structure and returns a reference to that structure. These results will also persist in this query object until the next query is executed, or clearResults() is called. An more lightweight version of this method that returns results through a listener is also available. </summary>
    </member>
    <member name="M:Mogre.RaySceneQuery.GetLastResults">
      <summary>Gets the results of the last query that was run using this object, provided the query was executed using the collection-returning version of execute. </summary>
    </member>
    <member name="M:Mogre.RaySceneQuery.ClearResults">
      <summary>Clears the results of the last query execution. You only need to call this if you specifically want to free up the memory used by this object to hold the last query results. This object clears the results itself when executing and when destroying itself. </summary>
    </member>
    <member name="M:Mogre.RaySceneQuery.QueryResult(Mogre.SceneQuery+WorldFragment,System.Single)">
      <summary>Self-callback in order to deal with execute which returns collection. </summary>
    </member>
    <member name="M:Mogre.RaySceneQuery.QueryResult(Mogre.MovableObject,System.Single)">
      <summary>Self-callback in order to deal with execute which returns collection. </summary>
    </member>
    <member name="P:Mogre.RaySceneQuery.SortByDistance">
      <summary>Gets whether the results are sorted by distance. </summary>
    </member>
    <member name="P:Mogre.RaySceneQuery.Ray">
      <summary>Sets/Gets the ray which is to be used for this query. </summary>
    </member>
    <member name="P:Mogre.RaySceneQuery.MaxResults">
      <summary>Gets the maximum number of results returned from the query (only relevant if results are being sorted) </summary>
    </member>
    <member name="T:Mogre.IntersectionSceneQueryListener">
      <summary>Alternative listener class for dealing with IntersectionSceneQuery. Because the IntersectionSceneQuery returns results in pairs, rather than singularly, the listener interface must be customised from the standard SceneQueryListener. </summary>
    </member>
    <member name="M:Mogre.IntersectionSceneQueryListener.QueryResult(Mogre.MovableObject,Mogre.SceneQuery+WorldFragment)">
      <summary>Called when a movable intersects a world fragment. As with SceneQueryListener, the implementor of this method should return 'true' if further results are required, or 'false' to abandon any further results from the current query. </summary>
    </member>
    <member name="M:Mogre.IntersectionSceneQueryListener.QueryResult(Mogre.MovableObject,Mogre.MovableObject)">
      <summary>Called when 2 movable objects intersect one another. As with SceneQueryListener, the implementor of this method should return 'true' if further results are required, or 'false' to abandon any further results from the current query. </summary>
    </member>
    <member name="T:Mogre.IntersectionSceneQueryResult">
      <summary>Holds the results of an intersection scene query (pair values). </summary>
    </member>
    <member name="P:Mogre.IntersectionSceneQueryResult.movables2world">
      <summary>List of movable / world intersections. </summary>
    </member>
    <member name="P:Mogre.IntersectionSceneQueryResult.movables2movables">
      <summary>List of movable / movable intersections (entities, particle systems etc). </summary>
    </member>
    <member name="T:Mogre.IntersectionSceneQuery">
      <summary>Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another. This SceneQuery subclass considers the whole world and returns pairs of objects which are close enough to each other that they may be intersecting. Because of this slightly different focus, the return types and listener interface are different for this class. </summary>
    </member>
    <member name="M:Mogre.IntersectionSceneQuery.Execute(Mogre.IIntersectionSceneQueryListener)">
      <summary>Executes the query and returns each match through a listener interface. Note that this method does not store the results of the query internally so does not update the 'last result' value. This means that this version of execute is more lightweight and therefore more efficient than the version which returns the results as a collection. </summary>
    </member>
    <member name="M:Mogre.IntersectionSceneQuery.Execute">
      <summary>Executes the query, returning the results back in one list. This method executes the scene query as configured, gathers the results into one structure and returns a reference to that structure. These results will also persist in this query object until the next query is executed, or clearResults() is called. An more lightweight version of this method that returns results through a listener is also available. </summary>
    </member>
    <member name="M:Mogre.IntersectionSceneQuery.ClearResults">
      <summary>Clears the results of the last query execution. You only need to call this if you specifically want to free up the memory used by this object to hold the last query results. This object clears the results itself when executing and when destroying itself. </summary>
    </member>
    <member name="M:Mogre.IntersectionSceneQuery.QueryResult(Mogre.MovableObject,Mogre.SceneQuery+WorldFragment)">
      <summary>Self-callback in order to deal with execute which returns collection. </summary>
    </member>
    <member name="M:Mogre.IntersectionSceneQuery.QueryResult(Mogre.MovableObject,Mogre.MovableObject)">
      <summary>Self-callback in order to deal with execute which returns collection. </summary>
    </member>
    <member name="P:Mogre.IntersectionSceneQuery.LastResults">
      <summary>Gets the results of the last query that was run using this object, provided the query was executed using the collection-returning version of execute. </summary>
    </member>
    <member name="T:Mogre.SceneManagerMetaData_NativePtr">
      <summary>Structure containing information about a scene manager. </summary>
    </member>
    <member name="P:Mogre.SceneManagerMetaData_NativePtr.worldGeometrySupported">
      <summary>Flag indicating whether world geometry is supported. </summary>
    </member>
    <member name="P:Mogre.SceneManagerMetaData_NativePtr.sceneTypeMask">
      <summary>A mask describing which sorts of scenes this manager can handle. </summary>
    </member>
    <member name="P:Mogre.SceneManagerMetaData_NativePtr.description">
      <summary>A text description of the scene manager. </summary>
    </member>
    <member name="P:Mogre.SceneManagerMetaData_NativePtr.typeName">
      <summary>A globally unique string identifying the scene manager type. </summary>
    </member>
    <member name="T:Mogre.VisibleObjectsBoundsInfo_NativePtr">
      <summary>Structure collecting together information about the visible objects that have been discovered in a scene. </summary>
    </member>
    <member name="M:Mogre.VisibleObjectsBoundsInfo_NativePtr.MergeNonRenderedButInFrustum(Mogre.AxisAlignedBox,Mogre.Sphere,Mogre.Camera)">
      <summary>Merge an object that is not being rendered because it's not a shadow caster, but is a shadow receiver so should be included in the range. </summary>
    </member>
    <member name="P:Mogre.VisibleObjectsBoundsInfo_NativePtr.maxDistanceInFrustum">
      <summary>Sets/The farthest object in the frustum regardless of visibility / shadow caster flags. </summary>
    </member>
    <member name="P:Mogre.VisibleObjectsBoundsInfo_NativePtr.minDistanceInFrustum">
      <summary>Sets/The closest a object in the frustum regardless of visibility / shadow caster flags. </summary>
    </member>
    <member name="P:Mogre.VisibleObjectsBoundsInfo_NativePtr.maxDistance">
      <summary>Sets/The farthest a visible objects is from the camera. </summary>
    </member>
    <member name="P:Mogre.VisibleObjectsBoundsInfo_NativePtr.minDistance">
      <summary>Sets/The closest a visible object is to the camera. </summary>
    </member>
    <member name="P:Mogre.VisibleObjectsBoundsInfo_NativePtr.receiverAabb">
      <summary>Sets/The axis-aligned bounds of the visible shadow receiver objects. </summary>
    </member>
    <member name="P:Mogre.VisibleObjectsBoundsInfo_NativePtr.aabb">
      <summary>Sets/The axis-aligned bounds of the visible objects. </summary>
    </member>
    <member name="T:Mogre.ViewPoint">
      <summary>Structure for holding a position &amp; orientation pair. </summary>
    </member>
    <member name="T:Mogre.SceneManager">
      <summary>Manages the organisation and rendering of a 'scene' i.e. a collection of objects and potentially world geometry. This class defines the interface and the basic behaviour of a 'Scene Manager'. A SceneManager organises the culling and rendering of the scene, in conjunction with the RenderQueue. This class is designed to be extended through subclassing in order to provide more specialised scene organisation structures for particular needs. The default SceneManager culls based on a hierarchy of node bounding boxes, other implementations can use an octree (OctreeSceneManager), a BSP tree (BspSceneManager), and many other options. New SceneManager implementations can be added at runtime by plugins, see SceneManagerEnumerator for the interfaces for adding new SceneManager types. There is a distinction between 'objects' (which subclass MovableObject, and are movable, discrete objects in the world), and 'world geometry', which is large, generally static geometry. World geometry tends to influence the SceneManager organisational structure (e.g. lots of indoor static geometry might result in a spatial tree structure) and as such world geometry is generally tied to a given SceneManager implementation, whilst MovableObject instances can be used with any SceneManager. Subclasses are free to define world geometry however they please. Multiple SceneManager instances can exist at one time, each one with a distinct scene. Which SceneManager is used to render a scene is dependent on the Camera, which will always call back the SceneManager which created it to render the scene. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,System.Void*)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
      <param name="pValue">A pointer to the value - the size should be calculated by the scene manager based on the key </param>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,Mogre.Quaternion)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,Mogre.Vector2)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,Mogre.Vector3)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,System.String)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,System.Single)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,System.Int32)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
    </member>
    <member name="M:Mogre.SceneManager.SetOption(System.String,System.Boolean)">
      <summary>Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. On success, true is returned. On failiure, false is returned. </summary>
      <param name="strKey">The name of the option to set </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,System.Void*)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
      <param name="pDestValue">A pointer to a memory location where the value will be copied. Currently, the memory will be allocated by the scene manager, but this may change </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,Mogre.Quaternion&amp;)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,Mogre.Vector2&amp;)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,Mogre.Vector3&amp;)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,System.String&amp;)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,System.Single&amp;)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,System.Int32&amp;)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOption(System.String,System.Boolean&amp;)">
      <summary>Method for getting the value of an implementation-specific Scene Manager option. On success, true is returned and pDestValue points to the value of the given option. On failiure, false is returned and pDestValue is set to NULL. </summary>
      <param name="strKey">The name of the option </param>
    </member>
    <member name="M:Mogre.SceneManager.PrepareShadowTextures(Mogre.Camera,Mogre.Viewport)">
      <summary>Method for preparing shadow textures ready for use in a regular render Do not call manually unless before frame start or rendering is paused If lightList is not supplied, will render all lights in frustum </summary>
    </member>
    <member name="M:Mogre.SceneManager.PrepareShadowTextures(Mogre.Camera,Mogre.Viewport,Mogre.Const_LightList)">
      <summary>Method for preparing shadow textures ready for use in a regular render Do not call manually unless before frame start or rendering is paused If lightList is not supplied, will render all lights in frustum </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateCamera(System.String)">
      <summary>Creates a camera to be managed by this scene manager. This camera must be added to the scene at a later time using the attachObject method of the SceneNode class. </summary>
      <param name="name">Name to give the new camera. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetCamera(System.String)">
      <summary>Retrieves a pointer to the named camera. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasCamera(System.String)">
      <summary>Returns whether a camera with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyCamera(System.String)">
      <summary>Removes a camera from the scene. This method removes an camera from the scene based on the camera's name rather than a pointer. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyCamera(Mogre.Camera)">
      <summary>Removes a camera from the scene. This method removes a previously added camera from the scene. The camera is deleted so the caller must ensure no references to it's previous instance (e.g. in a SceneNode) are used. </summary>
      <param name="cam">Pointer to the camera to remove </param>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllCameras">
      <summary>Removes (and destroys) all cameras from the scene. Some cameras are internal created to dealing with texture shadow, their aren't supposed to destroy outside. So, while you are using texture shadow, don't call this method, or you can set the shadow technique other than texture-based, which will destroy all internal created shadow cameras and textures. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateLight">
      <summary>Creates a light for use in the scene. Lights can either be in a fixed position and independent of the scene graph, or they can be attached to SceneNodes so they derive their position from the parent node. Either way, they are created using this method so that the SceneManager manages their existence. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateLight(System.String)">
      <summary>Creates a light for use in the scene. Lights can either be in a fixed position and independent of the scene graph, or they can be attached to SceneNodes so they derive their position from the parent node. Either way, they are created using this method so that the SceneManager manages their existence. </summary>
      <param name="name">The name of the new light, to identify it later. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetLight(System.String)">
      <summary>Returns a pointer to the named Light which has previously been added to the scene. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasLight(System.String)">
      <summary>Returns whether a light with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetLightClippingPlanes(Mogre.Light)">
      <summary>Retrieve a set of clipping planes for a given light. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetLightScissorRect(Mogre.Light,Mogre.Camera)">
      <summary>Retrieve a scissor rectangle for a given light and camera. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyLight(Mogre.Light)">
      <summary>Removes the light from the scene and destroys it based on a pointer. Any pointers held to this light after calling this method will be invalid. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyLight(System.String)">
      <summary>Removes the named light from the scene and destroys it. Any pointers held to this light after calling this method will be invalid. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllLights">
      <summary>Removes and destroys all lights in the scene. </summary>
    </member>
    <member name="M:Mogre.SceneManager._notifyLightsDirty">
      <summary>Advance method to increase the lights dirty counter due lights changed. Scene manager tracking lights that affecting the frustum, if changes detected (the changes includes light list itself and the light's position and attenuation range), then increase the lights dirty counter. For some reason, you can call this method to force whole scene objects re-populate their light list. But near in mind, call to this method will harm performance, so should avoid if possible. </summary>
    </member>
    <member name="M:Mogre.SceneManager._getLightsDirtyCounter">
      <summary>Advance method to gets the lights dirty counter. Scene manager tracking lights that affecting the frustum, if changes detected (the changes includes light list itself and the light's position and attenuation range), then increase the lights dirty counter. When implementing customise lights finding algorithm relied on either SceneManager::_getLightsAffectingFrustum or SceneManager::_populateLightList, might check this value for sure that the light list are really need to re-populate, otherwise, returns cached light list (if exists) for better performance. </summary>
    </member>
    <member name="M:Mogre.SceneManager._getLightsAffectingFrustum">
      <summary>Get the list of lights which could be affecting the frustum. Note that default implementation of this method returns a cached light list, which is populated when rendering the scene. So by default the list of lights is only available during scene rendering. </summary>
    </member>
    <member name="M:Mogre.SceneManager._populateLightList(Mogre.SceneNode,System.Single,Mogre.LightList)">
      <summary>Populates a light list with an ordered set of the lights which are closest to the position of the SceneNode given. Note that since directional lights have no position, they are always considered closer than any point lights and as such will always take precedence. This overloaded version will take the SceneNode's position and use the second method to populate the list. Subclasses of the default SceneManager may wish to take into account other issues such as possible visibility of the light if that information is included in their data structures. This basic scenemanager simply orders by distance, eliminating those lights which are out of range or could not be affecting the frustum (i.e. only the lights returned by SceneManager::_getLightsAffectingFrustum are take into account). Also note that subclasses of the SceneNode might be used here to provide cached scene related data, accelerating the list population (for example light lists for SceneNodes could be cached inside subclassed SceneNode objects). The number of items in the list may exceed the maximum number of lights supported by the renderer, but the extraneous ones will never be used. In fact the limit will be imposed by Pass::getMaxSimultaneousLights. </summary>
      <param name="sn">The SceneNode for which to evaluate the list of lights </param>
      <param name="radius">The bounding radius to test </param>
      <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population. </param>
    </member>
    <member name="M:Mogre.SceneManager._populateLightList(Mogre.SceneNode,System.Single,Mogre.LightList,System.UInt32)">
      <summary>Populates a light list with an ordered set of the lights which are closest to the position of the SceneNode given. Note that since directional lights have no position, they are always considered closer than any point lights and as such will always take precedence. This overloaded version will take the SceneNode's position and use the second method to populate the list. Subclasses of the default SceneManager may wish to take into account other issues such as possible visibility of the light if that information is included in their data structures. This basic scenemanager simply orders by distance, eliminating those lights which are out of range or could not be affecting the frustum (i.e. only the lights returned by SceneManager::_getLightsAffectingFrustum are take into account). Also note that subclasses of the SceneNode might be used here to provide cached scene related data, accelerating the list population (for example light lists for SceneNodes could be cached inside subclassed SceneNode objects). The number of items in the list may exceed the maximum number of lights supported by the renderer, but the extraneous ones will never be used. In fact the limit will be imposed by Pass::getMaxSimultaneousLights. </summary>
      <param name="sn">The SceneNode for which to evaluate the list of lights </param>
      <param name="radius">The bounding radius to test </param>
      <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population. </param>
      <param name="lightMask">The mask with which to include / exclude lights </param>
    </member>
    <member name="M:Mogre.SceneManager._populateLightList(Mogre.Vector3,System.Single,Mogre.LightList)">
      <summary>Populate a light list with an ordered set of the lights which are closest to the position specified. Note that since directional lights have no position, they are always considered closer than any point lights and as such will always take precedence. Subclasses of the default SceneManager may wish to take into account other issues such as possible visibility of the light if that information is included in their data structures. This basic scenemanager simply orders by distance, eliminating those lights which are out of range or could not be affecting the frustum (i.e. only the lights returned by SceneManager::_getLightsAffectingFrustum are take into account). The number of items in the list max exceed the maximum number of lights supported by the renderer, but the extraneous ones will never be used. In fact the limit will be imposed by Pass::getMaxSimultaneousLights. </summary>
      <param name="position">The position at which to evaluate the list of lights </param>
      <param name="radius">The bounding radius to test </param>
      <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population. </param>
    </member>
    <member name="M:Mogre.SceneManager._populateLightList(Mogre.Vector3,System.Single,Mogre.LightList,System.UInt32)">
      <summary>Populate a light list with an ordered set of the lights which are closest to the position specified. Note that since directional lights have no position, they are always considered closer than any point lights and as such will always take precedence. Subclasses of the default SceneManager may wish to take into account other issues such as possible visibility of the light if that information is included in their data structures. This basic scenemanager simply orders by distance, eliminating those lights which are out of range or could not be affecting the frustum (i.e. only the lights returned by SceneManager::_getLightsAffectingFrustum are take into account). The number of items in the list max exceed the maximum number of lights supported by the renderer, but the extraneous ones will never be used. In fact the limit will be imposed by Pass::getMaxSimultaneousLights. </summary>
      <param name="position">The position at which to evaluate the list of lights </param>
      <param name="radius">The bounding radius to test </param>
      <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population. </param>
      <param name="lightMask">The mask with which to include / exclude lights </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateSceneNode(System.String)">
      <summary>Creates an instance of a SceneNode with a given name. Note that this does not add the SceneNode to the scene hierarchy. This method is for convenience, since it allows an instance to be created for which the SceneManager is responsible for allocating and releasing memory, which is convenient in complex scenes. To include the returned SceneNode in the scene, use the addChild method of the SceneNode which is to be it's parent. Note that this method takes a name parameter, which makes the node easier to retrieve directly again later. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateSceneNode">
      <summary>Creates an instance of a SceneNode. Note that this does not add the SceneNode to the scene hierarchy. This method is for convenience, since it allows an instance to be created for which the SceneManager is responsible for allocating and releasing memory, which is convenient in complex scenes. To include the returned SceneNode in the scene, use the addChild method of the SceneNode which is to be it's parent. Note that this method takes no parameters, and the node created is unnamed (it is actually given a generated name, which you can retrieve if you want). If you wish to create a node with a specific name, call the alternative method which takes a name parameter. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroySceneNode(Mogre.SceneNode)">
      <summary>Destroys a SceneNode. This allows you to physically delete an individual SceneNode if you want to. Note that this is not normally recommended, it's better to allow SceneManager to delete the nodes when the scene is cleared. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroySceneNode(System.String)">
      <summary>Destroys a SceneNode with a given name. This allows you to physically delete an individual SceneNode if you want to. Note that this is not normally recommended, it's better to allow SceneManager to delete the nodes when the scene is cleared. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetSceneNode(System.String)">
      <summary>Retrieves a named SceneNode from the scene graph. If you chose to name a SceneNode as you created it, or if you happened to make a note of the generated name, you can look it up wherever it is in the scene graph using this method. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasSceneNode(System.String)">
      <summary>Returns whether a scene node with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateEntity(Mogre.SceneManager+PrefabType)">
      <summary>Create an Entity (instance of a discrete mesh) from a range of prefab shapes, generating the name. </summary>
      <param name="ptype">The prefab type. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateEntity(System.String,Mogre.SceneManager+PrefabType)">
      <summary>Create an Entity (instance of a discrete mesh) from a range of prefab shapes. </summary>
      <param name="entityName">The name to be given to the entity (must be unique). </param>
      <param name="ptype">The prefab type. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateEntity(System.String)">
      <summary>Create an Entity (instance of a discrete mesh) with an autogenerated name. </summary>
      <param name="meshName">The name of the Mesh it is to be based on (e.g. 'knot.oof'). The mesh will be loaded if it is not already. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateEntity(System.String,System.String)">
      <summary>Create an Entity (instance of a discrete mesh). </summary>
      <param name="entityName">The name to be given to the entity (must be unique). </param>
      <param name="meshName">The name of the Mesh it is to be based on (e.g. 'knot.oof'). The mesh will be loaded if it is not already. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateEntity(System.String,System.String,System.String)">
      <summary>Create an Entity (instance of a discrete mesh). </summary>
      <param name="entityName">The name to be given to the entity (must be unique). </param>
      <param name="meshName">The name of the Mesh it is to be based on (e.g. 'knot.oof'). The mesh will be loaded if it is not already. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetEntity(System.String)">
      <summary>Retrieves a pointer to the named Entity. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasEntity(System.String)">
      <summary>Returns whether an entity with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyEntity(System.String)">
      <summary>Removes &amp; destroys an Entity from the SceneManager by name. Must only be done if the Entity is not attached to a SceneNode. It may be safer to wait to clear the whole scene if you are unsure use clearScene. SceneManager::clearScene</summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyEntity(Mogre.Entity)">
      <summary>Removes &amp; destroys an Entity from the SceneManager. Must only be done if the Entity is not attached to a SceneNode. It may be safer to wait to clear the whole scene if you are unsure use clearScene. SceneManager::clearScene</summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllEntities">
      <summary>Removes &amp; destroys all Entities. Again, use caution since no Entity must be referred to elsewhere e.g. attached to a SceneNode otherwise a crash is likely. Use clearScene if you are unsure (it clears SceneNode entries too.) SceneManager::clearScene</summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateManualObject">
      <summary>Create a ManualObject, an object which you populate with geometry manually through a GL immediate-mode style interface. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateManualObject(System.String)">
      <summary>Create a ManualObject, an object which you populate with geometry manually through a GL immediate-mode style interface. </summary>
      <param name="name">The name to be given to the object (must be unique). </param>
    </member>
    <member name="M:Mogre.SceneManager.GetManualObject(System.String)">
      <summary>Retrieves a pointer to the named ManualObject. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasManualObject(System.String)">
      <summary>Returns whether a manual object with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyManualObject(System.String)">
      <summary>Removes &amp; destroys a ManualObject from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyManualObject(Mogre.ManualObject)">
      <summary>Removes &amp; destroys a ManualObject from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllManualObjects">
      <summary>Removes &amp; destroys all ManualObjects from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateBillboardChain">
      <summary>Create a BillboardChain, an object which you can use to render a linked chain of billboards. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateBillboardChain(System.String)">
      <summary>Create a BillboardChain, an object which you can use to render a linked chain of billboards. </summary>
      <param name="name">The name to be given to the object (must be unique). </param>
    </member>
    <member name="M:Mogre.SceneManager.GetBillboardChain(System.String)">
      <summary>Retrieves a pointer to the named BillboardChain. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasBillboardChain(System.String)">
      <summary>Returns whether a billboard chain with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyBillboardChain(System.String)">
      <summary>Removes &amp; destroys a BillboardChain from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyBillboardChain(Mogre.BillboardChain)">
      <summary>Removes &amp; destroys a BillboardChain from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllBillboardChains">
      <summary>Removes &amp; destroys all BillboardChains from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateRibbonTrail">
      <summary>Create a RibbonTrail, an object which you can use to render a linked chain of billboards which follows one or more nodes. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateRibbonTrail(System.String)">
      <summary>Create a RibbonTrail, an object which you can use to render a linked chain of billboards which follows one or more nodes. </summary>
      <param name="name">The name to be given to the object (must be unique). </param>
    </member>
    <member name="M:Mogre.SceneManager.GetRibbonTrail(System.String)">
      <summary>Retrieves a pointer to the named RibbonTrail. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasRibbonTrail(System.String)">
      <summary>Returns whether a ribbon trail with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyRibbonTrail(System.String)">
      <summary>Removes &amp; destroys a RibbonTrail from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyRibbonTrail(Mogre.RibbonTrail)">
      <summary>Removes &amp; destroys a RibbonTrail from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllRibbonTrails">
      <summary>Removes &amp; destroys all RibbonTrails from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateParticleSystem">
      <summary>Creates a particle system based on a template. This method creates a new ParticleSystem instance based on the named template (defined through ParticleSystemManager::createTemplate) and returns a pointer to the caller. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. Each system created from a template takes the template's settings at the time of creation, but is completely separate from the template from there on. Creating a particle system does not make it a part of the scene. As with other MovableObject subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. This is probably the more useful particle system creation method since it does not require manual setup of the system. Note that the initial quota is based on the template but may be changed later. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateParticleSystem(System.UInt32)">
      <summary>Create a blank particle system with a generated name. This method creates a new, blank ParticleSystem instance and returns a pointer to it. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. The instance returned from this method won't actually do anything because on creation a particle system has no emitters. The caller should manipulate the instance through it's ParticleSystem methods to actually create a real particle effect. Creating a particle system does not make it a part of the scene. As with other MovableObject subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. </summary>
      <param name="quota">The maximum number of particles to allow in this system. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateParticleSystem(System.UInt32,System.String)">
      <summary>Create a blank particle system with a generated name. This method creates a new, blank ParticleSystem instance and returns a pointer to it. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. The instance returned from this method won't actually do anything because on creation a particle system has no emitters. The caller should manipulate the instance through it's ParticleSystem methods to actually create a real particle effect. Creating a particle system does not make it a part of the scene. As with other MovableObject subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. </summary>
      <param name="quota">The maximum number of particles to allow in this system. </param>
      <param name="resourceGroup">The resource group which will be used to load dependent resources </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateParticleSystem(System.String)">
      <summary>Creates a particle system based on a template. This method creates a new ParticleSystem instance based on the named template (defined through ParticleSystemManager::createTemplate) and returns a pointer to the caller. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. Each system created from a template takes the template's settings at the time of creation, but is completely separate from the template from there on. Creating a particle system does not make it a part of the scene. As with other MovableObject subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. This is probably the more useful particle system creation method since it does not require manual setup of the system. Note that the initial quota is based on the template but may be changed later. </summary>
      <param name="name">The name to give the new particle system instance. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateParticleSystem(System.String,System.UInt32)">
      <summary>Create a blank particle system. This method creates a new, blank ParticleSystem instance and returns a pointer to it. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. The instance returned from this method won't actually do anything because on creation a particle system has no emitters. The caller should manipulate the instance through it's ParticleSystem methods to actually create a real particle effect. Creating a particle system does not make it a part of the scene. As with other MovableObject subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. </summary>
      <param name="name">The name to give the ParticleSystem. </param>
      <param name="quota">The maximum number of particles to allow in this system. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateParticleSystem(System.String,System.UInt32,System.String)">
      <summary>Create a blank particle system. This method creates a new, blank ParticleSystem instance and returns a pointer to it. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. The instance returned from this method won't actually do anything because on creation a particle system has no emitters. The caller should manipulate the instance through it's ParticleSystem methods to actually create a real particle effect. Creating a particle system does not make it a part of the scene. As with other MovableObject subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. </summary>
      <param name="name">The name to give the ParticleSystem. </param>
      <param name="quota">The maximum number of particles to allow in this system. </param>
      <param name="resourceGroup">The resource group which will be used to load dependent resources </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateParticleSystem(System.String,System.String)">
      <summary>Creates a particle system based on a template. This method creates a new ParticleSystem instance based on the named template (defined through ParticleSystemManager::createTemplate) and returns a pointer to the caller. The caller should not delete this object, it will be freed at system shutdown, or can be released earlier using the destroyParticleSystem method. Each system created from a template takes the template's settings at the time of creation, but is completely separate from the template from there on. Creating a particle system does not make it a part of the scene. As with other MovableObject subclasses, a ParticleSystem is not rendered until it is attached to a SceneNode. This is probably the more useful particle system creation method since it does not require manual setup of the system. Note that the initial quota is based on the template but may be changed later. </summary>
      <param name="name">The name to give the new particle system instance. </param>
      <param name="templateName">The name of the template to base the new instance on. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetParticleSystem(System.String)">
      <summary>Retrieves a pointer to the named ParticleSystem. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasParticleSystem(System.String)">
      <summary>Returns whether a particle system with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyParticleSystem(System.String)">
      <summary>Removes &amp; destroys a ParticleSystem from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyParticleSystem(Mogre.ParticleSystem)">
      <summary>Removes &amp; destroys a ParticleSystem from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllParticleSystems">
      <summary>Removes &amp; destroys all ParticleSystems from the SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.ClearScene">
      <summary>Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc. Cameras are not deleted at this stage since they are still referenced by viewports, which are not destroyed during this process. </summary>
    </member>
    <member name="M:Mogre.SceneManager.PrepareWorldGeometry(Mogre.DataStreamPtr)">
      <summary>Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. Depending on the type of SceneManager (subclasses will be specialised for particular world geometry types) you have requested via the Root or SceneManagerEnumerator classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </summary>
      <param name="stream">Data stream containing data to load </param>
    </member>
    <member name="M:Mogre.SceneManager.PrepareWorldGeometry(Mogre.DataStreamPtr,System.String)">
      <summary>Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. Depending on the type of SceneManager (subclasses will be specialised for particular world geometry types) you have requested via the Root or SceneManagerEnumerator classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </summary>
      <param name="stream">Data stream containing data to load </param>
      <param name="typeName">String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </param>
    </member>
    <member name="M:Mogre.SceneManager.PrepareWorldGeometry(System.String)">
      <summary>Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. Depending on the type of SceneManager (subclasses will be specialised for particular world geometry types) you have requested via the Root or SceneManagerEnumerator classes, you can pass a filename to this method and it will attempt to load the world-level geometry for use. If you try to load an inappropriate type of world data an exception will be thrown. The default SceneManager cannot handle any sort of world geometry and so will always throw an exception. However subclasses like BspSceneManager can load particular types of world geometry e.g. "q3dm1.bsp". </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetWorldGeometry(Mogre.DataStreamPtr)">
      <summary>Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. Depending on the type of SceneManager (subclasses will be specialised for particular world geometry types) you have requested via the Root or SceneManagerEnumerator classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </summary>
      <param name="stream">Data stream containing data to load </param>
    </member>
    <member name="M:Mogre.SceneManager.SetWorldGeometry(Mogre.DataStreamPtr,System.String)">
      <summary>Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. Depending on the type of SceneManager (subclasses will be specialised for particular world geometry types) you have requested via the Root or SceneManagerEnumerator classes, you can pass a stream to this method and it will attempt to load the world-level geometry for use. If the manager can only handle one input format the typeName parameter is not required. The stream passed will be read (and it's state updated). </summary>
      <param name="stream">Data stream containing data to load </param>
      <param name="typeName">String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetWorldGeometry(System.String)">
      <summary>Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. Depending on the type of SceneManager (subclasses will be specialised for particular world geometry types) you have requested via the Root or SceneManagerEnumerator classes, you can pass a filename to this method and it will attempt to load the world-level geometry for use. If you try to load an inappropriate type of world data an exception will be thrown. The default SceneManager cannot handle any sort of world geometry and so will always throw an exception. However subclasses like BspSceneManager can load particular types of world geometry e.g. "q3dm1.bsp". </summary>
    </member>
    <member name="M:Mogre.SceneManager.EstimateWorldGeometry(Mogre.DataStreamPtr)">
      <summary>Estimate the number of loading stages required to load the named world geometry. Operates just like the version of this method which takes a filename, but operates on a stream instead. Note that since the stream is updated, you'll need to reset the stream or reopen it when it comes to loading it for real. </summary>
      <param name="stream">Data stream containing data to load </param>
    </member>
    <member name="M:Mogre.SceneManager.EstimateWorldGeometry(Mogre.DataStreamPtr,System.String)">
      <summary>Estimate the number of loading stages required to load the named world geometry. Operates just like the version of this method which takes a filename, but operates on a stream instead. Note that since the stream is updated, you'll need to reset the stream or reopen it when it comes to loading it for real. </summary>
      <param name="stream">Data stream containing data to load </param>
      <param name="typeName">String identifying the type of world geometry contained in the stream - not required if this manager only supports one type of world geometry. </param>
    </member>
    <member name="M:Mogre.SceneManager.EstimateWorldGeometry(System.String)">
      <summary>Estimate the number of loading stages required to load the named world geometry. This method should be overridden by SceneManagers that provide custom world geometry that can take some time to load. They should return from this method a count of the number of stages of progress they can report on whilst loading. During real loading (setWorldGeometry), they should call ResourceGroupManager::_notifyWorldGeometryProgress exactly that number of times when loading the geometry for real. The default is to return 0, ie to not report progress. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetSuggestedViewpoint">
      <summary>Asks the SceneManager to provide a suggested viewpoint from which the scene should be viewed. Typically this method returns the origin unless a) world geometry has been loaded using SceneManager::setWorldGeometry and b) that world geometry has suggested 'start' points. If there is more than one viewpoint which the scene manager can suggest, it will always suggest the first one unless the random parameter is true. On success, true is returned. On failiure, false is returned. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetSuggestedViewpoint(System.Boolean)">
      <summary>Asks the SceneManager to provide a suggested viewpoint from which the scene should be viewed. Typically this method returns the origin unless a) world geometry has been loaded using SceneManager::setWorldGeometry and b) that world geometry has suggested 'start' points. If there is more than one viewpoint which the scene manager can suggest, it will always suggest the first one unless the random parameter is true. On success, true is returned. On failiure, false is returned. </summary>
      <param name="random">If true, and there is more than one possible suggestion, a random one will be used. If false the same one will always be suggested. </param>
    </member>
    <member name="M:Mogre.SceneManager.HasOption(System.String)">
      <summary>Method for verifying wether the scene manager has an implementation-specific option. If the scene manager contains the given option, true is returned. If it does not, false is returned. </summary>
      <param name="strKey">The name of the option to check for. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOptionValues(System.String,Mogre.StringVector)">
      <summary>Method for getting all possible values for a specific option. When this list is too large (i.e. the option expects, for example, a float), the return value will be true, but the list will contain just one element whose size will be set to 0. Otherwise, the list will be filled with all the possible values the option can accept. On success (the option exists), true is returned. On failure, false is returned. </summary>
      <param name="strKey">The name of the option to get the values for. </param>
      <param name="refValueList">A reference to a list that will be filled with the available values. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetOptionKeys(Mogre.StringVector)">
      <summary>Method for getting all the implementation-specific options of the scene manager. On success, true is returned. On failiure, false is returned. </summary>
      <param name="refKeys">A reference to a list that will be filled with all the available options. </param>
    </member>
    <member name="M:Mogre.SceneManager._updateSceneGraph(Mogre.Camera)">
      <summary>Internal method for updating the scene graph ie the tree of SceneNode instances managed by this class. This must be done before issuing objects to the rendering pipeline, since derived transformations from parent nodes are not updated until required. This SceneManager is a basic implementation which simply updates all nodes from the root. This ensures the scene is up to date but requires all the nodes to be updated even if they are not visible. Subclasses could trim this such that only potentially visible nodes are updated. </summary>
    </member>
    <member name="M:Mogre.SceneManager._findVisibleObjects(Mogre.Camera,Mogre.VisibleObjectsBoundsInfo_NativePtr,System.Boolean)">
      <summary>Internal method which parses the scene to find visible objects to render. If you're implementing a custom scene manager, this is the most important method to override since it's here you can apply your custom world partitioning scheme. Once you have added the appropriate objects to the render queue, you can let the default SceneManager objects _renderVisibleObjects handle the actual rendering of the objects you pick. Any visible objects will be added to a rendering queue, which is indexed by material in order to ensure objects with the same material are rendered together to minimise render state changes. </summary>
    </member>
    <member name="M:Mogre.SceneManager._applySceneAnimations">
      <summary>Internal method for applying animations to scene nodes. Uses the internally stored AnimationState objects to apply animation to SceneNodes. </summary>
    </member>
    <member name="M:Mogre.SceneManager._renderVisibleObjects">
      <summary>Sends visible objects found in _findVisibleObjects to the rendering engine. </summary>
    </member>
    <member name="M:Mogre.SceneManager._renderScene(Mogre.Camera,Mogre.Viewport,System.Boolean)">
      <summary>Prompts the class to send its contents to the renderer. This method prompts the scene manager to send the contents of the scene it manages to the rendering pipeline, possibly preceded by some sorting, culling or other scene management tasks. Note that this method is not normally called directly by the user application; it is called automatically by the Ogre rendering loop. </summary>
      <param name="camera">Pointer to a camera from whose viewpoint the scene is to be rendered. </param>
      <param name="vp">The target viewport </param>
      <param name="includeOverlays">Whether or not overlay objects should be rendered </param>
    </member>
    <member name="M:Mogre.SceneManager._queueSkiesForRendering(Mogre.Camera)">
      <summary>Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome. </summary>
    </member>
    <member name="M:Mogre.SceneManager._setDestinationRenderSystem(Mogre.RenderSystem)">
      <summary>Notifies the scene manager of its destination render system Called automatically by RenderSystem::addSceneManager this method simply notifies the manager of the render system to which its output must be directed. </summary>
      <param name="sys">Pointer to the RenderSystem subclass to be used as a render target. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Boolean)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="drawFirst">If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the plane.d value is large enough that no objects will 'poke through' the sky plane when it is rendered. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Boolean,System.Single)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="drawFirst">If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the plane.d value is large enough that no objects will 'poke through' the sky plane when it is rendered. </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Boolean,System.Single,System.Int32)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="drawFirst">If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the plane.d value is large enough that no objects will 'poke through' the sky plane when it is rendered. </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
      <param name="xsegments">Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Boolean,System.Single,System.Int32,System.Int32)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="drawFirst">If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the plane.d value is large enough that no objects will 'poke through' the sky plane when it is rendered. </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
      <param name="xsegments">Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Boolean,System.Single,System.Int32,System.Int32,System.String)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="drawFirst">If true, the plane is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the plane.d value is large enough that no objects will 'poke through' the sky plane when it is rendered. </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
      <param name="xsegments">Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </param>
      <param name="groupName">The name of the resource group to which to assign the plane mesh. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Byte)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Byte,System.Single)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Byte,System.Single,System.Int32)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
      <param name="xsegments">Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Byte,System.Single,System.Int32,System.Int32)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
      <param name="xsegments">Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyPlane(System.Boolean,Mogre.Plane,System.String,System.Single,System.Single,System.Byte,System.Single,System.Int32,System.Int32,System.String)">
      <summary>Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. You can create sky planes yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world plane which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this plane applies to any camera using this scene manager). To apply scaling, scrolls etc to the sky texture(s) you should use the TextureUnitState class methods. </summary>
      <param name="enable">True to enable the plane, false to disable it </param>
      <param name="plane">Details of the plane, i.e. it's normal and it's distance from the camera. </param>
      <param name="materialName">The name of the material the plane will use </param>
      <param name="scale">The scaling applied to the sky plane - higher values mean a bigger sky plane - you may want to tweak this depending on the size of plane.d and the other characteristics of your scene </param>
      <param name="tiling">How many times to tile the texture across the sky. Applies to all texture layers. If you need finer control use the TextureUnitState texture coordinate transformation methods. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="bow">If zero, the plane will be completely flat (like previous versions. If above zero, the plane will be curved, allowing the sky to appear below camera level. Curved sky planes are simular to skydomes, but are more compatable with fog. </param>
      <param name="xsegments">Determines the number of segments the plane will have to it. This is most important when you are bowing the plane, but may also be useful if you need tesselation on the plane to perform per-vertex effects. </param>
      <param name="groupName">The name of the resource group to which to assign the plane mesh. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetSkyPlaneGenParameters">
      <summary>Get the parameters used to construct the SkyPlane, if any </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyBox(System.Boolean,System.String)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single,System.Boolean)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
      <param name="drawFirst">If true, the box is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky box when it is rendered. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single,System.Boolean,Mogre.Quaternion)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
      <param name="drawFirst">If true, the box is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky box when it is rendered. </param>
      <param name="orientation">Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyBox(System.Boolean,System.String,System.Single,System.Boolean,Mogre.Quaternion,System.String)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
      <param name="drawFirst">If true, the box is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky box when it is rendered. </param>
      <param name="orientation">Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
      <param name="groupName">The name of the resource group to which to assign the plane mesh. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyBox(System.Boolean,System.String)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyBox(System.Boolean,System.String,System.Single)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyBox(System.Boolean,System.String,System.Single,System.Byte)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyBox(System.Boolean,System.String,System.Single,System.Byte,Mogre.Quaternion)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="orientation">Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyBox(System.Boolean,System.String,System.Single,System.Byte,Mogre.Quaternion,System.String)">
      <summary>Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. You could create a sky box yourself using the standard mesh and entity methods, but this creates a plane which the camera can never get closer or further away from - it moves with the camera. (NB you could create this effect by creating a world box which was attached to the same SceneNode as the Camera too, but this would only apply to a single camera whereas this skybox applies to any camera using this scene manager). The material you use for the skybox can either contain layers which are single textures, or they can be cubic textures, i.e. made up of 6 images, one for each plane of the cube. See the TextureUnitState class for more information. </summary>
      <param name="enable">True to enable the skybox, false to disable it </param>
      <param name="materialName">The name of the material the box will use </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="orientation">Optional parameter to specify the orientation of the box. By default the 'top' of the box is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
      <param name="groupName">The name of the resource group to which to assign the plane mesh. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetSkyBoxGenParameters">
      <summary>Get the parameters used to generate the current SkyBox, if any </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="drawFirst">If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean,Mogre.Quaternion)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="drawFirst">If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean,Mogre.Quaternion,System.Int32)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="drawFirst">If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean,Mogre.Quaternion,System.Int32,System.Int32)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="drawFirst">If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean,Mogre.Quaternion,System.Int32,System.Int32,System.Int32)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="drawFirst">If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Boolean,Mogre.Quaternion,System.Int32,System.Int32,System.Int32,System.String)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="drawFirst">If true, the dome is drawn before all other geometry in the scene, without updating the depth buffer. This is the safest rendering method since all other objects will always appear in front of the sky. However this is not the most efficient way if most of the sky is often occluded by other objects. If this is the case, you can set this parameter to false meaning it draws after all other geometry which can be an optimisation - however you must ensure that the distance value is large enough that no objects will 'poke through' the sky when it is rendered. </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
      <param name="groupName">The name of the resource group to which to assign the plane mesh. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Byte)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Byte,Mogre.Quaternion)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Byte,Mogre.Quaternion,System.Int32)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Byte,Mogre.Quaternion,System.Int32,System.Int32)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Byte,Mogre.Quaternion,System.Int32,System.Int32,System.Int32)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
    </member>
    <member name="M:Mogre.SceneManager._setSkyDome(System.Boolean,System.String,System.Single,System.Single,System.Single,System.Byte,Mogre.Quaternion,System.Int32,System.Int32,System.Int32,System.String)">
      <summary>Enables / disables a 'sky dome' i.e. an illusion of a curved sky. A sky dome is actually formed by 5 sides of a cube, but with texture coordinates generated such that the surface appears curved like a dome. Sky domes are appropriate where you need a realistic looking sky where the scene is not going to be 'fogged', and there is always a 'floor' of some sort to prevent the viewer looking below the horizon (the distortion effect below the horizon can be pretty horrible, and there is never anyhting directly below the viewer). If you need a complete wrap-around background, use the setSkyBox method instead. You can actually combine a sky box and a sky dome if you want, to give a positional backdrop with an overlayed curved cloud layer. Sky domes work well with 2D repeating textures like clouds. You can change the apparant 'curvature' of the sky depending on how your scene is viewed - lower curvatures are better for 'open' scenes like landscapes, whilst higher curvatures are better for say FPS levels where you don't see a lot of the sky at once and the exaggerated curve looks good. </summary>
      <param name="enable">True to enable the skydome, false to disable it </param>
      <param name="materialName">The name of the material the dome will use </param>
      <param name="curvature">The curvature of the dome. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="tiling">How many times to tile the texture(s) across the dome. </param>
      <param name="distance">Distance in world coorinates from the camera to each plane of the box the dome is rendered on. The default is normally OK. </param>
      <param name="renderQueue">The render queue to use when rendering this object </param>
      <param name="orientation">Optional parameter to specify the orientation of the dome. By default the 'top' of the dome is deemed to be in the +y direction, and the 'front' at the -z direction. You can use this parameter to rotate the sky if you want. </param>
      <param name="groupName">The name of the resource group to which to assign the plane mesh. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetSkyDomeGenParameters">
      <summary>Get the parameters used to generate the current SkyDome, if any </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetFog">
      <summary>Sets the fogging mode applied to the scene. This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see Material::setFog). </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetFog(Mogre.FogMode)">
      <summary>Sets the fogging mode applied to the scene. This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see Material::setFog). </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetFog(Mogre.FogMode,Mogre.ColourValue)">
      <summary>Sets the fogging mode applied to the scene. This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see Material::setFog). </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetFog(Mogre.FogMode,Mogre.ColourValue,System.Single)">
      <summary>Sets the fogging mode applied to the scene. This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see Material::setFog). </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetFog(Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to the scene. This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see Material::setFog). </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </param>
      <param name="linearStart">Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </param>
    </member>
    <member name="M:Mogre.SceneManager.SetFog(Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to the scene. This method sets up the scene-wide fogging effect. These settings apply to all geometry rendered, UNLESS the material with which it is rendered has it's own fog settings (see Material::setFog). </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </param>
      <param name="linearStart">Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </param>
      <param name="linearEnd">Distance in world units at which linear fog becomes completely opaque. Only applicable if mode is FOG_LINEAR. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateBillboardSet">
      <summary>Creates a new BillboardSet for use with this scene manager. This method creates a new BillboardSet which is registered with the SceneManager. The SceneManager will destroy this object when it shuts down or when the SceneManager::clearScene method is called, so the caller does not have to worry about destroying this object (in fact, it definitely should not do this). See the BillboardSet documentations for full details of the returned class. BillboardSet</summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateBillboardSet(System.UInt32)">
      <summary>Creates a new BillboardSet for use with this scene manager, with a generated name. BillboardSet</summary>
      <param name="poolSize">The initial size of the pool of billboards (see BillboardSet for more information) </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateBillboardSet(System.String)">
      <summary>Creates a new BillboardSet for use with this scene manager. This method creates a new BillboardSet which is registered with the SceneManager. The SceneManager will destroy this object when it shuts down or when the SceneManager::clearScene method is called, so the caller does not have to worry about destroying this object (in fact, it definitely should not do this). See the BillboardSet documentations for full details of the returned class. BillboardSet</summary>
      <param name="name">The name to give to this billboard set. Must be unique. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateBillboardSet(System.String,System.UInt32)">
      <summary>Creates a new BillboardSet for use with this scene manager. This method creates a new BillboardSet which is registered with the SceneManager. The SceneManager will destroy this object when it shuts down or when the SceneManager::clearScene method is called, so the caller does not have to worry about destroying this object (in fact, it definitely should not do this). See the BillboardSet documentations for full details of the returned class. BillboardSet</summary>
      <param name="name">The name to give to this billboard set. Must be unique. </param>
      <param name="poolSize">The initial size of the pool of billboards (see BillboardSet for more information) </param>
    </member>
    <member name="M:Mogre.SceneManager.GetBillboardSet(System.String)">
      <summary>Retrieves a pointer to the named BillboardSet. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasBillboardSet(System.String)">
      <summary>Returns whether a billboardset with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyBillboardSet(System.String)">
      <summary>Removes &amp; destroys an BillboardSet from the SceneManager by name. Must only be done if the BillboardSet is not attached to a SceneNode. It may be safer to wait to clear the whole scene. If you are unsure, use clearScene. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyBillboardSet(Mogre.BillboardSet)">
      <summary>Removes &amp; destroys an BillboardSet from the SceneManager. Must only be done if the BillboardSet is not attached to a SceneNode. It may be safer to wait to clear the whole scene. If you are unsure, use clearScene. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllBillboardSets">
      <summary>Removes &amp; destroys all BillboardSets. Again, use caution since no BillboardSet must be referred to elsewhere e.g. attached to a SceneNode otherwise a crash is likely. Use clearScene if you are unsure (it clears SceneNode entries too.) SceneManager::clearScene</summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateAnimation(System.String,System.Single)">
      <summary>Creates an animation which can be used to animate scene nodes. An animation is a collection of 'tracks' which over time change the position / orientation of Node objects. In this case, the animation will likely have tracks to modify the position / orientation of SceneNode objects, e.g. to make objects move along a path. You don't need to use an Animation object to move objects around - you can do it yourself using the methods of the Node in your FrameListener class. However, when you need relatively complex scripted animation, this is the class to use since it will interpolate between keyframes for you and generally make the whole process easier to manage. A single animation can affect multiple Node objects (each AnimationTrack affects a single Node). In addition, through animation blending a single Node can be affected by multiple animations, athough this is more useful when performing skeletal animation (see Skeleton::createAnimation). Note that whilst it uses the same classes, the animations created here are kept separate from the skeletal animations of meshes (each Skeleton owns those animations). </summary>
      <param name="name">The name of the animation, must be unique within this SceneManager. </param>
      <param name="length">The total length of the animation. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetAnimation(System.String)">
      <summary>Looks up an Animation object previously created with createAnimation. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasAnimation(System.String)">
      <summary>Returns whether an animation with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAnimation(System.String)">
      <summary>Destroys an Animation. You should ensure that none of your code is referencing this animation objects since the memory will be freed. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllAnimations">
      <summary>Removes all animations created using this SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateAnimationState(System.String)">
      <summary>Create an AnimationState object for managing application of animations. You can create Animation objects for animating SceneNode obejcts using the createAnimation method. However, in order to actually apply those animations you have to call methods on Node and Animation in a particular order (namely Node::resetToInitialState and Animation::apply). To make this easier and to help track the current time position of animations, the AnimationState object is provided.  So if you don't want to control animation application manually, call this method, update the returned object as you like every frame and let SceneManager apply the animation state for you. Remember, AnimationState objects are disabled by default at creation time. Turn them on when you want them using their setEnabled method. Note that any SceneNode affected by this automatic animation will have it's state reset to it's initial position before application of the animation. Unless specifically modified using Node::setInitialState the Node assumes it's initial state is at the origin. If you want the base state of the SceneNode to be elsewhere, make your changes to the node using the standard transform methods, then call setInitialState to 'bake' this reference position into the node. If the target of your animation is to be a generic AnimableValue, you should ensure that it has a base value set (unlike nodes this has no default).AnimableValue::setAsBaseValue. </summary>
      <param name="animName">The name of an animation created already with createAnimation. </param>
    </member>
    <member name="M:Mogre.SceneManager.GetAnimationState(System.String)">
      <summary>Retrieves animation state as previously created using createAnimationState. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasAnimationState(System.String)">
      <summary>Returns whether an animation state with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAnimationState(System.String)">
      <summary>Destroys an AnimationState. You should ensure that none of your code is referencing this animation state object since the memory will be freed. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllAnimationStates">
      <summary>Removes all animation states created using this SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManager.ManualRender(Mogre.IRenderable,Mogre.Pass,Mogre.Viewport,Mogre.Matrix4,Mogre.Matrix4)">
      <summary>Manual rendering method for rendering a single object. </summary>
      <param name="rend">The renderable to issue to the pipeline </param>
      <param name="pass">The pass to use </param>
      <param name="vp">Pointer to the viewport to render to, or 0 to use the existing viewport </param>
      <param name="viewMatrix">The transform to apply from world to view space </param>
      <param name="projMatrix">The transform to apply from view to screen space </param>
    </member>
    <member name="M:Mogre.SceneManager.ManualRender(Mogre.IRenderable,Mogre.Pass,Mogre.Viewport,Mogre.Matrix4,Mogre.Matrix4,System.Boolean)">
      <summary>Manual rendering method for rendering a single object. </summary>
      <param name="rend">The renderable to issue to the pipeline </param>
      <param name="pass">The pass to use </param>
      <param name="vp">Pointer to the viewport to render to, or 0 to use the existing viewport </param>
      <param name="doBeginEndFrame">If true, beginFrame() and endFrame() are called, otherwise not. You should leave this as false if you are calling this within the main render loop. </param>
      <param name="viewMatrix">The transform to apply from world to view space </param>
      <param name="projMatrix">The transform to apply from view to screen space </param>
    </member>
    <member name="M:Mogre.SceneManager.ManualRender(Mogre.IRenderable,Mogre.Pass,Mogre.Viewport,Mogre.Matrix4,Mogre.Matrix4,System.Boolean,System.Boolean)">
      <summary>Manual rendering method for rendering a single object. </summary>
      <param name="rend">The renderable to issue to the pipeline </param>
      <param name="pass">The pass to use </param>
      <param name="vp">Pointer to the viewport to render to, or 0 to use the existing viewport </param>
      <param name="doBeginEndFrame">If true, beginFrame() and endFrame() are called, otherwise not. You should leave this as false if you are calling this within the main render loop. </param>
      <param name="viewMatrix">The transform to apply from world to view space </param>
      <param name="projMatrix">The transform to apply from view to screen space </param>
      <param name="lightScissoringClipping">If true, passes that have the getLightScissorEnabled and/or getLightClipPlanesEnabled flags will cause calculation and setting of scissor rectangle and user clip planes. </param>
    </member>
    <member name="M:Mogre.SceneManager.ManualRender(Mogre.IRenderable,Mogre.Pass,Mogre.Viewport,Mogre.Matrix4,Mogre.Matrix4,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Manual rendering method for rendering a single object. </summary>
      <param name="rend">The renderable to issue to the pipeline </param>
      <param name="pass">The pass to use </param>
      <param name="vp">Pointer to the viewport to render to, or 0 to use the existing viewport </param>
      <param name="doBeginEndFrame">If true, beginFrame() and endFrame() are called, otherwise not. You should leave this as false if you are calling this within the main render loop. </param>
      <param name="viewMatrix">The transform to apply from world to view space </param>
      <param name="projMatrix">The transform to apply from view to screen space </param>
      <param name="lightScissoringClipping">If true, passes that have the getLightScissorEnabled and/or getLightClipPlanesEnabled flags will cause calculation and setting of scissor rectangle and user clip planes. </param>
      <param name="doLightIteration">If true, this method will issue the renderable to the pipeline possibly multiple times, if the pass indicates it should be done once per light </param>
    </member>
    <member name="M:Mogre.SceneManager.ManualRender(Mogre.IRenderable,Mogre.Pass,Mogre.Viewport,Mogre.Matrix4,Mogre.Matrix4,System.Boolean,System.Boolean,System.Boolean,Mogre.Const_LightList)">
      <summary>Manual rendering method for rendering a single object. </summary>
      <param name="rend">The renderable to issue to the pipeline </param>
      <param name="pass">The pass to use </param>
      <param name="vp">Pointer to the viewport to render to, or 0 to use the existing viewport </param>
      <param name="doBeginEndFrame">If true, beginFrame() and endFrame() are called, otherwise not. You should leave this as false if you are calling this within the main render loop. </param>
      <param name="viewMatrix">The transform to apply from world to view space </param>
      <param name="projMatrix">The transform to apply from view to screen space </param>
      <param name="lightScissoringClipping">If true, passes that have the getLightScissorEnabled and/or getLightClipPlanesEnabled flags will cause calculation and setting of scissor rectangle and user clip planes. </param>
      <param name="doLightIteration">If true, this method will issue the renderable to the pipeline possibly multiple times, if the pass indicates it should be done once per light </param>
      <param name="manualLightList">Only applicable if doLightIteration is false, this method allows you to pass in a previously determined set of lights which will be used for a single render of this object. </param>
    </member>
    <member name="M:Mogre.SceneManager.ManualRender(Mogre.RenderOperation,Mogre.Pass,Mogre.Viewport,Mogre.Matrix4,Mogre.Matrix4,Mogre.Matrix4)">
      <summary>Manual rendering method, for advanced users only. This method allows you to send rendering commands through the pipeline on demand, bypassing OGRE's normal world processing. You should only use this if you really know what you're doing; OGRE does lots of things for you that you really should let it do. However, there are times where it may be useful to have this manual interface, for example overlaying something on top of the scene rendered by OGRE. Because this is an instant rendering method, timing is important. The best time to call it is from a RenderTargetListener event handler. Don't call this method a lot, it's designed for rare (1 or 2 times per frame) use. Calling it regularly per frame will cause frame rate drops! </summary>
      <param name="rend">A RenderOperation object describing the rendering op </param>
      <param name="pass">The Pass to use for this render </param>
      <param name="vp">Pointer to the viewport to render to, or 0 to use the current viewport </param>
      <param name="worldMatrix">The transform to apply from object to world space </param>
      <param name="viewMatrix">The transform to apply from world to view space </param>
      <param name="projMatrix">The transform to apply from view to screen space </param>
    </member>
    <member name="M:Mogre.SceneManager.ManualRender(Mogre.RenderOperation,Mogre.Pass,Mogre.Viewport,Mogre.Matrix4,Mogre.Matrix4,Mogre.Matrix4,System.Boolean)">
      <summary>Manual rendering method, for advanced users only. This method allows you to send rendering commands through the pipeline on demand, bypassing OGRE's normal world processing. You should only use this if you really know what you're doing; OGRE does lots of things for you that you really should let it do. However, there are times where it may be useful to have this manual interface, for example overlaying something on top of the scene rendered by OGRE. Because this is an instant rendering method, timing is important. The best time to call it is from a RenderTargetListener event handler. Don't call this method a lot, it's designed for rare (1 or 2 times per frame) use. Calling it regularly per frame will cause frame rate drops! </summary>
      <param name="rend">A RenderOperation object describing the rendering op </param>
      <param name="pass">The Pass to use for this render </param>
      <param name="vp">Pointer to the viewport to render to, or 0 to use the current viewport </param>
      <param name="worldMatrix">The transform to apply from object to world space </param>
      <param name="viewMatrix">The transform to apply from world to view space </param>
      <param name="projMatrix">The transform to apply from view to screen space </param>
      <param name="doBeginEndFrame">If true, beginFrame() and endFrame() are called, otherwise not. You should leave this as false if you are calling this within the main render loop. </param>
    </member>
    <member name="M:Mogre.SceneManager.AddRenderObjectListener(Mogre.RenderObjectListener)">
      <summary>Registers a new Render Object Listener which will be notified when rendering an object. </summary>
    </member>
    <member name="M:Mogre.SceneManager.RemoveRenderObjectListener(Mogre.RenderObjectListener)">
      <summary>Removes a listener previously added with addRenderObjectListener. </summary>
    </member>
    <member name="M:Mogre.SceneManager.AddSpecialCaseRenderQueue(System.Byte)">
      <summary>Adds an item to the 'special case' render queue list. Normally all render queues are rendered, in their usual sequence, only varying if a RenderQueueListener nominates for the queue to be repeated or skipped. This method allows you to add a render queue to a 'special case' list, which varies the behaviour. The effect of this list depends on the 'mode' in which this list is in, which might be to exclude these render queues, or to include them alone (excluding all other queues). This allows you to perform broad selective rendering without requiring a RenderQueueListener. </summary>
      <param name="qid">The identifier of the queue which should be added to the special case list. Nothing happens if the queue is already in the list. </param>
    </member>
    <member name="M:Mogre.SceneManager.RemoveSpecialCaseRenderQueue(System.Byte)">
      <summary>Removes an item to the 'special case' render queue list. SceneManager::addSpecialCaseRenderQueue</summary>
      <param name="qid">The identifier of the queue which should be removed from the special case list. Nothing happens if the queue is not in the list. </param>
    </member>
    <member name="M:Mogre.SceneManager.ClearSpecialCaseRenderQueues">
      <summary>Clears the 'special case' render queue list. SceneManager::addSpecialCaseRenderQueue</summary>
    </member>
    <member name="M:Mogre.SceneManager.SetSpecialCaseRenderQueueMode(Mogre.SceneManager+SpecialCaseRenderQueueMode)">
      <summary>Sets the way the special case render queue list is processed. SceneManager::addSpecialCaseRenderQueue</summary>
      <param name="mode">The mode of processing </param>
    </member>
    <member name="M:Mogre.SceneManager.GetSpecialCaseRenderQueueMode">
      <summary>Gets the way the special case render queue list is processed. </summary>
    </member>
    <member name="M:Mogre.SceneManager.IsRenderQueueToBeProcessed(System.Byte)">
      <summary>Returns whether or not the named queue will be rendered based on the current 'special case' render queue list and mode. SceneManager::addSpecialCaseRenderQueuetrue if the queue will be rendered, false otherwise </summary>
      <param name="qid">The identifier of the queue which should be tested </param>
    </member>
    <member name="M:Mogre.SceneManager._notifyAutotrackingSceneNode(Mogre.SceneNode,System.Boolean)">
      <summary>Internal method for notifying the manager that a SceneNode is autotracking. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateAABBQuery(Mogre.AxisAlignedBox)">
      <summary>Creates an AxisAlignedBoxSceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, for an axis aligned box region. See SceneQuery and AxisAlignedBoxSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="box">Details of the box which describes the region for this query. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateAABBQuery(Mogre.AxisAlignedBox,System.UInt32)">
      <summary>Creates an AxisAlignedBoxSceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, for an axis aligned box region. See SceneQuery and AxisAlignedBoxSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="box">Details of the box which describes the region for this query. </param>
      <param name="mask">The query mask to apply to this query; can be used to filter out certain objects; see SceneQuery for details. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateSphereQuery(Mogre.Sphere)">
      <summary>Creates a SphereSceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, for a spherical region. See SceneQuery and SphereSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="sphere">Details of the sphere which describes the region for this query. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateSphereQuery(Mogre.Sphere,System.UInt32)">
      <summary>Creates a SphereSceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, for a spherical region. See SceneQuery and SphereSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="sphere">Details of the sphere which describes the region for this query. </param>
      <param name="mask">The query mask to apply to this query; can be used to filter out certain objects; see SceneQuery for details. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreatePlaneBoundedVolumeQuery(Mogre.Const_PlaneBoundedVolumeList)">
      <summary>Creates a PlaneBoundedVolumeListSceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, for a region enclosed by a set of planes (normals pointing inwards). See SceneQuery and PlaneBoundedVolumeListSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="volumes">Details of the volumes which describe the region for this query. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreatePlaneBoundedVolumeQuery(Mogre.Const_PlaneBoundedVolumeList,System.UInt32)">
      <summary>Creates a PlaneBoundedVolumeListSceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, for a region enclosed by a set of planes (normals pointing inwards). See SceneQuery and PlaneBoundedVolumeListSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="volumes">Details of the volumes which describe the region for this query. </param>
      <param name="mask">The query mask to apply to this query; can be used to filter out certain objects; see SceneQuery for details. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateRayQuery(Mogre.Ray)">
      <summary>Creates a RaySceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, looking for objects which fall along a ray. See SceneQuery and RaySceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="ray">Details of the ray which describes the region for this query. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateRayQuery(Mogre.Ray,System.UInt32)">
      <summary>Creates a RaySceneQuery for this scene manager. This method creates a new instance of a query object for this scene manager, looking for objects which fall along a ray. See SceneQuery and RaySceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="ray">Details of the ray which describes the region for this query. </param>
      <param name="mask">The query mask to apply to this query; can be used to filter out certain objects; see SceneQuery for details. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateIntersectionQuery">
      <summary>Creates an IntersectionSceneQuery for this scene manager. This method creates a new instance of a query object for locating intersecting objects. See SceneQuery and IntersectionSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateIntersectionQuery(System.UInt32)">
      <summary>Creates an IntersectionSceneQuery for this scene manager. This method creates a new instance of a query object for locating intersecting objects. See SceneQuery and IntersectionSceneQuery for full details. The instance returned from this method must be destroyed by calling SceneManager::destroyQuery when it is no longer required. </summary>
      <param name="mask">The query mask to apply to this query; can be used to filter out certain objects; see SceneQuery for details. </param>
    </member>
    <member name="M:Mogre.SceneManager.DestroyQuery(Mogre.SceneQuery)">
      <summary>Destroys a scene query of any type. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetCameraIterator">
      <summary>Returns a specialised MapIterator over all cameras in the scene. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetAnimationIterator">
      <summary>Returns a specialised MapIterator over all animations in the scene. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetAnimationStateIterator">
      <summary>Returns a specialised MapIterator over all animation states in the scene. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureSize(System.UInt16)">
      <summary>Set the size of the texture used for all texture-based shadows. The larger the shadow texture, the better the detail on texture based shadows, but obviously this takes more memory. The default size is 512. Sizes must be a power of 2. This is the simple form, see setShadowTextureConfig for the more complex form. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureConfig(System.UInt32,Mogre.ShadowTextureConfig)">
      <summary>Set the detailed configuration for a shadow texture. </summary>
      <param name="shadowIndex">The index of the texture to configure, must be &lt; the number of shadow textures setting </param>
      <param name="config">Configuration structure </param>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureConfig(System.UInt32,System.UInt16,System.UInt16,Mogre.PixelFormat)">
      <summary>Set the detailed configuration for a shadow texture. </summary>
      <param name="shadowIndex">The index of the texture to configure, must be &lt; the number of shadow textures setting </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The pixel format of the texture </param>
    </member>
    <member name="M:Mogre.SceneManager.GetShadowTextureConfigIterator">
      <summary>Get an iterator over the current shadow texture settings. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTexturePixelFormat(Mogre.PixelFormat)">
      <summary>Set the pixel format of the textures used for texture-based shadows. By default, a colour texture is used (PF_X8R8G8B8) for texture shadows, but if you want to use more advanced texture shadow types you can alter this. If you do, you will have to also call setShadowTextureCasterMaterial and setShadowTextureReceiverMaterial to provide shader-based materials to use these customised shadow texture formats. This is the simple form, see setShadowTextureConfig for the more complex form. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureCountPerLightType(Mogre.Light+LightTypes,System.UInt32)">
      <summary>Set the number of shadow textures a light type uses. The default for all light types is 1. This means that each light uses only 1 shadow texture. Call this if you need more than 1 shadow texture per light, E.G. PSSM. This feature only works with the Integrated shadow technique. Also remember to increase the total number of shadow textures you request appropriately (e.g. via setShadowTextureCount)!! </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetShadowTextureCountPerLightType(Mogre.Light+LightTypes)">
      <summary>Get the number of shadow textures is assigned for the given light type. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureSettings(System.UInt16,System.UInt16)">
      <summary>Sets the size and count of textures used in texture-based shadows. setShadowTextureSize and setShadowTextureCount for details, this method just allows you to change both at once, which can save on reallocation if the textures have already been created. This is the simple form, see setShadowTextureConfig for the more complex form. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureSettings(System.UInt16,System.UInt16,Mogre.PixelFormat)">
      <summary>Sets the size and count of textures used in texture-based shadows. setShadowTextureSize and setShadowTextureCount for details, this method just allows you to change both at once, which can save on reallocation if the textures have already been created. This is the simple form, see setShadowTextureConfig for the more complex form. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetShadowTexture(System.UInt32)">
      <summary>Get a reference to the shadow texture currently in use at the given index. If you change shadow settings, this reference may no longer be correct, so be sure not to hold the returned reference over texture shadow configuration changes. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureFadeStart(System.Single)">
      <summary>Sets the proportional distance at which texture shadows begin to fade out. To hide the edges where texture shadows end (in directional lights) Ogre will fade out the shadow in the distance. This value is a proportional distance of the entire shadow visibility distance at which the shadow begins to fade out. The default is 0.7 </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureFadeEnd(System.Single)">
      <summary>Sets the proportional distance at which texture shadows finish to fading out. To hide the edges where texture shadows end (in directional lights) Ogre will fade out the shadow in the distance. This value is a proportional distance of the entire shadow visibility distance at which the shadow is completely invisible. The default is 0.9. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureCasterMaterial(System.String)">
      <summary>Sets the default material to use for rendering shadow casters. By default shadow casters are rendered into the shadow texture using an automatically generated fixed-function pass. This allows basic projective texture shadows, but it's possible to use more advanced shadow techniques by overriding the caster and receiver materials, for example providing vertex and fragment programs to implement shadow maps. You can rely on the ambient light in the scene being set to the requested texture shadow colour, if that's useful. Individual objects may also override the vertex program in your default material if their materials include shadow_caster_vertex_program_ref, shadow_receiver_vertex_program_ref shadow_caster_material entries, so if you use both make sure they are compatible. Only a single pass is allowed in your material, although multiple techniques may be used for hardware fallback. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowTextureReceiverMaterial(System.String)">
      <summary>Sets the default material to use for rendering shadow receivers. By default shadow receivers are rendered as a post-pass using basic modulation. This allows basic projective texture shadows, but it's possible to use more advanced shadow techniques by overriding the caster and receiver materials, for example providing vertex and fragment programs to implement shadow maps. You can rely on texture unit 0 containing the shadow texture, and for the unit to be set to use projective texturing from the light (only useful if you're using fixed-function, which is unlikely; otherwise you should rely on the texture_viewproj_matrix auto binding) Individual objects may also override the vertex program in your default material if their materials include shadow_caster_vertex_program_ref shadow_receiver_vertex_program_ref shadow_receiver_material entries, so if you use both make sure they are compatible. Only a single pass is allowed in your material, although multiple techniques may be used for hardware fallback. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowCameraSetup(Mogre.ShadowCameraSetupPtr)">
      <summary>Set the shadow camera setup to use for all lights which don't have their own shadow camera setup. ShadowCameraSetup</summary>
    </member>
    <member name="M:Mogre.SceneManager.GetShadowCameraSetup">
      <summary>Get the shadow camera setup in use for all lights which don't have their own shadow camera setup. ShadowCameraSetup</summary>
    </member>
    <member name="M:Mogre.SceneManager.SetShadowUseInfiniteFarPlane(System.Boolean)">
      <summary>Sets whether we should use an inifinite camera far plane when rendering stencil shadows. Stencil shadow coherency is very reliant on the shadow volume not being clipped by the far plane. If this clipping happens, you get a kind of 'negative' shadow effect. The best way to achieve coherency is to move the far plane of the camera out to infinity, thus preventing the far plane from clipping the shadow volumes. When combined with vertex program extrusion of the volume to infinity, which Ogre does when available, this results in very robust shadow volumes. For this reason, when you enable stencil shadows, Ogre automatically changes your camera settings to project to infinity if the card supports it. You can disable this behaviour if you like by calling this method; although you can never enable infinite projection if the card does not support it. If you disable infinite projection, or it is not available, you need to be far more careful with your light attenuation / directional light extrusion distances to avoid clipping artefacts at the far plane. Recent cards will generally support infinite far plane projection. However, we have found some cases where they do not, especially on Direct3D. There is no standard capability we can check to validate this, so we use some heuristics based on experience: OpenGL always seems to support it no matter what the card Direct3D on non-vertex program capable systems (including vertex program capable cards on Direct3D7) does not support it Direct3D on GeForce3 and GeForce4 Ti does not seem to support infinite projection
Therefore in the RenderSystem implementation, we may veto the use of an infinite far plane based on these heuristics. </summary>
    </member>
    <member name="M:Mogre.SceneManager._setActiveCompositorChain(Mogre.CompositorChain)">
      <summary>Sets the active compositor chain of the current scene being rendered. CompositorChain does this automatically, no need to call manually. </summary>
    </member>
    <member name="M:Mogre.SceneManager.SetLateMaterialResolving(System.Boolean)">
      <summary>Sets whether to use late material resolving or not. If set, materials will be resolved from the materials at the pass-setting stage and not at the render queue building stage. This is useful when the active material scheme during the render queue building stage is different from the one during the rendering stage. </summary>
    </member>
    <member name="M:Mogre.SceneManager._getActiveCompositorChain">
      <summary>Gets the active compositor chain of the current scene being rendered </summary>
    </member>
    <member name="M:Mogre.SceneManager.AddListener(Mogre.SceneManager+IListener)">
      <summary>Add a listener which will get called back on scene manager events. </summary>
    </member>
    <member name="M:Mogre.SceneManager.RemoveListener(Mogre.SceneManager+IListener)">
      <summary>Remove a listener </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateStaticGeometry(System.String)">
      <summary>Creates a StaticGeometry instance suitable for use with this SceneManager. StaticGeometry is a way of batching up geometry into a more efficient form at the expense of being able to move it. Please read the StaticGeometry class documentation for full information. The new StaticGeometry instance </summary>
      <param name="name">The name to give the new object </param>
    </member>
    <member name="M:Mogre.SceneManager.GetStaticGeometry(System.String)">
      <summary>Retrieve a previously created StaticGeometry instance. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasStaticGeometry(System.String)">
      <summary>Returns whether a static geometry instance with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyStaticGeometry(System.String)">
      <summary>Remove &amp; destroy a StaticGeometry instance. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyStaticGeometry(Mogre.StaticGeometry)">
      <summary>Remove &amp; destroy a StaticGeometry instance. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllStaticGeometry">
      <summary>Remove &amp; destroy all StaticGeometry instances. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateInstancedGeometry(System.String)">
      <summary>Creates a InstancedGeometry instance suitable for use with this SceneManager. InstancedGeometry is a way of batching up geometry into a more efficient form, and still be able to move it. Please read the InstancedGeometry class documentation for full information. The new InstancedGeometry instance </summary>
      <param name="name">The name to give the new object </param>
    </member>
    <member name="M:Mogre.SceneManager.GetInstancedGeometry(System.String)">
      <summary>Retrieve a previously created InstancedGeometry instance. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyInstancedGeometry(System.String)">
      <summary>Remove &amp; destroy a InstancedGeometry instance. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyInstancedGeometry(Mogre.InstancedGeometry)">
      <summary>Remove &amp; destroy a InstancedGeometry instance. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllInstancedGeometry">
      <summary>Remove &amp; destroy all InstancedGeometry instances. </summary>
    </member>
    <member name="M:Mogre.SceneManager.CreateMovableObject(System.String)">
      <summary>Create a movable object of the type specified without a name. This is the generalised form of MovableObject creation where you can create a MovableObject of any specialised type generically, including any new types registered using plugins. The name is generated automatically. </summary>
      <param name="typeName">The type of object to create </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateMovableObject(System.String,Mogre.Const_NameValuePairList)">
      <summary>Create a movable object of the type specified without a name. This is the generalised form of MovableObject creation where you can create a MovableObject of any specialised type generically, including any new types registered using plugins. The name is generated automatically. </summary>
      <param name="typeName">The type of object to create </param>
      <param name="params">Optional name/value pair list to give extra parameters to the created object. </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateMovableObject(System.String,System.String)">
      <summary>Create a movable object of the type specified. This is the generalised form of MovableObject creation where you can create a MovableObject of any specialised type generically, including any new types registered using plugins. </summary>
      <param name="name">The name to give the object. Must be unique within type. </param>
      <param name="typeName">The type of object to create </param>
    </member>
    <member name="M:Mogre.SceneManager.CreateMovableObject(System.String,System.String,Mogre.Const_NameValuePairList)">
      <summary>Create a movable object of the type specified. This is the generalised form of MovableObject creation where you can create a MovableObject of any specialised type generically, including any new types registered using plugins. </summary>
      <param name="name">The name to give the object. Must be unique within type. </param>
      <param name="typeName">The type of object to create </param>
      <param name="params">Optional name/value pair list to give extra parameters to the created object. </param>
    </member>
    <member name="M:Mogre.SceneManager.DestroyMovableObject(Mogre.MovableObject)">
      <summary>Destroys a MovableObject. The MovableObject will automatically detach itself from any nodes on destruction. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyMovableObject(System.String,System.String)">
      <summary>Destroys a MovableObject with the name specified, of the type specified. The MovableObject will automatically detach itself from any nodes on destruction. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllMovableObjectsByType(System.String)">
      <summary>Destroy all MovableObjects of a given type. </summary>
    </member>
    <member name="M:Mogre.SceneManager.DestroyAllMovableObjects">
      <summary>Destroy all MovableObjects. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetMovableObject(System.String,System.String)">
      <summary>Get a reference to a previously created MovableObject. Throws an exception if the named instance does not exist </summary>
    </member>
    <member name="M:Mogre.SceneManager.HasMovableObject(System.String,System.String)">
      <summary>Returns whether a movable object instance with the given name exists. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetMovableObjectIterator(System.String)">
      <summary>Get an iterator over all MovableObect instances of a given type. The iterator returned from this method is not thread safe, do not use this if you are creating or deleting objects of this type in another thread. </summary>
    </member>
    <member name="M:Mogre.SceneManager.InjectMovableObject(Mogre.MovableObject)">
      <summary>Inject a MovableObject instance created externally. This method 'injects' a MovableObject instance created externally into the MovableObject instance registry held in the SceneManager. You might want to use this if you have a MovableObject which you don't want to register a factory for; for example a MovableObject which cannot be generally constructed by clients. It is important that the MovableObject has a unique name for the type, and that its getMovableType() method returns a proper type name. </summary>
    </member>
    <member name="M:Mogre.SceneManager.ExtractMovableObject(Mogre.MovableObject)">
      <summary>Extract a previously injected MovableObject. Essentially this does the same as destroyMovableObject, but only removes the instance from the internal lists, it does not attempt to destroy it. </summary>
    </member>
    <member name="M:Mogre.SceneManager.ExtractMovableObject(System.String,System.String)">
      <summary>Extract a previously injected MovableObject. Essentially this does the same as destroyMovableObject, but only removes the instance from the internal lists, it does not attempt to destroy it. </summary>
    </member>
    <member name="M:Mogre.SceneManager.ExtractAllMovableObjectsByType(System.String)">
      <summary>Extract all injected MovableObjects of a given type. Essentially this does the same as destroyAllMovableObjectsByType, but only removes the instances from the internal lists, it does not attempt to destroy them. </summary>
    </member>
    <member name="M:Mogre.SceneManager._getCombinedVisibilityMask">
      <summary>Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask. </summary>
    </member>
    <member name="M:Mogre.SceneManager._injectRenderWithPass(Mogre.Pass,Mogre.IRenderable)">
      <summary>Render something as if it came from the current queue. </summary>
      <param name="pass">Material pass to use for setting up this quad. </param>
      <param name="rend">Renderable to render </param>
    </member>
    <member name="M:Mogre.SceneManager._injectRenderWithPass(Mogre.Pass,Mogre.IRenderable,System.Boolean)">
      <summary>Render something as if it came from the current queue. </summary>
      <param name="pass">Material pass to use for setting up this quad. </param>
      <param name="rend">Renderable to render </param>
      <param name="shadowDerivation">Whether passes should be replaced with shadow caster / receiver passes </param>
    </member>
    <member name="M:Mogre.SceneManager._injectRenderWithPass(Mogre.Pass,Mogre.IRenderable,System.Boolean,System.Boolean)">
      <summary>Render something as if it came from the current queue. </summary>
      <param name="pass">Material pass to use for setting up this quad. </param>
      <param name="rend">Renderable to render </param>
      <param name="shadowDerivation">Whether passes should be replaced with shadow caster / receiver passes </param>
    </member>
    <member name="M:Mogre.SceneManager._injectRenderWithPass(Mogre.Pass,Mogre.IRenderable,System.Boolean,System.Boolean,Mogre.Const_LightList)">
      <summary>Render something as if it came from the current queue. </summary>
      <param name="pass">Material pass to use for setting up this quad. </param>
      <param name="rend">Renderable to render </param>
      <param name="shadowDerivation">Whether passes should be replaced with shadow caster / receiver passes </param>
    </member>
    <member name="M:Mogre.SceneManager._suppressRenderStateChanges(System.Boolean)">
      <summary>Indicates to the SceneManager whether it should suppress changing the RenderSystem states when rendering objects. This method allows you to tell the SceneManager not to change any RenderSystem state until you tell it to. This method is only intended for advanced use, don't use it if you're unsure of the effect. The only RenderSystems calls made are to set the world matrix for each object (note - view an projection matrices are NOT SET - they are under your control) and to render the object; it is up to the caller to do everything else, including enabling any vertex / fragment programs and updating their parameter state, and binding parameters to the RenderSystem. Calling this implicitly disables shadow processing since no shadows can be rendered without changing state. </summary>
      <param name="suppress">If true, no RenderSystem state changes will be issued until this method is called again with a parameter of false. </param>
    </member>
    <member name="M:Mogre.SceneManager._areRenderStateChangesSuppressed">
      <summary>Are render state changes suppressed? _suppressRenderStateChanges</summary>
    </member>
    <member name="M:Mogre.SceneManager._setPass(Mogre.Pass)">
      <summary>Internal method for setting up the renderstate for a rendering pass. A Pass object that was used instead of the one passed in, can happen when rendering shadow passes </summary>
      <param name="pass">The Pass details to set. </param>
    </member>
    <member name="M:Mogre.SceneManager._setPass(Mogre.Pass,System.Boolean)">
      <summary>Internal method for setting up the renderstate for a rendering pass. A Pass object that was used instead of the one passed in, can happen when rendering shadow passes </summary>
      <param name="pass">The Pass details to set. </param>
      <param name="evenIfSuppressed">Sets the pass details even if render state changes are suppressed; if you are using this to manually set state when render state changes are suppressed, you should set this to true. </param>
    </member>
    <member name="M:Mogre.SceneManager._setPass(Mogre.Pass,System.Boolean,System.Boolean)">
      <summary>Internal method for setting up the renderstate for a rendering pass. A Pass object that was used instead of the one passed in, can happen when rendering shadow passes </summary>
      <param name="pass">The Pass details to set. </param>
      <param name="evenIfSuppressed">Sets the pass details even if render state changes are suppressed; if you are using this to manually set state when render state changes are suppressed, you should set this to true. </param>
      <param name="shadowDerivation">If false, disables the derivation of shadow passes from original passes </param>
    </member>
    <member name="M:Mogre.SceneManager._suppressShadows(System.Boolean)">
      <summary>Indicates to the SceneManager whether it should suppress the active shadow rendering technique until told otherwise. This is a temporary alternative to setShadowTechnique to suppress the rendering of shadows and forcing all processing down the standard rendering path. This is intended for internal use only. </summary>
      <param name="suppress">If true, no shadow rendering will occur until this method is called again with a parameter of false. </param>
    </member>
    <member name="M:Mogre.SceneManager._areShadowsSuppressed">
      <summary>Are shadows suppressed? _suppressShadows</summary>
    </member>
    <member name="M:Mogre.SceneManager._renderQueueGroupObjects(Mogre.RenderQueueGroup,Mogre.QueuedRenderableCollection+OrganisationMode)">
      <summary>Render the objects in a given queue group You should only call this from a RenderQueueInvocation implementation </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetVisibleObjectsBoundsInfo(Mogre.Camera)">
      <summary>Returns a visibility boundary box for a specific camera. </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetShadowCasterBoundsInfo(Mogre.Light)">
      <summary>Returns the shadow caster AAB for a specific light-camera combination </summary>
    </member>
    <member name="M:Mogre.SceneManager.GetShadowCasterBoundsInfo(Mogre.Light,System.UInt32)">
      <summary>Returns the shadow caster AAB for a specific light-camera combination </summary>
    </member>
    <member name="M:Mogre.SceneManager.AddLodListener(Mogre.LodListener)">
      <summary>Add a level of detail listener. </summary>
    </member>
    <member name="M:Mogre.SceneManager.RemoveLodListener(Mogre.LodListener)">
      <summary>Remove a level of detail listener. Do not call from inside an LodListener callback method. </summary>
    </member>
    <member name="M:Mogre.SceneManager._notifyMovableObjectLodChanged(Mogre.MovableObjectLodChangedEvent_NativePtr)">
      <summary>Notify that a movable object lod change event has occurred. </summary>
    </member>
    <member name="M:Mogre.SceneManager._notifyEntityMeshLodChanged(Mogre.EntityMeshLodChangedEvent_NativePtr)">
      <summary>Notify that an entity mesh lod change event has occurred. </summary>
    </member>
    <member name="M:Mogre.SceneManager._notifyEntityMaterialLodChanged(Mogre.EntityMaterialLodChangedEvent_NativePtr)">
      <summary>Notify that an entity material lod change event has occurred. </summary>
    </member>
    <member name="M:Mogre.SceneManager._handleLodEvents">
      <summary>Handle lod events. </summary>
    </member>
    <member name="P:Mogre.SceneManager.WorldGeometryRenderQueue">
      <summary>Sets/Gets the render queue that the world geometry (if any) this SceneManager renders will be associated with. SceneManagers which provide 'world geometry' should place it in a specialised render queue in order to make it possible to enable / disable it easily using the addSpecialCaseRenderQueue method. Even if the SceneManager does not use the render queues to render the world geometry, it should still pick a queue to represent it's manual rendering, and check isRenderQueueToBeProcessed before rendering. </summary>
    </member>
    <member name="P:Mogre.SceneManager.VisibilityMask">
      <summary>Sets/Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. </summary>
    </member>
    <member name="P:Mogre.SceneManager.TypeName">
      <summary>Retrieve the type name of this scene manager. This method has to be implemented by subclasses. It should return the type name of this SceneManager which agrees with the type name of the SceneManagerFactory which created it. </summary>
    </member>
    <member name="P:Mogre.SceneManager.SkyPlaneNode">
      <summary>Get the sky plane node, if enabled. </summary>
    </member>
    <member name="P:Mogre.SceneManager.SkyDomeNode">
      <summary>Get the sky dome node, if enabled. </summary>
    </member>
    <member name="P:Mogre.SceneManager.SkyBoxNode">
      <summary>Get the skybox node, if enabled. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShowDebugShadows">
      <summary>Sets/Are debug shadows shown? </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShowBoundingBoxes">
      <summary>Sets/Allows all bounding boxes of scene nodes to be displayed. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowUseLightClipPlanes">
      <summary>Sets/Gets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowTextureSelfShadow">
      <summary>Sets/Gets whether or not texture shadows attempt to self-shadow. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowTextureCount">
      <summary>Sets/Get the number of the textures allocated for texture based shadows. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowTechnique">
      <summary>Sets/Gets the current shadow technique. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowIndexBufferSize">
      <summary>Sets/Get the size of the shadow index buffer. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowFarDistance">
      <summary>Sets/Gets the default maximum distance away from the camera that shadows will be visible. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowDirLightTextureOffset">
      <summary>Sets/Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowDirectionalLightExtrusionDistance">
      <summary>Sets/Gets the distance a shadow volume is extruded for a directional light. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowColour">
      <summary>Sets/Get the colour used to modulate areas in shadow. This is only applicable for shadow techniques which involve darkening the area in shadow, as opposed to masking out the light. This colour provided is used as a modulative value to darken the areas. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ShadowCasterRenderBackFaces">
      <summary>Sets/Gets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. </summary>
    </member>
    <member name="P:Mogre.SceneManager.RootSceneNode">
      <summary>Gets the SceneNode at the root of the scene hierarchy. The entire scene is held as a hierarchy of nodes, which allows things like relative transforms, general changes in rendering state etc (See the SceneNode class for more info). In this basic SceneManager class, the application using Ogre is free to structure this hierarchy however it likes, since it has no real significance apart from making transforms relative to each node (more specialised subclasses will provide utility methods for building specific node structures e.g. loading a BSP tree). However, in all cases there is only ever one root node of the hierarchy, and this method returns a pointer to it. </summary>
    </member>
    <member name="P:Mogre.SceneManager.RenderQueue">
      <summary>Retrieves the internal render queue, for advanced users only. The render queue is mainly used internally to manage the scene object rendering queue, it also exports some methods to allow advanced users to configure the behavior of rendering process. Most methods provided by RenderQueue are supposed to be used internally only, you should reference to the RenderQueue API for more information. Do not access this directly unless you know what you are doing. </summary>
    </member>
    <member name="P:Mogre.SceneManager.NormaliseNormalsOnScale">
      <summary>Sets/Get whether to automatically normalise normals on objects whenever they are scaled. </summary>
    </member>
    <member name="P:Mogre.SceneManager.Name">
      <summary>Return the instance name of this SceneManager. </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsSkyPlaneEnabled">
      <summary>Return whether a key plane is enabled </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsSkyDomeEnabled">
      <summary>Return whether a skydome is enabled </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsSkyBoxEnabled">
      <summary>Return whether a skybox is enabled </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsShadowTechniqueTextureBased">
      <summary>Is there a texture shadow based shadowing technique in use? </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsShadowTechniqueStencilBased">
      <summary>Is there a stencil shadow based shadowing technique in use? </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsShadowTechniqueModulative">
      <summary>Is there a modulative shadowing technique in use? </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsShadowTechniqueInUse">
      <summary>Is there any shadowing technique in use? </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsShadowTechniqueIntegrated">
      <summary>Is the shadow technique integrated into primary materials? </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsShadowTechniqueAdditive">
      <summary>Is there an additive shadowing technique in use? </summary>
    </member>
    <member name="P:Mogre.SceneManager.IsLateMaterialResolving">
      <summary>Gets whether using late material resolving or not. setLateMaterialResolving</summary>
    </member>
    <member name="P:Mogre.SceneManager.FogStart">
      <summary>Returns the fog start distance for the scene. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FogMode">
      <summary>Returns the fog mode for the scene. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FogEnd">
      <summary>Returns the fog end distance for the scene. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FogDensity">
      <summary>Returns the fog density for the scene. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FogColour">
      <summary>Returns the fog colour for the scene. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FlipCullingOnNegativeScale">
      <summary>Sets/Get whether to automatically flip the culling mode on objects whenever they are negatively scaled. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FindVisibleObjects">
      <summary>Sets/Gets whether the SceneManager should search for visible objects, or whether they are being manually handled. </summary>
    </member>
    <member name="P:Mogre.SceneManager.DisplaySceneNodes">
      <summary>Sets/Returns true if all scene nodes axis are to be displayed </summary>
    </member>
    <member name="P:Mogre.SceneManager.DestinationRenderSystem">
      <summary>Get the rendersystem subclass to which the output of this Scene Manager gets sent </summary>
    </member>
    <member name="P:Mogre.SceneManager.CurrentViewport">
      <summary>Gets the current viewport being rendered (advanced use only, only valid during viewport update. </summary>
    </member>
    <member name="P:Mogre.SceneManager.CameraRelativeRendering">
      <summary>Sets/Get whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. </summary>
    </member>
    <member name="P:Mogre.SceneManager.AmbientLight">
      <summary>Sets/Returns the ambient light level to be used for the scene. </summary>
    </member>
    <member name="P:Mogre.SceneManager.USER_TYPE_MASK_LIMIT">
      <summary>Sets/User type mask limit. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FRUSTUM_TYPE_MASK">
      <summary>Sets/Query type mask which will be used for frusta and cameras. </summary>
    </member>
    <member name="P:Mogre.SceneManager.LIGHT_TYPE_MASK">
      <summary>Sets/Query type mask which will be used for lights. </summary>
    </member>
    <member name="P:Mogre.SceneManager.STATICGEOMETRY_TYPE_MASK">
      <summary>Sets/Query type mask which will be used for StaticGeometry. </summary>
    </member>
    <member name="P:Mogre.SceneManager.FX_TYPE_MASK">
      <summary>Sets/Query type mask which will be used for effects like billboardsets / particle systems. </summary>
    </member>
    <member name="P:Mogre.SceneManager.ENTITY_TYPE_MASK">
      <summary>Sets/Query type mask which will be used for entities. </summary>
    </member>
    <member name="P:Mogre.SceneManager.WORLD_GEOMETRY_TYPE_MASK">
      <summary>Sets/Query type mask which will be used for world geometry. </summary>
    </member>
    <member name="T:Mogre.SceneManager+IlluminationRenderStage">
      <summary>Describes the stage of rendering when performing complex illumination. </summary>
    </member>
    <member name="F:Mogre.SceneManager+IlluminationRenderStage.IRS_NONE">
      <summary>No special illumination stage. </summary>
    </member>
    <member name="F:Mogre.SceneManager+IlluminationRenderStage.IRS_RENDER_TO_TEXTURE">
      <summary>Render to texture stage, used for texture based shadows. </summary>
    </member>
    <member name="F:Mogre.SceneManager+IlluminationRenderStage.IRS_RENDER_RECEIVER_PASS">
      <summary>Render from shadow texture to receivers stage. </summary>
    </member>
    <member name="T:Mogre.SceneManager+SpecialCaseRenderQueueMode">
      <summary>Enumeration of the possible modes allowed for processing the special case render queue list. SceneManager::setSpecialCaseRenderQueueMode</summary>
    </member>
    <member name="F:Mogre.SceneManager+SpecialCaseRenderQueueMode.SCRQM_INCLUDE">
      <summary>Render only the queues in the special case list. </summary>
    </member>
    <member name="F:Mogre.SceneManager+SpecialCaseRenderQueueMode.SCRQM_EXCLUDE">
      <summary>Render all except the queues in the special case list. </summary>
    </member>
    <member name="T:Mogre.SceneManager+PrefabType">
      <summary>Prefab shapes available without loading a model. Minimal implementation at present. </summary>
    </member>
    <member name="T:Mogre.DefaultIntersectionSceneQuery">
      <summary>Default implementation of IntersectionSceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultIntersectionSceneQuery.Execute(Mogre.IIntersectionSceneQueryListener)">
      <summary>See IntersectionSceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultIntersectionSceneQuery.Execute(Mogre.IIntersectionSceneQueryListener)">
      <summary>See IntersectionSceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultIntersectionSceneQuery.Execute">
      <summary>See IntersectionSceneQuery. </summary>
    </member>
    <member name="T:Mogre.DefaultRaySceneQuery">
      <summary>Default implementation of RaySceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultRaySceneQuery.Execute(Mogre.IRaySceneQueryListener)">
      <summary>See RayScenQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultRaySceneQuery.Execute(Mogre.IRaySceneQueryListener)">
      <summary>See RayScenQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultRaySceneQuery.Execute">
      <summary>See RayScenQuery. </summary>
    </member>
    <member name="T:Mogre.DefaultSphereSceneQuery">
      <summary>Default implementation of SphereSceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultSphereSceneQuery.Execute(Mogre.ISceneQueryListener)">
      <summary>See SceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultSphereSceneQuery.Execute(Mogre.ISceneQueryListener)">
      <summary>See SceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultSphereSceneQuery.Execute">
      <summary>See SceneQuery. </summary>
    </member>
    <member name="T:Mogre.DefaultPlaneBoundedVolumeListSceneQuery">
      <summary>Default implementation of PlaneBoundedVolumeListSceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultPlaneBoundedVolumeListSceneQuery.Execute(Mogre.ISceneQueryListener)">
      <summary>See SceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultPlaneBoundedVolumeListSceneQuery.Execute(Mogre.ISceneQueryListener)">
      <summary>See SceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultPlaneBoundedVolumeListSceneQuery.Execute">
      <summary>See SceneQuery. </summary>
    </member>
    <member name="T:Mogre.DefaultAxisAlignedBoxSceneQuery">
      <summary>Default implementation of AxisAlignedBoxSceneQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultAxisAlignedBoxSceneQuery.Execute(Mogre.ISceneQueryListener)">
      <summary>See RayScenQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultAxisAlignedBoxSceneQuery.Execute(Mogre.ISceneQueryListener)">
      <summary>See RayScenQuery. </summary>
    </member>
    <member name="M:Mogre.DefaultAxisAlignedBoxSceneQuery.Execute">
      <summary>See RayScenQuery. </summary>
    </member>
    <member name="T:Mogre.SceneManagerFactory">
      <summary>Class which will create instances of a given SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManagerFactory.CreateInstance(System.String)">
      <summary>Create a new instance of a SceneManager. Don't call directly, use SceneManagerEnumerator::createSceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManagerFactory.DestroyInstance(Mogre.SceneManager)">
      <summary>Destroy an instance of a SceneManager. </summary>
    </member>
    <member name="P:Mogre.SceneManagerFactory.MetaData">
      <summary>Get information about the SceneManager type created by this factory. </summary>
    </member>
    <member name="T:Mogre.RenderQueue">
      <summary>Class to manage the scene object rendering queue. Objects are grouped by material to minimise rendering state changes. The map from material to renderable object is wrapped in a class for ease of use. This class now includes the concept of 'queue groups' which allows the application adding the renderable to specifically schedule it so that it is included in a discrete group. Good for separating renderables into the main scene, backgrounds and overlays, and also could be used in the future for more complex multipass routines like stenciling. </summary>
    </member>
    <member name="M:Mogre.RenderQueue.Clear">
      <summary>Empty the queue - should only be called by SceneManagers. </summary>
    </member>
    <member name="M:Mogre.RenderQueue.Clear(System.Boolean)">
      <summary>Empty the queue - should only be called by SceneManagers. </summary>
      <param name="destroyPassMaps">Set to true to destroy all pass maps so that the queue is completely clean (useful when switching scene managers) </param>
    </member>
    <member name="M:Mogre.RenderQueue.GetQueueGroup(System.Byte)">
      <summary>Get a render queue group. OGRE registers new queue groups as they are requested, therefore this method will always return a valid group. </summary>
    </member>
    <member name="M:Mogre.RenderQueue.AddRenderable(Mogre.IRenderable)">
      <summary>Add a renderable object to the queue. This methods adds a Renderable to the queue, which will be rendered later by the SceneManager. This is the advanced version of the call which allows the renderable to be added to any queue. Called by implementation of MovableObject::_updateRenderQueue. </summary>
      <param name="pRend">Pointer to the Renderable to be added to the queue </param>
    </member>
    <member name="M:Mogre.RenderQueue.AddRenderable(Mogre.IRenderable,System.Byte)">
      <summary>Add a renderable object to the queue. This methods adds a Renderable to the queue, which will be rendered later by the SceneManager. This is the advanced version of the call which allows the renderable to be added to any queue. Called by implementation of MovableObject::_updateRenderQueue. </summary>
      <param name="pRend">Pointer to the Renderable to be added to the queue </param>
      <param name="groupID">The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the SceneManager respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </param>
    </member>
    <member name="M:Mogre.RenderQueue.AddRenderable(Mogre.IRenderable,System.Byte,System.UInt16)">
      <summary>Add a renderable object to the queue. This methods adds a Renderable to the queue, which will be rendered later by the SceneManager. This is the advanced version of the call which allows the renderable to be added to any queue. Called by implementation of MovableObject::_updateRenderQueue. </summary>
      <param name="pRend">Pointer to the Renderable to be added to the queue </param>
      <param name="groupID">The group the renderable is to be added to. This can be used to schedule renderable objects in separate groups such that the SceneManager respects the divisions between the groupings and does not reorder them outside these boundaries. This can be handy for overlays where no matter what you want the overlay to be rendered last. </param>
      <param name="priority">Controls the priority of the renderable within the queue group. If this number is raised, the renderable will be rendered later in the group compared to it's peers. Don't use this unless you really need to, manually ordering renderables prevents OGRE from sorting them for best efficiency. However this could be useful for ordering 2D elements manually for example. </param>
    </member>
    <member name="M:Mogre.RenderQueue._getQueueGroupIterator">
      <summary>Internal method, returns an iterator for the queue groups. </summary>
    </member>
    <member name="M:Mogre.RenderQueue.SetRenderableListener(Mogre.RenderQueue+IRenderableListener)">
      <summary>Set a renderable listener on the queue. There can only be a single renderable listener on the queue, since that listener has complete control over the techniques in use. </summary>
    </member>
    <member name="M:Mogre.RenderQueue.Merge(Mogre.RenderQueue)">
      <summary>Merge render queue. </summary>
    </member>
    <member name="M:Mogre.RenderQueue.ProcessVisibleObject(Mogre.MovableObject,Mogre.Camera,System.Boolean,Mogre.VisibleObjectsBoundsInfo_NativePtr)">
      <summary>Utility method to perform the standard actions associated with getting a visible object to add itself to the queue. This is a replacement for SceneManager implementations of the associated tasks related to calling MovableObject::_updateRenderQueue. </summary>
    </member>
    <member name="P:Mogre.RenderQueue.SplitPassesByLightingType">
      <summary>Sets/Gets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. </summary>
    </member>
    <member name="P:Mogre.RenderQueue.SplitNoShadowPasses">
      <summary>Sets/Gets whether or not the queue will split passes which have shadow receive turned off (in their parent material), which is needed when certain shadow techniques are used. </summary>
    </member>
    <member name="P:Mogre.RenderQueue.ShadowCastersCannotBeReceivers">
      <summary>Sets/Gets whether or not objects which cast shadows should be treated as never receiving shadows. </summary>
    </member>
    <member name="P:Mogre.RenderQueue.DefaultRenderablePriority">
      <summary>Sets/Gets the current default renderable priority, which will be used for all renderables which do not specify which priority they wish to use. </summary>
    </member>
    <member name="P:Mogre.RenderQueue.DefaultQueueGroup">
      <summary>Sets/Gets the current default queue group, which will be used for all renderable which do not specify which group they wish to be on. </summary>
    </member>
    <member name="T:Mogre.RenderOperation">
      <summary>'New' rendering operation using vertex buffers. </summary>
    </member>
    <member name="P:Mogre.RenderOperation.srcRenderable">
      <summary>Debug pointer back to renderable which created this. </summary>
    </member>
    <member name="P:Mogre.RenderOperation.indexData">
      <summary>Sets/Index data - only valid if useIndexes is true. </summary>
    </member>
    <member name="P:Mogre.RenderOperation.useIndexes">
      <summary>Sets/Specifies whether to use indexes to determine the vertices to use as input. If false, the vertices are simply read in sequence to define the primitives. If true, indexes are used instead to identify vertices anywhere in the buffer, and allowing vertices to be used more than once. If true, then the indexBuffer, indexStart and numIndexes properties must be valid. </summary>
    </member>
    <member name="P:Mogre.RenderOperation.operationType">
      <summary>Sets/The rendering operation type to perform. </summary>
    </member>
    <member name="P:Mogre.RenderOperation.vertexData">
      <summary>Sets/Vertex source data. </summary>
    </member>
    <member name="T:Mogre.RenderOperation+OperationTypes">
      <summary>The rendering operation type to perform. </summary>
    </member>
    <member name="F:Mogre.RenderOperation+OperationTypes.OT_POINT_LIST">
      <summary>A list of points, 1 vertex per point. </summary>
    </member>
    <member name="F:Mogre.RenderOperation+OperationTypes.OT_LINE_LIST">
      <summary>A list of lines, 2 vertices per line. </summary>
    </member>
    <member name="F:Mogre.RenderOperation+OperationTypes.OT_LINE_STRIP">
      <summary>A strip of connected lines, 1 vertex per line plus 1 start vertex. </summary>
    </member>
    <member name="F:Mogre.RenderOperation+OperationTypes.OT_TRIANGLE_LIST">
      <summary>A list of triangles, 3 vertices per triangle. </summary>
    </member>
    <member name="F:Mogre.RenderOperation+OperationTypes.OT_TRIANGLE_STRIP">
      <summary>A strip of triangles, 3 vertices for the first triangle, and 1 per triangle after that. </summary>
    </member>
    <member name="F:Mogre.RenderOperation+OperationTypes.OT_TRIANGLE_FAN">
      <summary>A fan of triangles, 3 vertices for the first triangle, and 1 per triangle after that. </summary>
    </member>
    <member name="T:Mogre.DriverVersion">
      <summary>DriverVersion is used by RenderSystemCapabilities and both GL and D3D9 to store the version of the current GPU driver </summary>
    </member>
    <member name="T:Mogre.RenderSystemCapabilities">
      <summary>singleton class for storing the capabilities of the graphics card. This class stores the capabilities of the graphics card. This information is set by the individual render systems. </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.ParseVendorFromString(System.String)">
      <summary>Parse and set vendor. </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.IsCapabilityRenderSystemSpecific(Mogre.Capabilities)">
      <summary>Returns true if capability is render system specific </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.SetCapability(Mogre.Capabilities)">
      <summary>Adds a capability flag </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.UnsetCapability(Mogre.Capabilities)">
      <summary>Remove a capability flag </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.HasCapability(Mogre.Capabilities)">
      <summary>Checks for a capability </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.AddShaderProfile(System.String)">
      <summary>Adds the profile to the list of supported profiles </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.RemoveShaderProfile(System.String)">
      <summary>Remove a given shader profile, if present. </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.IsShaderProfileSupported(System.String)">
      <summary>Returns true if profile is in the list of supported profiles </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.GetSupportedShaderProfiles">
      <summary>Returns a set of all supported shader profiles </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.SetCategoryRelevant(Mogre.CapabilitiesCategory,System.Boolean)">
      <summary>Mark a category as 'relevant' or not, ie will it be reported. </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.IsCategoryRelevant(Mogre.CapabilitiesCategory)">
      <summary>Return whether a category is 'relevant' or not, ie will it be reported. </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.Log(Mogre.Log)">
      <summary>Write the capabilities to the pass in Log</summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.VendorFromString(System.String)">
      <summary>Convert a vendor string to an enum. </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilities.VendorToString(Mogre.GPUVendor)">
      <summary>Convert a vendor enum to a string. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.VertexTextureUnitsShared">
      <summary>Sets/Get whether the vertex texture units are shared with the fragment processor. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.VertexProgramConstantIntCount">
      <summary>Sets/The number of integer constants vertex programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.VertexProgramConstantFloatCount">
      <summary>Sets/The number of floating-point constants vertex programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.VertexProgramConstantBoolCount">
      <summary>Sets/The number of boolean constants vertex programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.StencilBufferBitDepth">
      <summary>Sets/Determines the bit depth of the hardware accelerated stencil buffer, if supported. If hardware stencilling is not supported, the software will provide an 8-bit software stencil. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.RenderSystemName">
      <summary>Sets/Get the identifier of the rendersystem from which these capabilities were generated. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.NumVertexTextureUnits">
      <summary>Sets/Get the number of vertex texture units supported. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.NumVertexBlendMatrices">
      <summary>Sets/Returns the number of matrices available to hardware vertex blending for this rendering system. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.NumTextureUnits">
      <summary>Sets/Returns the number of texture units the current output hardware supports.</summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.NumMultiRenderTargets">
      <summary>Sets/The number of simultaneous render targets supported. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.NonPOW2TexturesLimited">
      <summary>Sets/Are non-power of two textures limited in features? If the RSC_NON_POWER_OF_2_TEXTURES capability is set, but this method returns true, you can use non power of 2 textures only if: You load them explicitly with no mip maps You don't use DXT texture compression You use clamp texture addressing</summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.MaxPointSize">
      <summary>Sets/Maximum point screen size in pixels. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.GeometryProgramNumOutputVertices">
      <summary>Sets/Get the number of vertices a single geometry program run can emit. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.GeometryProgramConstantIntCount">
      <summary>Sets/The number of integer constants geometry programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.GeometryProgramConstantFloatCount">
      <summary>Sets/The number of floating-point constants geometry programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.GeometryProgramConstantBoolCount">
      <summary>Sets/The number of boolean constants geometry programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.FragmentProgramConstantIntCount">
      <summary>Sets/The number of integer constants fragment programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.FragmentProgramConstantFloatCount">
      <summary>Sets/The number of floating-point constants fragment programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.FragmentProgramConstantBoolCount">
      <summary>Sets/The number of boolean constants fragment programs support. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilities.DeviceName">
      <summary>Sets/gets the device name for render system </summary>
    </member>
    <member name="T:Mogre.Image">
      <summary>Class representing an image file. The Image class usually holds uncompressed image data and is the only object that can be loaded in a texture. Image objects handle image data decoding themselves by the means of locating the correct Codec object for each data type. Typically, you would want to use an Image object to load a texture when extra processing needs to be done on an image before it is loaded or when you want to blit to an existing texture. </summary>
    </member>
    <member name="M:Mogre.Image.FlipAroundY">
      <summary>Flips (mirrors) the image around the Y-axis. An example of an original and flipped image:                 
                originalimg
                00000000000
                00000000000
                00000000000
                00000000000
                00000000000
                ------------&gt; flip axis
                00000000000
                00000000000
                00000000000
                00000000000
                00000000000
                originalimg
                </summary>
    </member>
    <member name="M:Mogre.Image.FlipAroundX">
      <summary>Flips (mirrors) the image around the X-axis. An example of an original and flipped image: 
                        flip axis
                            |
                originalimg|gmilanigiro
                00000000000|00000000000
                00000000000|00000000000
                00000000000|00000000000
                00000000000|00000000000
                00000000000|00000000000
                </summary>
    </member>
    <member name="M:Mogre.Image.LoadDynamicImage(System.Byte*,System.UInt32,System.UInt32,Mogre.PixelFormat)">
      <summary>Stores a pointer to raw data in memory. The pixel format has to be specified. This method loads an image into memory held in the object. The pixel format will be either greyscale or RGB with an optional Alpha component. The type can be determined by calling getFormat(). Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height face 0, mip 1, width/2 x height/2  face 0, mip 2, width/4 x height/4  .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. The memory associated with this buffer is NOT destroyed with the Image object. This function is deprecated; one should really use the Image::loadDynamicImage(pData, width, height, depth, format, ...) to be compatible with future Ogre versions. </summary>
    </member>
    <member name="M:Mogre.Image.LoadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat)">
      <summary>Stores a pointer to raw data in memory. The pixel format has to be specified. This method loads an image into memory held in the object. The pixel format will be either greyscale or RGB with an optional Alpha component. The type can be determined by calling getFormat(). Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps, volume maps, and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height (x depth) face 0, mip 1, width/2 x height/2 (x depth/2) face 0, mip 2, width/4 x height/4 (x depth/4) .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. The memory associated with this buffer is NOT destroyed with the Image object, unless autoDelete is set to true. The size of the buffer must be numFaces*PixelUtilgetMemorySize(width, height, depth, format) </summary>
    </member>
    <member name="M:Mogre.Image.LoadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat,System.Boolean)">
      <summary>Stores a pointer to raw data in memory. The pixel format has to be specified. This method loads an image into memory held in the object. The pixel format will be either greyscale or RGB with an optional Alpha component. The type can be determined by calling getFormat(). Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps, volume maps, and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height (x depth) face 0, mip 1, width/2 x height/2 (x depth/2) face 0, mip 2, width/4 x height/4 (x depth/4) .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. The memory associated with this buffer is NOT destroyed with the Image object, unless autoDelete is set to true. The size of the buffer must be numFaces*PixelUtilgetMemorySize(width, height, depth, format) </summary>
    </member>
    <member name="M:Mogre.Image.LoadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat,System.Boolean,System.UInt32)">
      <summary>Stores a pointer to raw data in memory. The pixel format has to be specified. This method loads an image into memory held in the object. The pixel format will be either greyscale or RGB with an optional Alpha component. The type can be determined by calling getFormat(). Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps, volume maps, and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height (x depth) face 0, mip 1, width/2 x height/2 (x depth/2) face 0, mip 2, width/4 x height/4 (x depth/4) .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. The memory associated with this buffer is NOT destroyed with the Image object, unless autoDelete is set to true. The size of the buffer must be numFaces*PixelUtilgetMemorySize(width, height, depth, format) </summary>
    </member>
    <member name="M:Mogre.Image.LoadDynamicImage(System.Byte*,System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat,System.Boolean,System.UInt32,System.UInt32)">
      <summary>Stores a pointer to raw data in memory. The pixel format has to be specified. This method loads an image into memory held in the object. The pixel format will be either greyscale or RGB with an optional Alpha component. The type can be determined by calling getFormat(). Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps, volume maps, and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height (x depth) face 0, mip 1, width/2 x height/2 (x depth/2) face 0, mip 2, width/4 x height/4 (x depth/4) .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. The memory associated with this buffer is NOT destroyed with the Image object, unless autoDelete is set to true. The size of the buffer must be numFaces*PixelUtilgetMemorySize(width, height, depth, format) </summary>
    </member>
    <member name="M:Mogre.Image.LoadRawData(Mogre.DataStreamPtr,System.UInt32,System.UInt32,Mogre.PixelFormat)">
      <summary>Loads raw data from a stream. The pixel format has to be specified. This function is deprecated; one should really use the Image::loadRawData(stream, width, height, depth, format, ...) to be compatible with future Ogre versions. Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height face 0, mip 1, width/2 x height/2  face 0, mip 2, width/4 x height/4  .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. </summary>
    </member>
    <member name="M:Mogre.Image.LoadRawData(Mogre.DataStreamPtr,System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat)">
      <summary>Loads raw data from a stream. See the function loadDynamicImage for a description of the parameters. The size of the buffer must be numFaces*PixelUtilgetMemorySize(width, height, depth, format) Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height (x depth) face 0, mip 1, width/2 x height/2 (x depth/2) face 0, mip 2, width/4 x height/4 (x depth/4) .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. </summary>
    </member>
    <member name="M:Mogre.Image.LoadRawData(Mogre.DataStreamPtr,System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat,System.UInt32)">
      <summary>Loads raw data from a stream. See the function loadDynamicImage for a description of the parameters. The size of the buffer must be numFaces*PixelUtilgetMemorySize(width, height, depth, format) Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height (x depth) face 0, mip 1, width/2 x height/2 (x depth/2) face 0, mip 2, width/4 x height/4 (x depth/4) .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. </summary>
    </member>
    <member name="M:Mogre.Image.LoadRawData(Mogre.DataStreamPtr,System.UInt32,System.UInt32,System.UInt32,Mogre.PixelFormat,System.UInt32,System.UInt32)">
      <summary>Loads raw data from a stream. See the function loadDynamicImage for a description of the parameters. The size of the buffer must be numFaces*PixelUtilgetMemorySize(width, height, depth, format) Whilst typically your image is likely to be a simple 2D image, you can define complex images including cube maps and images including custom mip levels. The layout of the internal memory should be: face 0, mip 0 (top), width x height (x depth) face 0, mip 1, width/2 x height/2 (x depth/2) face 0, mip 2, width/4 x height/4 (x depth/4) .. remaining mips for face 0 ..  face 1, mip 0 (top), width x height (x depth)&lt;/li .. and so on.  
Of course, you will never have multiple faces (cube map) and depth too. </summary>
    </member>
    <member name="M:Mogre.Image.Load(Mogre.DataStreamPtr)">
      <summary>Loads an image file from a stream. This method works in the same way as the filename-based load method except it loads the image from a DataStream object. This DataStream is expected to contain the encoded data as it would be held in a file. Any format for which and associated ImageCodec is registered can be loaded. This can include complex formats like DDS with embedded custom mipmaps, cube faces and volume textures. The type can be determined by calling getFormat(). Image::load( const String&amp; strFileName ) </summary>
      <param name="stream">The source data. </param>
    </member>
    <member name="M:Mogre.Image.Load(Mogre.DataStreamPtr,System.String)">
      <summary>Loads an image file from a stream. This method works in the same way as the filename-based load method except it loads the image from a DataStream object. This DataStream is expected to contain the encoded data as it would be held in a file. Any format for which and associated ImageCodec is registered can be loaded. This can include complex formats like DDS with embedded custom mipmaps, cube faces and volume textures. The type can be determined by calling getFormat(). Image::load( const String&amp; strFileName ) </summary>
      <param name="stream">The source data. </param>
      <param name="type">The type of the image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </param>
    </member>
    <member name="M:Mogre.Image.Load(System.String,System.String)">
      <summary>Loads an image file. This method loads an image into memory. Any format for which and associated ImageCodec is registered can be loaded. This can include complex formats like DDS with embedded custom mipmaps, cube faces and volume textures. The type can be determined by calling getFormat(). The memory associated with this buffer is destroyed with the Image object. </summary>
      <param name="strFileName">Name of a file file to load. </param>
      <param name="groupName">Name of the resource group to search for the image </param>
    </member>
    <member name="M:Mogre.Image.LoadTwoImagesAsRGBA(Mogre.DataStreamPtr,Mogre.DataStreamPtr,Mogre.PixelFormat)">
      <summary>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </summary>
      <param name="rgbStream">Stream of image supplying the RGB channels (any alpha is ignored) </param>
      <param name="alphaStream">Stream of image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </param>
    </member>
    <member name="M:Mogre.Image.LoadTwoImagesAsRGBA(Mogre.DataStreamPtr,Mogre.DataStreamPtr,Mogre.PixelFormat,System.String)">
      <summary>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </summary>
      <param name="rgbStream">Stream of image supplying the RGB channels (any alpha is ignored) </param>
      <param name="alphaStream">Stream of image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </param>
      <param name="rgbType">The type of the RGB image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </param>
    </member>
    <member name="M:Mogre.Image.LoadTwoImagesAsRGBA(Mogre.DataStreamPtr,Mogre.DataStreamPtr,Mogre.PixelFormat,System.String,System.String)">
      <summary>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </summary>
      <param name="rgbStream">Stream of image supplying the RGB channels (any alpha is ignored) </param>
      <param name="alphaStream">Stream of image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </param>
      <param name="rgbType">The type of the RGB image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </param>
      <param name="alphaType">The type of the alpha image. Used to decide what decompression codec to use. Can be left blank if the stream data includes a header to identify the data. </param>
    </member>
    <member name="M:Mogre.Image.LoadTwoImagesAsRGBA(System.String,System.String,System.String)">
      <summary>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </summary>
      <param name="rgbFilename">Filename of image supplying the RGB channels (any alpha is ignored) </param>
      <param name="alphaFilename">Filename of image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </param>
      <param name="groupName">The resource group from which to load the images </param>
    </member>
    <member name="M:Mogre.Image.LoadTwoImagesAsRGBA(System.String,System.String,System.String,Mogre.PixelFormat)">
      <summary>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </summary>
      <param name="rgbFilename">Filename of image supplying the RGB channels (any alpha is ignored) </param>
      <param name="alphaFilename">Filename of image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </param>
      <param name="groupName">The resource group from which to load the images </param>
      <param name="format">The destination format </param>
    </member>
    <member name="M:Mogre.Image.CombineTwoImagesAsRGBA(Mogre.Image,Mogre.Image)">
      <summary>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </summary>
      <param name="rgb">Image supplying the RGB channels (any alpha is ignored) </param>
      <param name="alpha">Image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </param>
    </member>
    <member name="M:Mogre.Image.CombineTwoImagesAsRGBA(Mogre.Image,Mogre.Image,Mogre.PixelFormat)">
      <summary>Utility method to combine 2 separate images into this one, with the first image source supplying the RGB channels, and the second image supplying the alpha channel (as luminance or separate alpha). </summary>
      <param name="rgb">Image supplying the RGB channels (any alpha is ignored) </param>
      <param name="alpha">Image supplying the alpha channel. If a luminance image the single channel is used directly, if an RGB image then the values are converted to greyscale. </param>
      <param name="format">The destination format </param>
    </member>
    <member name="M:Mogre.Image.Save(System.String)">
      <summary>Save the image as a file. Saving and loading are implemented by back end (sometimes third party) codecs. Implemented saving functionality is more limited than loading in some cases. Particulary DDS file format support is currently limited to true colour or single channel float32, square, power of two textures with no mipmaps. Volumetric support is currently limited to DDS files. </summary>
    </member>
    <member name="M:Mogre.Image.Encode(System.String)">
      <summary>Encode the image and return a stream to the data. </summary>
      <param name="formatextension">An extension to identify the image format to encode into, e.g. "jpg" or "png" </param>
    </member>
    <member name="M:Mogre.Image.HasFlag(Mogre.ImageFlags)">
      <summary>Returns true if the image has the appropriate flag set. </summary>
    </member>
    <member name="M:Mogre.Image.GetColourAt(System.Int32,System.Int32,System.Int32)">
      <summary>Get colour value from a certain location in the image. The z coordinate is only valid for cubemaps and volume textures. This uses the first (largest) mipmap. </summary>
    </member>
    <member name="M:Mogre.Image.GetPixelBox">
      <summary>Get a PixelBox encapsulating the image data of a mipmap </summary>
    </member>
    <member name="M:Mogre.Image.GetPixelBox(System.UInt32)">
      <summary>Get a PixelBox encapsulating the image data of a mipmap </summary>
    </member>
    <member name="M:Mogre.Image.GetPixelBox(System.UInt32,System.UInt32)">
      <summary>Get a PixelBox encapsulating the image data of a mipmap </summary>
    </member>
    <member name="M:Mogre.Image.FreeMemory">
      <summary>Delete all the memory held by this image, if owned by this image (not dynamic). </summary>
    </member>
    <member name="M:Mogre.Image.Resize(System.UInt16,System.UInt16)">
      <summary>Resize a 2D image, applying the appropriate filter. </summary>
    </member>
    <member name="M:Mogre.Image.Resize(System.UInt16,System.UInt16,Mogre.Image+Filter)">
      <summary>Resize a 2D image, applying the appropriate filter. </summary>
    </member>
    <member name="M:Mogre.Image.ApplyGamma(System.Byte&amp;,System.Single,System.UInt32,System.Byte)">
      <summary>Does gamma adjustment. Basic algo taken from Titan Engine, copyright (c) 2000 Ignacio Castano Iguado </summary>
    </member>
    <member name="M:Mogre.Image.Scale(Mogre.PixelBox,Mogre.PixelBox)">
      <summary>Scale a 1D, 2D or 3D image volume. This function can do pixel format conversion in the process. dst and src can point to the same PixelBox object without any problem </summary>
      <param name="src">PixelBox containing the source pointer, dimensions and format </param>
      <param name="dst">PixelBox containing the destination pointer, dimensions and format </param>
    </member>
    <member name="M:Mogre.Image.Scale(Mogre.PixelBox,Mogre.PixelBox,Mogre.Image+Filter)">
      <summary>Scale a 1D, 2D or 3D image volume. This function can do pixel format conversion in the process. dst and src can point to the same PixelBox object without any problem </summary>
      <param name="src">PixelBox containing the source pointer, dimensions and format </param>
      <param name="dst">PixelBox containing the destination pointer, dimensions and format </param>
      <param name="filter">Which filter to use </param>
    </member>
    <member name="M:Mogre.Image.GetFileExtFromMagic(Mogre.DataStreamPtr)">
      <summary>Static function to get an image type string from a stream via magic numbers. </summary>
    </member>
    <member name="M:Mogre.Image.#ctor(Mogre.Image)">
      <summary>Copy-constructor - copies all the data from the target image. </summary>
    </member>
    <member name="M:Mogre.Image.#ctor">
      <summary>Standard constructor. </summary>
    </member>
    <member name="P:Mogre.Image.Width">
      <summary>Gets the width of the image in pixels. </summary>
    </member>
    <member name="P:Mogre.Image.Size">
      <summary>Returns the size of the data buffer. </summary>
    </member>
    <member name="P:Mogre.Image.RowSpan">
      <summary>Gets the physical width in bytes of each row of pixels. </summary>
    </member>
    <member name="P:Mogre.Image.NumMipmaps">
      <summary>Returns the number of mipmaps contained in the image. </summary>
    </member>
    <member name="P:Mogre.Image.NumFaces">
      <summary>Get the number of faces of the image. This is usually 6 for a cubemap, and 1 for a normal image. </summary>
    </member>
    <member name="P:Mogre.Image.Height">
      <summary>Gets the height of the image in pixels. </summary>
    </member>
    <member name="P:Mogre.Image.HasAlpha">
      <summary>Returns true if the image has an alpha component. </summary>
    </member>
    <member name="P:Mogre.Image.Format">
      <summary>Returns the image format. </summary>
    </member>
    <member name="P:Mogre.Image.Depth">
      <summary>Gets the depth of the image. </summary>
    </member>
    <member name="P:Mogre.Image.Data">
      <summary>Returns a pointer to the internal image buffer. Be careful with this method. You will almost certainly prefer to use getPixelBox, especially with complex images which include many faces or custom mipmaps. </summary>
    </member>
    <member name="P:Mogre.Image.BPP">
      <summary>Returns the number of bits per pixel. </summary>
    </member>
    <member name="T:Mogre.Texture">
      <summary>Abstract class representing a Texture resource. The actual concrete subclass which will exist for a texture is dependent on the rendering system in use (Direct3D, OpenGL etc). This class represents the commonalities, and is the one 'used' by programmers even though the real implementation could be different in reality. Texture objects are created through the 'create' method of the TextureManager concrete subclass. </summary>
    </member>
    <member name="M:Mogre.Texture.SetHardwareGammaEnabled(System.Boolean)">
      <summary>Sets whether this texture will be set up so that on sampling it, hardware gamma correction is applied. 24-bit textures are often saved in gamma colour space; this preserves precision in the 'darks'. However, if you're performing blending on the sampled colours, you really want to be doing it in linear space. One way is to apply a gamma correction value on loading (see setGamma), but this means you lose precision in those dark colours. An alternative is to get the hardware to do the gamma correction when reading the texture and converting it to a floating point value for the rest of the pipeline. This option allows you to do that; it's only supported in relatively recent hardware (others will ignore it) but can improve the quality of colour reproduction. Must be called before any 'load' method since it may affect the construction of the underlying hardware resources. Also note this only useful on textures using 8-bit colour channels. </summary>
    </member>
    <member name="M:Mogre.Texture.SetFSAA(System.UInt32,System.String)">
      <summary>Set the level of multisample AA to be used if this texture is a rendertarget. This option will be ignored if TU_RENDERTARGET is not part of the usage options on this texture, or if the hardware does not support it. Root::createRenderWindow) </summary>
      <param name="fsaa">The number of samples </param>
      <param name="fsaaHint">Any hinting text (</param>
    </member>
    <member name="M:Mogre.Texture.CreateInternalResources">
      <summary>Creates the internal texture resources for this texture. This method creates the internal texture resources (pixel buffers, texture surfaces etc) required to begin using this texture. You do not need to call this method directly unless you are manually creating a texture, in which case something must call it, after having set the size and format of the texture (e.g. the ManualResourceLoader might be the best one to call it). If you are not defining a manual texture, or if you use one of the self-contained load...() methods, then it will be called for you. </summary>
    </member>
    <member name="M:Mogre.Texture.FreeInternalResources">
      <summary>Frees internal texture resources for this texture. </summary>
    </member>
    <member name="M:Mogre.Texture.CopyToTexture(Mogre.TexturePtr)">
      <summary>Copies (and maybe scales to fit) the contents of this texture to another texture. </summary>
    </member>
    <member name="M:Mogre.Texture.LoadImage(Mogre.Image)">
      <summary>Loads the data from an image. Important: only call this from outside the load() routine of a Resource. Don't call it within (including ManualResourceLoader) - use _loadImages() instead. This method is designed to be external, performs locking and checks the load status before loading. </summary>
    </member>
    <member name="M:Mogre.Texture.LoadRawData(Mogre.DataStreamPtr,System.UInt16,System.UInt16,Mogre.PixelFormat)">
      <summary>Loads the data from a raw stream. Important: only call this from outside the load() routine of a Resource. Don't call it within (including ManualResourceLoader) - use _loadImages() instead. This method is designed to be external, performs locking and checks the load status before loading. </summary>
      <param name="stream">Data stream containing the raw pixel data </param>
      <param name="uWidth">Width of the image </param>
      <param name="uHeight">Height of the image </param>
      <param name="eFormat">The format of the pixel data </param>
    </member>
    <member name="M:Mogre.Texture._loadImages(Mogre.Const_ConstImagePtrList)">
      <summary>Internal method to load the texture from a set of images. Do NOT call this method unless you are inside the load() routine already, e.g. a ManualResourceLoader. It is not threadsafe and does not check or update resource loading status. </summary>
    </member>
    <member name="M:Mogre.Texture.SetDesiredBitDepths(System.UInt16,System.UInt16)">
      <summary>Sets desired bit depth for integer and float pixel format. </summary>
    </member>
    <member name="M:Mogre.Texture.GetBuffer">
      <summary>Return hardware pixel buffer for a surface. This buffer can then be used to copy data from and to a particular level of the texture. A shared pointer to a hardware pixel buffer The buffer is invalidated when the resource is unloaded or destroyed. Do not use it after the lifetime of the containing texture. </summary>
    </member>
    <member name="M:Mogre.Texture.GetBuffer(System.UInt32)">
      <summary>Return hardware pixel buffer for a surface. This buffer can then be used to copy data from and to a particular level of the texture. A shared pointer to a hardware pixel buffer The buffer is invalidated when the resource is unloaded or destroyed. Do not use it after the lifetime of the containing texture. </summary>
      <param name="face">Face number, in case of a cubemap texture. Must be 0 for other types of textures. For cubemaps, this is one of +X (0), -X (1), +Y (2), -Y (3), +Z (4), -Z (5) </param>
    </member>
    <member name="M:Mogre.Texture.GetBuffer(System.UInt32,System.UInt32)">
      <summary>Return hardware pixel buffer for a surface. This buffer can then be used to copy data from and to a particular level of the texture. A shared pointer to a hardware pixel buffer The buffer is invalidated when the resource is unloaded or destroyed. Do not use it after the lifetime of the containing texture. </summary>
      <param name="face">Face number, in case of a cubemap texture. Must be 0 for other types of textures. For cubemaps, this is one of +X (0), -X (1), +Y (2), -Y (3), +Z (4), -Z (5) </param>
      <param name="mipmap">Mipmap level. This goes from 0 for the first, largest mipmap level to getNumMipmaps()-1 for the smallest. </param>
    </member>
    <member name="M:Mogre.Texture.ConvertToImage(Mogre.Image)">
      <summary>Populate an Image with the contents of this texture. </summary>
      <param name="destImage">The target image (contents will be overwritten) </param>
    </member>
    <member name="M:Mogre.Texture.ConvertToImage(Mogre.Image,System.Boolean)">
      <summary>Populate an Image with the contents of this texture. </summary>
      <param name="destImage">The target image (contents will be overwritten) </param>
      <param name="includeMipMaps">Whether to embed mipmaps in the image </param>
    </member>
    <member name="P:Mogre.Texture.Width">
      <summary>Sets/Returns the width of the texture. </summary>
    </member>
    <member name="P:Mogre.Texture.Usage">
      <summary>Sets/Returns the TextureUsage indentifier for this Texture</summary>
    </member>
    <member name="P:Mogre.Texture.TreatLuminanceAsAlpha">
      <summary>Sets/Gets whether luminace pixel format will treated as alpha format when load this texture. </summary>
    </member>
    <member name="P:Mogre.Texture.TextureType">
      <summary>Sets/Gets the type of texture </summary>
    </member>
    <member name="P:Mogre.Texture.SrcWidth">
      <summary>Returns the width of the original input texture (may differ due to hardware requirements). </summary>
    </member>
    <member name="P:Mogre.Texture.SrcHeight">
      <summary>Returns the height of the original input texture (may differ due to hardware requirements). </summary>
    </member>
    <member name="P:Mogre.Texture.SrcFormat">
      <summary>Returns the pixel format of the original input texture (may differ due to hardware requirements and pixel format convertion). </summary>
    </member>
    <member name="P:Mogre.Texture.SrcDepth">
      <summary>Returns the original depth of the input texture (only applicable for 3D textures). </summary>
    </member>
    <member name="P:Mogre.Texture.NumMipmaps">
      <summary>Sets/Gets the number of mipmaps to be used for this texture. </summary>
    </member>
    <member name="P:Mogre.Texture.NumFaces">
      <summary>Return the number of faces this texture has. This will be 6 for a cubemap texture and 1 for a 1D, 2D or 3D one. </summary>
    </member>
    <member name="P:Mogre.Texture.MipmapsHardwareGenerated">
      <summary>Are mipmaps hardware generated? Will only be accurate after texture load, or createInternalResources </summary>
    </member>
    <member name="P:Mogre.Texture.IsHardwareGammaEnabled">
      <summary>Gets whether this texture will be set up so that on sampling it, hardware gamma correction is applied. </summary>
    </member>
    <member name="P:Mogre.Texture.Height">
      <summary>Sets/Returns the height of the texture. </summary>
    </member>
    <member name="P:Mogre.Texture.HasAlpha">
      <summary>Returns true if the texture has an alpha layer. </summary>
    </member>
    <member name="P:Mogre.Texture.Gamma">
      <summary>Sets/Returns the gamma adjustment factor applied to this texture on loading. </summary>
    </member>
    <member name="P:Mogre.Texture.FSAAHint">
      <summary>Get the multisample AA hint if this texture is a rendertarget. </summary>
    </member>
    <member name="P:Mogre.Texture.FSAA">
      <summary>Get the level of multisample AA to be used if this texture is a rendertarget. </summary>
    </member>
    <member name="P:Mogre.Texture.Format">
      <summary>Sets/Returns the pixel format for the texture surface. </summary>
    </member>
    <member name="P:Mogre.Texture.DesiredIntegerBitDepth">
      <summary>Sets/gets desired bit depth for integer pixel format textures. </summary>
    </member>
    <member name="P:Mogre.Texture.DesiredFormat">
      <summary>Returns the desired pixel format for the texture surface. </summary>
    </member>
    <member name="P:Mogre.Texture.DesiredFloatBitDepth">
      <summary>Sets/gets desired bit depth for float pixel format textures. </summary>
    </member>
    <member name="P:Mogre.Texture.Depth">
      <summary>Sets/Returns the depth of the texture (only applicable for 3D textures). </summary>
    </member>
    <member name="T:Mogre.TexturePtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to TexturePtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.TextureUnitState">
      <summary>Class representing the state of a single texture unit during a Pass of a Technique, of a Material. Texture units are pipelines for retrieving texture data for rendering onto your objects in the world. Using them is common to both the fixed-function and the programmable (vertex and fragment program) pipeline, but some of the settings will only have an effect in the fixed-function pipeline (for example, setting a texture rotation will have no effect if you use the programmable pipeline, because this is overridden by the fragment program). The effect of each setting as regards the 2 pipelines is commented in each setting. When I use the term 'fixed-function pipeline' I mean traditional rendering where you do not use vertex or fragment programs (shaders). Programmable pipeline means that for this pass you are using vertex or fragment programs. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureName(System.String)">
      <summary>Sets this texture layer to use a single texture, given the name of the texture to use on this layer. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureName(System.String,Mogre.TextureType)">
      <summary>Sets this texture layer to use a single texture, given the name of the texture to use on this layer. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetCubicTextureName(System.String[])">
      <summary>Sets this texture layer to use a combination of 6 texture maps, each one relating to a face of a cube. Cubic textures are made up of 6 separate texture images. Each one of these is an orthoganal view of the world with a FOV of 90 degrees and an aspect ratio of 1:1. You can generate these from 3D Studio by rendering a scene to a reflection map of a transparent cube and saving the output files. Cubic maps can be used either for skyboxes (complete wrap-around skies, like space) or as environment maps to simulate reflections. The system deals with these 2 scenarios in different ways: for cubic environment maps, the 6 textures are combined into a single 'cubic' texture map which is then addressed using 3D texture coordinates. This is required because you don't know what face of the box you're going to need to address when you render an object, and typically you need to reflect more than one face on the one object, so all 6 textures are needed to be 'active' at once. Cubic environment maps are enabled by calling this method with the forUVW parameter set to true, and then calling setEnvironmentMap(true).  Note that not all cards support cubic environment mapping.   for skyboxes, the 6 textures are kept separate and used independently for each face of the skybox. This is done because not all cards support 3D cubic maps and skyboxes do not need to use 3D texture coordinates so it is simpler to render each face of the box with 2D coordinates, changing texture between faces.  Skyboxes are created by calling SceneManager::setSkyBox.    Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetCubicTextureName(System.String[],System.Boolean)">
      <summary>Sets this texture layer to use a combination of 6 texture maps, each one relating to a face of a cube. Cubic textures are made up of 6 separate texture images. Each one of these is an orthoganal view of the world with a FOV of 90 degrees and an aspect ratio of 1:1. You can generate these from 3D Studio by rendering a scene to a reflection map of a transparent cube and saving the output files. Cubic maps can be used either for skyboxes (complete wrap-around skies, like space) or as environment maps to simulate reflections. The system deals with these 2 scenarios in different ways: for cubic environment maps, the 6 textures are combined into a single 'cubic' texture map which is then addressed using 3D texture coordinates. This is required because you don't know what face of the box you're going to need to address when you render an object, and typically you need to reflect more than one face on the one object, so all 6 textures are needed to be 'active' at once. Cubic environment maps are enabled by calling this method with the forUVW parameter set to true, and then calling setEnvironmentMap(true).  Note that not all cards support cubic environment mapping.   for skyboxes, the 6 textures are kept separate and used independently for each face of the skybox. This is done because not all cards support 3D cubic maps and skyboxes do not need to use 3D texture coordinates so it is simpler to render each face of the box with 2D coordinates, changing texture between faces.  Skyboxes are created by calling SceneManager::setSkyBox.    Applies to both fixed-function and programmable pipeline. </summary>
      <param name="forUVW">Set to true if you want a single 3D texture addressable with 3D texture coordinates rather than 6 separate textures. Useful for cubic environment mapping. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetCubicTextureName(System.String)">
      <summary>Sets this texture layer to use a combination of 6 texture maps, each one relating to a face of a cube. Cubic textures are made up of 6 separate texture images. Each one of these is an orthoganal view of the world with a FOV of 90 degrees and an aspect ratio of 1:1. You can generate these from 3D Studio by rendering a scene to a reflection map of a transparent cube and saving the output files. Cubic maps can be used either for skyboxes (complete wrap-around skies, like space) or as environment maps to simulate reflections. The system deals with these 2 scenarios in different ways: for cubic environment maps, the 6 textures are combined into a single 'cubic' texture map which is then addressed using 3D texture coordinates. This is required because you don't know what face of the box you're going to need to address when you render an object, and typically you need to reflect more than one face on the one object, so all 6 textures are needed to be 'active' at once. Cubic environment maps are enabled by calling this method with the forUVW parameter set to true, and then calling setEnvironmentMap(true).  Note that not all cards support cubic environment mapping.   for skyboxes, the 6 textures are kept separate and used independently for each face of the skybox. This is done because not all cards support 3D cubic maps and skyboxes do not need to use 3D texture coordinates so it is simpler to render each face of the box with 2D coordinates, changing texture between faces.  Skyboxes are created by calling SceneManager::setSkyBox.    Applies to both fixed-function and programmable pipeline. </summary>
      <param name="name">The basic name of the texture e.g. brickwall.jpg, stonefloor.png. There must be 6 versions of this texture with the suffixes _fr, _bk, _up, _dn, _lf, and _rt (before the extension) which make up the 6 sides of the box. The textures must all be the same size and be powers of 2 in width &amp; height. If you can't make your texture names conform to this, use the alternative method of the same name which takes an array of texture names instead. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetCubicTextureName(System.String,System.Boolean)">
      <summary>Sets this texture layer to use a combination of 6 texture maps, each one relating to a face of a cube. Cubic textures are made up of 6 separate texture images. Each one of these is an orthoganal view of the world with a FOV of 90 degrees and an aspect ratio of 1:1. You can generate these from 3D Studio by rendering a scene to a reflection map of a transparent cube and saving the output files. Cubic maps can be used either for skyboxes (complete wrap-around skies, like space) or as environment maps to simulate reflections. The system deals with these 2 scenarios in different ways: for cubic environment maps, the 6 textures are combined into a single 'cubic' texture map which is then addressed using 3D texture coordinates. This is required because you don't know what face of the box you're going to need to address when you render an object, and typically you need to reflect more than one face on the one object, so all 6 textures are needed to be 'active' at once. Cubic environment maps are enabled by calling this method with the forUVW parameter set to true, and then calling setEnvironmentMap(true).  Note that not all cards support cubic environment mapping.   for skyboxes, the 6 textures are kept separate and used independently for each face of the skybox. This is done because not all cards support 3D cubic maps and skyboxes do not need to use 3D texture coordinates so it is simpler to render each face of the box with 2D coordinates, changing texture between faces.  Skyboxes are created by calling SceneManager::setSkyBox.    Applies to both fixed-function and programmable pipeline. </summary>
      <param name="name">The basic name of the texture e.g. brickwall.jpg, stonefloor.png. There must be 6 versions of this texture with the suffixes _fr, _bk, _up, _dn, _lf, and _rt (before the extension) which make up the 6 sides of the box. The textures must all be the same size and be powers of 2 in width &amp; height. If you can't make your texture names conform to this, use the alternative method of the same name which takes an array of texture names instead. </param>
      <param name="forUVW">Set to true if you want a single 3D texture addressable with 3D texture coordinates rather than 6 separate textures. Useful for cubic environment mapping. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAnimatedTextureName(System.String[],System.UInt32)">
      <summary>Sets the names of the texture images for an animated texture. This an alternative method to the one where you specify a single name and let the system derive the names of each frame, incase your images can't conform to this naming standard. Animated textures are just a series of images making up the frames of the animation. All the images must be the same size, and you must provide their names as an array in the first parameter. You can change the active frame on a texture layer by calling the setCurrentFrame method. If you can make your texture images conform to a naming standard of basicName_frame.ext, you can call the alternative setAnimatedTextureName method which just takes a base name instead. Applies to both fixed-function and programmable pipeline. </summary>
      <param name="names">Pointer to array of names of the textures to use, in frame order. </param>
      <param name="numFrames">The number of frames in the sequence. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAnimatedTextureName(System.String[],System.UInt32,System.Single)">
      <summary>Sets the names of the texture images for an animated texture. This an alternative method to the one where you specify a single name and let the system derive the names of each frame, incase your images can't conform to this naming standard. Animated textures are just a series of images making up the frames of the animation. All the images must be the same size, and you must provide their names as an array in the first parameter. You can change the active frame on a texture layer by calling the setCurrentFrame method. If you can make your texture images conform to a naming standard of basicName_frame.ext, you can call the alternative setAnimatedTextureName method which just takes a base name instead. Applies to both fixed-function and programmable pipeline. </summary>
      <param name="names">Pointer to array of names of the textures to use, in frame order. </param>
      <param name="numFrames">The number of frames in the sequence. </param>
      <param name="duration">The length of time it takes to display the whole animation sequence, in seconds. If 0, no automatic transition occurs. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAnimatedTextureName(System.String,System.UInt32)">
      <summary>Sets the names of the texture images for an animated texture. Animated textures are just a series of images making up the frames of the animation. All the images must be the same size, and their names must have a frame number appended before the extension, e.g. if you specify a name of "wall.jpg" with 3 frames, the image names must be "wall_0.jpg", "wall_1.jpg" and "wall_2.jpg". You can change the active frame on a texture layer by calling the setCurrentFrame method. If you can't make your texture images conform to the naming standard layed out here, you can call the alternative setAnimatedTextureName method which takes an array of names instead. Applies to both fixed-function and programmable pipeline. </summary>
      <param name="name">The base name of the textures to use e.g. wall.jpg for frames wall_0.jpg, wall_1.jpg etc. </param>
      <param name="numFrames">The number of frames in the sequence. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAnimatedTextureName(System.String,System.UInt32,System.Single)">
      <summary>Sets the names of the texture images for an animated texture. Animated textures are just a series of images making up the frames of the animation. All the images must be the same size, and their names must have a frame number appended before the extension, e.g. if you specify a name of "wall.jpg" with 3 frames, the image names must be "wall_0.jpg", "wall_1.jpg" and "wall_2.jpg". You can change the active frame on a texture layer by calling the setCurrentFrame method. If you can't make your texture images conform to the naming standard layed out here, you can call the alternative setAnimatedTextureName method which takes an array of names instead. Applies to both fixed-function and programmable pipeline. </summary>
      <param name="name">The base name of the textures to use e.g. wall.jpg for frames wall_0.jpg, wall_1.jpg etc. </param>
      <param name="numFrames">The number of frames in the sequence. </param>
      <param name="duration">The length of time it takes to display the whole animation sequence, in seconds. If 0, no automatic transition occurs. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.GetTextureDimensions">
      <summary>Returns the width and height of the texture in the given frame. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.GetTextureDimensions(System.UInt32)">
      <summary>Returns the width and height of the texture in the given frame. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.GetFrameTextureName(System.UInt32)">
      <summary>Gets the name of the texture associated with a frame number. Throws an exception if frameNumber exceeds the number of stored frames. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetFrameTextureName(System.String,System.UInt32)">
      <summary>Sets the name of the texture associated with a frame. Throws an exception if frameNumber exceeds the number of stored frames. Applies to both fixed-function and programmable pipeline. </summary>
      <param name="name">The name of the texture </param>
      <param name="frameNumber">The frame the texture name is to be placed in </param>
    </member>
    <member name="M:Mogre.TextureUnitState.AddFrameTextureName(System.String)">
      <summary>Add a Texture name to the end of the frame container. Applies to both fixed-function and programmable pipeline. </summary>
      <param name="name">The name of the texture </param>
    </member>
    <member name="M:Mogre.TextureUnitState.DeleteFrameTextureName(System.UInt32)">
      <summary>deletes a specific texture frame. The texture used is not deleted but the texture will no longer be used by the Texture Unit. An exception is raised if the frame number exceeds the number of actual frames. Applies to both fixed-function and programmable pipeline. </summary>
      <param name="frameNumber">The frame number of the texture to be deleted. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetBindingType(Mogre.TextureUnitState+BindingType)">
      <summary>Sets the type of unit these texture settings should be bound to. Some render systems, when implementing vertex texture fetch, separate the binding of textures for use in the vertex program versus those used in fragment programs. This setting allows you to target the vertex processing unit with a texture binding, in those cases. For rendersystems which have a unified binding for the vertex and fragment units, this setting makes no difference. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.GetBindingType">
      <summary>Gets the type of unit these texture settings should be bound to. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetContentType(Mogre.TextureUnitState+ContentType)">
      <summary>Set the type of content this TextureUnitState references. The default is to reference a standard named texture, but this unit can also reference automated content like a shadow texture. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.GetContentType">
      <summary>Get the type of content this TextureUnitState references. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.Is3D">
      <summary>Returns true if this texture layer uses a composite 3D cubic texture. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetHardwareGammaEnabled(System.Boolean)">
      <summary>Sets whether this texture will be set up so that on sampling it, hardware gamma correction is applied. 24-bit textures are often saved in gamma colour space; this preserves precision in the 'darks'. However, if you're performing blending on the sampled colours, you really want to be doing it in linear space. One way is to apply a gamma correction value on loading (see setGamma), but this means you lose precision in those dark colours. An alternative is to get the hardware to do the gamma correction when reading the texture and converting it to a floating point value for the rest of the pipeline. This option allows you to do that; it's only supported in relatively recent hardware (others will ignore it) but can improve the quality of colour reproduction. Must be called before any 'load' method since it may affect the construction of the underlying hardware resources. Also note this only useful on textures using 8-bit colour channels.</summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureScroll(System.Single,System.Single)">
      <summary>Sets the translation offset of the texture, ie scrolls the texture. This method sets the translation element of the texture transformation, and is easier to use than setTextureTransform if you are combining translation, scaling and rotation in your texture transformation. Again if you want to animate these values you need to use a ControllerHas no effect in the programmable pipeline. ControllerManager, Controller</summary>
      <param name="u">The amount the texture should be moved horizontally (u direction). </param>
      <param name="v">The amount the texture should be moved vertically (v direction). </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureScale(System.Single,System.Single)">
      <summary>Sets the scaling factor applied to texture coordinates. This method sets the scale element of the texture transformation, and is easier to use than setTextureTransform if you are combining translation, scaling and rotation in your texture transformation. Again if you want to animate these values you need to use a Controller (see ControllerManager and it's methods for more information). Has no effect in the programmable pipeline. </summary>
      <param name="uScale">The value by which the texture is to be scaled horizontally. </param>
      <param name="vScale">The value by which the texture is to be scaled vertically. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.GetTextureAddressingMode">
      <summary>Gets the texture addressing mode for a given coordinate, i.e. what happens at uv values above 1.0. The default is TAM_WRAP i.e. the texture repeats over values of 1.0. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureAddressingMode(Mogre.TextureUnitState+UVWAddressingMode)">
      <summary>Sets the texture addressing mode, i.e. what happens at uv values above 1.0. The default is TAM_WRAP i.e. the texture repeats over values of 1.0. This applies for both the fixed-function and programmable pipelines. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureAddressingMode(Mogre.TextureUnitState+TextureAddressingMode,Mogre.TextureUnitState+TextureAddressingMode,Mogre.TextureUnitState+TextureAddressingMode)">
      <summary>Sets the texture addressing mode, i.e. what happens at uv values above 1.0. The default is TAM_WRAP i.e. the texture repeats over values of 1.0. This applies for both the fixed-function and programmable pipelines. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureAddressingMode(Mogre.TextureUnitState+TextureAddressingMode)">
      <summary>Sets the texture addressing mode, i.e. what happens at uv values above 1.0. The default is TAM_WRAP i.e. the texture repeats over values of 1.0. This is a shortcut method which sets the addressing mode for all coordinates at once; you can also call the more specific method to set the addressing mode per coordinate. This applies for both the fixed-function and programmable pipelines. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOperationEx(Mogre.LayerBlendOperationEx)">
      <summary>Setting advanced blending options. This is an extended version of the TextureUnitState::setColourOperation method which allows extremely detailed control over the blending applied between this and earlier layers. See the IMPORTANT note below about the issues between mulitpass and multitexturing that using this method can create. Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (ie. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, ie. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation. The defaults for each layer are: op = LBX_MODULATE source1 = LBS_TEXTURE source2 = LBS_CURRENT 
ie. each layer takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0 - 1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like LBO_MODULATE_X2. See the LayerBlendOperation and LayerBlendSource enumerated types for full details. Because of the limitations on some underlying APIs (Direct3D included) the LBS_TEXTURE argument can only be used as the first argument, not the second. The final 3 parameters are only required if you decide to pass values manually into the operation, i.e. you want one or more of the inputs to the colour calculation to come from a fixed value that you supply. Hence you only need to fill these in if you supply LBS_MANUAL to the corresponding source, or use the LBX_BLEND_MANUAL operation. Ogre tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you MUST also call TextureUnitState::setColourOpMultipassFallback to specify which effect you want to fall back on if sufficient hardware is not available. This has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOperationEx(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource)">
      <summary>Setting advanced blending options. This is an extended version of the TextureUnitState::setColourOperation method which allows extremely detailed control over the blending applied between this and earlier layers. See the IMPORTANT note below about the issues between mulitpass and multitexturing that using this method can create. Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (ie. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, ie. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation. The defaults for each layer are: op = LBX_MODULATE source1 = LBS_TEXTURE source2 = LBS_CURRENT 
ie. each layer takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0 - 1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like LBO_MODULATE_X2. See the LayerBlendOperation and LayerBlendSource enumerated types for full details. Because of the limitations on some underlying APIs (Direct3D included) the LBS_TEXTURE argument can only be used as the first argument, not the second. The final 3 parameters are only required if you decide to pass values manually into the operation, i.e. you want one or more of the inputs to the colour calculation to come from a fixed value that you supply. Hence you only need to fill these in if you supply LBS_MANUAL to the corresponding source, or use the LBX_BLEND_MANUAL operation. Ogre tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you MUST also call TextureUnitState::setColourOpMultipassFallback to specify which effect you want to fall back on if sufficient hardware is not available. This has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first colour to the operation e.g. texture colour </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOperationEx(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource)">
      <summary>Setting advanced blending options. This is an extended version of the TextureUnitState::setColourOperation method which allows extremely detailed control over the blending applied between this and earlier layers. See the IMPORTANT note below about the issues between mulitpass and multitexturing that using this method can create. Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (ie. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, ie. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation. The defaults for each layer are: op = LBX_MODULATE source1 = LBS_TEXTURE source2 = LBS_CURRENT 
ie. each layer takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0 - 1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like LBO_MODULATE_X2. See the LayerBlendOperation and LayerBlendSource enumerated types for full details. Because of the limitations on some underlying APIs (Direct3D included) the LBS_TEXTURE argument can only be used as the first argument, not the second. The final 3 parameters are only required if you decide to pass values manually into the operation, i.e. you want one or more of the inputs to the colour calculation to come from a fixed value that you supply. Hence you only need to fill these in if you supply LBS_MANUAL to the corresponding source, or use the LBX_BLEND_MANUAL operation. Ogre tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you MUST also call TextureUnitState::setColourOpMultipassFallback to specify which effect you want to fall back on if sufficient hardware is not available. This has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first colour to the operation e.g. texture colour </param>
      <param name="source2">The source of the second colour to the operation e.g. current surface colour </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOperationEx(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource,Mogre.ColourValue)">
      <summary>Setting advanced blending options. This is an extended version of the TextureUnitState::setColourOperation method which allows extremely detailed control over the blending applied between this and earlier layers. See the IMPORTANT note below about the issues between mulitpass and multitexturing that using this method can create. Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (ie. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, ie. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation. The defaults for each layer are: op = LBX_MODULATE source1 = LBS_TEXTURE source2 = LBS_CURRENT 
ie. each layer takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0 - 1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like LBO_MODULATE_X2. See the LayerBlendOperation and LayerBlendSource enumerated types for full details. Because of the limitations on some underlying APIs (Direct3D included) the LBS_TEXTURE argument can only be used as the first argument, not the second. The final 3 parameters are only required if you decide to pass values manually into the operation, i.e. you want one or more of the inputs to the colour calculation to come from a fixed value that you supply. Hence you only need to fill these in if you supply LBS_MANUAL to the corresponding source, or use the LBX_BLEND_MANUAL operation. Ogre tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you MUST also call TextureUnitState::setColourOpMultipassFallback to specify which effect you want to fall back on if sufficient hardware is not available. This has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first colour to the operation e.g. texture colour </param>
      <param name="source2">The source of the second colour to the operation e.g. current surface colour </param>
      <param name="arg1">Manually supplied colour value (only required if source1 = LBS_MANUAL) </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOperationEx(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource,Mogre.ColourValue,Mogre.ColourValue)">
      <summary>Setting advanced blending options. This is an extended version of the TextureUnitState::setColourOperation method which allows extremely detailed control over the blending applied between this and earlier layers. See the IMPORTANT note below about the issues between mulitpass and multitexturing that using this method can create. Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (ie. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, ie. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation. The defaults for each layer are: op = LBX_MODULATE source1 = LBS_TEXTURE source2 = LBS_CURRENT 
ie. each layer takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0 - 1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like LBO_MODULATE_X2. See the LayerBlendOperation and LayerBlendSource enumerated types for full details. Because of the limitations on some underlying APIs (Direct3D included) the LBS_TEXTURE argument can only be used as the first argument, not the second. The final 3 parameters are only required if you decide to pass values manually into the operation, i.e. you want one or more of the inputs to the colour calculation to come from a fixed value that you supply. Hence you only need to fill these in if you supply LBS_MANUAL to the corresponding source, or use the LBX_BLEND_MANUAL operation. Ogre tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you MUST also call TextureUnitState::setColourOpMultipassFallback to specify which effect you want to fall back on if sufficient hardware is not available. This has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first colour to the operation e.g. texture colour </param>
      <param name="source2">The source of the second colour to the operation e.g. current surface colour </param>
      <param name="arg1">Manually supplied colour value (only required if source1 = LBS_MANUAL) </param>
      <param name="arg2">Manually supplied colour value (only required if source2 = LBS_MANUAL) </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOperationEx(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource,Mogre.ColourValue,Mogre.ColourValue,System.Single)">
      <summary>Setting advanced blending options. This is an extended version of the TextureUnitState::setColourOperation method which allows extremely detailed control over the blending applied between this and earlier layers. See the IMPORTANT note below about the issues between mulitpass and multitexturing that using this method can create. Texture colour operations determine how the final colour of the surface appears when rendered. Texture units are used to combine colour values from various sources (ie. the diffuse colour of the surface from lighting calculations, combined with the colour of the texture). This method allows you to specify the 'operation' to be used, ie. the calculation such as adds or multiplies, and which values to use as arguments, such as a fixed value or a value from a previous calculation. The defaults for each layer are: op = LBX_MODULATE source1 = LBS_TEXTURE source2 = LBS_CURRENT 
ie. each layer takes the colour results of the previous layer, and multiplies them with the new texture being applied. Bear in mind that colours are RGB values from 0.0 - 1.0 so multiplying them together will result in values in the same range, 'tinted' by the multiply. Note however that a straight multiply normally has the effect of darkening the textures - for this reason there are brightening operations like LBO_MODULATE_X2. See the LayerBlendOperation and LayerBlendSource enumerated types for full details. Because of the limitations on some underlying APIs (Direct3D included) the LBS_TEXTURE argument can only be used as the first argument, not the second. The final 3 parameters are only required if you decide to pass values manually into the operation, i.e. you want one or more of the inputs to the colour calculation to come from a fixed value that you supply. Hence you only need to fill these in if you supply LBS_MANUAL to the corresponding source, or use the LBX_BLEND_MANUAL operation. Ogre tries to use multitexturing hardware to blend texture layers together. However, if it runs out of texturing units (e.g. 2 of a GeForce2, 4 on a GeForce3) it has to fall back on multipass rendering, i.e. rendering the same object multiple times with different textures. This is both less efficient and there is a smaller range of blending operations which can be performed. For this reason, if you use this method you MUST also call TextureUnitState::setColourOpMultipassFallback to specify which effect you want to fall back on if sufficient hardware is not available. This has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first colour to the operation e.g. texture colour </param>
      <param name="source2">The source of the second colour to the operation e.g. current surface colour </param>
      <param name="arg1">Manually supplied colour value (only required if source1 = LBS_MANUAL) </param>
      <param name="arg2">Manually supplied colour value (only required if source2 = LBS_MANUAL) </param>
      <param name="manualBlend">Manually supplied 'blend' value - only required for operations which require manual blend e.g. LBX_BLEND_MANUAL </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOperation(Mogre.LayerBlendOperation)">
      <summary>Determines how this texture layer is combined with the one below it (or the diffuse colour of the geometry if this is layer 0). This method is the simplest way to blend tetxure layers, because it requires only one parameter, gives you the most common blending types, and automatically sets up 2 blending methods: one for if single-pass multitexturing hardware is available, and another for if it is not and the blending must be achieved through multiple rendering passes. It is, however, quite limited and does not expose the more flexible multitexturing operations, simply because these can't be automatically supported in multipass fallback mode. If want to use the fancier options, use TextureUnitState::setColourOperationEx, but you'll either have to be sure that enough multitexturing units will be available, or you should explicitly set a fallback using TextureUnitState::setColourOpMultipassFallback. The default method is LBO_MODULATE for all layers. This option has no effect in the programmable pipeline. </summary>
      <param name="op">One of the LayerBlendOperation enumerated blending types. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetColourOpMultipassFallback(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Sets the multipass fallback operation for this layer, if you used TextureUnitState::setColourOperationEx and not enough multitexturing hardware is available. Because some effects exposed using TextureUnitState::setColourOperationEx are only supported under multitexturing hardware, if the hardware is lacking the system must fallback on multipass rendering, which unfortunately doesn't support as many effects. This method is for you to specify the fallback operation which most suits you. You'll notice that the interface is the same as the Material::setSceneBlending method; this is because multipass rendering IS effectively scene blending, since each layer is rendered on top of the last using the same mechanism as making an object transparent, it's just being rendered in the same place repeatedly to get the multitexture effect. If you use the simpler (and hence less flexible) TextureUnitState::setColourOperation method you don't need to call this as the system sets up the fallback for you. This option has no effect in the programmable pipeline, because there is no multipass fallback and multitexture blending is handled by the fragment shader. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAlphaOperation(Mogre.LayerBlendOperationEx)">
      <summary>Sets the alpha operation to be applied to this texture. This works in exactly the same way as setColourOperation, except that the effect is applied to the level of alpha (i.e. transparency) of the texture rather than its colour. When the alpha of a texel (a pixel on a texture) is 1.0, it is opaque, wheras it is fully transparent if the alpha is 0.0. Please refer to the setColourOperation method for more info. setColourOperationThis option has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAlphaOperation(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource)">
      <summary>Sets the alpha operation to be applied to this texture. This works in exactly the same way as setColourOperation, except that the effect is applied to the level of alpha (i.e. transparency) of the texture rather than its colour. When the alpha of a texel (a pixel on a texture) is 1.0, it is opaque, wheras it is fully transparent if the alpha is 0.0. Please refer to the setColourOperation method for more info. setColourOperationThis option has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first alpha value to the operation e.g. texture alpha </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAlphaOperation(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource)">
      <summary>Sets the alpha operation to be applied to this texture. This works in exactly the same way as setColourOperation, except that the effect is applied to the level of alpha (i.e. transparency) of the texture rather than its colour. When the alpha of a texel (a pixel on a texture) is 1.0, it is opaque, wheras it is fully transparent if the alpha is 0.0. Please refer to the setColourOperation method for more info. setColourOperationThis option has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first alpha value to the operation e.g. texture alpha </param>
      <param name="source2">The source of the second alpha value to the operation e.g. current surface alpha </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAlphaOperation(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource,System.Single)">
      <summary>Sets the alpha operation to be applied to this texture. This works in exactly the same way as setColourOperation, except that the effect is applied to the level of alpha (i.e. transparency) of the texture rather than its colour. When the alpha of a texel (a pixel on a texture) is 1.0, it is opaque, wheras it is fully transparent if the alpha is 0.0. Please refer to the setColourOperation method for more info. setColourOperationThis option has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first alpha value to the operation e.g. texture alpha </param>
      <param name="source2">The source of the second alpha value to the operation e.g. current surface alpha </param>
      <param name="arg1">Manually supplied alpha value (only required if source1 = LBS_MANUAL) </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAlphaOperation(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource,System.Single,System.Single)">
      <summary>Sets the alpha operation to be applied to this texture. This works in exactly the same way as setColourOperation, except that the effect is applied to the level of alpha (i.e. transparency) of the texture rather than its colour. When the alpha of a texel (a pixel on a texture) is 1.0, it is opaque, wheras it is fully transparent if the alpha is 0.0. Please refer to the setColourOperation method for more info. setColourOperationThis option has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first alpha value to the operation e.g. texture alpha </param>
      <param name="source2">The source of the second alpha value to the operation e.g. current surface alpha </param>
      <param name="arg1">Manually supplied alpha value (only required if source1 = LBS_MANUAL) </param>
      <param name="arg2">Manually supplied alpha value (only required if source2 = LBS_MANUAL) </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetAlphaOperation(Mogre.LayerBlendOperationEx,Mogre.LayerBlendSource,Mogre.LayerBlendSource,System.Single,System.Single,System.Single)">
      <summary>Sets the alpha operation to be applied to this texture. This works in exactly the same way as setColourOperation, except that the effect is applied to the level of alpha (i.e. transparency) of the texture rather than its colour. When the alpha of a texel (a pixel on a texture) is 1.0, it is opaque, wheras it is fully transparent if the alpha is 0.0. Please refer to the setColourOperation method for more info. setColourOperationThis option has no effect in the programmable pipeline. </summary>
      <param name="op">The operation to be used, e.g. modulate (multiply), add, subtract </param>
      <param name="source1">The source of the first alpha value to the operation e.g. texture alpha </param>
      <param name="source2">The source of the second alpha value to the operation e.g. current surface alpha </param>
      <param name="arg1">Manually supplied alpha value (only required if source1 = LBS_MANUAL) </param>
      <param name="arg2">Manually supplied alpha value (only required if source2 = LBS_MANUAL) </param>
      <param name="manualBlend">Manually supplied 'blend' value - only required for operations which require manual blend e.g. LBX_BLEND_MANUAL </param>
    </member>
    <member name="M:Mogre.TextureUnitState.AddEffect(Mogre.TextureUnitState+TextureEffect_NativePtr)">
      <summary>Generic method for setting up texture effects. Allows you to specify effects directly by using the TextureEffectType enumeration. The arguments that go with it depend on the effect type. Only one effect of each type can be applied to a texture layer. This method is used internally by Ogre but it is better generally for applications to use the more intuitive specialised methods such as setEnvironmentMap and setScroll. This option has no effect in the programmable pipeline. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetEnvironmentMap(System.Boolean)">
      <summary>Turns on/off texture coordinate effect that makes this layer an environment map. Environment maps make an object look reflective by using the object's vertex normals relative to the camera view to generate texture coordinates. The vectors generated can either be used to address a single 2D texture which is a 'fish-eye' lens view of a scene, or a 3D cubic environment map which requires 6 textures for each side of the inside of a cube. The type depends on what texture you set up - if you use the setTextureName method then a 2D fisheye lens texture is required, whereas if you used setCubicTextureName then a cubic environemnt map will be used. This effect works best if the object has lots of gradually changing normals. The texture also has to be designed for this effect - see the example spheremap.png included with the sample application for a 2D environment map; a cubic map can be generated by rendering 6 views of a scene to each of the cube faces with orthoganal views. Enabling this disables any other texture coordinate generation effects. However it can be combined with texture coordinate modification functions, which then operate on the generated coordinates rather than static model texture coordinates. This option has no effect in the programmable pipeline. </summary>
      <param name="enable">True to enable, false to disable </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetEnvironmentMap(System.Boolean,Mogre.TextureUnitState+EnvMapType)">
      <summary>Turns on/off texture coordinate effect that makes this layer an environment map. Environment maps make an object look reflective by using the object's vertex normals relative to the camera view to generate texture coordinates. The vectors generated can either be used to address a single 2D texture which is a 'fish-eye' lens view of a scene, or a 3D cubic environment map which requires 6 textures for each side of the inside of a cube. The type depends on what texture you set up - if you use the setTextureName method then a 2D fisheye lens texture is required, whereas if you used setCubicTextureName then a cubic environemnt map will be used. This effect works best if the object has lots of gradually changing normals. The texture also has to be designed for this effect - see the example spheremap.png included with the sample application for a 2D environment map; a cubic map can be generated by rendering 6 views of a scene to each of the cube faces with orthoganal views. Enabling this disables any other texture coordinate generation effects. However it can be combined with texture coordinate modification functions, which then operate on the generated coordinates rather than static model texture coordinates. This option has no effect in the programmable pipeline. </summary>
      <param name="enable">True to enable, false to disable </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetScrollAnimation(System.Single,System.Single)">
      <summary>Sets up an animated scroll for the texture layer. Useful for creating constant scrolling effects on a texture layer (for varying scrolls, see setTransformAnimation). This option has no effect in the programmable pipeline. </summary>
      <param name="uSpeed">The number of horizontal loops per second (+ve=moving right, -ve = moving left) </param>
      <param name="vSpeed">The number of vertical loops per second (+ve=moving up, -ve= moving down) </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetRotateAnimation(System.Single)">
      <summary>Sets up an animated texture rotation for this layer. Useful for constant rotations (for varying rotations, see setTransformAnimation). This option has no effect in the programmable pipeline. </summary>
      <param name="speed">The number of complete anticlockwise revolutions per second (use -ve for clockwise) </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTransformAnimation(Mogre.TextureUnitState+TextureTransformType,Mogre.WaveformType)">
      <summary>Sets up a general time-relative texture modification effect. This can be called multiple times for different values of ttype, but only the latest effect applies if called multiple time for the same ttype. This option has no effect in the programmable pipeline. </summary>
      <param name="ttype">The type of transform, either translate (scroll), scale (stretch) or rotate (spin) </param>
      <param name="waveType">The shape of the wave, see WaveformType enum for details </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTransformAnimation(Mogre.TextureUnitState+TextureTransformType,Mogre.WaveformType,System.Single)">
      <summary>Sets up a general time-relative texture modification effect. This can be called multiple times for different values of ttype, but only the latest effect applies if called multiple time for the same ttype. This option has no effect in the programmable pipeline. </summary>
      <param name="ttype">The type of transform, either translate (scroll), scale (stretch) or rotate (spin) </param>
      <param name="waveType">The shape of the wave, see WaveformType enum for details </param>
      <param name="base">The base value for the function (range of output = {base, base + amplitude}) </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTransformAnimation(Mogre.TextureUnitState+TextureTransformType,Mogre.WaveformType,System.Single,System.Single)">
      <summary>Sets up a general time-relative texture modification effect. This can be called multiple times for different values of ttype, but only the latest effect applies if called multiple time for the same ttype. This option has no effect in the programmable pipeline. </summary>
      <param name="ttype">The type of transform, either translate (scroll), scale (stretch) or rotate (spin) </param>
      <param name="waveType">The shape of the wave, see WaveformType enum for details </param>
      <param name="base">The base value for the function (range of output = {base, base + amplitude}) </param>
      <param name="frequency">The speed of the wave in cycles per second </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTransformAnimation(Mogre.TextureUnitState+TextureTransformType,Mogre.WaveformType,System.Single,System.Single,System.Single)">
      <summary>Sets up a general time-relative texture modification effect. This can be called multiple times for different values of ttype, but only the latest effect applies if called multiple time for the same ttype. This option has no effect in the programmable pipeline. </summary>
      <param name="ttype">The type of transform, either translate (scroll), scale (stretch) or rotate (spin) </param>
      <param name="waveType">The shape of the wave, see WaveformType enum for details </param>
      <param name="base">The base value for the function (range of output = {base, base + amplitude}) </param>
      <param name="frequency">The speed of the wave in cycles per second </param>
      <param name="phase">The offset of the start of the wave, e.g. 0.5 to start half-way through the wave </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTransformAnimation(Mogre.TextureUnitState+TextureTransformType,Mogre.WaveformType,System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets up a general time-relative texture modification effect. This can be called multiple times for different values of ttype, but only the latest effect applies if called multiple time for the same ttype. This option has no effect in the programmable pipeline. </summary>
      <param name="ttype">The type of transform, either translate (scroll), scale (stretch) or rotate (spin) </param>
      <param name="waveType">The shape of the wave, see WaveformType enum for details </param>
      <param name="base">The base value for the function (range of output = {base, base + amplitude}) </param>
      <param name="frequency">The speed of the wave in cycles per second </param>
      <param name="phase">The offset of the start of the wave, e.g. 0.5 to start half-way through the wave </param>
      <param name="amplitude">Scales the output so that instead of lying within 0..1 it lies within 0..1*amplitude for exaggerated effects </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetProjectiveTexturing(System.Boolean)">
      <summary>Enables or disables projective texturing on this texture unit. Projective texturing allows you to generate texture coordinates based on a Frustum, which gives the impression that a texture is being projected onto the surface. Note that once you have called this method, the texture unit continues to monitor the Frustum you passed in and the projection will change if you can alter it. It also means that you must ensure that the Frustum object you pass a pointer to remains in existence for as long as this TextureUnitState does. This effect cannot be combined with other texture generation effects, such as environment mapping. It also has no effect on passes which have a vertex program enabled - projective texturing has to be done in the vertex program instead. </summary>
      <param name="enabled">Whether to enable / disable </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetProjectiveTexturing(System.Boolean,Mogre.Frustum)">
      <summary>Enables or disables projective texturing on this texture unit. Projective texturing allows you to generate texture coordinates based on a Frustum, which gives the impression that a texture is being projected onto the surface. Note that once you have called this method, the texture unit continues to monitor the Frustum you passed in and the projection will change if you can alter it. It also means that you must ensure that the Frustum object you pass a pointer to remains in existence for as long as this TextureUnitState does. This effect cannot be combined with other texture generation effects, such as environment mapping. It also has no effect on passes which have a vertex program enabled - projective texturing has to be done in the vertex program instead. </summary>
      <param name="enabled">Whether to enable / disable </param>
      <param name="projectionSettings">The Frustum which will be used to derive the projection parameters. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.RemoveAllEffects">
      <summary>Removes all effects applied to this texture layer. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.RemoveEffect(Mogre.TextureUnitState+TextureEffectType)">
      <summary>Removes a single effect applied to this texture layer. Because you can only have 1 effect of each type (e.g. 1 texture coordinate generation) applied to a layer, only the effect type is required. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetBlank">
      <summary>Sets this texture layer to be blank. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.RetryTextureLoad">
      <summary>Tells the unit to retry loading the texture if it had failed to load. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureFiltering(Mogre.FilterOptions,Mogre.FilterOptions,Mogre.FilterOptions)">
      <summary>Set a the detailed filtering options on this texture unit.  minFilter The filtering to use when reducing the size of the texture. Can be FO_POINT, FO_LINEAR or FO_ANISOTROPIC  magFilter The filtering to use when increasing the size of the texture Can be FO_POINT, FO_LINEAR or FO_ANISOTROPIC  mipFilter The filtering to use between mip levels Can be FO_NONE (turns off mipmapping), FO_POINT or FO_LINEAR (trilinear filtering) </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureFiltering(Mogre.FilterType,Mogre.FilterOptions)">
      <summary>Set a single filtering option on this texture unit.  ftype The filtering type to set  opts The filtering option to set </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.SetTextureFiltering(Mogre.TextureFilterOptions)">
      <summary>Set the texture filtering for this unit, using the simplified interface. You also have the option of specifying the minification, magnification and mip filter individually if you want more control over filtering options. See the alternative setTextureFiltering methods for details. This option applies in both the fixed function and the programmable pipeline. </summary>
      <param name="filterType">The high-level filter type to use. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetCompositorReference(System.String,System.String)">
      <summary>Set the compositor reference for this texture unit state. Only valid when content type is compositor. </summary>
      <param name="compositorName">the name of the compositor to reference </param>
      <param name="textureName">the name of the texture to reference </param>
    </member>
    <member name="M:Mogre.TextureUnitState.SetCompositorReference(System.String,System.String,System.UInt32)">
      <summary>Set the compositor reference for this texture unit state. Only valid when content type is compositor. </summary>
      <param name="compositorName">the name of the compositor to reference </param>
      <param name="textureName">the name of the texture to reference </param>
      <param name="mrtIndex">the index of the wanted texture, if referencing an MRT </param>
    </member>
    <member name="M:Mogre.TextureUnitState._prepare">
      <summary>Internal method for preparing this object for load, as part of Material::prepare</summary>
    </member>
    <member name="M:Mogre.TextureUnitState._unprepare">
      <summary>Internal method for undoing the preparation this object as part of Material::unprepare </summary>
    </member>
    <member name="M:Mogre.TextureUnitState._load">
      <summary>Internal method for loading this object as part of Material::load</summary>
    </member>
    <member name="M:Mogre.TextureUnitState._unload">
      <summary>Internal method for unloading this object as part of Material::unload</summary>
    </member>
    <member name="M:Mogre.TextureUnitState._notifyNeedsRecompile">
      <summary>Tells the class that it needs recompilation. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. If no matching aliases are found then the TUS state does not change. Cubic, 1d, 2d, and 3d textures are determined from current state of the Texture Unit. Assumes animated frames are sequentially numbered in the name. If matching texture aliases are found then true is returned.True if matching texture aliases were found in the Texture Unit State. </summary>
      <param name="aliasList">is a map container of texture alias, texture name pairs </param>
    </member>
    <member name="M:Mogre.TextureUnitState.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList,System.Boolean)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. If no matching aliases are found then the TUS state does not change. Cubic, 1d, 2d, and 3d textures are determined from current state of the Texture Unit. Assumes animated frames are sequentially numbered in the name. If matching texture aliases are found then true is returned.True if matching texture aliases were found in the Texture Unit State. </summary>
      <param name="aliasList">is a map container of texture alias, texture name pairs </param>
      <param name="apply">set true to apply the texture aliases else just test to see if texture alias matches are found. </param>
    </member>
    <member name="M:Mogre.TextureUnitState._notifyParent(Mogre.Pass)">
      <summary>Notify this object that its parent has changed </summary>
    </member>
    <member name="M:Mogre.TextureUnitState._getTexturePtr(System.UInt32)">
      <summary>Get the texture pointer for the current frame. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState._getTexturePtr">
      <summary>Get the texture pointer for the current frame. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState._setTexturePtr(Mogre.TexturePtr,System.UInt32)">
      <summary>Set the texture pointer for a given frame (internal use only!). </summary>
    </member>
    <member name="M:Mogre.TextureUnitState._setTexturePtr(Mogre.TexturePtr)">
      <summary>Set the texture pointer for the current frame (internal use only!). </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.#ctor(Mogre.Pass,System.String)">
      <summary>Name-based constructor. </summary>
    </member>
    <member name="M:Mogre.TextureUnitState.#ctor(Mogre.Pass,System.String,System.UInt32)">
      <summary>Name-based constructor. </summary>
      <param name="texCoordSet">The index of the texture coordinate set to use. </param>
    </member>
    <member name="M:Mogre.TextureUnitState.#ctor(Mogre.Pass)">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.TextureType">
      <summary>Returns the type of this texture. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.TextureTransform">
      <summary>Sets/Gets the current texture transformation matrix. Causes a reclaculation of the matrix if any parameters have been changed via setTextureScroll, setTextureScale and setTextureRotate. Has no effect in the programmable pipeline. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.TextureNameAlias">
      <summary>Sets/gets the Texture Name Alias of the Texture Unit. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.TextureName">
      <summary>Get the name of current texture image for this layer. This will either always be a single name for this layer, or will be the name of the current frame for an animated or otherwise multi-frame texture. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.TextureMipmapBias">
      <summary>Sets/Gets the bias value applied to the mipmap calculation. TextureUnitState::setTextureMipmapBias</summary>
    </member>
    <member name="P:Mogre.TextureUnitState.TextureCoordSet">
      <summary>Sets/Gets the index of the set of texture co-ords this layer uses. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.TextureBorderColour">
      <summary>Sets/Sets the texture border colour. The default is ColourValue::Black, and this value only used when addressing mode is TAM_BORDER. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.ReferencedTextureName">
      <summary>Gets the name of the texture in the compositor that this texture references </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.ReferencedMRTIndex">
      <summary>Gets the MRT index of the texture in the compositor that this texture references </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.ReferencedCompositorName">
      <summary>Gets the name of the compositor that this texture referneces </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.Parent">
      <summary>Gets the parent Pass object. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.NumMipmaps">
      <summary>Sets/Gets how many mipmaps have been requested for the texture. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.NumFrames">
      <summary>Gets the number of frames for a texture. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.Name">
      <summary>Sets/get the name of the Texture Unit State </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.IsTextureLoadFailing">
      <summary>Tests if the texture associated with this unit has failed to load. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.IsHardwareGammaEnabled">
      <summary>Gets whether this texture will be set up so that on sampling it, hardware gamma correction is applied.</summary>
    </member>
    <member name="P:Mogre.TextureUnitState.IsCubic">
      <summary>Returns true if this texture unit is either a series of 6 2D textures, each in it's own frame, or is a full 3D cube map. You can tell which by checking getTextureType. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.IsBlank">
      <summary>Determines if this texture layer is currently blank. This can happen if a texture fails to load or some other non-fatal error. Worth checking after setting texture name. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.IsAlpha">
      <summary>Sets/Gets whether this texture is requested to be loaded as alpha if single channel </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.HasViewRelativeTextureCoordinateGeneration">
      <summary>Returns whether this unit has texture coordinate generation that depends on the camera. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.DesiredFormat">
      <summary>Sets/Gets the desired pixel format when load the texture. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.CurrentFrame">
      <summary>Sets/Gets the active frame in an animated or multi-image texture layer. Applies to both fixed-function and programmable pipeline. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.ColourBlendMode">
      <summary>Get multitexturing colour blending mode. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.ColourBlendFallbackSrc">
      <summary>Get the multipass fallback for colour blending operation source factor. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.ColourBlendFallbackDest">
      <summary>Get the multipass fallback for colour blending operation destination factor. </summary>
    </member>
    <member name="P:Mogre.TextureUnitState.AlphaBlendMode">
      <summary>Get multitexturing alpha blending mode. </summary>
    </member>
    <member name="T:Mogre.TextureUnitState+TextureEffectType">
      <summary>Definition of the broad types of texture effect you can apply to a texture unit. Note that these have no effect when using the programmable pipeline, since their effect is overridden by the vertex / fragment programs. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureEffectType.ET_ENVIRONMENT_MAP">
      <summary>Generate all texture coords based on angle between camera and vertex. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureEffectType.ET_PROJECTIVE_TEXTURE">
      <summary>Generate texture coords based on a frustum. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureEffectType.ET_UVSCROLL">
      <summary>Constant u/v scrolling effect. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureEffectType.ET_USCROLL">
      <summary>Constant u scrolling effect. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureEffectType.ET_VSCROLL">
      <summary>Constant u/v scrolling effect. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureEffectType.ET_ROTATE">
      <summary>Constant rotation. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureEffectType.ET_TRANSFORM">
      <summary>More complex transform. </summary>
    </member>
    <member name="T:Mogre.TextureUnitState+EnvMapType">
      <summary>Enumeration to specify type of envmap. Note that these have no effect when using the programmable pipeline, since their effect is overridden by the vertex / fragment programs. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+EnvMapType.ENV_PLANAR">
      <summary>Envmap based on vector from camera to vertex position, good for planar geometry. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+EnvMapType.ENV_CURVED">
      <summary>Envmap based on dot of vector from camera to vertex and vertex normal, good for curves. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+EnvMapType.ENV_REFLECTION">
      <summary>Envmap intended to supply reflection vectors for cube mapping. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+EnvMapType.ENV_NORMAL">
      <summary>Envmap intended to supply normal vectors for cube mapping. </summary>
    </member>
    <member name="T:Mogre.TextureUnitState+TextureTransformType">
      <summary>Useful enumeration when dealing with procedural transforms. Note that these have no effect when using the programmable pipeline, since their effect is overridden by the vertex / fragment programs. </summary>
    </member>
    <member name="T:Mogre.TextureUnitState+TextureAddressingMode">
      <summary>Texture addressing modes - default is TAM_WRAP. These settings are relevant in both the fixed-function and the programmable pipeline. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureAddressingMode.TAM_WRAP">
      <summary>Texture wraps at values over 1.0. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureAddressingMode.TAM_MIRROR">
      <summary>Texture mirrors (flips) at joins over 1.0. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureAddressingMode.TAM_CLAMP">
      <summary>Texture clamps at 1.0. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+TextureAddressingMode.TAM_BORDER">
      <summary>Texture coordinates outside the range [0.0, 1.0] are set to the border colour. </summary>
    </member>
    <member name="T:Mogre.TextureUnitState+TextureCubeFace">
      <summary>Enum identifying the frame indexes for faces of a cube map (not the composite 3D type. </summary>
    </member>
    <member name="T:Mogre.TextureUnitState+BindingType">
      <summary>The type of unit to bind the texture settings to. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+BindingType.BT_FRAGMENT">
      <summary>Regular fragment processing unit - the default. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+BindingType.BT_VERTEX">
      <summary>Vertex processing unit - indicates this unit will be used for a vertex texture fetch. </summary>
    </member>
    <member name="T:Mogre.TextureUnitState+ContentType">
      <summary>Enum identifying the type of content this texture unit contains. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+ContentType.CONTENT_NAMED">
      <summary>Normal texture identified by name. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+ContentType.CONTENT_SHADOW">
      <summary>A shadow texture, automatically bound by engine. </summary>
    </member>
    <member name="F:Mogre.TextureUnitState+ContentType.CONTENT_COMPOSITOR">
      <summary>A compositor texture, automatically linked to active viewport's chain. </summary>
    </member>
    <member name="T:Mogre.IlluminationPass_NativePtr">
      <summary>Struct recording a pass which can be used for a specific illumination stage. This structure is used to record categorised passes which fit into a number of distinct illumination phases - ambient, diffuse / specular (per-light) and decal (post-lighting texturing). An original pass may fit into one of these categories already, or it may require splitting into its component parts in order to be categorised properly. </summary>
    </member>
    <member name="P:Mogre.IlluminationPass_NativePtr.originalPass">
      <summary>Sets/The original pass which spawned this one. </summary>
    </member>
    <member name="P:Mogre.IlluminationPass_NativePtr.destroyOnShutdown">
      <summary>Sets/Whether this pass is one which should be deleted itself. </summary>
    </member>
    <member name="P:Mogre.IlluminationPass_NativePtr.pass">
      <summary>Sets/The pass to use in this stage. </summary>
    </member>
    <member name="T:Mogre.Pass">
      <summary>Class defining a single pass of a Technique (of a Material), i.e. a single rendering call. Rendering can be repeated with many passes for more complex effects. Each pass is either a fixed-function pass (meaning it does not use a vertex or fragment program) or a programmable pass (meaning it does use either a vertex and fragment program, or both). Programmable passes are complex to define, because they require custom programs and you have to set all constant inputs to the programs (like the position of lights, any base material colours you wish to use etc), but they do give you much total flexibility over the algorithms used to render your pass, and you can create some effects which are impossible with a fixed-function pass. On the other hand, you can define a fixed-function pass in very little time, and you can use a range of fixed-function effects like environment mapping very easily, plus your pass will be more likely to be compatible with older hardware. There are pros and cons to both, just remember that if you use a programmable pass to create some great effects, allow more time for definition and testing. </summary>
    </member>
    <member name="M:Mogre.Pass.SetAmbient(System.Single,System.Single,System.Single)">
      <summary>Sets the ambient colour reflectance properties of this pass. The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much ambient light (directionless global light) is reflected. The default is full white, meaning objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light effects, or change the blend of colours to make the object have a base colour other than white. This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </summary>
    </member>
    <member name="M:Mogre.Pass.SetDiffuse(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the diffuse colour reflectance properties of this pass. The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much diffuse light (light from instances of the Light class in the scene) is reflected. The default is full white, meaning objects reflect the maximum white light they can from Light objects. This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </summary>
    </member>
    <member name="M:Mogre.Pass.SetSpecular(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the specular colour reflectance properties of this pass. The base colour of a pass is determined by how much red, green and blue light is reflects (provided texture layer #0 has a blend mode other than LBO_REPLACE). This property determines how much specular light (highlights from instances of the Light class in the scene) is reflected. The default is to reflect no specular light. The size of the specular highlights is determined by the separate 'shininess' property. This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </summary>
    </member>
    <member name="M:Mogre.Pass.SetSelfIllumination(System.Single,System.Single,System.Single)">
      <summary>Sets the amount of self-illumination an object has. If an object is self-illuminating, it does not need external sources to light it, ambient or otherwise. It's like the object has it's own personal ambient light. This property is rarely useful since you can already specify per-pass ambient light, but is here for completeness. This setting has no effect if dynamic lighting is disabled (see Pass::setLightingEnabled), or if this is a programmable pass. </summary>
    </member>
    <member name="M:Mogre.Pass.SetPointAttenuation(System.Boolean)">
      <summary>Sets how points are attenuated with distance. When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2). For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively. The resulting size is clamped to the minimum and maximum point size. </summary>
      <param name="enabled">Whether point attenuation is enabled </param>
    </member>
    <member name="M:Mogre.Pass.SetPointAttenuation(System.Boolean,System.Single)">
      <summary>Sets how points are attenuated with distance. When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2). For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively. The resulting size is clamped to the minimum and maximum point size. </summary>
      <param name="enabled">Whether point attenuation is enabled </param>
      <param name="constant">Parameters to the attenuation function defined above </param>
    </member>
    <member name="M:Mogre.Pass.SetPointAttenuation(System.Boolean,System.Single,System.Single)">
      <summary>Sets how points are attenuated with distance. When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2). For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively. The resulting size is clamped to the minimum and maximum point size. </summary>
      <param name="enabled">Whether point attenuation is enabled </param>
      <param name="constant">Parameters to the attenuation function defined above </param>
    </member>
    <member name="M:Mogre.Pass.SetPointAttenuation(System.Boolean,System.Single,System.Single,System.Single)">
      <summary>Sets how points are attenuated with distance. When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2). For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively. The resulting size is clamped to the minimum and maximum point size. </summary>
      <param name="enabled">Whether point attenuation is enabled </param>
      <param name="constant">Parameters to the attenuation function defined above </param>
    </member>
    <member name="M:Mogre.Pass.CreateTextureUnitState(System.String)">
      <summary>Inserts a new TextureUnitState object into the Pass. This unit is is added on top of all previous units. Applies to both fixed-function and programmable passes. </summary>
    </member>
    <member name="M:Mogre.Pass.CreateTextureUnitState(System.String,System.UInt16)">
      <summary>Inserts a new TextureUnitState object into the Pass. This unit is is added on top of all previous units. Applies to both fixed-function and programmable passes. </summary>
      <param name="texCoordSet">The index of the texture coordinate set to use. </param>
    </member>
    <member name="M:Mogre.Pass.CreateTextureUnitState">
      <summary>Inserts a new TextureUnitState object into the Pass. This unit is is added on top of all previous units. </summary>
    </member>
    <member name="M:Mogre.Pass.AddTextureUnitState(Mogre.TextureUnitState)">
      <summary>Adds the passed in TextureUnitState, to the existing Pass. Throws an exception if the TextureUnitState is attached to another Pass. </summary>
      <param name="state">The Texture Unit State to be attached to this pass. It must not be attached to another pass. </param>
    </member>
    <member name="M:Mogre.Pass.GetTextureUnitState(System.String)">
      <summary>Retrieves the Texture Unit State matching name. Returns 0 if name match is not found. </summary>
    </member>
    <member name="M:Mogre.Pass.GetTextureUnitState(System.UInt16)">
      <summary>Retrieves a pointer to a texture unit state so it may be modified. </summary>
    </member>
    <member name="M:Mogre.Pass.GetTextureUnitStateIndex(Mogre.TextureUnitState)">
      <summary>Retrieve the index of the Texture Unit State in the pass. Throws an exception if the state is not attached to the pass. </summary>
      <param name="state">The Texture Unit State this is attached to this pass. </param>
    </member>
    <member name="M:Mogre.Pass.GetTextureUnitStateIterator">
      <summary>Get an iterator over the TextureUnitStates contained in this Pass. </summary>
    </member>
    <member name="M:Mogre.Pass.RemoveTextureUnitState(System.UInt16)">
      <summary>Removes the indexed texture unit state from this pass. Note that removing a texture which is not the topmost will have a larger performance impact. </summary>
    </member>
    <member name="M:Mogre.Pass.RemoveAllTextureUnitStates">
      <summary>Removes all texture unit settings. </summary>
    </member>
    <member name="M:Mogre.Pass.SetSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Allows very fine control of blending this Pass with the existing contents of the scene. Whereas the texture blending operations seen in the TextureUnitState class are concerned with blending between texture layers, this blending is about combining the output of the material as a whole with the existing contents of the rendering target. This blending therefore allows object transparency and other special effects. This version of the method allows complete control over the blending operation, by specifying the source and destination blending factors. The result of the blending operation is:  final = (texture * sourceFactor) + (pixel * destFactor)  Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. This method is applicable for both the fixed-function and programmable pipelines. </summary>
      <param name="sourceFactor">The source factor in the above calculation, i.e. multiplied by the texture colour components. </param>
      <param name="destFactor">The destination factor in the above calculation, i.e. multiplied by the pixel colour components. </param>
    </member>
    <member name="M:Mogre.Pass.SetSceneBlending(Mogre.SceneBlendType)">
      <summary>Sets the kind of blending this pass has with the existing contents of the scene. Wheras the texture blending operations seen in the TextureUnitState class are concerned with blending between texture layers, this blending is about combining the output of the Pass as a whole with the existing contents of the rendering target. This blending therefore allows object transparency and other special effects. If all passes in a technique have a scene blend, then the whole technique is considered to be transparent. This method allows you to select one of a number of predefined blending types. If you require more control than this, use the alternative version of this method which allows you to specify source and destination blend factors. This method is applicable for both the fixed-function and programmable pipelines. </summary>
      <param name="sbt">One of the predefined SceneBlendType blending types </param>
    </member>
    <member name="M:Mogre.Pass.SetSeparateSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Allows very fine control of blending this Pass with the existing contents of the scene. Wheras the texture blending operations seen in the TextureUnitState class are concerned with blending between texture layers, this blending is about combining the output of the material as a whole with the existing contents of the rendering target. This blending therefore allows object transparency and other special effects. This version of the method allows complete control over the blending operation, by specifying the source and destination blending factors. The result of the blending operation is:  final = (texture * sourceFactor) + (pixel * destFactor)  Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. This method is applicable for both the fixed-function and programmable pipelines. </summary>
      <param name="sourceFactor">The source factor in the above calculation, i.e. multiplied by the texture colour components. </param>
      <param name="destFactor">The destination factor in the above calculation, i.e. multiplied by the pixel colour components. </param>
      <param name="sourceFactorAlpha">The alpha source factor in the above calculation, i.e. multiplied by the texture alpha component. </param>
      <param name="destFactorAlpha">The alpha destination factor in the above calculation, i.e. multiplied by the pixel alpha component. </param>
    </member>
    <member name="M:Mogre.Pass.SetSeparateSceneBlending(Mogre.SceneBlendType,Mogre.SceneBlendType)">
      <summary>Sets the kind of blending this pass has with the existing contents of the scene, separately for color and alpha channels Whereas the texture blending operations seen in the TextureUnitState class are concerned with blending between texture layers, this blending is about combining the output of the Pass as a whole with the existing contents of the rendering target. This blending therefore allows object transparency and other special effects. If all passes in a technique have a scene blend, then the whole technique is considered to be transparent. This method allows you to select one of a number of predefined blending types. If you require more control than this, use the alternative version of this method which allows you to specify source and destination blend factors. This method is applicable for both the fixed-function and programmable pipelines. </summary>
      <param name="sbt">One of the predefined SceneBlendType blending types for the color channel </param>
      <param name="sbta">One of the predefined SceneBlendType blending types for the alpha channel </param>
    </member>
    <member name="M:Mogre.Pass.SetSeparateSceneBlendingOperation(Mogre.SceneBlendOperation,Mogre.SceneBlendOperation)">
      <summary>Sets the specific operation used to blend source and destination pixels together. By default this operation is +, which creates this equation  final = (texture * sourceFactor) + (pixel * destFactor)  By setting this to something other than SBO_ADD you can change the operation to achieve a different effect. This function allows more control over blending since it allows you to select different blending modes for the color and alpha channels </summary>
      <param name="op">The blending operation mode to use for color channels in this pass </param>
      <param name="op">The blending operation mode to use for alpha channels in this pass </param>
    </member>
    <member name="M:Mogre.Pass.SetFog(System.Boolean)">
      <summary>Sets the fogging mode applied to this pass. Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. The SceneManager class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </summary>
      <param name="overrideScene">If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </param>
    </member>
    <member name="M:Mogre.Pass.SetFog(System.Boolean,Mogre.FogMode)">
      <summary>Sets the fogging mode applied to this pass. Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. The SceneManager class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </summary>
      <param name="overrideScene">If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </param>
      <param name="mode">Only applicable if overrideScene is true. You can disable fog which is turned on for the rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as defined in the enum FogMode. </param>
    </member>
    <member name="M:Mogre.Pass.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue)">
      <summary>Sets the fogging mode applied to this pass. Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. The SceneManager class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </summary>
      <param name="overrideScene">If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </param>
      <param name="mode">Only applicable if overrideScene is true. You can disable fog which is turned on for the rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as defined in the enum FogMode. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
    </member>
    <member name="M:Mogre.Pass.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single)">
      <summary>Sets the fogging mode applied to this pass. Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. The SceneManager class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </summary>
      <param name="overrideScene">If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </param>
      <param name="mode">Only applicable if overrideScene is true. You can disable fog which is turned on for the rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as defined in the enum FogMode. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </param>
    </member>
    <member name="M:Mogre.Pass.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to this pass. Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. The SceneManager class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </summary>
      <param name="overrideScene">If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </param>
      <param name="mode">Only applicable if overrideScene is true. You can disable fog which is turned on for the rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as defined in the enum FogMode. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </param>
      <param name="linearStart">Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </param>
    </member>
    <member name="M:Mogre.Pass.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to this pass. Fogging is an effect that is applied as polys are rendered. Sometimes, you want fog to be applied to an entire scene. Other times, you want it to be applied to a few polygons only. This pass-level specification of fog parameters lets you easily manage both. The SceneManager class also has a setFog method which applies scene-level fog. This method lets you change the fog behaviour for this pass compared to the standard scene-level fog. </summary>
      <param name="overrideScene">If true, you authorise this pass to override the scene's fog params with it's own settings. If you specify false, so other parameters are necessary, and this is the default behaviour for passes. </param>
      <param name="mode">Only applicable if overrideScene is true. You can disable fog which is turned on for the rest of the scene by specifying FOG_NONE. Otherwise, set a pass-specific fog mode as defined in the enum FogMode. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 0.001. </param>
      <param name="linearStart">Distance in world units at which linear fog starts to encroach. Only applicable if mode is FOG_LINEAR. </param>
      <param name="linearEnd">Distance in world units at which linear fog becomes completely opaque. Only applicable if mode is FOG_LINEAR. </param>
    </member>
    <member name="M:Mogre.Pass.SetDepthBias(System.Single)">
      <summary>Sets the depth bias to be used for this material. When polygons are coplanar, you can get problems with 'depth fighting' where the pixels from the two polys compete for the same screen pixel. This is particularly a problem for decals (polys attached to another surface to represent details such as bulletholes etc.). A way to combat this problem is to use a depth bias to adjust the depth buffer value used for the decal such that it is slightly higher than the true value, ensuring that the decal appears on top. There are two aspects to the biasing, a constant bias value and a slope-relative biasing value, which varies according to the maximum depth slope relative to the camera, ie: finalBias = maxSlope * slopeScaleBias + constantBias Note that slope scale bias, whilst more accurate, may be ignored by old hardware. </summary>
      <param name="constantBias">The constant bias value, expressed as a factor of the minimum observable depth </param>
    </member>
    <member name="M:Mogre.Pass.SetDepthBias(System.Single,System.Single)">
      <summary>Sets the depth bias to be used for this material. When polygons are coplanar, you can get problems with 'depth fighting' where the pixels from the two polys compete for the same screen pixel. This is particularly a problem for decals (polys attached to another surface to represent details such as bulletholes etc.). A way to combat this problem is to use a depth bias to adjust the depth buffer value used for the decal such that it is slightly higher than the true value, ensuring that the decal appears on top. There are two aspects to the biasing, a constant bias value and a slope-relative biasing value, which varies according to the maximum depth slope relative to the camera, ie: finalBias = maxSlope * slopeScaleBias + constantBias Note that slope scale bias, whilst more accurate, may be ignored by old hardware. </summary>
      <param name="constantBias">The constant bias value, expressed as a factor of the minimum observable depth </param>
      <param name="slopeScaleBias">The slope-relative bias value, expressed as a factor of the depth slope </param>
    </member>
    <member name="M:Mogre.Pass.SetAlphaRejectSettings(Mogre.CompareFunction,System.Byte)">
      <summary>Sets the way the pass will have use alpha to totally reject pixels from the pipeline. The default is CMPF_ALWAYS_PASS i.e. alpha is not used to reject pixels. This option applies in both the fixed function and the programmable pipeline. </summary>
      <param name="func">The comparison which must pass for the pixel to be written. </param>
      <param name="value">1 byte value against which alpha values will be tested(0-255) </param>
    </member>
    <member name="M:Mogre.Pass.SetAlphaRejectSettings(Mogre.CompareFunction,System.Byte,System.Boolean)">
      <summary>Sets the way the pass will have use alpha to totally reject pixels from the pipeline. The default is CMPF_ALWAYS_PASS i.e. alpha is not used to reject pixels. This option applies in both the fixed function and the programmable pipeline. </summary>
      <param name="func">The comparison which must pass for the pixel to be written. </param>
      <param name="value">1 byte value against which alpha values will be tested(0-255) </param>
      <param name="alphaToCoverageEnabled">Whether to enable alpha to coverage support </param>
    </member>
    <member name="M:Mogre.Pass.SetAlphaToCoverageEnabled(System.Boolean)">
      <summary>Sets whether to use alpha to coverage (A2C) when blending alpha rejected values. Alpha to coverage performs multisampling on the edges of alpha-rejected textures to produce a smoother result. It is only supported when multisampling is already enabled on the render target, and when the hardware supports alpha to coverage (see RenderSystemCapabilities). </summary>
    </member>
    <member name="M:Mogre.Pass.SetIteratePerLight(System.Boolean)">
      <summary>Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered. The default behaviour for a pass (when this option is 'false'), is for a pass to be rendered only once (or the number of times set in setPassIterationCount), with all the lights which could affect this object set at the same time (up to the maximum lights allowed in the render system, which is typically 8). Setting this option to 'true' changes this behaviour, such that instead of trying to issue render this pass once per object, it is run per light, or for a group of 'n' lights each time which can affect this object, the number of times set in setPassIterationCount (default is once). In this case, only light index 0 is ever used, and is a different light every time the pass is issued, up to the total number of lights which is affecting this object. This has 2 advantages: There is no limit on the number of lights which can be supported It's easier to write vertex / fragment programs for this because a single program can be used for any number of lights 
However, this technique is more expensive, and typically you will want an additional ambient pass, because if no lights are affecting the object it will not be rendered at all, which will look odd even if ambient light is zero (imagine if there are lit objects behind it - the objects silhouette would not show up). Therefore, use this option with care, and you would be well advised to provide a less expensive fallback technique for use in the distance. The number of times this pass runs is still limited by the maximum number of lights allowed as set in setMaxSimultaneousLights, so you will never get more passes than this. Also, the iteration is started from the 'start light' as set in Pass::setStartLight, and the number of passes is the number of lights to iterate over divided by the number of lights per iteration (default 1, set by setLightCountPerIteration). </summary>
      <param name="enabled">Whether this feature is enabled </param>
    </member>
    <member name="M:Mogre.Pass.SetIteratePerLight(System.Boolean,System.Boolean)">
      <summary>Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered. The default behaviour for a pass (when this option is 'false'), is for a pass to be rendered only once (or the number of times set in setPassIterationCount), with all the lights which could affect this object set at the same time (up to the maximum lights allowed in the render system, which is typically 8). Setting this option to 'true' changes this behaviour, such that instead of trying to issue render this pass once per object, it is run per light, or for a group of 'n' lights each time which can affect this object, the number of times set in setPassIterationCount (default is once). In this case, only light index 0 is ever used, and is a different light every time the pass is issued, up to the total number of lights which is affecting this object. This has 2 advantages: There is no limit on the number of lights which can be supported It's easier to write vertex / fragment programs for this because a single program can be used for any number of lights 
However, this technique is more expensive, and typically you will want an additional ambient pass, because if no lights are affecting the object it will not be rendered at all, which will look odd even if ambient light is zero (imagine if there are lit objects behind it - the objects silhouette would not show up). Therefore, use this option with care, and you would be well advised to provide a less expensive fallback technique for use in the distance. The number of times this pass runs is still limited by the maximum number of lights allowed as set in setMaxSimultaneousLights, so you will never get more passes than this. Also, the iteration is started from the 'start light' as set in Pass::setStartLight, and the number of passes is the number of lights to iterate over divided by the number of lights per iteration (default 1, set by setLightCountPerIteration). </summary>
      <param name="enabled">Whether this feature is enabled </param>
      <param name="onlyForOneLightType">If true, the pass will only be run for a single type of light, other light types will be ignored. </param>
    </member>
    <member name="M:Mogre.Pass.SetIteratePerLight(System.Boolean,System.Boolean,Mogre.Light+LightTypes)">
      <summary>Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered. The default behaviour for a pass (when this option is 'false'), is for a pass to be rendered only once (or the number of times set in setPassIterationCount), with all the lights which could affect this object set at the same time (up to the maximum lights allowed in the render system, which is typically 8). Setting this option to 'true' changes this behaviour, such that instead of trying to issue render this pass once per object, it is run per light, or for a group of 'n' lights each time which can affect this object, the number of times set in setPassIterationCount (default is once). In this case, only light index 0 is ever used, and is a different light every time the pass is issued, up to the total number of lights which is affecting this object. This has 2 advantages: There is no limit on the number of lights which can be supported It's easier to write vertex / fragment programs for this because a single program can be used for any number of lights 
However, this technique is more expensive, and typically you will want an additional ambient pass, because if no lights are affecting the object it will not be rendered at all, which will look odd even if ambient light is zero (imagine if there are lit objects behind it - the objects silhouette would not show up). Therefore, use this option with care, and you would be well advised to provide a less expensive fallback technique for use in the distance. The number of times this pass runs is still limited by the maximum number of lights allowed as set in setMaxSimultaneousLights, so you will never get more passes than this. Also, the iteration is started from the 'start light' as set in Pass::setStartLight, and the number of passes is the number of lights to iterate over divided by the number of lights per iteration (default 1, set by setLightCountPerIteration). </summary>
      <param name="enabled">Whether this feature is enabled </param>
      <param name="onlyForOneLightType">If true, the pass will only be run for a single type of light, other light types will be ignored. </param>
      <param name="lightType">The single light type which will be considered for this pass </param>
    </member>
    <member name="M:Mogre.Pass.SetVertexProgram(System.String)">
      <summary>Sets the details of the vertex program to use. Only applicable to programmable passes, this sets the details of the vertex program to use in this pass. The program will not be loaded until the parent Material is loaded. </summary>
      <param name="name">The name of the program - this must have been created using GpuProgramManager by the time that this Pass is loaded. If this parameter is blank, any vertex program in this pass is disabled. </param>
    </member>
    <member name="M:Mogre.Pass.SetVertexProgram(System.String,System.Boolean)">
      <summary>Sets the details of the vertex program to use. Only applicable to programmable passes, this sets the details of the vertex program to use in this pass. The program will not be loaded until the parent Material is loaded. </summary>
      <param name="name">The name of the program - this must have been created using GpuProgramManager by the time that this Pass is loaded. If this parameter is blank, any vertex program in this pass is disabled. </param>
      <param name="resetParams">If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </param>
    </member>
    <member name="M:Mogre.Pass.SetVertexProgramParameters(Mogre.GpuProgramParametersSharedPtr)">
      <summary>Sets the vertex program parameters. Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </summary>
    </member>
    <member name="M:Mogre.Pass.GetVertexProgramParameters">
      <summary>Gets the vertex program parameters used by this pass. </summary>
    </member>
    <member name="M:Mogre.Pass.GetVertexProgram">
      <summary>Gets the vertex program used by this pass, only available after _load(). </summary>
    </member>
    <member name="M:Mogre.Pass.SetShadowCasterVertexProgram(System.String)">
      <summary>Sets the details of the vertex program to use when rendering as a shadow caster. Texture-based shadows require that the caster is rendered to a texture in a solid colour (the shadow colour in the case of modulative texture shadows). Whilst Ogre can arrange this for the fixed function pipeline, passes which use vertex programs might need the vertex programs still to run in order to preserve any deformation etc that it does. However, lighting calculations must be a lot simpler, with only the ambient colour being used (which the engine will ensure is bound to the shadow colour). Therefore, it is up to implementors of vertex programs to provide an alternative vertex program which can be used to render the object to a shadow texture. Do all the same vertex transforms, but set the colour of the vertex to the ambient colour, as bound using the standard auto parameter binding mechanism. Some vertex programs will work without doing this, because Ogre ensures that all lights except for ambient are set black. However, the chances are that your vertex program is doing a lot of unnecessary work in this case, since the other lights are having no effect, and it is good practice to supply an alternative. This is only applicable to programmable passes. The default behaviour is for Ogre to switch to fixed-function rendering if an explicit vertex program alternative is not set. </summary>
    </member>
    <member name="M:Mogre.Pass.SetShadowCasterVertexProgramParameters(Mogre.GpuProgramParametersSharedPtr)">
      <summary>Sets the vertex program parameters for rendering as a shadow caster. Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </summary>
    </member>
    <member name="M:Mogre.Pass.GetShadowCasterVertexProgramParameters">
      <summary>Gets the vertex program parameters used by this pass when rendering shadow casters. </summary>
    </member>
    <member name="M:Mogre.Pass.GetShadowCasterVertexProgram">
      <summary>Gets the vertex program used by this pass when rendering shadow casters, only available after _load(). </summary>
    </member>
    <member name="M:Mogre.Pass.SetShadowReceiverVertexProgram(System.String)">
      <summary>Sets the details of the vertex program to use when rendering as a shadow receiver. Texture-based shadows require that the shadow receiver is rendered using a projective texture. Whilst Ogre can arrange this for the fixed function pipeline, passes which use vertex programs might need the vertex programs still to run in order to preserve any deformation etc that it does. So in this case, we need a vertex program which does the appropriate vertex transformation, but generates projective texture coordinates. Therefore, it is up to implementors of vertex programs to provide an alternative vertex program which can be used to render the object as a shadow receiver. Do all the same vertex transforms, but generate 2 sets of texture coordinates using the auto parameter ACT_TEXTURE_VIEWPROJ_MATRIX, which Ogre will bind to the parameter name / index you supply as the second parameter to this method. 2 texture sets are needed because Ogre needs to use 2 texture units for some shadow effects. This is only applicable to programmable passes. The default behaviour is for Ogre to switch to fixed-function rendering if an explict vertex program alternative is not set. </summary>
    </member>
    <member name="M:Mogre.Pass.SetShadowReceiverVertexProgramParameters(Mogre.GpuProgramParametersSharedPtr)">
      <summary>Sets the vertex program parameters for rendering as a shadow receiver. Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </summary>
    </member>
    <member name="M:Mogre.Pass.SetShadowReceiverFragmentProgram(System.String)">
      <summary>This method allows you to specify a fragment program for use when rendering a texture shadow receiver. Texture shadows are applied by rendering the receiver. Modulative texture shadows are performed as a post-render darkening pass, and as such fragment programs are generally not required per-object. Additive texture shadows, however, are applied by accumulating light masked out using a texture shadow (black &amp; white by default, unless you customise this using SceneManager::setCustomShadowCasterMaterial). OGRE can do this for you for most materials, but if you use a custom lighting program (e.g. per pixel lighting) then you'll need to provide a custom version for receiving shadows. You don't need to provide this for shadow casters if you don't use self-shadowing since they will never be shadow receivers too. The shadow texture is always bound to texture unit 0 when rendering texture shadow passes. Therefore your custom shadow receiver program may well just need to shift it's texture unit usage up by one unit, and take the shadow texture into account in its calculations. </summary>
    </member>
    <member name="M:Mogre.Pass.SetShadowReceiverFragmentProgramParameters(Mogre.GpuProgramParametersSharedPtr)">
      <summary>Sets the fragment program parameters for rendering as a shadow receiver. Only applicable to programmable passes, and this particular call is designed for low-level programs; use the named parameter methods for setting high-level program parameters. </summary>
    </member>
    <member name="M:Mogre.Pass.GetShadowReceiverVertexProgramParameters">
      <summary>Gets the vertex program parameters used by this pass when rendering shadow receivers. </summary>
    </member>
    <member name="M:Mogre.Pass.GetShadowReceiverVertexProgram">
      <summary>Gets the vertex program used by this pass when rendering shadow receivers, only available after _load(). </summary>
    </member>
    <member name="M:Mogre.Pass.GetShadowReceiverFragmentProgramParameters">
      <summary>Gets the fragment program parameters used by this pass when rendering shadow receivers. </summary>
    </member>
    <member name="M:Mogre.Pass.GetShadowReceiverFragmentProgram">
      <summary>Gets the fragment program used by this pass when rendering shadow receivers, only available after _load(). </summary>
    </member>
    <member name="M:Mogre.Pass.SetFragmentProgram(System.String)">
      <summary>Sets the details of the fragment program to use. Only applicable to programmable passes, this sets the details of the fragment program to use in this pass. The program will not be loaded until the parent Material is loaded. </summary>
      <param name="name">The name of the program - this must have been created using GpuProgramManager by the time that this Pass is loaded. If this parameter is blank, any fragment program in this pass is disabled. </param>
    </member>
    <member name="M:Mogre.Pass.SetFragmentProgram(System.String,System.Boolean)">
      <summary>Sets the details of the fragment program to use. Only applicable to programmable passes, this sets the details of the fragment program to use in this pass. The program will not be loaded until the parent Material is loaded. </summary>
      <param name="name">The name of the program - this must have been created using GpuProgramManager by the time that this Pass is loaded. If this parameter is blank, any fragment program in this pass is disabled. </param>
      <param name="resetParams">If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </param>
    </member>
    <member name="M:Mogre.Pass.SetFragmentProgramParameters(Mogre.GpuProgramParametersSharedPtr)">
      <summary>Sets the fragment program parameters. Only applicable to programmable passes. </summary>
    </member>
    <member name="M:Mogre.Pass.GetFragmentProgramParameters">
      <summary>Gets the fragment program parameters used by this pass. </summary>
    </member>
    <member name="M:Mogre.Pass.GetFragmentProgram">
      <summary>Gets the fragment program used by this pass, only available after _load(). </summary>
    </member>
    <member name="M:Mogre.Pass.SetGeometryProgram(System.String)">
      <summary>Sets the details of the geometry program to use. Only applicable to programmable passes, this sets the details of the geometry program to use in this pass. The program will not be loaded until the parent Material is loaded. </summary>
      <param name="name">The name of the program - this must have been created using GpuProgramManager by the time that this Pass is loaded. If this parameter is blank, any geometry program in this pass is disabled. </param>
    </member>
    <member name="M:Mogre.Pass.SetGeometryProgram(System.String,System.Boolean)">
      <summary>Sets the details of the geometry program to use. Only applicable to programmable passes, this sets the details of the geometry program to use in this pass. The program will not be loaded until the parent Material is loaded. </summary>
      <param name="name">The name of the program - this must have been created using GpuProgramManager by the time that this Pass is loaded. If this parameter is blank, any geometry program in this pass is disabled. </param>
      <param name="resetParams">If true, this will create a fresh set of parameters from the new program being linked, so if you had previously set parameters you will have to set them again. If you set this to false, you must be absolutely sure that the parameters match perfectly, and in the case of named parameters refers to the indexes underlying them, not just the names. </param>
    </member>
    <member name="M:Mogre.Pass.SetGeometryProgramParameters(Mogre.GpuProgramParametersSharedPtr)">
      <summary>Sets the geometry program parameters. Only applicable to programmable passes. </summary>
    </member>
    <member name="M:Mogre.Pass.GetGeometryProgramParameters">
      <summary>Gets the geometry program parameters used by this pass. </summary>
    </member>
    <member name="M:Mogre.Pass.GetGeometryProgram">
      <summary>Gets the geometry program used by this pass, only available after _load(). </summary>
    </member>
    <member name="M:Mogre.Pass._split(System.UInt16)">
      <summary>Splits this Pass to one which can be handled in the number of texture units specified. Only works on non-programmable passes, programmable passes cannot be split, it's up to the author to ensure that there is a fallback Technique for less capable cards. A new Pass which contains the remaining units, and a scene_blend setting appropriate to approximate the multitexture. This Pass will be attached to the parent Technique of this Pass. </summary>
      <param name="numUnits">The target number of texture units </param>
    </member>
    <member name="M:Mogre.Pass._notifyIndex(System.UInt16)">
      <summary>Internal method to adjust pass index. </summary>
    </member>
    <member name="M:Mogre.Pass._prepare">
      <summary>Internal method for preparing to load this pass. </summary>
    </member>
    <member name="M:Mogre.Pass._unprepare">
      <summary>Internal method for undoing the load preparartion for this pass. </summary>
    </member>
    <member name="M:Mogre.Pass._load">
      <summary>Internal method for loading this pass. </summary>
    </member>
    <member name="M:Mogre.Pass._unload">
      <summary>Internal method for unloading this pass. </summary>
    </member>
    <member name="M:Mogre.Pass._dirtyHash">
      <summary>Mark the hash as dirty. </summary>
    </member>
    <member name="M:Mogre.Pass._recalculateHash">
      <summary>Internal method for recalculating the hash. Do not call this unless you are sure the old hash is not still being used by anything. If in doubt, call _dirtyHash if you want to force recalculation of the has next time. </summary>
    </member>
    <member name="M:Mogre.Pass._notifyNeedsRecompile">
      <summary>Tells the pass that it needs recompilation. </summary>
    </member>
    <member name="M:Mogre.Pass._getTextureUnitWithContentTypeIndex(Mogre.TextureUnitState+ContentType,System.UInt16)">
      <summary>Gets the 'nth' texture which references the given content type. If the 'nth' texture unit which references the content type doesn't exist, then this method returns an arbitrary high-value outside the valid range to index texture units. </summary>
    </member>
    <member name="M:Mogre.Pass.SetTextureFiltering(Mogre.TextureFilterOptions)">
      <summary>Set texture filtering for every texture unit This property actually exists on the TextureUnitState class For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the TextureUnitState instance and set the property there. TextureUnitState::setTextureFiltering</summary>
    </member>
    <member name="M:Mogre.Pass.SetTextureAnisotropy(System.UInt32)">
      <summary>Sets the anisotropy level to be used for all textures. This property has been moved to the TextureUnitState class, which is accessible via the Technique and Pass. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the Technique, Pass and TextureUnitState instances and set the property there. TextureUnitState::setTextureAnisotropy</summary>
    </member>
    <member name="M:Mogre.Pass.QueueForDeletion">
      <summary>Queue this pass for deletion when appropriate. </summary>
    </member>
    <member name="M:Mogre.Pass.SetPassIterationCount(System.UInt32)">
      <summary>set the number of iterations that this pass should perform when doing fast multi pass operation. Only applicable for programmable passes. </summary>
      <param name="count">number of iterations to perform fast multi pass operations. A value greater than 1 will cause the pass to be executed count number of times without changing the render state. This is very usefull for passes that use programmable shaders that have to iterate more than once but don't need a render state change. Using multi pass can dramatically speed up rendering for materials that do things like fur, blur. A value of 1 turns off multi pass operation and the pass does the normal pass operation. </param>
    </member>
    <member name="M:Mogre.Pass.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. All Texture Unit States within the pass are checked. If matching texture aliases are found then true is returned.</summary>
    </member>
    <member name="M:Mogre.Pass.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList,System.Boolean)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. All Texture Unit States within the pass are checked. If matching texture aliases are found then true is returned.</summary>
    </member>
    <member name="M:Mogre.Pass.GetDirtyHashList">
      <summary>Static method to retrieve all the Passes which need their hash values recalculated. </summary>
    </member>
    <member name="M:Mogre.Pass.GetPassGraveyard">
      <summary>Static method to retrieve all the Passes which are pending deletion. </summary>
    </member>
    <member name="M:Mogre.Pass.ClearDirtyHashList">
      <summary>Static method to reset the list of passes which need their hash values recalculated. For performance, the dirty list is not updated progressively as the hashes are recalculated, instead we expect the processor of the dirty hash list to clear the list when they are done. </summary>
    </member>
    <member name="M:Mogre.Pass.ProcessPendingPassUpdates">
      <summary>Process all dirty and pending deletion passes. </summary>
    </member>
    <member name="M:Mogre.Pass.#ctor(Mogre.Technique,System.UInt16,Mogre.Pass)">
      <summary>Copy constructor. </summary>
    </member>
    <member name="M:Mogre.Pass.#ctor(Mogre.Technique,System.UInt16)">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.Pass.VertexProgramName">
      <summary>Gets the name of the vertex program used by this pass. </summary>
    </member>
    <member name="P:Mogre.Pass.VertexColourTracking">
      <summary>Sets/Gets which material properties follow the vertex colour </summary>
    </member>
    <member name="P:Mogre.Pass.UserObjectBindings">
      <summary>Return an instance of user objects binding associated with this class. You can use it to associate one or more custom objects with this class instance. UserObjectBindings::setUserAny. </summary>
    </member>
    <member name="P:Mogre.Pass.TransparentSortingForced">
      <summary>Sets/Returns whether or not transparent sorting is forced. </summary>
    </member>
    <member name="P:Mogre.Pass.TransparentSortingEnabled">
      <summary>Sets/Returns whether or not transparent sorting is enabled. </summary>
    </member>
    <member name="P:Mogre.Pass.StartLight">
      <summary>Sets/Gets the light index that this pass will start at in the light list. </summary>
    </member>
    <member name="P:Mogre.Pass.Specular">
      <summary>Sets/Gets the specular colour reflectance of the pass. </summary>
    </member>
    <member name="P:Mogre.Pass.SourceBlendFactorAlpha">
      <summary>Retrieves the alpha source blending factor for the material (as set using Materiall::setSeparateSceneBlending). </summary>
    </member>
    <member name="P:Mogre.Pass.SourceBlendFactor">
      <summary>Retrieves the source blending factor for the material (as set using Materiall::setSceneBlending). </summary>
    </member>
    <member name="P:Mogre.Pass.Shininess">
      <summary>Sets/Gets the 'shininess' property of the pass (affects specular highlights). </summary>
    </member>
    <member name="P:Mogre.Pass.ShadowReceiverVertexProgramName">
      <summary>Gets the name of the vertex program used by this pass when rendering shadow receivers. </summary>
    </member>
    <member name="P:Mogre.Pass.ShadowReceiverFragmentProgramName">
      <summary>Gets the name of the fragment program used by this pass when rendering shadow receivers. </summary>
    </member>
    <member name="P:Mogre.Pass.ShadowCasterVertexProgramName">
      <summary>Gets the name of the vertex program used by this pass when rendering shadow casters. </summary>
    </member>
    <member name="P:Mogre.Pass.ShadingMode">
      <summary>Sets/Returns the type of light shading to be used. </summary>
    </member>
    <member name="P:Mogre.Pass.SelfIllumination">
      <summary>Sets/Gets the self illumination colour of the pass. </summary>
    </member>
    <member name="P:Mogre.Pass.SceneBlendingOperationAlpha">
      <summary>Returns the current alpha blending operation </summary>
    </member>
    <member name="P:Mogre.Pass.SceneBlendingOperation">
      <summary>Sets/Returns the current blending operation </summary>
    </member>
    <member name="P:Mogre.Pass.RunOnlyForOneLightType">
      <summary>Does this pass run only for a single light type (if getIteratePerLight is true). </summary>
    </member>
    <member name="P:Mogre.Pass.ResourceGroup">
      <summary>Gets the resource group of the ultimate parent Material. </summary>
    </member>
    <member name="P:Mogre.Pass.PolygonModeOverrideable">
      <summary>Sets/Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting. </summary>
    </member>
    <member name="P:Mogre.Pass.PolygonMode">
      <summary>Sets/Returns the type of light shading to be used. </summary>
    </member>
    <member name="P:Mogre.Pass.PointSpritesEnabled">
      <summary>Sets/Returns whether point sprites are enabled when rendering a point list. </summary>
    </member>
    <member name="P:Mogre.Pass.PointSize">
      <summary>Sets/Gets the point size of the pass. This property determines what point size is used to render a point list. </summary>
    </member>
    <member name="P:Mogre.Pass.PointMinSize">
      <summary>Sets/Get the minimum point size, when point attenuation is in use. </summary>
    </member>
    <member name="P:Mogre.Pass.PointMaxSize">
      <summary>Sets/Get the maximum point size, when point attenuation is in use. 0 indicates the max size supported by the card. </summary>
    </member>
    <member name="P:Mogre.Pass.PointAttenuationQuadratic">
      <summary>Returns the quadratic coefficient of point attenuation. </summary>
    </member>
    <member name="P:Mogre.Pass.PointAttenuationLinear">
      <summary>Returns the linear coefficient of point attenuation. </summary>
    </member>
    <member name="P:Mogre.Pass.PointAttenuationConstant">
      <summary>Returns the constant coefficient of point attenuation. </summary>
    </member>
    <member name="P:Mogre.Pass.PassIterationCount">
      <summary>Gets the pass iteration count value. </summary>
    </member>
    <member name="P:Mogre.Pass.Parent">
      <summary>Gets the parent Technique. </summary>
    </member>
    <member name="P:Mogre.Pass.OnlyLightType">
      <summary>Gets the single light type this pass runs for if getIteratePerLight and getRunOnlyForOneLightType are both true. </summary>
    </member>
    <member name="P:Mogre.Pass.NumTextureUnitStates">
      <summary>Returns the number of texture unit settings. </summary>
    </member>
    <member name="P:Mogre.Pass.NormaliseNormals">
      <summary>Sets/Returns true if this pass has auto-normalisation of normals set. </summary>
    </member>
    <member name="P:Mogre.Pass.Name">
      <summary>Sets/get the name of the pass </summary>
    </member>
    <member name="P:Mogre.Pass.MaxSimultaneousLights">
      <summary>Sets/Gets the maximum number of lights to be used by this pass. </summary>
    </member>
    <member name="P:Mogre.Pass.ManualCullingMode">
      <summary>Sets/Retrieves the manual culling mode for this pass setManualCullingMode</summary>
    </member>
    <member name="P:Mogre.Pass.LightScissoringEnabled">
      <summary>Sets/Gets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it. </summary>
    </member>
    <member name="P:Mogre.Pass.LightingEnabled">
      <summary>Sets/Returns whether or not dynamic lighting is enabled. </summary>
    </member>
    <member name="P:Mogre.Pass.LightCountPerIteration">
      <summary>Sets/If light iteration is enabled, determine the number of lights per iteration. </summary>
    </member>
    <member name="P:Mogre.Pass.LightClipPlanesEnabled">
      <summary>Sets/Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light. </summary>
    </member>
    <member name="P:Mogre.Pass.IterationDepthBias">
      <summary>Sets/Gets a factor which derives an additional depth bias from the number of times a pass is iterated. </summary>
    </member>
    <member name="P:Mogre.Pass.IteratePerLight">
      <summary>Does this pass run once for every light in range? </summary>
    </member>
    <member name="P:Mogre.Pass.IsTransparent">
      <summary>Returns true if this pass has some element of transparency. </summary>
    </member>
    <member name="P:Mogre.Pass.IsProgrammable">
      <summary>Returns true if this pass is programmable i.e. includes either a vertex or fragment program. </summary>
    </member>
    <member name="P:Mogre.Pass.IsPointAttenuationEnabled">
      <summary>Returns whether points are attenuated with distance. </summary>
    </member>
    <member name="P:Mogre.Pass.IsAmbientOnly">
      <summary>Returns whether this pass is ambient only. </summary>
    </member>
    <member name="P:Mogre.Pass.IsAlphaToCoverageEnabled">
      <summary>Gets whether to use alpha to coverage (A2C) when blending alpha rejected values. </summary>
    </member>
    <member name="P:Mogre.Pass.Index">
      <summary>Gets the index of this Pass in the parent Technique. </summary>
    </member>
    <member name="P:Mogre.Pass.IlluminationStage">
      <summary>Sets/Get the manually assigned illumination stage, if any. </summary>
    </member>
    <member name="P:Mogre.Pass.HasVertexProgram">
      <summary>Returns true if this pass uses a programmable vertex pipeline. </summary>
    </member>
    <member name="P:Mogre.Pass.HasShadowReceiverVertexProgram">
      <summary>Returns true if this pass uses a shadow receiver vertex program. </summary>
    </member>
    <member name="P:Mogre.Pass.HasShadowReceiverFragmentProgram">
      <summary>Returns true if this pass uses a shadow receiver fragment program. </summary>
    </member>
    <member name="P:Mogre.Pass.HasShadowCasterVertexProgram">
      <summary>Returns true if this pass uses a shadow caster vertex program. </summary>
    </member>
    <member name="P:Mogre.Pass.HasSeparateSceneBlendingOperations">
      <summary>Returns true if this pass uses separate scene blending operations. </summary>
    </member>
    <member name="P:Mogre.Pass.HasSeparateSceneBlending">
      <summary>Return true if this pass uses separate scene blending </summary>
    </member>
    <member name="P:Mogre.Pass.Hash">
      <summary>Gets the 'hash' of this pass, ie a precomputed number to use for sorting This hash is used to sort passes, and for this reason the pass is hashed using firstly its index (so that all passes are rendered in order), then by the textures which it's TextureUnitState instances are using. </summary>
    </member>
    <member name="P:Mogre.Pass.HasGeometryProgram">
      <summary>Returns true if this pass uses a programmable geometry pipeline. </summary>
    </member>
    <member name="P:Mogre.Pass.HasFragmentProgram">
      <summary>Returns true if this pass uses a programmable fragment pipeline. </summary>
    </member>
    <member name="P:Mogre.Pass.GeometryProgramName">
      <summary>Gets the name of the geometry program used by this pass. </summary>
    </member>
    <member name="P:Mogre.Pass.FragmentProgramName">
      <summary>Gets the name of the fragment program used by this pass. </summary>
    </member>
    <member name="P:Mogre.Pass.FogStart">
      <summary>Returns the fog start distance for this pass. Only valid if getFogOverride is true. </summary>
    </member>
    <member name="P:Mogre.Pass.FogOverride">
      <summary>Returns true if this pass is to override the scene fog settings. </summary>
    </member>
    <member name="P:Mogre.Pass.FogMode">
      <summary>Returns the fog mode for this pass. Only valid if getFogOverride is true. </summary>
    </member>
    <member name="P:Mogre.Pass.FogEnd">
      <summary>Returns the fog end distance for this pass. Only valid if getFogOverride is true. </summary>
    </member>
    <member name="P:Mogre.Pass.FogDensity">
      <summary>Returns the fog density for this pass. Only valid if getFogOverride is true. </summary>
    </member>
    <member name="P:Mogre.Pass.FogColour">
      <summary>Returns the fog colour for the scene. </summary>
    </member>
    <member name="P:Mogre.Pass.Diffuse">
      <summary>Sets/Gets the diffuse colour reflectance of the pass. </summary>
    </member>
    <member name="P:Mogre.Pass.DestBlendFactorAlpha">
      <summary>Retrieves the alpha destination blending factor for the material (as set using Materiall::setSeparateSceneBlending). </summary>
    </member>
    <member name="P:Mogre.Pass.DestBlendFactor">
      <summary>Retrieves the destination blending factor for the material (as set using Materiall::setSceneBlending). </summary>
    </member>
    <member name="P:Mogre.Pass.DepthWriteEnabled">
      <summary>Sets/Returns whether or not this pass renders with depth-buffer writing on or not. setDepthWriteEnabled</summary>
    </member>
    <member name="P:Mogre.Pass.DepthFunction">
      <summary>Sets/Returns the function used to compare depth values when depth checking is on. setDepthFunction</summary>
    </member>
    <member name="P:Mogre.Pass.DepthCheckEnabled">
      <summary>Sets/Returns whether or not this pass renders with depth-buffer checking on or not. setDepthCheckEnabled</summary>
    </member>
    <member name="P:Mogre.Pass.DepthBiasSlopeScale">
      <summary>Retrieves the slope-scale depth bias value as set by setDepthBias. </summary>
    </member>
    <member name="P:Mogre.Pass.DepthBiasConstant">
      <summary>Retrieves the const depth bias value as set by setDepthBias. </summary>
    </member>
    <member name="P:Mogre.Pass.CullingMode">
      <summary>Sets/Returns the culling mode for geometry rendered with this pass. See setCullingMode for more information. </summary>
    </member>
    <member name="P:Mogre.Pass.ColourWriteEnabled">
      <summary>Sets/Determines if colour buffer writing is enabled for this pass. </summary>
    </member>
    <member name="P:Mogre.Pass.Ambient">
      <summary>Sets/Gets the ambient colour reflectance of the pass. </summary>
    </member>
    <member name="P:Mogre.Pass.AlphaRejectValue">
      <summary>Sets/Gets the alpha reject value. See setAlphaRejectSettings for more information. </summary>
    </member>
    <member name="P:Mogre.Pass.AlphaRejectFunction">
      <summary>Sets/Gets the alpha reject function. See setAlphaRejectSettings for more information. </summary>
    </member>
    <member name="T:Mogre.Pass+BuiltinHashFunction">
      <summary>There are some default hash functions used to order passes so that render state changes are minimised, this enumerates them. </summary>
    </member>
    <member name="F:Mogre.Pass+BuiltinHashFunction.MIN_TEXTURE_CHANGE">
      <summary>Try to minimise the number of texture changes. </summary>
    </member>
    <member name="F:Mogre.Pass+BuiltinHashFunction.MIN_GPU_PROGRAM_CHANGE">
      <summary>Try to minimise the number of GPU program changes. Only really useful if you use GPU programs for all of your materials. </summary>
    </member>
    <member name="T:Mogre.Technique">
      <summary>Class representing an approach to rendering this particular Material. Ogre will attempt to use the best technique supported by the active hardware, unless you specifically request a lower detail technique (say for distant rendering). </summary>
    </member>
    <member name="M:Mogre.Technique._compile(System.Boolean)">
      <summary>Internal compilation method; see Material::compile. Any information explaining problems with the compile. </summary>
    </member>
    <member name="M:Mogre.Technique._compileIlluminationPasses">
      <summary>Internal method for splitting the passes into illumination passes. </summary>
    </member>
    <member name="M:Mogre.Technique.CreatePass">
      <summary>Creates a new Pass for this Technique. A Pass is a single rendering pass, i.e. a single draw of the given material. Note that if you create a pass without a fragment program, during compilation of the material the pass may be split into multiple passes if the graphics card cannot handle the number of texture units requested. For passes with fragment programs, however, the number of passes you create will never be altered, so you have to make sure that you create an alternative fallback Technique for if a card does not have enough facilities for what you're asking for. </summary>
    </member>
    <member name="M:Mogre.Technique.GetPass(System.String)">
      <summary>Retrieves the Pass matching name. Returns 0 if name match is not found. </summary>
    </member>
    <member name="M:Mogre.Technique.GetPass(System.UInt16)">
      <summary>Retrieves the Pass with the given index. </summary>
    </member>
    <member name="M:Mogre.Technique.RemovePass(System.UInt16)">
      <summary>Removes the Pass with the given index. </summary>
    </member>
    <member name="M:Mogre.Technique.RemoveAllPasses">
      <summary>Removes all Passes from this Technique. </summary>
    </member>
    <member name="M:Mogre.Technique.MovePass(System.UInt16,System.UInt16)">
      <summary>Move a pass from source index to destination index. If successful then returns true. </summary>
    </member>
    <member name="M:Mogre.Technique.GetPassIterator">
      <summary>Gets an iterator over the passes in this Technique. </summary>
    </member>
    <member name="M:Mogre.Technique.GetIlluminationPassIterator">
      <summary>Gets an iterator over the illumination-stage categorised passes. </summary>
    </member>
    <member name="M:Mogre.Technique._prepare">
      <summary>Internal prepare method, derived from call to Material::prepare. </summary>
    </member>
    <member name="M:Mogre.Technique._unprepare">
      <summary>Internal unprepare method, derived from call to Material::unprepare. </summary>
    </member>
    <member name="M:Mogre.Technique._load">
      <summary>Internal load method, derived from call to Material::load. </summary>
    </member>
    <member name="M:Mogre.Technique._unload">
      <summary>Internal unload method, derived from call to Material::unload. </summary>
    </member>
    <member name="M:Mogre.Technique._notifyNeedsRecompile">
      <summary>Tells the technique that it needs recompilation. </summary>
    </member>
    <member name="M:Mogre.Technique.GetShadowCasterMaterial">
      <summary>return this material specific shadow casting specific material </summary>
    </member>
    <member name="M:Mogre.Technique.SetShadowCasterMaterial(System.String)">
      <summary>set this material specific shadow casting specific material </summary>
    </member>
    <member name="M:Mogre.Technique.SetShadowCasterMaterial(Mogre.MaterialPtr)">
      <summary>set this material specific shadow casting specific material </summary>
    </member>
    <member name="M:Mogre.Technique.GetShadowReceiverMaterial">
      <summary>return this material specific shadow receiving specific material </summary>
    </member>
    <member name="M:Mogre.Technique.SetShadowReceiverMaterial(System.String)">
      <summary>set this material specific shadow receiving specific material </summary>
    </member>
    <member name="M:Mogre.Technique.SetShadowReceiverMaterial(Mogre.MaterialPtr)">
      <summary>set this material specific shadow receiving specific material </summary>
    </member>
    <member name="M:Mogre.Technique.SetPointSize(System.Single)">
      <summary>Sets the point size properties for every Pass in this Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setPointSize</summary>
    </member>
    <member name="M:Mogre.Technique.SetAmbient(Mogre.ColourValue)">
      <summary>Sets the ambient colour reflectance properties for every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setAmbient</summary>
    </member>
    <member name="M:Mogre.Technique.SetAmbient(System.Single,System.Single,System.Single)">
      <summary>Sets the ambient colour reflectance properties for every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setAmbient</summary>
    </member>
    <member name="M:Mogre.Technique.SetDiffuse(Mogre.ColourValue)">
      <summary>Sets the diffuse colour reflectance properties of every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setDiffuse</summary>
    </member>
    <member name="M:Mogre.Technique.SetDiffuse(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the diffuse colour reflectance properties of every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setDiffuse</summary>
    </member>
    <member name="M:Mogre.Technique.SetSpecular(Mogre.ColourValue)">
      <summary>Sets the specular colour reflectance properties of every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSpecular</summary>
    </member>
    <member name="M:Mogre.Technique.SetSpecular(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the specular colour reflectance properties of every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSpecular</summary>
    </member>
    <member name="M:Mogre.Technique.SetShininess(System.Single)">
      <summary>Sets the shininess properties of every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setShininess</summary>
    </member>
    <member name="M:Mogre.Technique.SetSelfIllumination(Mogre.ColourValue)">
      <summary>Sets the amount of self-illumination of every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSelfIllumination</summary>
    </member>
    <member name="M:Mogre.Technique.SetSelfIllumination(System.Single,System.Single,System.Single)">
      <summary>Sets the amount of self-illumination of every Pass in every Technique. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSelfIllumination</summary>
    </member>
    <member name="M:Mogre.Technique.SetDepthCheckEnabled(System.Boolean)">
      <summary>Sets whether or not each Pass renders with depth-buffer checking on or not. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setDepthCheckEnabled</summary>
    </member>
    <member name="M:Mogre.Technique.SetDepthWriteEnabled(System.Boolean)">
      <summary>Sets whether or not each Pass renders with depth-buffer writing on or not. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setDepthWriteEnabled</summary>
    </member>
    <member name="M:Mogre.Technique.SetDepthFunction(Mogre.CompareFunction)">
      <summary>Sets the function used to compare depth values when depth checking is on. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setDepthFunction</summary>
    </member>
    <member name="M:Mogre.Technique.SetColourWriteEnabled(System.Boolean)">
      <summary>Sets whether or not colour buffer writing is enabled for each Pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setColourWriteEnabled</summary>
    </member>
    <member name="M:Mogre.Technique.SetCullingMode(Mogre.CullingMode)">
      <summary>Sets the culling mode for each pass based on the 'vertex winding'. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setCullingMode</summary>
    </member>
    <member name="M:Mogre.Technique.SetManualCullingMode(Mogre.ManualCullingMode)">
      <summary>Sets the manual culling mode, performed by CPU rather than hardware. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setManualCullingMode</summary>
    </member>
    <member name="M:Mogre.Technique.SetLightingEnabled(System.Boolean)">
      <summary>Sets whether or not dynamic lighting is enabled for every Pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setLightingEnabled</summary>
    </member>
    <member name="M:Mogre.Technique.SetShadingMode(Mogre.ShadeOptions)">
      <summary>Sets the type of light shading required This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setShadingMode</summary>
    </member>
    <member name="M:Mogre.Technique.SetFog(System.Boolean)">
      <summary>Sets the fogging mode applied to each pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Technique.SetFog(System.Boolean,Mogre.FogMode)">
      <summary>Sets the fogging mode applied to each pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Technique.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue)">
      <summary>Sets the fogging mode applied to each pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Technique.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single)">
      <summary>Sets the fogging mode applied to each pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Technique.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to each pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Technique.SetFog(System.Boolean,Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single,System.Single)">
      <summary>Sets the fogging mode applied to each pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setFog</summary>
    </member>
    <member name="M:Mogre.Technique.SetDepthBias(System.Single,System.Single)">
      <summary>Sets the depth bias to be used for each Pass. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setDepthBias</summary>
    </member>
    <member name="M:Mogre.Technique.SetTextureFiltering(Mogre.TextureFilterOptions)">
      <summary>Set texture filtering for every texture unit in every PassThis property actually exists on the TextureUnitState class For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the Pass and TextureUnitState instances and set the property there. TextureUnitState::setTextureFiltering</summary>
    </member>
    <member name="M:Mogre.Technique.SetTextureAnisotropy(System.UInt32)">
      <summary>Sets the anisotropy level to be used for all textures. This property has been moved to the TextureUnitState class, which is accessible via the Technique and Pass. For simplicity, this method allows you to set these properties for every current TeextureUnitState, If you need more precision, retrieve the Technique, Pass and TextureUnitState instances and set the property there. TextureUnitState::setTextureAnisotropy</summary>
    </member>
    <member name="M:Mogre.Technique.SetSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Allows very fine control of blending every Pass with the existing contents of the scene. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSceneBlending</summary>
    </member>
    <member name="M:Mogre.Technique.SetSceneBlending(Mogre.SceneBlendType)">
      <summary>Sets the kind of blending every pass has with the existing contents of the scene. This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSceneBlending</summary>
    </member>
    <member name="M:Mogre.Technique.SetSeparateSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Allows very fine control of blending every Pass with the existing contents of the scene, using individual factors both color and alpha channels This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSeparateSceneBlending</summary>
    </member>
    <member name="M:Mogre.Technique.SetSeparateSceneBlending(Mogre.SceneBlendType,Mogre.SceneBlendType)">
      <summary>Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels This property actually exists on the Pass class. For simplicity, this method allows you to set these properties for every current Pass within this Technique. If you need more precision, retrieve the Pass instance and set the property there. Pass::setSeparateSceneBlending</summary>
    </member>
    <member name="M:Mogre.Technique._getSchemeIndex">
      <summary>Internal method for getting the scheme index. </summary>
    </member>
    <member name="M:Mogre.Technique.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. All passes, and Texture Unit States within the technique are checked. If matching texture aliases are found then true is returned.</summary>
    </member>
    <member name="M:Mogre.Technique.ApplyTextureAliases(Mogre.Const_AliasTextureNamePairList,System.Boolean)">
      <summary>Applies texture names to Texture Unit State with matching texture name aliases. All passes, and Texture Unit States within the technique are checked. If matching texture aliases are found then true is returned.</summary>
    </member>
    <member name="M:Mogre.Technique.AddGPUVendorRule(Mogre.Technique+GPUVendorRule)">
      <summary>Add a rule which manually influences the support for this technique based on a GPU vendor. You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. Any rule for the same vendor will be removed before adding this one. </summary>
    </member>
    <member name="M:Mogre.Technique.AddGPUVendorRule(Mogre.GPUVendor,Mogre.Technique+IncludeOrExclude)">
      <summary>Add a rule which manually influences the support for this technique based on a GPU vendor. You can use this facility to manually control whether a technique is considered supported, based on a GPU vendor. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. Any rule for the same vendor will be removed before adding this one. </summary>
      <param name="vendor">The GPU vendor </param>
      <param name="includeOrExclude">Whether this is an inclusive or exclusive rule </param>
    </member>
    <member name="M:Mogre.Technique.RemoveGPUVendorRule(Mogre.GPUVendor)">
      <summary>Removes a matching vendor rule. addGPUVendorRule</summary>
    </member>
    <member name="M:Mogre.Technique.GetGPUVendorRuleIterator">
      <summary>Get an iterator over the currently registered vendor rules. </summary>
    </member>
    <member name="M:Mogre.Technique.AddGPUDeviceNameRule(Mogre.Technique+GPUDeviceNameRule)">
      <summary>Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. '*8800*'). You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. Any rule for the same device pattern will be removed before adding this one. </summary>
    </member>
    <member name="M:Mogre.Technique.AddGPUDeviceNameRule(System.String,Mogre.Technique+IncludeOrExclude)">
      <summary>Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. '*8800*'). You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. Any rule for the same device pattern will be removed before adding this one. </summary>
      <param name="devicePattern">The GPU vendor </param>
      <param name="includeOrExclude">Whether this is an inclusive or exclusive rule </param>
    </member>
    <member name="M:Mogre.Technique.AddGPUDeviceNameRule(System.String,Mogre.Technique+IncludeOrExclude,System.Boolean)">
      <summary>Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. '*8800*'). You can use this facility to manually control whether a technique is considered supported, based on a GPU device name pattern. You can add inclusive or exclusive rules, and you can add as many of each as you like. If at least one inclusive rule is added, a technique is considered unsupported if it does not match any of those inclusive rules. If exclusive rules are added, the technique is considered unsupported if it matches any of those inclusive rules. The pattern you supply can include wildcard characters ('*') if you only want to match part of the device name. Any rule for the same device pattern will be removed before adding this one. </summary>
      <param name="devicePattern">The GPU vendor </param>
      <param name="includeOrExclude">Whether this is an inclusive or exclusive rule </param>
      <param name="caseSensitive">Whether the match is case sensitive or not </param>
    </member>
    <member name="M:Mogre.Technique.RemoveGPUDeviceNameRule(System.String)">
      <summary>Removes a matching device name rule. addGPUDeviceNameRule</summary>
    </member>
    <member name="M:Mogre.Technique.GetGPUDeviceNameRuleIterator">
      <summary>Get an iterator over the currently registered device name rules. </summary>
    </member>
    <member name="M:Mogre.Technique.#ctor(Mogre.Material,Mogre.Technique)">
      <summary>Copy constructor. </summary>
    </member>
    <member name="M:Mogre.Technique.#ctor(Mogre.Material)">
      <summary>Constructor. </summary>
    </member>
    <member name="P:Mogre.Technique.UserObjectBindings">
      <summary>Return an instance of user objects binding associated with this class. You can use it to associate one or more custom objects with this class instance. UserObjectBindings::setUserAny. </summary>
    </member>
    <member name="P:Mogre.Technique.SchemeName">
      <summary>Sets/Returns the scheme to which this technique is assigned. Technique::setSchemeName</summary>
    </member>
    <member name="P:Mogre.Technique.ResourceGroup">
      <summary>Gets the resource group of the ultimate parent Material. </summary>
    </member>
    <member name="P:Mogre.Technique.Parent">
      <summary>Gets the parent Material. </summary>
    </member>
    <member name="P:Mogre.Technique.NumPasses">
      <summary>Retrieves the number of passes. </summary>
    </member>
    <member name="P:Mogre.Technique.Name">
      <summary>Sets/Gets the name of the technique. </summary>
    </member>
    <member name="P:Mogre.Technique.LodIndex">
      <summary>Sets/Gets the level-of-detail index assigned to this Technique. </summary>
    </member>
    <member name="P:Mogre.Technique.IsTransparentSortingForced">
      <summary>Returns true if this Technique has transparent sorting forced. This basically boils down to whether the first pass has transparent sorting forced or not </summary>
    </member>
    <member name="P:Mogre.Technique.IsTransparentSortingEnabled">
      <summary>Returns true if this Technique has transparent sorting enabled. This basically boils down to whether the first pass has transparent sorting enabled or not </summary>
    </member>
    <member name="P:Mogre.Technique.IsTransparent">
      <summary>Returns true if this Technique involves transparency. This basically boils down to whether the first pass has a scene blending factor. Even if the other passes do not, the base colour, including parts of the original scene, may be used for blending, therefore we have to treat the whole Technique as transparent. </summary>
    </member>
    <member name="P:Mogre.Technique.IsSupported">
      <summary>Indicates if this technique is supported by the current graphics card. This will only be correct after the Technique has been compiled, which is usually done from Material::compile. </summary>
    </member>
    <member name="P:Mogre.Technique.IsDepthWriteEnabled">
      <summary>Is depth writing going to occur on this technique? </summary>
    </member>
    <member name="P:Mogre.Technique.IsDepthCheckEnabled">
      <summary>Is depth checking going to occur on this technique? </summary>
    </member>
    <member name="P:Mogre.Technique.HasColourWriteDisabled">
      <summary>Exists colour writing disabled pass on this technique? </summary>
    </member>
    <member name="T:Mogre.Technique+IncludeOrExclude">
      <summary>Directive used to manually control technique support based on the inclusion or exclusion of some factor. </summary>
    </member>
    <member name="F:Mogre.Technique+IncludeOrExclude.INCLUDE">
      <summary>Inclusive - only support if present. </summary>
    </member>
    <member name="F:Mogre.Technique+IncludeOrExclude.EXCLUDE">
      <summary>Exclusive - do not support if present. </summary>
    </member>
    <member name="T:Mogre.ConfigOption_NativePtr">
      <summary>Packages the details of a configuration option. Used for RenderSystem::getConfigOptions. If immutable is true, this option must be disabled for modifying. </summary>
    </member>
    <member name="T:Mogre.GpuProgram">
      <summary>Defines a program which runs on the GPU such as a vertex or fragment program. This class defines the low-level program in assembler code, the sort used to directly assemble into machine instructions for the GPU to execute. By nature, this means that the assembler source is rendersystem specific, which is why this is an abstract class - real instances are created through the RenderSystem. If you wish to use higher level shading languages like HLSL and Cg, you need to use the HighLevelGpuProgram class instead. </summary>
    </member>
    <member name="M:Mogre.GpuProgram._getBindingDelegate">
      <summary>Returns the GpuProgram which should be bound to the pipeline. This method is simply to allow some subclasses of GpuProgram to delegate the program which is bound to the pipeline to a delegate, if required. </summary>
    </member>
    <member name="M:Mogre.GpuProgram.CreateParameters">
      <summary>Creates a new parameters object compatible with this program definition. It is recommended that you use this method of creating parameters objects rather than going direct to GpuProgramManager, because this method will populate any implementation-specific extras (like named parameters) where they are appropriate. </summary>
    </member>
    <member name="M:Mogre.GpuProgram.SetSkeletalAnimationIncluded(System.Boolean)">
      <summary>Sets whether a vertex program includes the required instructions to perform skeletal animation. If this is set to true, OGRE will not blend the geometry according to skeletal animation, it will expect the vertex program to do it. </summary>
    </member>
    <member name="M:Mogre.GpuProgram.SetMorphAnimationIncluded(System.Boolean)">
      <summary>Sets whether a vertex program includes the required instructions to perform morph animation. If this is set to true, OGRE will not blend the geometry according to morph animation, it will expect the vertex program to do it. </summary>
    </member>
    <member name="M:Mogre.GpuProgram.SetPoseAnimationIncluded(System.UInt16)">
      <summary>Sets whether a vertex program includes the required instructions to perform pose animation. If this is set to true, OGRE will not blend the geometry according to pose animation, it will expect the vertex program to do it. </summary>
      <param name="poseCount">The number of simultaneous poses the program can blend </param>
    </member>
    <member name="M:Mogre.GpuProgram.SetVertexTextureFetchRequired(System.Boolean)">
      <summary>Sets whether this vertex program requires support for vertex texture fetch from the hardware. </summary>
    </member>
    <member name="M:Mogre.GpuProgram.SetAdjacencyInfoRequired(System.Boolean)">
      <summary>Sets whether this geometry program requires adjacency information from the input primitives. </summary>
    </member>
    <member name="M:Mogre.GpuProgram.GetDefaultParameters">
      <summary>Get a reference to the default parameters which are to be used for all uses of this program. A program can be set up with a list of default parameters, which can save time when using a program many times in a material with roughly the same settings. By retrieving the default parameters and populating it with the most used options, any new parameter objects created from this program afterwards will automatically include the default parameters; thus users of the program need only change the parameters which are unique to their own usage of the program. </summary>
    </member>
    <member name="M:Mogre.GpuProgram.ResetCompileError">
      <summary>Reset a compile error if it occurred, allowing the load to be retried </summary>
    </member>
    <member name="M:Mogre.GpuProgram.SetManualNamedConstants(Mogre.GpuNamedConstants)">
      <summary>Allows you to manually provide a set of named parameter mappings to a program which would not be able to derive named parameters itself. You may wish to use this if you have assembler programs that were compiled from a high-level source, and want the convenience of still being able to use the named parameters from the original high-level source. setManualNamedConstantsFile</summary>
    </member>
    <member name="P:Mogre.GpuProgram.Type">
      <summary>Sets/Get the program type. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.SyntaxCode">
      <summary>Sets/Gets the syntax code for this program e.g. arbvp1, fp20, vs_1_1 etc </summary>
    </member>
    <member name="P:Mogre.GpuProgram.SourceFile">
      <summary>Sets/Gets the name of the file used as source for this program. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.Source">
      <summary>Sets/Gets the assembler source for this program. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.PassTransformStates">
      <summary>Returns whether a vertex program wants transform state to be passed through fixed pipeline low level API rendering calls Most vertex programs do not need fixed-function transform information, however GLSL shaders can refer to this state so enable this option </summary>
    </member>
    <member name="P:Mogre.GpuProgram.PassSurfaceAndLightStates">
      <summary>Returns whether a vertex program wants light and material states to be passed through fixed pipeline low level API rendering calls (default false, subclasses can override) Most vertex programs do not need this material information, however GLSL shaders can refer to this material and lighting state so enable this option </summary>
    </member>
    <member name="P:Mogre.GpuProgram.PassFogStates">
      <summary>Returns whether a fragment program wants fog state to be passed through fixed pipeline low level API rendering calls (default true, subclasses can override) On DirectX, shader model 2 and earlier continues to have fixed-function fog applied to it, so fog state is still passed (you should disable fog on the pass if you want to perform fog in the shader). In OpenGL it is also common to be able to access the fixed-function fog state inside the shader. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.NumberOfPosesIncluded">
      <summary>Returns the number of simultaneous poses the vertex program can blend, for use in pose animation. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.NamedConstants">
      <summary>Get a read-only reference to the named constants registered for this program (manually or automatically). </summary>
    </member>
    <member name="P:Mogre.GpuProgram.ManualNamedConstantsFile">
      <summary>Sets/Gets the name of a file from which to load named parameters mapping for a program which would not be able to derive named parameters itself. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.Language">
      <summary>Returns a string that specifies the language of the gpu programs as specified in a material script. ie: asm, cg, hlsl, glsl </summary>
    </member>
    <member name="P:Mogre.GpuProgram.IsVertexTextureFetchRequired">
      <summary>Returns whether this vertex program requires support for vertex texture fetch from the hardware. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.IsSupported">
      <summary>Returns whether this program can be supported on the current renderer and hardware. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.IsSkeletalAnimationIncluded">
      <summary>Returns whether a vertex program includes the required instructions to perform skeletal animation. If this returns true, OGRE will not blend the geometry according to skeletal animation, it will expect the vertex program to do it. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.IsPoseAnimationIncluded">
      <summary>Returns whether a vertex program includes the required instructions to perform pose animation. If this returns true, OGRE will not blend the geometry according to pose animation, it will expect the vertex program to do it. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.IsMorphAnimationIncluded">
      <summary>Returns whether a vertex program includes the required instructions to perform morph animation. If this returns true, OGRE will not blend the geometry according to morph animation, it will expect the vertex program to do it. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.IsAdjacencyInfoRequired">
      <summary>Returns whether this geometry program requires adjacency information from the input primitives. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.HasDefaultParameters">
      <summary>Returns true if default parameters have been set up. </summary>
    </member>
    <member name="P:Mogre.GpuProgram.HasCompileError">
      <summary>Did this program encounter a compile error when loading? </summary>
    </member>
    <member name="P:Mogre.GpuProgram.ConstantDefinitions">
      <summary>Get the full list of named constants. Only available if this parameters object has named parameters, which means either a high-level program which loads them, or a low-level program which has them specified manually. </summary>
    </member>
    <member name="T:Mogre.GpuProgramPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to GpuProgramPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.RenderSystem">
      <summary>Defines the functionality of a 3D API The RenderSystem class provides a base interface which abstracts the general functionality of the 3D API e.g. Direct3D or OpenGL. Whilst a few of the general methods have implementations, most of this class is abstract, requiring a subclass based on a specific API to be constructed to provide the full functionality. Note there are 2 levels to the interface - one which will be used often by the caller of the Ogre library, and one which is at a lower level and will be used by the other classes provided by Ogre. These lower level methods are prefixed with '_' to differentiate them. The advanced user of the library may use these lower level methods to access the 3D API at a more fundamental level (dealing direct with render states and rendering primitives), but still benefiting from Ogre's abstraction of exactly which 3D API is in use. Steven Streeting 1.0 </summary>
    </member>
    <member name="M:Mogre.RenderSystem.GetConfigOptions">
      <summary>Returns the details of this API's configuration options Each render system must be able to inform the world of what options must/can be specified for it's operation. These are passed as strings for portability, but grouped into a structure (_ConfigOption) which includes both options and current value. Note that the settings returned from this call are affected by the options that have been set so far, since some options are interdependent. This routine is called automatically by the default configuration dialogue produced by Root::showConfigDialog or may be used by the caller for custom settings dialogs A 'map' of options, i.e. a list of options which is also indexed by option name. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetConfigOption(System.String,System.String)">
      <summary>Sets an option for this API Used to confirm the settings (normally chosen by the user) in order to make the renderer able to initialise with the settings as required. This may be video mode, D3D driver, full screen / windowed etc. Called automatically by the default configuration dialog, and by the restoration of saved settings. These settings are stored and only activated when RenderSystem::initialise or RenderSystem::reinitialise are called. If using a custom configuration dialog, it is advised that the caller calls RenderSystem::getConfigOptions again, since some options can alter resulting from a selection. </summary>
      <param name="name">The name of the option to alter. </param>
      <param name="value">The value to set the option to. </param>
    </member>
    <member name="M:Mogre.RenderSystem.CreateHardwareOcclusionQuery">
      <summary>Create an object for performing hardware occlusion queries. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.DestroyHardwareOcclusionQuery(Mogre.HardwareOcclusionQuery)">
      <summary>Destroy a hardware occlusion query object. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.ValidateConfigOptions">
      <summary>Validates the options set for the rendering system, returning a message if there are problems. If the returned string is empty, there are no problems. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._initialise(System.Boolean)">
      <summary>Start up the renderer using the settings selected (Or the defaults if none have been selected). Called by Root::setRenderSystem. Shouldn't really be called directly, although this can be done if the app wants to. If an application has more specific window requirements, however (e.g. a level design app), it should specify false for this parameter and do it manually. A pointer to the automatically created window, if requested, otherwise null. </summary>
      <param name="autoCreateWindow">If true, creates a render window automatically, based on settings chosen so far. This saves an extra call to _createRenderWindow for the main render window. </param>
    </member>
    <member name="M:Mogre.RenderSystem._initialise(System.Boolean,System.String)">
      <summary>Start up the renderer using the settings selected (Or the defaults if none have been selected). Called by Root::setRenderSystem. Shouldn't really be called directly, although this can be done if the app wants to. If an application has more specific window requirements, however (e.g. a level design app), it should specify false for this parameter and do it manually. A pointer to the automatically created window, if requested, otherwise null. </summary>
      <param name="autoCreateWindow">If true, creates a render window automatically, based on settings chosen so far. This saves an extra call to _createRenderWindow for the main render window. </param>
    </member>
    <member name="M:Mogre.RenderSystem.CreateRenderSystemCapabilities">
      <summary>Query the real capabilities of the GPU and driver in the RenderSystem</summary>
    </member>
    <member name="M:Mogre.RenderSystem.UseCustomRenderSystemCapabilities(Mogre.RenderSystemCapabilities)">
      <summary>Force the render system to use the special capabilities. Can only be called before the render system has been fully initializer (before createWindow is called) </summary>
      <param name="capabilities">has to be a subset of the real capabilities and the caller is responsible for deallocating capabilities. </param>
    </member>
    <member name="M:Mogre.RenderSystem.Reinitialise">
      <summary>Restart the renderer (normally following a change in settings). </summary>
    </member>
    <member name="M:Mogre.RenderSystem.Shutdown">
      <summary>Shutdown the renderer and cleanup resources. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetAmbientLight(System.Single,System.Single,System.Single)">
      <summary>Sets the colour &amp; strength of the ambient (global directionless) light in the world. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetShadingType(Mogre.ShadeOptions)">
      <summary>Sets the type of light shading required (default = Gouraud). </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetLightingEnabled(System.Boolean)">
      <summary>Sets whether or not dynamic lighting is enabled. </summary>
      <param name="enabled">If true, dynamic lighting is performed on geometry with normals supplied, geometry without normals will not be displayed. If false, no lighting is applied and all geometry will be full brightness. </param>
    </member>
    <member name="M:Mogre.RenderSystem._createRenderWindow(System.String,System.UInt32,System.UInt32,System.Boolean)">
      <summary>Creates a new rendering window. This method creates a new rendering window as specified by the paramteters. The rendering system could be responible for only a single window (e.g. in the case of a game), or could be in charge of multiple ones (in the case of a level editor). The option to create the window as a child of another is therefore given. This method will create an appropriate subclass of RenderWindow depending on the API and platform implementation. After creation, this window can be retrieved using getRenderTarget(). </summary>
      <param name="name">The name of the window. Used in other methods later like setRenderTarget and getRenderTarget. </param>
      <param name="width">The width of the new window. </param>
      <param name="height">The height of the new window. </param>
      <param name="fullScreen">Specify true to make the window full screen without borders, title bar or menu bar. </param>
    </member>
    <member name="M:Mogre.RenderSystem._createRenderWindow(System.String,System.UInt32,System.UInt32,System.Boolean,Mogre.Const_NameValuePairList)">
      <summary>Creates a new rendering window. This method creates a new rendering window as specified by the paramteters. The rendering system could be responible for only a single window (e.g. in the case of a game), or could be in charge of multiple ones (in the case of a level editor). The option to create the window as a child of another is therefore given. This method will create an appropriate subclass of RenderWindow depending on the API and platform implementation. After creation, this window can be retrieved using getRenderTarget(). </summary>
      <param name="name">The name of the window. Used in other methods later like setRenderTarget and getRenderTarget. </param>
      <param name="width">The width of the new window. </param>
      <param name="height">The height of the new window. </param>
      <param name="fullScreen">Specify true to make the window full screen without borders, title bar or menu bar. </param>
      <param name="miscParams">A NameValuePairList describing the other parameters for the new rendering window. Options are case sensitive. Unrecognised parameters will be ignored silently. These values might be platform dependent, but these are present for all platforms unless indicated otherwise: KeyType/ValuesDefaultDescriptionNotestitle Any string RenderTarget name The title of the window that will appear in the title bar colourDepth 16, 32 Desktop depth Colour depth of the resulting rendering window; only applies if fullScreen Win32 Specific  left Positive integers Centred Screen x coordinate from left top Positive integers Centred Screen y coordinate from left depthBuffer true, false true Use depth buffer DirectX9 specific  externalWindowHandle Win32: HWND as integer
 GLX: poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) 0 (none) External window handle, for embedding the OGRE render in an existing window externalGLControl true, false false Let the external window control OpenGL i.e. don't select a pixel format for the window, do not change v-sync and do not swap buffer. When set to true, the calling application is responsible of OpenGL initialization and buffer swapping. It should also create an OpenGL context for its own rendering, Ogre will create one for its use. Then the calling application must also enable Ogre OpenGL context before calling any Ogre function and restore its OpenGL context after these calls. OpenGL specific  externalGLContext Context as Unsigned Long 0 (create own context) Use an externally created GL context OpenGL Specific  parentWindowHandle Win32: HWND as integer
 GLX: poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) 0 (none) Parent window handle, for embedding the OGRE in a child of an external window macAPI String: "cocoa" or "carbon" "carbon" Specifies the type of rendering window on the Mac Platform. macAPICocoaUseNSView bool "true" or "false" "false" On the Mac platform the most diffused method to embed ogre in a custom application is to use the IntefaceBuilder and add to the interface an instance of OgreView. The pointer to this instance is then used as "externalWindowHandle". However, there are cases where you are NOT using the Interface Builder and you get the Cocoa NSView* of an existing interface. For example, this is happens when you want to render into a Java/AWT interface. In short, by setting this flag to "true" the Ogre::Root::createRenderWindow interprets the "externalWindowHandle" as a NSView* instead of an OgreView*. See OgreOSXCocoaView.h/mm.  FSAA Positive integer (usually 0, 2, 4, 8, 16) 0 Full screen antialiasing factor FSAAHint Depends on RenderSystem and hardware. Currently supports:
 "Quality": on systems that have an option to prefer higher AA quality over speed, use it Blank Full screen antialiasing hint displayFrequency Refresh rate in Hertz (e.g. 60, 75, 100) Desktop vsync rate Display frequency rate, for fullscreen mode vsync true, false false Synchronize buffer swaps to monitor vsync, eliminating tearing at the expense of a fixed frame rate vsyncInterval 1, 2, 3, 4 1 If vsync is enabled, the minimum number of vertical blanks that should occur between renders. For example if vsync is enabled, the refresh rate is 60 and this is set to 2, then the frame rate will be locked at 30. border none, fixed, resize resize The type of window border (in windowed mode) outerDimensions true, false false Whether the width/height is expressed as the size of the outer window, rather than the content area useNVPerfHUD true, false false Enable the use of nVidia NVPerfHUD gamma true, false false Enable hardware conversion from linear colour space to gamma colour space on rendering to the window. </param>
    </member>
    <member name="M:Mogre.RenderSystem.CreateMultiRenderTarget(System.String)">
      <summary>Create a MultiRenderTarget, which is a render target that renders to multiple RenderTextures at once. Surfaces can be bound and unbound at will. This fails if mCapabilities-&gt;getNumMultiRenderTargets() is smaller than 2. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.DestroyRenderWindow(System.String)">
      <summary>Destroys a render window </summary>
    </member>
    <member name="M:Mogre.RenderSystem.DestroyRenderTexture(System.String)">
      <summary>Destroys a render texture </summary>
    </member>
    <member name="M:Mogre.RenderSystem.DestroyRenderTarget(System.String)">
      <summary>Destroys a render target of any sort </summary>
    </member>
    <member name="M:Mogre.RenderSystem.AttachRenderTarget(Mogre.RenderTarget)">
      <summary>Attaches the passed render target to the render system. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.GetRenderTarget(System.String)">
      <summary>Returns a pointer to the render target with the passed name, or NULL if that render target cannot be found. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.DetachRenderTarget(System.String)">
      <summary>Detaches the render target with the passed name from the render system and returns a pointer to it. If the render target cannot be found, NULL is returned. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.GetRenderTargetIterator">
      <summary>Returns a specialised MapIterator over all render targets attached to the RenderSystem. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.GetErrorDescription(System.Int32)">
      <summary>Returns a description of an error code. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._useLights(Mogre.Const_LightList,System.UInt16)">
      <summary>Tells the rendersystem to use the attached set of lights (and no others) up to the number specified (this allows the same list to be used with different count limits) </summary>
    </member>
    <member name="M:Mogre.RenderSystem.AreFixedFunctionLightsInViewSpace">
      <summary>Are fixed-function lights provided in view space? Affects optimisation. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setWorldMatrix(Mogre.Matrix4)">
      <summary>Sets the world transform matrix. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setWorldMatrices(Mogre.Matrix4+NativeValue*,System.UInt16)">
      <summary>Sets multiple world matrices (vertex blending). </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setViewMatrix(Mogre.Matrix4)">
      <summary>Sets the view transform matrix </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setProjectionMatrix(Mogre.Matrix4)">
      <summary>Sets the projection transform matrix </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureUnitSettings(System.UInt32,Mogre.TextureUnitState)">
      <summary>Utility function for setting all the properties of a texture unit at once. This method is also worth using over the individual texture unit settings because it only sets those settings which are different from the current settings for this unit, thus minimising render state changes. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._disableTextureUnit(System.UInt32)">
      <summary>Turns off a texture unit. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._disableTextureUnitsFrom(System.UInt32)">
      <summary>Disables all texture units from the given unit upwards </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setSurfaceParams(Mogre.ColourValue,Mogre.ColourValue,Mogre.ColourValue,Mogre.ColourValue,System.Single)">
      <summary>Sets the surface properties to be used for future rendering.</summary>
    </member>
    <member name="M:Mogre.RenderSystem._setSurfaceParams(Mogre.ColourValue,Mogre.ColourValue,Mogre.ColourValue,Mogre.ColourValue,System.Single,System.Int32)">
      <summary>Sets the surface properties to be used for future rendering.</summary>
    </member>
    <member name="M:Mogre.RenderSystem._setPointSpritesEnabled(System.Boolean)">
      <summary>Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points. </summary>
      <param name="enabled">True enables point sprites, false returns to normal point rendering. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setPointParameters(System.Single,System.Boolean,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the size of points and how they are attenuated with distance. When performing point rendering or point sprite rendering, point size can be attenuated with distance. The equation for doing this is attenuation = 1 / (constant + linear * dist + quadratic * d^2) . For example, to disable distance attenuation (constant screensize) you would set constant to 1, and linear and quadratic to 0. A standard perspective attenuation would be 0, 1, 0 respectively. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTexture(System.UInt32,System.Boolean,System.String)">
      <summary>Sets the texture to bind to a given texture unit.</summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTexture(System.UInt32,System.Boolean,Mogre.TexturePtr)">
      <summary>Sets the texture to bind to a given texture unit.</summary>
    </member>
    <member name="M:Mogre.RenderSystem._setVertexTexture(System.UInt32,Mogre.TexturePtr)">
      <summary>Binds a texture to a vertex sampler. Not all rendersystems support separate vertex samplers. For those that do, you can set a texture for them, separate to the regular texture samplers, using this method. For those that don't, you should use the regular texture samplers which are shared between the vertex and fragment units; calling this method will throw an exception. RenderSystemCapabilites::getVertexTextureUnitsShared </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureCoordSet(System.UInt32,System.UInt32)">
      <summary>Sets the texture coordinate set to use for a texture unit.</summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureCoordCalculation(System.UInt32,Mogre.TexCoordCalcMethod)">
      <summary>Sets a method for automatically calculating texture coordinates for a stage. Should not be used by apps - for use by Ogre only. </summary>
      <param name="unit">Texture unit as above </param>
      <param name="m">Calculation method to use </param>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureCoordCalculation(System.UInt32,Mogre.TexCoordCalcMethod,Mogre.Frustum)">
      <summary>Sets a method for automatically calculating texture coordinates for a stage. Should not be used by apps - for use by Ogre only. </summary>
      <param name="unit">Texture unit as above </param>
      <param name="m">Calculation method to use </param>
      <param name="frustum">Optional Frustum param, only used for projective effects </param>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureBlendMode(System.UInt32,Mogre.LayerBlendModeEx_NativePtr)">
      <summary>Sets the texture blend modes from a TextureUnitState record. Meant for use internally only - apps should use the Material and TextureUnitState classes. </summary>
      <param name="unit">Texture unit as above </param>
      <param name="bm">Details of the blending mode </param>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureUnitFiltering(System.UInt32,Mogre.FilterType,Mogre.FilterOptions)">
      <summary>Sets a single filter for a given texture unit. </summary>
      <param name="unit">The texture unit to set the filtering options for </param>
      <param name="ftype">The filter type </param>
      <param name="filter">The filter to be used </param>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureUnitFiltering(System.UInt32,Mogre.FilterOptions,Mogre.FilterOptions,Mogre.FilterOptions)">
      <summary>Sets the filtering options for a given texture unit. </summary>
      <param name="unit">The texture unit to set the filtering options for </param>
      <param name="minFilter">The filter used when a texture is reduced in size </param>
      <param name="magFilter">The filter used when a texture is magnified </param>
      <param name="mipFilter">The filter used between mipmap levels, FO_NONE disables mipmapping </param>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureLayerAnisotropy(System.UInt32,System.UInt32)">
      <summary>Sets the maximal anisotropy for the specified texture unit. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureAddressingMode(System.UInt32,Mogre.TextureUnitState+UVWAddressingMode)">
      <summary>Sets the texture addressing mode for a texture unit. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureBorderColour(System.UInt32,Mogre.ColourValue)">
      <summary>Sets the texture border colour for a texture unit. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureMipmapBias(System.UInt32,System.Single)">
      <summary>Sets the mipmap bias value for a given texture unit. This allows you to adjust the mipmap calculation up or down for a given texture unit. Negative values force a larger mipmap to be used, positive values force a smaller mipmap to be used. Units are in numbers of levels, so +1 forces the mipmaps to one smaller level. Only does something if render system has capability RSC_MIPMAP_LOD_BIAS. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureMatrix(System.UInt32,Mogre.Matrix4)">
      <summary>Sets the texture coordinate transformation matrix for a texture unit. </summary>
      <param name="unit">Texture unit to affect </param>
      <param name="xform">The 4x4 matrix </param>
    </member>
    <member name="M:Mogre.RenderSystem._setSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendOperation)">
      <summary>Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setSeparateSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor)">
      <summary>Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setSeparateSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendOperation)">
      <summary>Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setSeparateSceneBlending(Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendFactor,Mogre.SceneBlendOperation,Mogre.SceneBlendOperation)">
      <summary>Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setAlphaRejectSettings(Mogre.CompareFunction,System.Byte,System.Boolean)">
      <summary>Sets the global alpha rejection approach for future renders. By default images are rendered regardless of texture alpha. This method lets you change that. </summary>
      <param name="func">The comparison function which must pass for a pixel to be written. </param>
      <param name="alphaToCoverage">Whether to enable alpha to coverage, if supported </param>
    </member>
    <member name="M:Mogre.RenderSystem._setTextureProjectionRelativeTo(System.Boolean,Mogre.Vector3)">
      <summary>Notify the rendersystem that it should adjust texture projection to be relative to a different origin. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._beginFrame">
      <summary>Signifies the beginning of a frame, i.e. the start of rendering on a single viewport. Will occur several times per complete frame if multiple viewports exist. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._endFrame">
      <summary>Ends rendering of a frame to the current viewport. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setViewport(Mogre.Viewport)">
      <summary>Sets the provided viewport as the active one for future rendering operations. This viewport is aware of it's own camera and render target. Must be implemented by subclass.</summary>
    </member>
    <member name="M:Mogre.RenderSystem._getViewport">
      <summary>Get the current active viewport for rendering. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setCullingMode(Mogre.CullingMode)">
      <summary>Sets the culling mode for the render system based on the 'vertex winding'. A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of triangles. Vertex winding refers to the direction in which the vertices are passed or indexed to in the rendering operation as viewed from the camera, and will wither be clockwise or anticlockwise (that's 'counterclockwise' for you Americans out there ;) The default is CULL_CLOCKWISE i.e. that only triangles whose vertices are passed/indexed in anticlockwise order are rendered - this is a common approach and is used in 3D studio models for example. You can alter this culling mode if you wish but it is not advised unless you know what you are doing. You may wish to use the CULL_NONE option for mesh data that you cull yourself where the vertex winding is uncertain. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferParams">
      <summary>Sets the mode of operation for depth buffer tests from this point onwards. Sometimes you may wish to alter the behaviour of the depth buffer to achieve special effects. Because it's unlikely that you'll set these options for an entire frame, but rather use them to tweak settings between rendering objects, this is an internal method (indicated by the '_' prefix) which will be used by a SceneManager implementation rather than directly from the client application. If this method is never called the settings are automatically the same as the default parameters. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferParams(System.Boolean)">
      <summary>Sets the mode of operation for depth buffer tests from this point onwards. Sometimes you may wish to alter the behaviour of the depth buffer to achieve special effects. Because it's unlikely that you'll set these options for an entire frame, but rather use them to tweak settings between rendering objects, this is an internal method (indicated by the '_' prefix) which will be used by a SceneManager implementation rather than directly from the client application. If this method is never called the settings are automatically the same as the default parameters. </summary>
      <param name="depthTest">If true, the depth buffer is tested for each pixel and the frame buffer is only updated if the depth function test succeeds. If false, no test is performed and pixels are always written. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferParams(System.Boolean,System.Boolean)">
      <summary>Sets the mode of operation for depth buffer tests from this point onwards. Sometimes you may wish to alter the behaviour of the depth buffer to achieve special effects. Because it's unlikely that you'll set these options for an entire frame, but rather use them to tweak settings between rendering objects, this is an internal method (indicated by the '_' prefix) which will be used by a SceneManager implementation rather than directly from the client application. If this method is never called the settings are automatically the same as the default parameters. </summary>
      <param name="depthTest">If true, the depth buffer is tested for each pixel and the frame buffer is only updated if the depth function test succeeds. If false, no test is performed and pixels are always written. </param>
      <param name="depthWrite">If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds. If false, the depth buffer is left unchanged even if a new pixel is written. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferParams(System.Boolean,System.Boolean,Mogre.CompareFunction)">
      <summary>Sets the mode of operation for depth buffer tests from this point onwards. Sometimes you may wish to alter the behaviour of the depth buffer to achieve special effects. Because it's unlikely that you'll set these options for an entire frame, but rather use them to tweak settings between rendering objects, this is an internal method (indicated by the '_' prefix) which will be used by a SceneManager implementation rather than directly from the client application. If this method is never called the settings are automatically the same as the default parameters. </summary>
      <param name="depthTest">If true, the depth buffer is tested for each pixel and the frame buffer is only updated if the depth function test succeeds. If false, no test is performed and pixels are always written. </param>
      <param name="depthWrite">If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds. If false, the depth buffer is left unchanged even if a new pixel is written. </param>
      <param name="depthFunction">Sets the function required for the depth test. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferCheckEnabled">
      <summary>Sets whether or not the depth buffer check is performed before a pixel write. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferCheckEnabled(System.Boolean)">
      <summary>Sets whether or not the depth buffer check is performed before a pixel write. </summary>
      <param name="enabled">If true, the depth buffer is tested for each pixel and the frame buffer is only updated if the depth function test succeeds. If false, no test is performed and pixels are always written. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferWriteEnabled">
      <summary>Sets whether or not the depth buffer is updated after a pixel write. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferWriteEnabled(System.Boolean)">
      <summary>Sets whether or not the depth buffer is updated after a pixel write. </summary>
      <param name="enabled">If true, the depth buffer is updated with the depth of the new pixel if the depth test succeeds. If false, the depth buffer is left unchanged even if a new pixel is written. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferFunction">
      <summary>Sets the comparison function for the depth buffer check. Advanced use only - allows you to choose the function applied to compare the depth values of new and existing pixels in the depth buffer. Only an issue if the deoth buffer check is enabled (see _setDepthBufferCheckEnabled) </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBufferFunction(Mogre.CompareFunction)">
      <summary>Sets the comparison function for the depth buffer check. Advanced use only - allows you to choose the function applied to compare the depth values of new and existing pixels in the depth buffer. Only an issue if the deoth buffer check is enabled (see _setDepthBufferCheckEnabled) </summary>
      <param name="func">The comparison between the new depth and the existing depth which must return true for the new pixel to be written. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setColourBufferWriteEnabled(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Sets whether or not colour buffer writing is enabled, and for which channels. For some advanced effects, you may wish to turn off the writing of certain colour channels, or even all of the colour channels so that only the depth buffer is updated in a rendering pass. However, the chances are that you really want to use this option through the Material class. </summary>
      <param name="red">Whether writing is enabled for each of the 4 colour channels. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBias(System.Single)">
      <summary>Sets the depth bias, NB you should use the Material version of this. When polygons are coplanar, you can get problems with 'depth fighting' where the pixels from the two polys compete for the same screen pixel. This is particularly a problem for decals (polys attached to another surface to represent details such as bulletholes etc.). A way to combat this problem is to use a depth bias to adjust the depth buffer value used for the decal such that it is slightly higher than the true value, ensuring that the decal appears on top. The final bias value is a combination of a constant bias and a bias proportional to the maximum depth slope of the polygon being rendered. The final bias is constantBias + slopeScaleBias * maxslope. Slope scale biasing is generally preferable but is not available on older hardware. </summary>
      <param name="constantBias">The constant bias value, expressed as a value in homogeneous depth coordinates. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setDepthBias(System.Single,System.Single)">
      <summary>Sets the depth bias, NB you should use the Material version of this. When polygons are coplanar, you can get problems with 'depth fighting' where the pixels from the two polys compete for the same screen pixel. This is particularly a problem for decals (polys attached to another surface to represent details such as bulletholes etc.). A way to combat this problem is to use a depth bias to adjust the depth buffer value used for the decal such that it is slightly higher than the true value, ensuring that the decal appears on top. The final bias value is a combination of a constant bias and a bias proportional to the maximum depth slope of the polygon being rendered. The final bias is constantBias + slopeScaleBias * maxslope. Slope scale biasing is generally preferable but is not available on older hardware. </summary>
      <param name="constantBias">The constant bias value, expressed as a value in homogeneous depth coordinates. </param>
      <param name="slopeScaleBias">The bias value which is factored by the maximum slope of the polygon, see the description above. This is not supported by all cards. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setFog">
      <summary>Sets the fogging mode for future geometry. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._setFog(Mogre.FogMode)">
      <summary>Sets the fogging mode for future geometry. </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setFog(Mogre.FogMode,Mogre.ColourValue)">
      <summary>Sets the fogging mode for future geometry. </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setFog(Mogre.FogMode,Mogre.ColourValue,System.Single)">
      <summary>Sets the fogging mode for future geometry. </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 1. i.e. completely opaque, lower values can mean that fog never completely obscures the scene. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setFog(Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single)">
      <summary>Sets the fogging mode for future geometry. </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 1. i.e. completely opaque, lower values can mean that fog never completely obscures the scene. </param>
      <param name="linearStart">Distance at which linear fog starts to encroach. The distance must be passed as a parametric value between 0 and 1, with 0 being the near clipping plane, and 1 being the far clipping plane. Only applicable if mode is FOG_LINEAR. </param>
    </member>
    <member name="M:Mogre.RenderSystem._setFog(Mogre.FogMode,Mogre.ColourValue,System.Single,System.Single,System.Single)">
      <summary>Sets the fogging mode for future geometry. </summary>
      <param name="mode">Set up the mode of fog as described in the FogMode enum, or set to FOG_NONE to turn off. </param>
      <param name="colour">The colour of the fog. Either set this to the same as your viewport background colour, or to blend in with a skydome or skybox. </param>
      <param name="expDensity">The density of the fog in FOG_EXP or FOG_EXP2 mode, as a value between 0 and 1. The default is 1. i.e. completely opaque, lower values can mean that fog never completely obscures the scene. </param>
      <param name="linearStart">Distance at which linear fog starts to encroach. The distance must be passed as a parametric value between 0 and 1, with 0 being the near clipping plane, and 1 being the far clipping plane. Only applicable if mode is FOG_LINEAR. </param>
      <param name="linearEnd">Distance at which linear fog becomes completely opaque.The distance must be passed as a parametric value between 0 and 1, with 0 being the near clipping plane, and 1 being the far clipping plane. Only applicable if mode is FOG_LINEAR. </param>
    </member>
    <member name="M:Mogre.RenderSystem._beginGeometryCount">
      <summary>The RenderSystem will keep a count of tris rendered, this resets the count. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._getFaceCount">
      <summary>Reports the number of tris rendered since the last _beginGeometryCount call. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._getBatchCount">
      <summary>Reports the number of batches rendered since the last _beginGeometryCount call. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._getVertexCount">
      <summary>Reports the number of vertices passed to the renderer since the last _beginGeometryCount call. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.ConvertColourValue(Mogre.ColourValue,System.UInt32&amp;)">
      <summary>Generates a packed data version of the passed in ColourValue suitable for use as with this RenderSystem. Since different render systems have different colour data formats (eg RGBA for GL, ARGB for D3D) this method allows you to use 1 method for all. </summary>
      <param name="colour">The colour to convert </param>
      <param name="pDest">Pointer to location to put the result. </param>
    </member>
    <member name="M:Mogre.RenderSystem._convertProjectionMatrix(Mogre.Matrix4,Mogre.Matrix4)">
      <summary>Converts a uniform projection matrix to suitable for this render system. Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._convertProjectionMatrix(Mogre.Matrix4,Mogre.Matrix4,System.Boolean)">
      <summary>Converts a uniform projection matrix to suitable for this render system. Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._makeProjectionMatrix(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Mogre.Matrix4)">
      <summary>Builds a perspective projection matrix for the case when frustum is not centered around camera. Viewport coordinates are in camera coordinate frame, i.e. camera is at the origin. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._makeProjectionMatrix(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Mogre.Matrix4,System.Boolean)">
      <summary>Builds a perspective projection matrix for the case when frustum is not centered around camera. Viewport coordinates are in camera coordinate frame, i.e. camera is at the origin. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._makeProjectionMatrix(Mogre.Radian,System.Single,System.Single,System.Single,Mogre.Matrix4)">
      <summary>Builds a perspective projection matrix suitable for this render system. Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._makeProjectionMatrix(Mogre.Radian,System.Single,System.Single,System.Single,Mogre.Matrix4,System.Boolean)">
      <summary>Builds a perspective projection matrix suitable for this render system. Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._makeOrthoMatrix(Mogre.Radian,System.Single,System.Single,System.Single,Mogre.Matrix4)">
      <summary>Builds an orthographic projection matrix suitable for this render system. Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._makeOrthoMatrix(Mogre.Radian,System.Single,System.Single,System.Single,Mogre.Matrix4,System.Boolean)">
      <summary>Builds an orthographic projection matrix suitable for this render system. Because different APIs have different requirements (some incompatible) for the projection matrix, this method allows each to implement their own correctly and pass back a generic OGRE matrix for storage in the engine. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._applyObliqueDepthProjection(Mogre.Matrix4,Mogre.Plane,System.Boolean)">
      <summary>Update a perspective projection matrix to use 'oblique depth projection'. This method can be used to change the nature of a perspective transform in order to make the near plane not perpendicular to the camera view direction, but to be at some different orientation. This can be useful for performing arbitrary clipping (e.g. to a reflection plane) which could otherwise only be done using user clip planes, which are more expensive, and not necessarily supported on all cards. </summary>
      <param name="matrix">The existing projection matrix. Note that this must be a perspective transform (not orthographic), and must not have already been altered by this method. The matrix will be altered in-place. </param>
      <param name="plane">The plane which is to be used as the clipping plane. This plane must be in CAMERA (view) space. </param>
      <param name="forGpuProgram">Is this for use with a Gpu program or fixed-function </param>
    </member>
    <member name="M:Mogre.RenderSystem._setPolygonMode(Mogre.PolygonMode)">
      <summary>Sets how to rasterise triangles, as points, wireframe or solid polys. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilCheckEnabled(System.Boolean)">
      <summary>Turns stencil buffer checking on or off. Stencilling (masking off areas of the rendering target based on the stencil buffer) can be turned on or off using this method. By default, stencilling is disabled. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams(Mogre.CompareFunction)">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
      <param name="func">The comparison function applied. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams(Mogre.CompareFunction,System.UInt32)">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
      <param name="func">The comparison function applied. </param>
      <param name="refValue">The reference value used in the comparison </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams(Mogre.CompareFunction,System.UInt32,System.UInt32)">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
      <param name="func">The comparison function applied. </param>
      <param name="refValue">The reference value used in the comparison </param>
      <param name="mask">The bitmask applied to both the stencil value and the reference value before comparison </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams(Mogre.CompareFunction,System.UInt32,System.UInt32,Mogre.StencilOperation)">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
      <param name="func">The comparison function applied. </param>
      <param name="refValue">The reference value used in the comparison </param>
      <param name="mask">The bitmask applied to both the stencil value and the reference value before comparison </param>
      <param name="stencilFailOp">The action to perform when the stencil check fails </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams(Mogre.CompareFunction,System.UInt32,System.UInt32,Mogre.StencilOperation,Mogre.StencilOperation)">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
      <param name="func">The comparison function applied. </param>
      <param name="refValue">The reference value used in the comparison </param>
      <param name="mask">The bitmask applied to both the stencil value and the reference value before comparison </param>
      <param name="stencilFailOp">The action to perform when the stencil check fails </param>
      <param name="depthFailOp">The action to perform when the stencil check passes, but the depth buffer check still fails </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams(Mogre.CompareFunction,System.UInt32,System.UInt32,Mogre.StencilOperation,Mogre.StencilOperation,Mogre.StencilOperation)">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
      <param name="func">The comparison function applied. </param>
      <param name="refValue">The reference value used in the comparison </param>
      <param name="mask">The bitmask applied to both the stencil value and the reference value before comparison </param>
      <param name="stencilFailOp">The action to perform when the stencil check fails </param>
      <param name="depthFailOp">The action to perform when the stencil check passes, but the depth buffer check still fails </param>
      <param name="passOp">The action to take when both the stencil and depth check pass. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetStencilBufferParams(Mogre.CompareFunction,System.UInt32,System.UInt32,Mogre.StencilOperation,Mogre.StencilOperation,Mogre.StencilOperation,System.Boolean)">
      <summary>This method allows you to set all the stencil buffer parameters in one call. The stencil buffer is used to mask out pixels in the render target, allowing you to do effects like mirrors, cut-outs, stencil shadows and more. Each of your batches of rendering is likely to ignore the stencil buffer, update it with new values, or apply it to mask the output of the render. The stencil test is:
		(Reference Value &amp; Mask) CompareFunction (Stencil Buffer Value &amp; Mask) The result of this will cause one of 3 actions depending on whether the test fails, succeeds but with the depth buffer check still failing, or succeeds with the depth buffer check passing too. Unlike other render states, stencilling is left for the application to turn on and off when it requires. This is because you are likely to want to change parameters between batches of arbitrary objects and control the ordering yourself. In order to batch things this way, you'll want to use OGRE's separate render queue groups (see RenderQueue) and register a RenderQueueListener to get notifications between batches. There are individual state change methods for each of the parameters set using this method. Note that the default values in this method represent the defaults at system start up too. </summary>
      <param name="func">The comparison function applied. </param>
      <param name="refValue">The reference value used in the comparison </param>
      <param name="mask">The bitmask applied to both the stencil value and the reference value before comparison </param>
      <param name="stencilFailOp">The action to perform when the stencil check fails </param>
      <param name="depthFailOp">The action to perform when the stencil check passes, but the depth buffer check still fails </param>
      <param name="passOp">The action to take when both the stencil and depth check pass. </param>
      <param name="twoSidedOperation">If set to true, then if you render both back and front faces (you'll have to turn off culling) then these parameters will apply for front faces, and the inverse of them will happen for back faces (keep remains the same). </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetVertexDeclaration(Mogre.VertexDeclaration)">
      <summary>Sets the current vertex declaration, ie the source of vertex data. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetVertexBufferBinding(Mogre.VertexBufferBinding)">
      <summary>Sets the current vertex buffer binding state. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetNormaliseNormals(System.Boolean)">
      <summary>Sets whether or not normals are to be automatically normalised. This is useful when, for example, you are scaling SceneNodes such that normals may not be unit-length anymore. Note though that this has an overhead so should not be turn on unless you really need it. You should not normally call this direct unless you are rendering world geometry; set it on the Renderable because otherwise it will be overridden by material settings. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._render(Mogre.RenderOperation)">
      <summary>Render something to the active viewport.</summary>
    </member>
    <member name="M:Mogre.RenderSystem.BindGpuProgram(Mogre.GpuProgram)">
      <summary>Binds a given GpuProgram (but not the parameters). Only one GpuProgram of each type can be bound at once, binding another one will simply replace the existing one. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.BindGpuProgramParameters(Mogre.GpuProgramType,Mogre.GpuProgramParametersSharedPtr,System.UInt16)">
      <summary>Bind Gpu program parameters. </summary>
      <param name="gptype">The type of program to bind the parameters to </param>
      <param name="params">The parameters to bind </param>
      <param name="variabilityMask">A mask of GpuParamVariability identifying which params need binding </param>
    </member>
    <member name="M:Mogre.RenderSystem.BindGpuProgramPassIterationParameters(Mogre.GpuProgramType)">
      <summary>Only binds Gpu program parameters used for passes that have more than one iteration rendering </summary>
    </member>
    <member name="M:Mogre.RenderSystem.UnbindGpuProgram(Mogre.GpuProgramType)">
      <summary>Unbinds GpuPrograms of a given GpuProgramType. This returns the pipeline to fixed-function processing for this type. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.IsGpuProgramBound(Mogre.GpuProgramType)">
      <summary>Returns whether or not a Gpu program of the given type is currently bound. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetClipPlanes(Mogre.Const_PlaneList)">
      <summary>Sets the user clipping region. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.AddClipPlane(System.Single,System.Single,System.Single,System.Single)">
      <summary>Add a user clipping plane. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.AddClipPlane(Mogre.Plane)">
      <summary>Add a user clipping plane. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.ResetClipPlanes">
      <summary>Clears the user clipping region. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._initRenderTargets">
      <summary>Utility method for initialising all render targets attached to this rendering system. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._notifyCameraRemoved(Mogre.Camera)">
      <summary>Utility method to notify all render targets that a camera has been removed, in case they were referring to it as their viewer. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._updateAllRenderTargets">
      <summary>Internal method for updating all render targets attached to this rendering system. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._updateAllRenderTargets(System.Boolean)">
      <summary>Internal method for updating all render targets attached to this rendering system. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._swapAllRenderTargetBuffers">
      <summary>Internal method for swapping all the buffers on all render targets, if _updateAllRenderTargets was called with a 'false' parameter. </summary>
    </member>
    <member name="M:Mogre.RenderSystem._swapAllRenderTargetBuffers(System.Boolean)">
      <summary>Internal method for swapping all the buffers on all render targets, if _updateAllRenderTargets was called with a 'false' parameter. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.SetScissorTest(System.Boolean)">
      <summary>Sets the 'scissor region' ie the region of the target in which rendering can take place. This method allows you to 'mask off' rendering in all but a given rectangular area as identified by the parameters to this method. Not all systems support this method. Check the RenderSystemCapabilities for the RSC_SCISSOR_TEST capability to see if it is supported. </summary>
      <param name="enabled">True to enable the scissor test, false to disable it. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetScissorTest(System.Boolean,System.UInt32)">
      <summary>Sets the 'scissor region' ie the region of the target in which rendering can take place. This method allows you to 'mask off' rendering in all but a given rectangular area as identified by the parameters to this method. Not all systems support this method. Check the RenderSystemCapabilities for the RSC_SCISSOR_TEST capability to see if it is supported. </summary>
      <param name="enabled">True to enable the scissor test, false to disable it. </param>
      <param name="left">The location of the corners of the rectangle, expressed in pixels. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetScissorTest(System.Boolean,System.UInt32,System.UInt32)">
      <summary>Sets the 'scissor region' ie the region of the target in which rendering can take place. This method allows you to 'mask off' rendering in all but a given rectangular area as identified by the parameters to this method. Not all systems support this method. Check the RenderSystemCapabilities for the RSC_SCISSOR_TEST capability to see if it is supported. </summary>
      <param name="enabled">True to enable the scissor test, false to disable it. </param>
      <param name="left">The location of the corners of the rectangle, expressed in pixels. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetScissorTest(System.Boolean,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Sets the 'scissor region' ie the region of the target in which rendering can take place. This method allows you to 'mask off' rendering in all but a given rectangular area as identified by the parameters to this method. Not all systems support this method. Check the RenderSystemCapabilities for the RSC_SCISSOR_TEST capability to see if it is supported. </summary>
      <param name="enabled">True to enable the scissor test, false to disable it. </param>
      <param name="left">The location of the corners of the rectangle, expressed in pixels. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetScissorTest(System.Boolean,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Sets the 'scissor region' ie the region of the target in which rendering can take place. This method allows you to 'mask off' rendering in all but a given rectangular area as identified by the parameters to this method. Not all systems support this method. Check the RenderSystemCapabilities for the RSC_SCISSOR_TEST capability to see if it is supported. </summary>
      <param name="enabled">True to enable the scissor test, false to disable it. </param>
      <param name="left">The location of the corners of the rectangle, expressed in pixels. </param>
    </member>
    <member name="M:Mogre.RenderSystem.ClearFrameBuffer(System.UInt32)">
      <summary>Clears one or more frame buffers on the active render target. </summary>
      <param name="buffers">Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared </param>
    </member>
    <member name="M:Mogre.RenderSystem.ClearFrameBuffer(System.UInt32,Mogre.ColourValue)">
      <summary>Clears one or more frame buffers on the active render target. </summary>
      <param name="buffers">Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared </param>
      <param name="colour">The colour to clear the colour buffer with, if enabled </param>
    </member>
    <member name="M:Mogre.RenderSystem.ClearFrameBuffer(System.UInt32,Mogre.ColourValue,System.Single)">
      <summary>Clears one or more frame buffers on the active render target. </summary>
      <param name="buffers">Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared </param>
      <param name="colour">The colour to clear the colour buffer with, if enabled </param>
      <param name="depth">The value to initialise the depth buffer with, if enabled </param>
    </member>
    <member name="M:Mogre.RenderSystem.ClearFrameBuffer(System.UInt32,Mogre.ColourValue,System.Single,System.UInt16)">
      <summary>Clears one or more frame buffers on the active render target. </summary>
      <param name="buffers">Combination of one or more elements of FrameBufferType denoting which buffers are to be cleared </param>
      <param name="colour">The colour to clear the colour buffer with, if enabled </param>
      <param name="depth">The value to initialise the depth buffer with, if enabled </param>
      <param name="stencil">The value to initialise the stencil buffer with, if enabled. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetCurrentPassIterationCount(System.UInt32)">
      <summary>set the current multi pass count value. This must be set prior to calling _render() if multiple renderings of the same pass state are required. </summary>
      <param name="count">Number of times to render the current state. </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetDeriveDepthBias(System.Boolean)">
      <summary>Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount. The depth bias set will be baseValue + iteration * multiplier </summary>
      <param name="derive">True to tell the RS to derive this automatically </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetDeriveDepthBias(System.Boolean,System.Single)">
      <summary>Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount. The depth bias set will be baseValue + iteration * multiplier </summary>
      <param name="derive">True to tell the RS to derive this automatically </param>
      <param name="baseValue">The base value to which the multiplier should be added </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetDeriveDepthBias(System.Boolean,System.Single,System.Single)">
      <summary>Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount. The depth bias set will be baseValue + iteration * multiplier </summary>
      <param name="derive">True to tell the RS to derive this automatically </param>
      <param name="baseValue">The base value to which the multiplier should be added </param>
      <param name="multiplier">The amount of depth bias to apply per iteration </param>
    </member>
    <member name="M:Mogre.RenderSystem.SetDeriveDepthBias(System.Boolean,System.Single,System.Single,System.Single)">
      <summary>Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount. The depth bias set will be baseValue + iteration * multiplier </summary>
      <param name="derive">True to tell the RS to derive this automatically </param>
      <param name="baseValue">The base value to which the multiplier should be added </param>
      <param name="multiplier">The amount of depth bias to apply per iteration </param>
      <param name="slopeScale">The constant slope scale bias for completeness </param>
    </member>
    <member name="M:Mogre.RenderSystem._setRenderTarget(Mogre.RenderTarget)">
      <summary>Set current render target to target, enabling its device context if needed </summary>
    </member>
    <member name="M:Mogre.RenderSystem.GetRenderSystemEvents">
      <summary>Gets a list of the rendersystem specific events that this rendersystem can raise. RenderSystem::addListener</summary>
    </member>
    <member name="M:Mogre.RenderSystem.PreExtraThreadsStarted">
      <summary>Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might access the rendering API are registered. Call this from your main thread before starting your other threads (which themselves should call registerThread()). Note that if you start your own threads, there is a specific startup sequence which must be respected and requires synchronisation between the threads: [Main thread]Call preExtraThreadsStarted [Main thread]Start other thread, wait [Other thread]Call registerThread, notify main thread &amp; continue [Main thread]Wake up &amp; call postExtraThreadsStarted 
Once this init sequence is completed the threads are independent but this startup sequence must be respected. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.RegisterThread">
      <summary>Register the an additional thread which may make calls to rendersystem-related objects. This method should only be called by additional threads during their initialisation. If they intend to use hardware rendering system resources they should call this method before doing anything related to the render system. Some rendering APIs require a per-thread setup and this method will sort that out. It is also necessary to call unregisterThread before the thread shuts down. This method takes no parameters - it must be called from the thread being registered and that context is enough. </summary>
    </member>
    <member name="M:Mogre.RenderSystem.UnregisterThread">
      <summary>Unregister an additional thread which may make calls to rendersystem-related objects. RenderSystem::registerThread</summary>
    </member>
    <member name="P:Mogre.RenderSystem.WBufferEnabled">
      <summary>Sets/Returns true if the renderer will try to use W-buffers when avalible. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.WaitForVerticalBlank">
      <summary>Sets/Returns true if the system is synchronising frames with the monitor vertical blank. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.VerticalTexelOffset">
      <summary>Returns the vertical texel offset value required for mapping texel origins to pixel origins in this rendersystem. Since rendersystems sometimes disagree on the origin of a texel, mapping from texels to pixels can sometimes be problematic to implement generically. This method allows you to retrieve the offset required to map the origin of a texel to the origin of a pixel in the vertical direction. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.VertexWindingInverted">
      <summary>Indicates whether or not the vertex windings set will be inverted for the current render (e.g. reflections) RenderSystem::setInvertVertexWinding</summary>
    </member>
    <member name="P:Mogre.RenderSystem.Name">
      <summary>Returns the name of the rendering system. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.MinimumDepthInputValue">
      <summary>Gets the minimum (closest) depth value to be used when rendering using identity transforms. When using identity transforms you can manually set the depth of a vertex; however the input values required differ per rendersystem. This method lets you retrieve the correct value. Renderable::getUseIdentityView, Renderable::getUseIdentityProjection</summary>
    </member>
    <member name="P:Mogre.RenderSystem.MaximumDepthInputValue">
      <summary>Gets the maximum (farthest) depth value to be used when rendering using identity transforms. When using identity transforms you can manually set the depth of a vertex; however the input values required differ per rendersystem. This method lets you retrieve the correct value. Renderable::getUseIdentityView, Renderable::getUseIdentityProjection</summary>
    </member>
    <member name="P:Mogre.RenderSystem.InvertVertexWinding">
      <summary>Sets/Gets whether or not vertex windings set should be inverted; this can be important for rendering reflections. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.HorizontalTexelOffset">
      <summary>Returns the horizontal texel offset value required for mapping texel origins to pixel origins in this rendersystem. Since rendersystems sometimes disagree on the origin of a texel, mapping from texels to pixels can sometimes be problematic to implement generically. This method allows you to retrieve the offset required to map the origin of a texel to the origin of a pixel in the horizontal direction. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.DriverVersion">
      <summary>Returns the driver version. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.DisplayMonitorCount">
      <summary>Gets the number of display monitors. Root::getDisplayMonitorCount</summary>
    </member>
    <member name="P:Mogre.RenderSystem.ColourVertexElementType">
      <summary>Get the native VertexElementType for a compact 32-bit colour value for this rendersystem. </summary>
    </member>
    <member name="P:Mogre.RenderSystem.Capabilities">
      <summary>Gets the capabilities of the render system. </summary>
    </member>
    <member name="E:Mogre.RenderSystem.EventOccurred">
      <summary>A rendersystem-specific event occurred. </summary>
    </member>
    <member name="T:Mogre.FrustumPlane">
      <summary>Worldspace clipping planes. </summary>
    </member>
    <member name="T:Mogre.ProjectionType">
      <summary>Specifies perspective (realistic) or orthographic (architectural) projection. </summary>
    </member>
    <member name="T:Mogre.OrientationMode">
      <summary>Specifies orientation mode. </summary>
    </member>
    <member name="T:Mogre.SceneBlendOperation">
      <summary>Blending operations controls how objects are blended into the scene. The default operation is add (+) but by changing this you can change how drawn objects are blended into the existing scene. </summary>
    </member>
    <member name="T:Mogre.SceneBlendFactor">
      <summary>Blending factors for manually blending objects with the scene. If there isn't a predefined SceneBlendType that you like, then you can specify the blending factors directly to affect the combination of object and the existing scene. See Material::setSceneBlending for more details. </summary>
    </member>
    <member name="T:Mogre.SceneBlendType">
      <summary>Types of blending that you can specify between an object and the existing contents of the scene. As opposed to the LayerBlendType, which classifies blends between texture layers, these blending types blend between the output of the texture units and the pixels already in the viewport, allowing for object transparency, glows, etc. These types are provided to give quick and easy access to common effects. You can also use the more manual method of supplying source and destination blending factors. See Material::setSceneBlending for more details. Material::setSceneBlending</summary>
    </member>
    <member name="F:Mogre.SceneBlendType.SBT_TRANSPARENT_ALPHA">
      <summary>Make the object transparent based on the final alpha values in the texture. </summary>
    </member>
    <member name="F:Mogre.SceneBlendType.SBT_TRANSPARENT_COLOUR">
      <summary>Make the object transparent based on the colour values in the texture (brighter = more opaque). </summary>
    </member>
    <member name="F:Mogre.SceneBlendType.SBT_ADD">
      <summary>Add the texture values to the existing scene content. </summary>
    </member>
    <member name="F:Mogre.SceneBlendType.SBT_MODULATE">
      <summary>Multiply the 2 colours together. </summary>
    </member>
    <member name="F:Mogre.SceneBlendType.SBT_REPLACE">
      <summary>The default blend mode where source replaces destination. </summary>
    </member>
    <member name="T:Mogre.LayerBlendSource">
      <summary>List of valid sources of values for blending operations used in TextureUnitState::setColourOperation and TextureUnitState::setAlphaOperation, and internally in the LayerBlendModeEx class. </summary>
    </member>
    <member name="F:Mogre.LayerBlendSource.LBS_CURRENT">
      <summary>the colour as built up from previous stages </summary>
    </member>
    <member name="F:Mogre.LayerBlendSource.LBS_TEXTURE">
      <summary>the colour derived from the texture assigned to this layer </summary>
    </member>
    <member name="F:Mogre.LayerBlendSource.LBS_DIFFUSE">
      <summary>the interpolated diffuse colour from the vertices </summary>
    </member>
    <member name="F:Mogre.LayerBlendSource.LBS_SPECULAR">
      <summary>the interpolated specular colour from the vertices </summary>
    </member>
    <member name="F:Mogre.LayerBlendSource.LBS_MANUAL">
      <summary>a colour supplied manually as a separate argument </summary>
    </member>
    <member name="T:Mogre.LayerBlendOperationEx">
      <summary>Expert list of valid texture blending operations, for use with TextureUnitState::setColourOperationEx and TextureUnitState::setAlphaOperation, and internally in the LayerBlendModeEx class. It's worth noting that these operations are for blending between texture layers and not between rendered objects and the existing scene. Because all of these modes are only supported in multitexture hardware it may be required to set up a fallback operation where this hardware is not available. </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_SOURCE1">
      <summary>use source1 without modification </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_SOURCE2">
      <summary>use source2 without modification </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_MODULATE">
      <summary>multiply source1 and source2 together </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_MODULATE_X2">
      <summary>as LBX_MODULATE but brighten afterwards (x2) </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_MODULATE_X4">
      <summary>as LBX_MODULATE but brighten more afterwards (x4) </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_ADD">
      <summary>add source1 and source2 together </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_ADD_SIGNED">
      <summary>as LBX_ADD, but subtract 0.5 from the result </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_ADD_SMOOTH">
      <summary>as LBX_ADD, but subtract product from the sum </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_SUBTRACT">
      <summary>subtract source2 from source1 </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_BLEND_DIFFUSE_ALPHA">
      <summary>use interpolated alpha value from vertices to scale source1, then add source2 scaled by (1-alpha) </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_BLEND_TEXTURE_ALPHA">
      <summary>as LBX_BLEND_DIFFUSE_ALPHA, but use alpha from texture </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_BLEND_CURRENT_ALPHA">
      <summary>as LBX_BLEND_DIFFUSE_ALPHA, but use current alpha from previous stages </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_BLEND_MANUAL">
      <summary>as LBX_BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0) </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_DOTPRODUCT">
      <summary>dot product of color1 and color2 </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperationEx.LBX_BLEND_DIFFUSE_COLOUR">
      <summary>use interpolated color values from vertices to scale source1, then add source2 scaled by (1-color) </summary>
    </member>
    <member name="T:Mogre.LayerBlendOperation">
      <summary>List of valid texture blending operations, for use with TextureUnitState::setColourOperation. This list is a more limited list than LayerBlendOperationEx because it only includes operations that are supportable in both multipass and multitexture rendering and thus provides automatic fallback if multitexture hardware is lacking or insufficient. </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperation.LBO_REPLACE">
      <summary>Replace all colour with texture with no adjustment. </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperation.LBO_ADD">
      <summary>Add colour components together. </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperation.LBO_MODULATE">
      <summary>Multiply colour components together. </summary>
    </member>
    <member name="F:Mogre.LayerBlendOperation.LBO_ALPHA_BLEND">
      <summary>Blend based on texture alpha. </summary>
    </member>
    <member name="T:Mogre.LayerBlendType">
      <summary>Type of texture blend mode. </summary>
    </member>
    <member name="T:Mogre.SceneType">
      <summary>Classification of a scene to allow a decision of what type of SceenManager to provide back to the application. </summary>
    </member>
    <member name="T:Mogre.RenderQueueGroupID">
      <summary>Enumeration of queue groups, by which the application may group queued renderables so that they are rendered together with events in between When passed into methods these are actually passed as a uint8 to allow you to use values in between if you want to. </summary>
    </member>
    <member name="F:Mogre.RenderQueueGroupID.RENDER_QUEUE_BACKGROUND">
      <summary>Use this queue for objects which must be rendered first e.g. backgrounds. </summary>
    </member>
    <member name="F:Mogre.RenderQueueGroupID.RENDER_QUEUE_SKIES_EARLY">
      <summary>First queue (after backgrounds), used for skyboxes if rendered first. </summary>
    </member>
    <member name="F:Mogre.RenderQueueGroupID.RENDER_QUEUE_MAIN">
      <summary>The default render queue. </summary>
    </member>
    <member name="F:Mogre.RenderQueueGroupID.RENDER_QUEUE_SKIES_LATE">
      <summary>Penultimate queue(before overlays), used for skyboxes if rendered last. </summary>
    </member>
    <member name="F:Mogre.RenderQueueGroupID.RENDER_QUEUE_OVERLAY">
      <summary>Use this queue for objects which must be rendered last e.g. overlays. </summary>
    </member>
    <member name="F:Mogre.RenderQueueGroupID.RENDER_QUEUE_MAX">
      <summary>Final possible render queue, don't exceed this. </summary>
    </member>
    <member name="T:Mogre.GPUVendor">
      <summary>Enumeration of GPU vendors. </summary>
    </member>
    <member name="F:Mogre.GPUVendor.GPU_VENDOR_COUNT">
      <summary>placeholder </summary>
    </member>
    <member name="T:Mogre.Capabilities">
      <summary>Enum describing the different hardware capabilities we want to check for OGRE_CAPS_VALUE(a, b) defines each capability </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_AUTOMIPMAP">
      <summary>Supports generating mipmaps in hardware. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_ANISOTROPY">
      <summary>Supports anisotropic texture filtering. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_DOT3">
      <summary>Supports fixed-function DOT3 texture blend. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_CUBEMAPPING">
      <summary>Supports cube mapping. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_HWSTENCIL">
      <summary>Supports hardware stencil buffer. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_VBO">
      <summary>Supports hardware vertex and index buffers. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_VERTEX_PROGRAM">
      <summary>Supports vertex programs (vertex shaders). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_FRAGMENT_PROGRAM">
      <summary>Supports fragment programs (pixel shaders). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_SCISSOR_TEST">
      <summary>Supports performing a scissor test to exclude areas of the screen. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_TWO_SIDED_STENCIL">
      <summary>Supports separate stencil updates for both front and back faces. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_STENCIL_WRAP">
      <summary>Supports wrapping the stencil value at the range extremeties. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_HWOCCLUSION">
      <summary>Supports hardware occlusion queries. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_USER_CLIP_PLANES">
      <summary>Supports user clipping planes. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_VERTEX_FORMAT_UBYTE4">
      <summary>Supports the VET_UBYTE4 vertex element type. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_INFINITE_FAR_PLANE">
      <summary>Supports infinite far plane projection. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_HWRENDER_TO_TEXTURE">
      <summary>Supports hardware render-to-texture (bigger than framebuffer). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_TEXTURE_FLOAT">
      <summary>Supports float textures and render targets. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_NON_POWER_OF_2_TEXTURES">
      <summary>Supports non-power of two textures. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_TEXTURE_3D">
      <summary>Supports 3d (volume) textures. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_POINT_SPRITES">
      <summary>Supports basic point sprite rendering. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_POINT_EXTENDED_PARAMETERS">
      <summary>Supports extra point parameters (minsize, maxsize, attenuation). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_VERTEX_TEXTURE_FETCH">
      <summary>Supports vertex texture fetch. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_MIPMAP_LOD_BIAS">
      <summary>Supports mipmap LOD biasing. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_GEOMETRY_PROGRAM">
      <summary>Supports hardware geometry programs. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_HWRENDER_TO_VERTEX_BUFFER">
      <summary>Supports rendering to vertex buffers. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_TEXTURE_COMPRESSION">
      <summary>Supports compressed textures. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_TEXTURE_COMPRESSION_DXT">
      <summary>Supports compressed textures in the DXT/ST3C formats. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_TEXTURE_COMPRESSION_VTC">
      <summary>Supports compressed textures in the VTC format. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_TEXTURE_COMPRESSION_PVRTC">
      <summary>Supports compressed textures in the PVRTC format. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_FIXED_FUNCTION">
      <summary>Supports fixed-function pipeline. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_MRT_DIFFERENT_BIT_DEPTHS">
      <summary>Supports MRTs with different bit depths. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_ALPHA_TO_COVERAGE">
      <summary>Supports Alpha to Coverage (A2C). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_ADVANCED_BLEND_OPERATIONS">
      <summary>Supports Blending operations other than +. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_PERSTAGECONSTANT">
      <summary>Is DirectX feature "per stage constants" supported. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_GL1_5_NOVBO">
      <summary>Supports openGL GLEW version 1.5. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_FBO">
      <summary>Support for Frame Buffer Objects (FBOs). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_FBO_ARB">
      <summary>Support for Frame Buffer Objects ARB implementation (regular FBO is higher precedence). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_FBO_ATI">
      <summary>Support for Frame Buffer Objects ATI implementation (ARB FBO is higher precedence). </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_PBUFFER">
      <summary>Support for PBuffer. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_GL1_5_NOHWOCCLUSION">
      <summary>Support for GL 1.5 but without HW occlusion workaround. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_POINT_EXTENDED_PARAMETERS_ARB">
      <summary>Support for point parameters ARB implementation. </summary>
    </member>
    <member name="F:Mogre.Capabilities.RSC_POINT_EXTENDED_PARAMETERS_EXT">
      <summary>Support for point parameters EXT implementation. </summary>
    </member>
    <member name="T:Mogre.CapabilitiesCategory">
      <summary>Enumerates the categories of capabilities. </summary>
    </member>
    <member name="F:Mogre.CapabilitiesCategory.CAPS_CATEGORY_COUNT">
      <summary>Placeholder for max value. </summary>
    </member>
    <member name="T:Mogre.TextureMipmap">
      <summary>Enum identifying special mipmap numbers </summary>
    </member>
    <member name="F:Mogre.TextureMipmap.MIP_UNLIMITED">
      <summary>Generate mipmaps up to 1x1. </summary>
    </member>
    <member name="F:Mogre.TextureMipmap.MIP_DEFAULT">
      <summary>Use TextureManager default. </summary>
    </member>
    <member name="T:Mogre.TextureType">
      <summary>Enum identifying the texture type </summary>
    </member>
    <member name="F:Mogre.TextureType.TEX_TYPE_1D">
      <summary>1D texture, used in combination with 1D texture coordinates </summary>
    </member>
    <member name="F:Mogre.TextureType.TEX_TYPE_2D">
      <summary>2D texture, used in combination with 2D texture coordinates (default) </summary>
    </member>
    <member name="F:Mogre.TextureType.TEX_TYPE_3D">
      <summary>3D volume texture, used in combination with 3D texture coordinates </summary>
    </member>
    <member name="F:Mogre.TextureType.TEX_TYPE_CUBE_MAP">
      <summary>3D cube map, used in combination with 3D texture coordinates </summary>
    </member>
    <member name="T:Mogre.TextureUsage">
      <summary>Enum identifying the texture usage </summary>
    </member>
    <member name="F:Mogre.TextureUsage.TU_STATIC">
      <summary>Enums describing buffer usage; not mutually exclusive.</summary>
    </member>
    <member name="F:Mogre.TextureUsage.TU_AUTOMIPMAP">
      <summary>mipmaps will be automatically generated for this texture </summary>
    </member>
    <member name="F:Mogre.TextureUsage.TU_RENDERTARGET">
      <summary>this texture will be a render target, i.e. used as a target for render to texture setting this flag will ignore all other texture usages except TU_AUTOMIPMAP </summary>
    </member>
    <member name="F:Mogre.TextureUsage.TU_DEFAULT">
      <summary>default to automatic mipmap generation static textures </summary>
    </member>
    <member name="T:Mogre.IlluminationStage">
      <summary>Categorisation of passes for the purpose of additive lighting. </summary>
    </member>
    <member name="F:Mogre.IlluminationStage.IS_AMBIENT">
      <summary>Part of the rendering which occurs without any kind of direct lighting. </summary>
    </member>
    <member name="F:Mogre.IlluminationStage.IS_PER_LIGHT">
      <summary>Part of the rendering which occurs per light. </summary>
    </member>
    <member name="F:Mogre.IlluminationStage.IS_DECAL">
      <summary>Post-lighting rendering. </summary>
    </member>
    <member name="F:Mogre.IlluminationStage.IS_UNKNOWN">
      <summary>Not determined. </summary>
    </member>
    <member name="T:Mogre.GpuProgramType">
      <summary>Enumerates the types of programs which can run on the GPU. </summary>
    </member>
    <member name="T:Mogre.StencilOperation">
      <summary>Enum describing the various actions which can be taken onthe stencil buffer. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_KEEP">
      <summary>Leave the stencil buffer unchanged. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_ZERO">
      <summary>Set the stencil value to zero. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_REPLACE">
      <summary>Set the stencil value to the reference value. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_INCREMENT">
      <summary>Increase the stencil value by 1, clamping at the maximum value. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_DECREMENT">
      <summary>Decrease the stencil value by 1, clamping at 0. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_INCREMENT_WRAP">
      <summary>Increase the stencil value by 1, wrapping back to 0 when incrementing the maximum value. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_DECREMENT_WRAP">
      <summary>Decrease the stencil value by 1, wrapping when decrementing 0. </summary>
    </member>
    <member name="F:Mogre.StencilOperation.SOP_INVERT">
      <summary>Invert the bits of the stencil buffer. </summary>
    </member>
    <member name="T:Mogre.TexCoordCalcMethod">
      <summary>Enum describing the ways to generate texture coordinates. </summary>
    </member>
    <member name="F:Mogre.TexCoordCalcMethod.TEXCALC_NONE">
      <summary>No calculated texture coordinates. </summary>
    </member>
    <member name="F:Mogre.TexCoordCalcMethod.TEXCALC_ENVIRONMENT_MAP">
      <summary>Environment map based on vertex normals. </summary>
    </member>
    <member name="F:Mogre.TexCoordCalcMethod.TEXCALC_ENVIRONMENT_MAP_PLANAR">
      <summary>Environment map based on vertex positions. </summary>
    </member>
    <member name="F:Mogre.TexCoordCalcMethod.TEXCALC_PROJECTIVE_TEXTURE">
      <summary>Projective texture. </summary>
    </member>
    <member name="T:Mogre.ParticleSystemRenderer">
      <summary>Abstract class defining the interface required to be implemented by classes which provide rendering capability to ParticleSystem instances. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._setMaterial(Mogre.MaterialPtr)">
      <summary>Sets the material this renderer must use; called by ParticleSystem. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyCurrentCamera(Mogre.Camera)">
      <summary>Delegated to by ParticleSystem::_notifyCurrentCamera</summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyAttached(Mogre.Node)">
      <summary>Delegated to by ParticleSystem::_notifyAttached</summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Delegated to by ParticleSystem::_notifyAttached</summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyParticleRotated">
      <summary>Optional callback notified when particles are rotated </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyParticleResized">
      <summary>Optional callback notified when particles are resized individually </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyParticleQuota(System.UInt32)">
      <summary>Tells the renderer that the particle quota has changed </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyDefaultDimensions(System.Single,System.Single)">
      <summary>Tells the renderer that the particle default size has changed </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyParticleEmitted(Mogre.Particle)">
      <summary>Optional callback notified when particle emitted </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._notifyParticleExpired(Mogre.Particle)">
      <summary>Optional callback notified when particle expired </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer.SetRenderQueueGroup(System.Byte)">
      <summary>Sets which render queue group this renderer should target with it's output. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer.SetKeepParticlesInLocalSpace(System.Boolean)">
      <summary>Setting carried over from ParticleSystem. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemRenderer._getSortMode">
      <summary>Gets the desired particles sort mode of this renderer </summary>
    </member>
    <member name="P:Mogre.ParticleSystemRenderer.Type">
      <summary>Gets the type of this renderer - must be implemented by subclasses </summary>
    </member>
    <member name="T:Mogre.BillboardParticleRenderer">
      <summary>Specialisation of ParticleSystemRenderer to render particles using a BillboardSet. This renderer has a few more options than the standard particle system, which will be passed to it automatically when the particle system itself does not understand them. </summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer.SetPointRenderingEnabled(System.Boolean)">
      <summary>Set whether or not the BillboardSet will use point rendering rather than manually generated quads. By default a billboardset is rendered by generating geometry for a textured quad in memory, taking into account the size and orientation settings, and uploading it to the video card. The alternative is to use hardware point rendering, which means that only one position needs to be sent per billboard rather than 4 and the hardware sorts out how this is rendered based on the render state. Using point rendering is faster than generating quads manually, but is more restrictive. The following restrictions apply: Only the BBT_POINT type is supported Size and appearance of each billboard is controlled by the material (Pass::setPointSize, Pass::setPointSizeAttenuation, Pass::setPointSpritesEnabled) Per-billboard size is not supported (stems from the above) Per-billboard rotation is not supported, this can only be controlled through texture unit rotation Only BBO_CENTER origin is supported Per-billboard texture coordinates are not supportedYou will almost certainly want to enable in your material pass both point attenuation and point sprites if you use this option. enabledTrue to enable point rendering, false otherwise</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._setMaterial(Mogre.MaterialPtr)">
      <summary>Sets the material this renderer must use; called by ParticleSystem.</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyCurrentCamera(Mogre.Camera)">
      <summary>Delegated to by ParticleSystem::_notifyCurrentCamera</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyParticleRotated">
      <summary>Optional callback notified when particles are rotated</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyParticleResized">
      <summary>Optional callback notified when particles are resized individually</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyParticleQuota(System.UInt32)">
      <summary>Tells the renderer that the particle quota has changed</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyAttached(Mogre.Node)">
      <summary>Delegated to by ParticleSystem::_notifyAttached</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Delegated to by ParticleSystem::_notifyAttached</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyDefaultDimensions(System.Single,System.Single)">
      <summary>Tells the renderer that the particle default size has changed</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer.SetRenderQueueGroup(System.Byte)">
      <summary>Sets which render queue group this renderer should target with it's output.</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer.SetKeepParticlesInLocalSpace(System.Boolean)">
      <summary>Setting carried over from ParticleSystem.</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._getSortMode">
      <summary>Gets the desired particles sort mode of this renderer</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._setMaterial(Mogre.MaterialPtr)">
      <summary>Sets the material this renderer must use; called by ParticleSystem.</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyCurrentCamera(Mogre.Camera)">
      <summary>Delegated to by ParticleSystem::_notifyCurrentCamera</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyAttached(Mogre.Node)">
      <summary>Delegated to by ParticleSystem::_notifyAttached</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Delegated to by ParticleSystem::_notifyAttached</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyParticleRotated">
      <summary>Optional callback notified when particles are rotated</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyParticleResized">
      <summary>Optional callback notified when particles are resized individually</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyParticleQuota(System.UInt32)">
      <summary>Tells the renderer that the particle quota has changed</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._notifyDefaultDimensions(System.Single,System.Single)">
      <summary>Tells the renderer that the particle default size has changed</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer.SetRenderQueueGroup(System.Byte)">
      <summary>Sets which render queue group this renderer should target with it's output.</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer.SetKeepParticlesInLocalSpace(System.Boolean)">
      <summary>Setting carried over from ParticleSystem.</summary>
    </member>
    <member name="M:Mogre.BillboardParticleRenderer._getSortMode">
      <summary>Gets the desired particles sort mode of this renderer</summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.UseAccurateFacing">
      <summary>Sets/Gets whether or not billboards use an 'accurate' facing model based on the vector from each billboard to the camera, rather than an optimised version using just the camera direction.</summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.Type">
      <summary>Gets the type of this renderer - must be implemented by subclasses</summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.IsPointRenderingEnabled">
      <summary>Returns whether point rendering is enabled.</summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.CommonUpVector">
      <summary>Sets/Gets the common up-vector for all billboards (BBT_PERPENDICULAR_SELF) </summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.CommonDirection">
      <summary>Sets/Gets the common direction for all billboards (BBT_ORIENTED_COMMON) </summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.BillboardType">
      <summary>Sets/Returns the billboard type in use. </summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.BillboardSet">
      <summary>Access BillboardSet in use. </summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.BillboardRotationType">
      <summary>Sets/Sets billboard rotation type. A member of the BillboardRotationType enum specifying the rotation type for all the billboards in this set. </summary>
    </member>
    <member name="P:Mogre.BillboardParticleRenderer.BillboardOrigin">
      <summary>Sets/Gets the point which acts as the origin point for all billboards in this set. A member of the BillboardOrigin enum specifying the origin for all the billboards in this set. </summary>
    </member>
    <member name="T:Mogre.Bone">
      <summary>A bone in a skeleton. See Skeleton for more information about the principles behind skeletal animation. This class is a node in the joint hierarchy. Mesh vertices also have assignments to bones to define how they move in relation to the skeleton. </summary>
    </member>
    <member name="M:Mogre.Bone.CreateChild(System.UInt16)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
      <param name="handle">The numeric handle to give the new bone; must be unique within the Skeleton. </param>
    </member>
    <member name="M:Mogre.Bone.CreateChild(System.UInt16,Mogre.Vector3)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
      <param name="handle">The numeric handle to give the new bone; must be unique within the Skeleton. </param>
      <param name="translate">Initial translation offset of child relative to parent </param>
    </member>
    <member name="M:Mogre.Bone.CreateChild(System.UInt16,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
      <param name="handle">The numeric handle to give the new bone; must be unique within the Skeleton. </param>
      <param name="translate">Initial translation offset of child relative to parent </param>
      <param name="rotate">Initial rotation relative to parent </param>
    </member>
    <member name="M:Mogre.Bone.SetBindingPose">
      <summary>Sets the current position / orientation to be the 'binding pose' ie the layout in which bones were originally bound to a mesh. </summary>
    </member>
    <member name="M:Mogre.Bone.Reset">
      <summary>Resets the position and orientation of this Bone to the original binding position. Bones are bound to the mesh in a binding pose. They are then modified from this position during animation. This method returns the bone to it's original position and orientation. </summary>
    </member>
    <member name="M:Mogre.Bone.SetManuallyControlled(System.Boolean)">
      <summary>Sets whether or not this bone is manually controlled. Manually controlled bones can be altered by the application at runtime, and their positions will not be reset by the animation routines. Note that you should also make sure that there are no AnimationTrack objects referencing this bone, or if there are, you should disable them using pAnimation-&gt;destroyTrack(pBone-&gt;getHandle()); </summary>
    </member>
    <member name="M:Mogre.Bone._getOffsetTransform(Mogre.Matrix4)">
      <summary>Gets the transform which takes bone space to current from the binding pose. Internal use only. </summary>
    </member>
    <member name="M:Mogre.Bone._getBindingPoseInverseScale">
      <summary>Gets the inverted binding pose scale. </summary>
    </member>
    <member name="M:Mogre.Bone._getBindingPoseInversePosition">
      <summary>Gets the inverted binding pose position. </summary>
    </member>
    <member name="M:Mogre.Bone._getBindingPoseInverseOrientation">
      <summary>Gets the inverted binding pose orientation. </summary>
    </member>
    <member name="M:Mogre.Bone.NeedUpdate">
      <summary>Node::needUpdate</summary>
    </member>
    <member name="M:Mogre.Bone.NeedUpdate(System.Boolean)">
      <summary>Node::needUpdate</summary>
    </member>
    <member name="M:Mogre.Bone.CreateChild(System.String)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
    </member>
    <member name="M:Mogre.Bone.CreateChild(System.String,Mogre.Vector3)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
    </member>
    <member name="M:Mogre.Bone.CreateChild(System.String,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
      <param name="rotate">Initial rotation relative to parent </param>
    </member>
    <member name="M:Mogre.Bone.CreateChild">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
    </member>
    <member name="M:Mogre.Bone.CreateChild(Mogre.Vector3)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
    </member>
    <member name="M:Mogre.Bone.CreateChild(Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates a new Bone as a child of this bone. This method creates a new bone which will inherit the transforms of this bone, with the handle specified. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
      <param name="rotate">Initial rotation relative to parent </param>
    </member>
    <member name="M:Mogre.Bone.NeedUpdate">
      <summary>Node::needUpdate</summary>
    </member>
    <member name="M:Mogre.Bone.NeedUpdate(System.Boolean)">
      <summary>Node::needUpdate</summary>
    </member>
    <member name="M:Mogre.Bone.#ctor(System.String,System.UInt16,Mogre.Skeleton)">
      <summary>Constructor, not to be used directly (use Bone::createChild or Skeleton::createBone) </summary>
    </member>
    <member name="M:Mogre.Bone.#ctor(System.UInt16,Mogre.Skeleton)">
      <summary>Constructor, not to be used directly (use Bone::createChild or Skeleton::createBone) </summary>
    </member>
    <member name="P:Mogre.Bone.IsManuallyControlled">
      <summary>Getter for mManuallyControlled Flag </summary>
    </member>
    <member name="P:Mogre.Bone.Handle">
      <summary>Gets the numeric handle for this bone (unique within the skeleton). </summary>
    </member>
    <member name="T:Mogre.OverlayElement">
      <summary>Abstract definition of a 2D element to be displayed in an Overlay. This class abstracts all the details of a 2D element which will appear in an overlay. In fact, not all OverlayElement instances can be directly added to an Overlay, only those which are OverlayContainer instances (a subclass of this class). OverlayContainer objects can contain any OverlayElement however. This is just to enforce some level of grouping on widgets. OverlayElements should be managed using OverlayManager. This class is responsible for instantiating / deleting elements, and also for accepting new types of element from plugins etc. Note that positions / dimensions of 2D screen elements are expressed as parametric values (0.0 - 1.0) because this makes them resolution-independent. However, most screen resolutions have an aspect ratio of 1.3333:1 (width : height) so note that in physical pixels 0.5 is wider than it is tall, so a 0.5x0.5 panel will not be square on the screen (but it will take up exactly half the screen in both dimensions). Because this class is designed to be extensible, it subclasses from StringInterface so its parameters can be set in a generic way. </summary>
    </member>
    <member name="M:Mogre.OverlayElement.Initialise">
      <summary>Initialise gui element </summary>
    </member>
    <member name="M:Mogre.OverlayElement.Show">
      <summary>Shows this element if it was hidden. </summary>
    </member>
    <member name="M:Mogre.OverlayElement.Hide">
      <summary>Hides this element if it was visible. </summary>
    </member>
    <member name="M:Mogre.OverlayElement.SetDimensions(System.Single,System.Single)">
      <summary>Sets the dimensions of this element in relation to the screen (1.0 = screen width/height). </summary>
    </member>
    <member name="M:Mogre.OverlayElement.SetPosition(System.Single,System.Single)">
      <summary>Sets the position of the top-left corner of the element, relative to the screen size (1.0 = screen width / height) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getLeft">
      <summary>Gets the left of this element in relation to the screen (where 0 = far left, 1.0 = far right) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getTop">
      <summary>Gets the top of this element in relation to the screen (where 0 = far left, 1.0 = far right) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getWidth">
      <summary>Gets the width of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getHeight">
      <summary>Gets the height of this element in relation to the screen (where 1.0 = screen height) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._setLeft(System.Single)">
      <summary>Sets the left of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._setTop(System.Single)">
      <summary>Sets the top of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._setWidth(System.Single)">
      <summary>Sets the width of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._setHeight(System.Single)">
      <summary>Sets the height of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._setPosition(System.Single,System.Single)">
      <summary>Sets the left and top of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="M:Mogre.OverlayElement._setDimensions(System.Single,System.Single)">
      <summary>Sets the width and height of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="M:Mogre.OverlayElement.GetMaterial">
      <summary>See Renderable</summary>
    </member>
    <member name="M:Mogre.OverlayElement.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>See Renderable</summary>
    </member>
    <member name="M:Mogre.OverlayElement._positionsOutOfDate">
      <summary>Tell the object to recalculate </summary>
    </member>
    <member name="M:Mogre.OverlayElement._update">
      <summary>Internal method to update the element based on transforms applied. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._updateFromParent">
      <summary>Updates this elements transform based on it's parent. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._notifyParent(Mogre.OverlayContainer,Mogre.Overlay)">
      <summary>Internal method for notifying the GUI element of it's parent and ultimate overlay. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getDerivedLeft">
      <summary>Gets the 'left' position as derived from own left and that of parents. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getDerivedTop">
      <summary>Gets the 'top' position as derived from own left and that of parents. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getRelativeWidth">
      <summary>Gets the 'width' as derived from own width and metrics mode. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getRelativeHeight">
      <summary>Gets the 'height' as derived from own height and metrics mode. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._getClippingRegion(Mogre.Rectangle)">
      <summary>Gets the clipping region of the element </summary>
    </member>
    <member name="M:Mogre.OverlayElement._notifyZOrder(System.UInt16)">
      <summary>Internal method to notify the element when Zorder of parent overlay has changed. Overlays have explicit Z orders. OverlayElements do not, they inherit the ZOrder of the overlay, and the Zorder is incremented for every container nested within this to ensure that containers are displayed behind contained items. This method is used internally to notify the element of a change in final zorder which is used to render the element. Return the next zordering number available. For single elements, this is simply newZOrder + 1, but for containers, they increment it once for each child (more if those children are also containers). </summary>
    </member>
    <member name="M:Mogre.OverlayElement._notifyWorldTransforms(Mogre.Matrix4)">
      <summary>Internal method to notify the element when it's world transform of parent overlay has changed. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._notifyViewport">
      <summary>Internal method to notify the element when the viewport of parent overlay has changed. </summary>
    </member>
    <member name="M:Mogre.OverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Internal method to put the contents onto the render queue. </summary>
    </member>
    <member name="M:Mogre.OverlayElement.Contains(System.Single,System.Single)">
      <summary>Returns true if xy is within the constraints of the component </summary>
    </member>
    <member name="M:Mogre.OverlayElement.FindElementAt(System.Single,System.Single)">
      <summary>Returns true if xy is within the constraints of the component </summary>
    </member>
    <member name="M:Mogre.OverlayElement.GetSquaredViewDepth(Mogre.Camera)">
      <summary>Overridden from Renderable</summary>
    </member>
    <member name="M:Mogre.OverlayElement.GetLights">
      <summary>Gets a list of lights, ordered relative to how close they are to this renderable. Directional lights, which have no position, will always be first on this list.</summary>
    </member>
    <member name="P:Mogre.OverlayElement.ZOrder">
      <summary>Returns the zOrder of the element </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Width">
      <summary>Sets/Gets the width of this element in relation to the screen (where 1.0 = screen width) </summary>
    </member>
    <member name="P:Mogre.OverlayElement.VerticalAlignment">
      <summary>Sets/Gets the vertical alignment for this element. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.TypeName">
      <summary>Gets the type name of the element. All concrete subclasses must implement this. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Top">
      <summary>Sets/Gets the top of this element in relation to the screen (where 0 = top, 1.0 = bottom) </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Parent">
      <summary>Returns the parent container. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Name">
      <summary>Gets the name of this overlay. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.MetricsMode">
      <summary>Sets/Retrieves the current settings of how the element metrics are interpreted. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.MaterialName">
      <summary>Sets/Gets the name of the material this element uses. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Left">
      <summary>Sets/Gets the left of this element in relation to the screen (where 0 = far left, 1.0 = far right) </summary>
    </member>
    <member name="P:Mogre.OverlayElement.IsVisible">
      <summary>Returns whether or not the element is visible. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.IsContainer">
      <summary>returns false as this class is not a container type </summary>
    </member>
    <member name="P:Mogre.OverlayElement.HorizontalAlignment">
      <summary>Sets/Gets the horizontal alignment for this element. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Height">
      <summary>Sets/Gets the height of this element in relation to the screen (where 1.0 = screen height) </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Colour">
      <summary>Sets/Gets the colour for this element. </summary>
    </member>
    <member name="P:Mogre.OverlayElement.Caption">
      <summary>Sets/Gets the caption for this element. </summary>
    </member>
    <member name="T:Mogre.OverlayContainer">
      <summary>A 2D element which contains other OverlayElement instances. This is a specialisation of OverlayElement for 2D elements that contain other elements. These are also the smallest elements that can be attached directly to an Overlay. OverlayContainers should be managed using OverlayManager. This class is responsible for instantiating / deleting elements, and also for accepting new types of element from plugins etc. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.AddChild(Mogre.OverlayElement)">
      <summary>Adds another OverlayElement to this container. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.AddChildImpl(Mogre.OverlayContainer)">
      <summary>Add a nested container to this container. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.AddChildImpl(Mogre.OverlayElement)">
      <summary>Adds another OverlayElement to this container. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.RemoveChild(System.String)">
      <summary>Removes a named element from this container. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.GetChild(System.String)">
      <summary>Gets the named child of this container. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.Initialise">
      <summary>Initialise gui element</summary>
    </member>
    <member name="M:Mogre.OverlayContainer.GetChildIterator">
      <summary>Gets an object for iterating over all the children of this object. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.GetChildContainerIterator">
      <summary>Gets an iterator for just the container children of this object. Good for cascading updates without having to use RTTI </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._positionsOutOfDate">
      <summary>Tell the object and its children to recalculate </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._update">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyZOrder(System.UInt16)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyViewport">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyWorldTransforms(Mogre.Matrix4)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyParent(Mogre.OverlayContainer,Mogre.Overlay)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.SetChildrenProcessEvents(System.Boolean)">
      <summary>Should this container pass events to their children </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.FindElementAt(System.Single,System.Single)">
      <summary>This returns a OverlayElement at position x,y. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.Initialise">
      <summary>Initialise gui element</summary>
    </member>
    <member name="M:Mogre.OverlayContainer._positionsOutOfDate">
      <summary>Tell the object and its children to recalculate </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._update">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyParent(Mogre.OverlayContainer,Mogre.Overlay)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyZOrder(System.UInt16)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyWorldTransforms(Mogre.Matrix4)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._notifyViewport">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="M:Mogre.OverlayContainer.FindElementAt(System.Single,System.Single)">
      <summary>This returns a OverlayElement at position x,y. </summary>
    </member>
    <member name="P:Mogre.OverlayContainer.IsContainer">
      <summary>Overridden from OverlayElement. </summary>
    </member>
    <member name="P:Mogre.OverlayContainer.IsChildrenProcessEvents">
      <summary>Should this container pass events to their children </summary>
    </member>
    <member name="T:Mogre.PanelOverlayElement">
      <summary>OverlayElement representing a flat, single-material (or transparent) panel which can contain other elements. This class subclasses OverlayContainer because it can contain other elements. Like other containers, if hidden it's contents are also hidden, if moved it's contents also move etc. The panel itself is a 2D rectangle which is either completely transparent, or is rendered with a single material. The texture(s) on the panel can be tiled depending on your requirements. This component is suitable for backgrounds and grouping other elements. Note that because it has a single repeating material it cannot have a discrete border (unless the texture has one and the texture is tiled only once). For a bordered panel, see it's subclass BorderPanelOverlayElement. Note that the material can have all the usual effects applied to it like multiple texture layers, scrolling / animated textures etc. For multiple texture layers, you have to set the tiling level for each layer. </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.Initialise">
      <summary>Initialise </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.SetTiling(System.Single,System.Single)">
      <summary>Sets the number of times textures should repeat. </summary>
      <param name="x">The number of times the texture should repeat horizontally </param>
      <param name="y">The number of times the texture should repeat vertically </param>
    </member>
    <member name="M:Mogre.PanelOverlayElement.SetTiling(System.Single,System.Single,System.UInt16)">
      <summary>Sets the number of times textures should repeat. </summary>
      <param name="x">The number of times the texture should repeat horizontally </param>
      <param name="y">The number of times the texture should repeat vertically </param>
      <param name="layer">The texture layer to specify (only needs to be altered if you're using a multi-texture layer material) </param>
    </member>
    <member name="M:Mogre.PanelOverlayElement.GetTileY">
      <summary>Gets the number of times the texture should repeat vertically. </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.GetTileY(System.UInt16)">
      <summary>Gets the number of times the texture should repeat vertically. </summary>
      <param name="layer">The texture layer to specify (only needs to be altered if you're using a multi-texture layer material) </param>
    </member>
    <member name="M:Mogre.PanelOverlayElement.SetUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the panel. </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.GetUV(System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;)">
      <summary>Get the uv coordinates for the panel </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.SetTransparent(System.Boolean)">
      <summary>Sets whether this panel is transparent (used only as a grouping level), or if it is actually rendered. </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.GetRenderOperation(Mogre.RenderOperation)">
      <summary>See Renderable. </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayContainer</summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.Initialise">
      <summary>Initialise </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayContainer</summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.Initialise">
      <summary>Initialise </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayContainer</summary>
    </member>
    <member name="M:Mogre.PanelOverlayElement.#ctor(System.String)">
      <summary>Constructor. </summary>
    </member>
    <member name="P:Mogre.PanelOverlayElement.TypeName">
      <summary>See OverlayElement. </summary>
    </member>
    <member name="P:Mogre.PanelOverlayElement.IsTransparent">
      <summary>Returns whether this panel is transparent. </summary>
    </member>
    <member name="T:Mogre.BorderPanelOverlayElement">
      <summary>A specialisation of the PanelOverlayElement to provide a panel with a border. Whilst the standard panel can use a single tiled material, this class allows panels with a tileable backdrop plus a border texture. This is handy for large panels that are too big to use a single large texture with a border, or for multiple different size panels where you want the border a constant width but the center to repeat. In addition to the usual PanelOverlayElement properties, this class has a 'border material', which specifies the material used for the edges of the panel, a border width (which can either be constant all the way around, or specified per edge), and the texture coordinates for each of the border sections. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetBorderSize(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the size of the border separately for all borders. This method sets a size all borders separately. Remember that the dimensions specified here are in relation to the size of the screen, so 0.1 is 1/10th of the screen width or height. Also note that because most screen resolutions are 1.333:1 width:height ratio that using the same border size will look slightly bigger across than up. </summary>
      <param name="left">The size of the left border as a factor of the screen dimensions ie 0.2 is one-fifth of the screen size. </param>
      <param name="right">The size of the left border as a factor of the screen dimensions. </param>
      <param name="top">The size of the top border as a factor of the screen dimensions. </param>
      <param name="bottom">The size of the bottom border as a factor of the screen dimensions. </param>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetBorderSize(System.Single,System.Single)">
      <summary>Sets the size of the border, with different sizes for vertical and horizontal borders. This method sets a size for the side and top / bottom borders separately. Remember that the dimensions specified here are in relation to the size of the screen, so 0.1 is 1/10th of the screen width or height. Also note that because most screen resolutions are 1.333:1 width:height ratio that using the same border size will look slightly bigger across than up. </summary>
      <param name="sides">The size of the side borders as a factor of the screen dimensions ie 0.2 is one-fifth of the screen size. </param>
      <param name="topAndBottom">The size of the top and bottom borders as a factor of the screen dimensions. </param>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetBorderSize(System.Single)">
      <summary>Sets the size of the border. This method sets a constant size for all borders. There are also alternative methods which allow you to set border widths for individual edges separately. Remember that the dimensions specified here are in relation to the size of the screen, so 0.1 is 1/10th of the screen width or height. Also note that because most screen resolutions are 1.333:1 width:height ratio that using the same border size will look slightly bigger across than up. </summary>
      <param name="size">The size of the border as a factor of the screen dimensions ie 0.2 is one-fifth of the screen size. </param>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetLeftBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the left edge of the border. The border panel uses 8 panels for the border (9 including the center). Imagine a table with 3 rows and 3 columns. The corners are always the same size, but the edges stretch depending on how big the panel is. Those who have done resizable HTML tables will be familiar with this approach. We only require 2 sets of uv coordinates, one for the top-left and one for the bottom-right of the panel, since it is assumed the sections are aligned on the texture. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetRightBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the right edge of the border. See setLeftBorderUV. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetTopBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the top edge of the border. See setLeftBorderUV. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetBottomBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the bottom edge of the border. See setLeftBorderUV. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetTopLeftBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the top-left corner of the border. See setLeftBorderUV. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetTopRightBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the top-right corner of the border. See setLeftBorderUV. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetBottomLeftBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the bottom-left corner of the border. See setLeftBorderUV. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.SetBottomRightBorderUV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates for the bottom-right corner of the border. See setLeftBorderUV. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayContainer</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement._update">
      <summary>Overridden from OverlayElement</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayContainer</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement._update">
      <summary>Overridden from OverlayElement</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayContainer</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement._update">
      <summary>Overridden from OverlayElement</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from OverlayContainer</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElement.#ctor(System.String)">
      <summary>Constructor </summary>
    </member>
    <member name="P:Mogre.BorderPanelOverlayElement.TopBorderSize">
      <summary>Gets the size of the top border. </summary>
    </member>
    <member name="P:Mogre.BorderPanelOverlayElement.RightBorderSize">
      <summary>Gets the size of the right border. </summary>
    </member>
    <member name="P:Mogre.BorderPanelOverlayElement.LeftBorderSize">
      <summary>Gets the size of the left border. </summary>
    </member>
    <member name="P:Mogre.BorderPanelOverlayElement.BottomBorderSize">
      <summary>Gets the size of the bottom border. </summary>
    </member>
    <member name="P:Mogre.BorderPanelOverlayElement.BorderMaterialName">
      <summary>Sets/Gets the name of the material to use for the borders. </summary>
    </member>
    <member name="T:Mogre.BorderRenderable">
      <summary>Class for rendering the border of a BorderPanelOverlayElement. We need this because we have to render twice, once with the inner panel's repeating material (handled by superclass) and once for the border's separate material. </summary>
    </member>
    <member name="M:Mogre.BorderRenderable.#ctor(Mogre.BorderPanelOverlayElement)">
      <summary>Constructed with pointers to parent. </summary>
    </member>
    <member name="T:Mogre.UserObjectBindings">
      <summary>Class that provide convenient interface to establish a linkage between custom user application objects and Ogre core classes. Any instance of Ogre class that will derive from this class could be associated with custom application object using this class interface. </summary>
    </member>
    <member name="M:Mogre.UserObjectBindings.EraseUserAny(System.String)">
      <summary>Erase the custom user object associated with this class and key from this binding. </summary>
      <param name="key">The key that the requested user object is associated with. </param>
    </member>
    <member name="M:Mogre.UserObjectBindings.Clear">
      <summary>Clear all user objects from this binding. </summary>
    </member>
    <member name="M:Mogre.UserObjectBindings.#ctor">
      <summary>Class constructor. </summary>
    </member>
    <member name="T:Mogre.GuiVerticalAlignment">
      <summary>Enum describing where '0' is in relation to the parent in the vertical dimension. Affects how 'top' is interpreted. </summary>
    </member>
    <member name="T:Mogre.GuiHorizontalAlignment">
      <summary>Enum describing where '0' is in relation to the parent in the horizontal dimension. Affects how 'left' is interpreted. </summary>
    </member>
    <member name="T:Mogre.GuiMetricsMode">
      <summary>Enum describing how the position / size of an element is to be recorded. </summary>
    </member>
    <member name="F:Mogre.GuiMetricsMode.GMM_RELATIVE">
      <summary>'left', 'top', 'height' and 'width' are parametrics from 0.0 to 1.0 </summary>
    </member>
    <member name="F:Mogre.GuiMetricsMode.GMM_PIXELS">
      <summary>Positions &amp; sizes are in absolute pixels. </summary>
    </member>
    <member name="F:Mogre.GuiMetricsMode.GMM_RELATIVE_ASPECT_ADJUSTED">
      <summary>Positions &amp; sizes are in virtual pixels. </summary>
    </member>
    <member name="T:Mogre.SceneNode">
      <summary>Class representing a node in the scene graph. A SceneNode is a type of Node which is used to organise objects in a scene. It has the same hierarchical transformation properties of the generic Node class, but also adds the ability to attach world objects to the node, and stores hierarchical bounding volumes of the nodes in the tree. Child nodes are contained within the bounds of the parent, and so on down the tree, allowing for fast culling. </summary>
    </member>
    <member name="M:Mogre.SceneNode.AttachObject(Mogre.MovableObject)">
      <summary>Adds an instance of a scene object to this node. Scene objects can include Entity objects, Camera objects, Light objects, ParticleSystem objects etc. Anything that subclasses from MovableObject. </summary>
    </member>
    <member name="M:Mogre.SceneNode.NumAttachedObjects">
      <summary>Reports the number of objects attached to this node. </summary>
    </member>
    <member name="M:Mogre.SceneNode.GetAttachedObject(System.String)">
      <summary>Retrieves a pointer to an attached object. Retrieves by object name, see alternate version to retrieve by index. </summary>
    </member>
    <member name="M:Mogre.SceneNode.GetAttachedObject(System.UInt16)">
      <summary>Retrieves a pointer to an attached object. Retrieves by index, see alternate version to retrieve by name. The index of an object may change as other objects are added / removed. </summary>
    </member>
    <member name="M:Mogre.SceneNode.DetachObject(System.String)">
      <summary>Detaches the named object from this node and returns a pointer to it. </summary>
    </member>
    <member name="M:Mogre.SceneNode.DetachObject(Mogre.MovableObject)">
      <summary>Detaches an object by pointer. </summary>
    </member>
    <member name="M:Mogre.SceneNode.DetachObject(System.UInt16)">
      <summary>Detaches the indexed object from this scene node. Detaches by index, see the alternate version to detach by name. Object indexes may change as other objects are added / removed. </summary>
    </member>
    <member name="M:Mogre.SceneNode.DetachAllObjects">
      <summary>Detaches all objects attached to this node. </summary>
    </member>
    <member name="M:Mogre.SceneNode._notifyRootNode">
      <summary>Notifies this SceneNode that it is the root scene node. Only SceneManager should call this! </summary>
    </member>
    <member name="M:Mogre.SceneNode._update(System.Boolean,System.Boolean)">
      <summary>Internal method to update the Node. Updates this scene node and any relevant children to incorporate transforms etc. Don't call this yourself unless you are writing a SceneManager implementation. </summary>
      <param name="updateChildren">If true, the update cascades down to all children. Specify false if you wish to update children separately, e.g. because of a more selective SceneManager implementation. </param>
      <param name="parentHasChanged">This flag indicates that the parent xform has changed, so the child should retrieve the parent's xform and combine it with its own even if it hasn't changed itself. </param>
    </member>
    <member name="M:Mogre.SceneNode._updateBounds">
      <summary>Tells the SceneNode to update the world bound info it stores. </summary>
    </member>
    <member name="M:Mogre.SceneNode._findVisibleObjects(Mogre.Camera,Mogre.RenderQueue,Mogre.VisibleObjectsBoundsInfo_NativePtr)">
      <summary>Internal method which locates any visible objects attached to this node and adds them to the passed in queue. Should only be called by a SceneManager implementation, and only after the _updat method has been called to ensure transforms and world bounds are up to date. SceneManager implementations can choose to let the search cascade automatically, or choose to prevent this and select nodes themselves based on some other criteria. </summary>
      <param name="cam">The active camera </param>
      <param name="queue">The SceneManager's rendering queue </param>
      <param name="visibleBounds">bounding information created on the fly containing all visible objects by the camera </param>
    </member>
    <member name="M:Mogre.SceneNode._findVisibleObjects(Mogre.Camera,Mogre.RenderQueue,Mogre.VisibleObjectsBoundsInfo_NativePtr,System.Boolean)">
      <summary>Internal method which locates any visible objects attached to this node and adds them to the passed in queue. Should only be called by a SceneManager implementation, and only after the _updat method has been called to ensure transforms and world bounds are up to date. SceneManager implementations can choose to let the search cascade automatically, or choose to prevent this and select nodes themselves based on some other criteria. </summary>
      <param name="cam">The active camera </param>
      <param name="queue">The SceneManager's rendering queue </param>
      <param name="visibleBounds">bounding information created on the fly containing all visible objects by the camera </param>
      <param name="includeChildren">If true, the call is cascaded down to all child nodes automatically. </param>
    </member>
    <member name="M:Mogre.SceneNode._findVisibleObjects(Mogre.Camera,Mogre.RenderQueue,Mogre.VisibleObjectsBoundsInfo_NativePtr,System.Boolean,System.Boolean)">
      <summary>Internal method which locates any visible objects attached to this node and adds them to the passed in queue. Should only be called by a SceneManager implementation, and only after the _updat method has been called to ensure transforms and world bounds are up to date. SceneManager implementations can choose to let the search cascade automatically, or choose to prevent this and select nodes themselves based on some other criteria. </summary>
      <param name="cam">The active camera </param>
      <param name="queue">The SceneManager's rendering queue </param>
      <param name="visibleBounds">bounding information created on the fly containing all visible objects by the camera </param>
      <param name="includeChildren">If true, the call is cascaded down to all child nodes automatically. </param>
      <param name="displayNodes">If true, the nodes themselves are rendered as a set of 3 axes as well as the objects being rendered. For debugging purposes. </param>
    </member>
    <member name="M:Mogre.SceneNode._findVisibleObjects(Mogre.Camera,Mogre.RenderQueue,Mogre.VisibleObjectsBoundsInfo_NativePtr,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Internal method which locates any visible objects attached to this node and adds them to the passed in queue. Should only be called by a SceneManager implementation, and only after the _updat method has been called to ensure transforms and world bounds are up to date. SceneManager implementations can choose to let the search cascade automatically, or choose to prevent this and select nodes themselves based on some other criteria. </summary>
      <param name="cam">The active camera </param>
      <param name="queue">The SceneManager's rendering queue </param>
      <param name="visibleBounds">bounding information created on the fly containing all visible objects by the camera </param>
      <param name="includeChildren">If true, the call is cascaded down to all child nodes automatically. </param>
      <param name="displayNodes">If true, the nodes themselves are rendered as a set of 3 axes as well as the objects being rendered. For debugging purposes. </param>
    </member>
    <member name="M:Mogre.SceneNode._getWorldAABB">
      <summary>Gets the axis-aligned bounding box of this node (and hence all subnodes). Recommended only if you are extending a SceneManager, because the bounding box returned from this method is only up to date after the SceneManager has called _update. </summary>
    </member>
    <member name="M:Mogre.SceneNode.GetAttachedObjectIterator">
      <summary>Retrieves an iterator which can be used to efficiently step through the objects attached to this node. This is a much faster way to go through all the objects attached to the node than using getAttachedObject. But the iterator returned is only valid until a change is made to the collection (ie an addition or removal) so treat the returned iterator as transient, and don't add / remove items as you go through the iterator, save changes until the end, or retrieve a new iterator after making the change. Making changes to the object returned through the iterator is OK though. </summary>
    </member>
    <member name="M:Mogre.SceneNode.RemoveAndDestroyChild(System.UInt16)">
      <summary>This method removes and destroys the child and all of its children. Unlike removeChild, which removes a single named child from this node but does not destroy it, this method destroys the child and all of it's children. Use this if you wish to recursively destroy a node as well as detaching it from it's parent. Note that any objects attached to the nodes will be detached but will not themselves be destroyed. </summary>
    </member>
    <member name="M:Mogre.SceneNode.RemoveAndDestroyChild(System.String)">
      <summary>This method removes and destroys the named child and all of its children. Unlike removeChild, which removes a single named child from this node but does not destroy it, this method destroys the child and all of it's children. Use this if you wish to recursively destroy a node as well as detaching it from it's parent. Note that any objects attached to the nodes will be detached but will not themselves be destroyed. </summary>
    </member>
    <member name="M:Mogre.SceneNode.RemoveAndDestroyAllChildren">
      <summary>Removes and destroys all children of this node. Use this to destroy all child nodes of this node and remove them from the scene graph. Note that all objects attached to this node will be detached but will not be destroyed. </summary>
    </member>
    <member name="M:Mogre.SceneNode.HideBoundingBox(System.Boolean)">
      <summary>Allows the overriding of the node's bounding box over the SceneManager's bounding box setting. Use this to override the bounding box setting of the node. </summary>
    </member>
    <member name="M:Mogre.SceneNode._addBoundingBoxToQueue(Mogre.RenderQueue)">
      <summary>Add the bounding box to the rendering queue. </summary>
    </member>
    <member name="M:Mogre.SceneNode.CreateChildSceneNode(System.String)">
      <summary>Creates a new named SceneNode as a child of this node. This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </summary>
    </member>
    <member name="M:Mogre.SceneNode.CreateChildSceneNode(System.String,Mogre.Vector3)">
      <summary>Creates a new named SceneNode as a child of this node. This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
    </member>
    <member name="M:Mogre.SceneNode.CreateChildSceneNode(System.String,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates a new named SceneNode as a child of this node. This creates a child node with a given name, which allows you to look the node up from the parent which holds this collection of nodes. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
      <param name="rotate">Initial rotation relative to parent </param>
    </member>
    <member name="M:Mogre.SceneNode.CreateChildSceneNode">
      <summary>Creates an unnamed new SceneNode as a child of this node. </summary>
    </member>
    <member name="M:Mogre.SceneNode.CreateChildSceneNode(Mogre.Vector3)">
      <summary>Creates an unnamed new SceneNode as a child of this node. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
    </member>
    <member name="M:Mogre.SceneNode.CreateChildSceneNode(Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates an unnamed new SceneNode as a child of this node. </summary>
      <param name="translate">Initial translation offset of child relative to parent </param>
      <param name="rotate">Initial rotation relative to parent </param>
    </member>
    <member name="M:Mogre.SceneNode.FindLights(Mogre.LightList,System.Single)">
      <summary>Allows retrieval of the nearest lights to the centre of this SceneNode. This method allows a list of lights, ordered by proximity to the centre of this SceneNode, to be retrieved. Can be useful when implementing MovableObject::queryLights and Renderable::getLights. Note that only lights could be affecting the frustum will take into account, which cached in scene manager. SceneManager::_getLightsAffectingFrustumSceneManager::_populateLightList</summary>
      <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population. </param>
      <param name="radius">Parameter to specify lights intersecting a given radius of this SceneNode's centre. </param>
    </member>
    <member name="M:Mogre.SceneNode.FindLights(Mogre.LightList,System.Single,System.UInt32)">
      <summary>Allows retrieval of the nearest lights to the centre of this SceneNode. This method allows a list of lights, ordered by proximity to the centre of this SceneNode, to be retrieved. Can be useful when implementing MovableObject::queryLights and Renderable::getLights. Note that only lights could be affecting the frustum will take into account, which cached in scene manager. SceneManager::_getLightsAffectingFrustumSceneManager::_populateLightList</summary>
      <param name="destList">List to be populated with ordered set of lights; will be cleared by this method before population. </param>
      <param name="radius">Parameter to specify lights intersecting a given radius of this SceneNode's centre. </param>
      <param name="lightMask">The mask with which to include / exclude lights </param>
    </member>
    <member name="M:Mogre.SceneNode.SetFixedYawAxis(System.Boolean)">
      <summary>Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice. This method allows you to change the yaw behaviour of the node - by default, it yaws around it's own local Y axis when told to yaw with TS_LOCAL, this makes it yaw around a fixed axis. You only really need this when you're using auto tracking (see setAutoTracking, because when you're manually rotating a node you can specify the TransformSpace in which you wish to work anyway. </summary>
      <param name="useFixed">If true, the axis passed in the second parameter will always be the yaw axis no matter what the node orientation. If false, the node returns to it's default behaviour. </param>
    </member>
    <member name="M:Mogre.SceneNode.SetFixedYawAxis(System.Boolean,Mogre.Vector3)">
      <summary>Tells the node whether to yaw around it's own local Y axis or a fixed axis of choice. This method allows you to change the yaw behaviour of the node - by default, it yaws around it's own local Y axis when told to yaw with TS_LOCAL, this makes it yaw around a fixed axis. You only really need this when you're using auto tracking (see setAutoTracking, because when you're manually rotating a node you can specify the TransformSpace in which you wish to work anyway. </summary>
      <param name="useFixed">If true, the axis passed in the second parameter will always be the yaw axis no matter what the node orientation. If false, the node returns to it's default behaviour. </param>
      <param name="fixedAxis">The axis to use if the first parameter is true. </param>
    </member>
    <member name="M:Mogre.SceneNode.Yaw(Mogre.Radian)">
      <summary>Rotate the node around the Y-axis. </summary>
    </member>
    <member name="M:Mogre.SceneNode.Yaw(Mogre.Radian,Mogre.Node+TransformSpace)">
      <summary>Rotate the node around the Y-axis. </summary>
    </member>
    <member name="M:Mogre.SceneNode.SetDirection(Mogre.Vector3)">
      <summary>Sets the node's direction vector ie it's local -z. Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </summary>
      <param name="vec">The direction vector </param>
    </member>
    <member name="M:Mogre.SceneNode.SetDirection(Mogre.Vector3,Mogre.Node+TransformSpace)">
      <summary>Sets the node's direction vector ie it's local -z. Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </summary>
      <param name="vec">The direction vector </param>
      <param name="relativeTo">The space in which this direction vector is expressed </param>
    </member>
    <member name="M:Mogre.SceneNode.SetDirection(Mogre.Vector3,Mogre.Node+TransformSpace,Mogre.Vector3)">
      <summary>Sets the node's direction vector ie it's local -z. Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </summary>
      <param name="vec">The direction vector </param>
      <param name="relativeTo">The space in which this direction vector is expressed </param>
      <param name="localDirectionVector">The vector which normally describes the natural direction of the node, usually -Z </param>
    </member>
    <member name="M:Mogre.SceneNode.SetDirection(System.Single,System.Single,System.Single)">
      <summary>Sets the node's direction vector ie it's local -z. Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </summary>
      <param name="x">The components of the direction vector </param>
    </member>
    <member name="M:Mogre.SceneNode.SetDirection(System.Single,System.Single,System.Single,Mogre.Node+TransformSpace)">
      <summary>Sets the node's direction vector ie it's local -z. Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </summary>
      <param name="x">The components of the direction vector </param>
      <param name="relativeTo">The space in which this direction vector is expressed </param>
    </member>
    <member name="M:Mogre.SceneNode.SetDirection(System.Single,System.Single,System.Single,Mogre.Node+TransformSpace,Mogre.Vector3)">
      <summary>Sets the node's direction vector ie it's local -z. Note that the 'up' vector for the orientation will automatically be recalculated based on the current 'up' vector (i.e. the roll will remain the same). If you need more control, use setOrientation. </summary>
      <param name="x">The components of the direction vector </param>
      <param name="relativeTo">The space in which this direction vector is expressed </param>
      <param name="localDirectionVector">The vector which normally describes the natural direction of the node, usually -Z </param>
    </member>
    <member name="M:Mogre.SceneNode.LookAt(Mogre.Vector3,Mogre.Node+TransformSpace)">
      <summary>Points the local -Z direction of this node at a point in space. </summary>
      <param name="targetPoint">A vector specifying the look at point. </param>
      <param name="relativeTo">The space in which the point resides </param>
    </member>
    <member name="M:Mogre.SceneNode.LookAt(Mogre.Vector3,Mogre.Node+TransformSpace,Mogre.Vector3)">
      <summary>Points the local -Z direction of this node at a point in space. </summary>
      <param name="targetPoint">A vector specifying the look at point. </param>
      <param name="relativeTo">The space in which the point resides </param>
      <param name="localDirectionVector">The vector which normally describes the natural direction of the node, usually -Z </param>
    </member>
    <member name="M:Mogre.SceneNode.SetAutoTracking(System.Boolean)">
      <summary>Enables / disables automatic tracking of another SceneNode. If you enable auto-tracking, this SceneNode will automatically rotate to point it's -Z at the target SceneNode every frame, no matter how it or the other SceneNode move. Note that by default the -Z points at the origin of the target SceneNode, if you want to tweak this, provide a vector in the 'offset' parameter and the target point will be adjusted. </summary>
      <param name="enabled">If true, tracking will be enabled and the next parameter cannot be null. If false tracking will be disabled and the current orientation will be maintained. </param>
    </member>
    <member name="M:Mogre.SceneNode.SetAutoTracking(System.Boolean,Mogre.SceneNode)">
      <summary>Enables / disables automatic tracking of another SceneNode. If you enable auto-tracking, this SceneNode will automatically rotate to point it's -Z at the target SceneNode every frame, no matter how it or the other SceneNode move. Note that by default the -Z points at the origin of the target SceneNode, if you want to tweak this, provide a vector in the 'offset' parameter and the target point will be adjusted. </summary>
      <param name="enabled">If true, tracking will be enabled and the next parameter cannot be null. If false tracking will be disabled and the current orientation will be maintained. </param>
      <param name="target">Pointer to the SceneNode to track. Make sure you don't delete this SceneNode before turning off tracking (e.g. SceneManager::clearScene will delete it so be careful of this). Can be null if and only if the enabled param is false. </param>
    </member>
    <member name="M:Mogre.SceneNode.SetAutoTracking(System.Boolean,Mogre.SceneNode,Mogre.Vector3)">
      <summary>Enables / disables automatic tracking of another SceneNode. If you enable auto-tracking, this SceneNode will automatically rotate to point it's -Z at the target SceneNode every frame, no matter how it or the other SceneNode move. Note that by default the -Z points at the origin of the target SceneNode, if you want to tweak this, provide a vector in the 'offset' parameter and the target point will be adjusted. </summary>
      <param name="enabled">If true, tracking will be enabled and the next parameter cannot be null. If false tracking will be disabled and the current orientation will be maintained. </param>
      <param name="target">Pointer to the SceneNode to track. Make sure you don't delete this SceneNode before turning off tracking (e.g. SceneManager::clearScene will delete it so be careful of this). Can be null if and only if the enabled param is false. </param>
      <param name="localDirectionVector">The local vector considered to be the usual 'direction' of the node; normally the local -Z but can be another direction. </param>
    </member>
    <member name="M:Mogre.SceneNode.SetAutoTracking(System.Boolean,Mogre.SceneNode,Mogre.Vector3,Mogre.Vector3)">
      <summary>Enables / disables automatic tracking of another SceneNode. If you enable auto-tracking, this SceneNode will automatically rotate to point it's -Z at the target SceneNode every frame, no matter how it or the other SceneNode move. Note that by default the -Z points at the origin of the target SceneNode, if you want to tweak this, provide a vector in the 'offset' parameter and the target point will be adjusted. </summary>
      <param name="enabled">If true, tracking will be enabled and the next parameter cannot be null. If false tracking will be disabled and the current orientation will be maintained. </param>
      <param name="target">Pointer to the SceneNode to track. Make sure you don't delete this SceneNode before turning off tracking (e.g. SceneManager::clearScene will delete it so be careful of this). Can be null if and only if the enabled param is false. </param>
      <param name="localDirectionVector">The local vector considered to be the usual 'direction' of the node; normally the local -Z but can be another direction. </param>
      <param name="offset">If supplied, this is the target point in local space of the target node instead of the origin of the target node. Good for fine tuning the look at point. </param>
    </member>
    <member name="M:Mogre.SceneNode._autoTrack">
      <summary>Internal method used by OGRE to update auto-tracking cameras. </summary>
    </member>
    <member name="M:Mogre.SceneNode.SetVisible(System.Boolean)">
      <summary>Makes all objects attached to this node become visible / invisible. This is a shortcut to calling setVisible() on the objects attached to this node, and optionally to all objects attached to child nodes. </summary>
      <param name="visible">Whether the objects are to be made visible or invisible </param>
    </member>
    <member name="M:Mogre.SceneNode.SetVisible(System.Boolean,System.Boolean)">
      <summary>Makes all objects attached to this node become visible / invisible. This is a shortcut to calling setVisible() on the objects attached to this node, and optionally to all objects attached to child nodes. </summary>
      <param name="visible">Whether the objects are to be made visible or invisible </param>
      <param name="cascade">If true, this setting cascades into child nodes too. </param>
    </member>
    <member name="M:Mogre.SceneNode.FlipVisibility">
      <summary>Inverts the visibility of all objects attached to this node. This is a shortcut to calling setVisible(!isVisible()) on the objects attached to this node, and optionally to all objects attached to child nodes. </summary>
    </member>
    <member name="M:Mogre.SceneNode.FlipVisibility(System.Boolean)">
      <summary>Inverts the visibility of all objects attached to this node. This is a shortcut to calling setVisible(!isVisible()) on the objects attached to this node, and optionally to all objects attached to child nodes. </summary>
      <param name="cascade">If true, this setting cascades into child nodes too. </param>
    </member>
    <member name="M:Mogre.SceneNode.SetDebugDisplayEnabled(System.Boolean)">
      <summary>Tells all objects attached to this node whether to display their debug information or not. This is a shortcut to calling setDebugDisplayEnabled() on the objects attached to this node, and optionally to all objects attached to child nodes. </summary>
      <param name="enabled">Whether the objects are to display debug info or not </param>
    </member>
    <member name="M:Mogre.SceneNode.SetDebugDisplayEnabled(System.Boolean,System.Boolean)">
      <summary>Tells all objects attached to this node whether to display their debug information or not. This is a shortcut to calling setDebugDisplayEnabled() on the objects attached to this node, and optionally to all objects attached to child nodes. </summary>
      <param name="enabled">Whether the objects are to display debug info or not </param>
      <param name="cascade">If true, this setting cascades into child nodes too. </param>
    </member>
    <member name="M:Mogre.SceneNode.Yaw(Mogre.Radian)">
      <summary>Rotate the node around the Y-axis. </summary>
    </member>
    <member name="M:Mogre.SceneNode.Yaw(Mogre.Radian,Mogre.Node+TransformSpace)">
      <summary>Rotate the node around the Y-axis. </summary>
    </member>
    <member name="M:Mogre.SceneNode._update(System.Boolean,System.Boolean)">
      <summary>Internal method to update the Node. Updates this scene node and any relevant children to incorporate transforms etc. Don't call this yourself unless you are writing a SceneManager implementation. </summary>
      <param name="updateChildren">If true, the update cascades down to all children. Specify false if you wish to update children separately, e.g. because of a more selective SceneManager implementation. </param>
      <param name="parentHasChanged">This flag indicates that the parent xform has changed, so the child should retrieve the parent's xform and combine it with its own even if it hasn't changed itself. </param>
    </member>
    <member name="M:Mogre.SceneNode.#ctor(Mogre.SceneManager,System.String)">
      <summary>Constructor, only to be called by the creator SceneManager. Creates a node with a specified name. </summary>
    </member>
    <member name="M:Mogre.SceneNode.#ctor(Mogre.SceneManager)">
      <summary>Constructor, only to be called by the creator SceneManager. Creates a node with a generated name. </summary>
    </member>
    <member name="P:Mogre.SceneNode.ShowBoundingBox">
      <summary>Sets/Allows the showing of the node's bounding box. Use this to show or hide the bounding box of the node. </summary>
    </member>
    <member name="P:Mogre.SceneNode.ParentSceneNode">
      <summary>Gets the parent of this SceneNode. </summary>
    </member>
    <member name="P:Mogre.SceneNode.IsInSceneGraph">
      <summary>Determines whether this node is in the scene graph, i.e. whether it's ultimate ancestor is the root scene node. </summary>
    </member>
    <member name="P:Mogre.SceneNode.Creator">
      <summary>Gets the creator of this scene node. This method returns the SceneManager which created this node. This can be useful for destroying this node. </summary>
    </member>
    <member name="P:Mogre.SceneNode.AutoTrackTarget">
      <summary>Get the auto tracking target for this node, if any. </summary>
    </member>
    <member name="P:Mogre.SceneNode.AutoTrackOffset">
      <summary>Get the auto tracking offset for this node, if the node is auto tracking. </summary>
    </member>
    <member name="P:Mogre.SceneNode.AutoTrackLocalDirection">
      <summary>Get the auto tracking local direction for this node, if it is auto tracking. </summary>
    </member>
    <member name="T:Mogre.Viewport">
      <summary>An abstraction of a viewport, i.e. a rendering region on a render target. A viewport is the meeting of a camera and a rendering surface - the camera renders the scene from a viewpoint, and places its results into some subset of a rendering target, which may be the whole surface or just a part of the surface. Each viewport has a single camera as source and a single target as destination. A camera only has 1 viewport, but a render target may have several. A viewport also has a Z-order, i.e. if there is more than one viewport on a single render target and they overlap, one must obscure the other in some predetermined way. </summary>
    </member>
    <member name="M:Mogre.Viewport._updateDimensions">
      <summary>Notifies the viewport of a possible change in dimensions. Used by the target to update the viewport's dimensions (usually the result of a change in target size). Internal use by Ogre only. </summary>
    </member>
    <member name="M:Mogre.Viewport.Update">
      <summary>Instructs the viewport to updates its contents. </summary>
    </member>
    <member name="M:Mogre.Viewport.Clear">
      <summary>Instructs the viewport to clear itself, without performing an update. You would not normally call this method when updating the viewport, since the viewport usually clears itself when updating anyway (Viewport::setClearEveryFrame). However, if you wish you have the option of manually clearing the frame buffer (or elements of it) using this method. </summary>
    </member>
    <member name="M:Mogre.Viewport.Clear(System.UInt32)">
      <summary>Instructs the viewport to clear itself, without performing an update. You would not normally call this method when updating the viewport, since the viewport usually clears itself when updating anyway (Viewport::setClearEveryFrame). However, if you wish you have the option of manually clearing the frame buffer (or elements of it) using this method. </summary>
      <param name="buffers">Bitmask identifying which buffer elements to clear </param>
    </member>
    <member name="M:Mogre.Viewport.Clear(System.UInt32,Mogre.ColourValue)">
      <summary>Instructs the viewport to clear itself, without performing an update. You would not normally call this method when updating the viewport, since the viewport usually clears itself when updating anyway (Viewport::setClearEveryFrame). However, if you wish you have the option of manually clearing the frame buffer (or elements of it) using this method. </summary>
      <param name="buffers">Bitmask identifying which buffer elements to clear </param>
      <param name="colour">The colour value to clear to, if FBT_COLOUR is included </param>
    </member>
    <member name="M:Mogre.Viewport.Clear(System.UInt32,Mogre.ColourValue,System.Single)">
      <summary>Instructs the viewport to clear itself, without performing an update. You would not normally call this method when updating the viewport, since the viewport usually clears itself when updating anyway (Viewport::setClearEveryFrame). However, if you wish you have the option of manually clearing the frame buffer (or elements of it) using this method. </summary>
      <param name="buffers">Bitmask identifying which buffer elements to clear </param>
      <param name="colour">The colour value to clear to, if FBT_COLOUR is included </param>
      <param name="depth">The depth value to clear to, if FBT_DEPTH is included </param>
    </member>
    <member name="M:Mogre.Viewport.Clear(System.UInt32,Mogre.ColourValue,System.Single,System.UInt16)">
      <summary>Instructs the viewport to clear itself, without performing an update. You would not normally call this method when updating the viewport, since the viewport usually clears itself when updating anyway (Viewport::setClearEveryFrame). However, if you wish you have the option of manually clearing the frame buffer (or elements of it) using this method. </summary>
      <param name="buffers">Bitmask identifying which buffer elements to clear </param>
      <param name="colour">The colour value to clear to, if FBT_COLOUR is included </param>
      <param name="depth">The depth value to clear to, if FBT_DEPTH is included </param>
      <param name="stencil">The stencil value to clear to, if FBT_STENCIL is included </param>
    </member>
    <member name="M:Mogre.Viewport.SetDimensions(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the dimensions (after creation). </summary>
      <param name="left" />
      <param name="top" />
      <param name="width" />
      <param name="height">Dimensions relative to the size of the target, represented as real values between 0 and 1. i.e. the full target area is 0, 0, 1, 1. </param>
    </member>
    <member name="M:Mogre.Viewport.SetOrientationMode(Mogre.OrientationMode)">
      <summary>Set the orientation mode of the viewport. </summary>
    </member>
    <member name="M:Mogre.Viewport.SetOrientationMode(Mogre.OrientationMode,System.Boolean)">
      <summary>Set the orientation mode of the viewport. </summary>
    </member>
    <member name="M:Mogre.Viewport.SetClearEveryFrame(System.Boolean)">
      <summary>Determines whether to clear the viewport before rendering. You can use this method to set which buffers are cleared (if any) before rendering every frame. </summary>
      <param name="clear">Whether or not to clear any buffers </param>
    </member>
    <member name="M:Mogre.Viewport.SetClearEveryFrame(System.Boolean,System.UInt32)">
      <summary>Determines whether to clear the viewport before rendering. You can use this method to set which buffers are cleared (if any) before rendering every frame. </summary>
      <param name="clear">Whether or not to clear any buffers </param>
      <param name="buffers">One or more values from FrameBufferType denoting which buffers to clear, if clear is set to true. Note you should not clear the stencil buffer here unless you know what you're doing. </param>
    </member>
    <member name="M:Mogre.Viewport.SetAutoUpdated(System.Boolean)">
      <summary>Sets whether this viewport should be automatically updated if Ogre's rendering loop or RenderTarget::update is being used. By default, if you use Ogre's own rendering loop (Root::startRendering) or call RenderTarget::update, all viewports are updated automatically. This method allows you to control that behaviour, if for example you have a viewport which you only want to update periodically. </summary>
      <param name="autoupdate">If true, the viewport is updated during the automatic render loop or when RenderTarget::update() is called. If false, the viewport is only updated when its update() method is called explicitly. </param>
    </member>
    <member name="M:Mogre.Viewport.GetActualDimensions(System.Int32&amp;,System.Int32&amp;,System.Int32&amp;,System.Int32&amp;)">
      <summary>Access to actual dimensions (based on target size). </summary>
    </member>
    <member name="M:Mogre.Viewport._getNumRenderedFaces">
      <summary>Gets the number of rendered faces in the last update. </summary>
    </member>
    <member name="M:Mogre.Viewport._getNumRenderedBatches">
      <summary>Gets the number of rendered batches in the last update. </summary>
    </member>
    <member name="M:Mogre.Viewport.SetVisibilityMask(System.UInt32)">
      <summary>Sets a per-viewport visibility mask. The visibility mask is a way to exclude objects from rendering for a given viewport. For each object in the frustum, a check is made between this mask and the objects visibility flags (MovableObject::setVisibilityFlags), and if a binary 'and' returns zero, the object will not be rendered. </summary>
    </member>
    <member name="M:Mogre.Viewport._getRenderQueueInvocationSequence">
      <summary>Get the invocation sequence - will return null if using standard. </summary>
    </member>
    <member name="M:Mogre.Viewport.PointOrientedToScreen(Mogre.Vector2,System.Int32,Mogre.Vector2)">
      <summary>Convert oriented input point coordinates to screen coordinates. </summary>
    </member>
    <member name="M:Mogre.Viewport.#ctor(Mogre.Camera,Mogre.RenderTarget,System.Single,System.Single,System.Single,System.Single,System.Int32)">
      <summary>The usual constructor. </summary>
      <param name="target">Pointer to the render target to be the destination for the rendering. </param>
      <param name="left" />
      <param name="top" />
      <param name="width" />
      <param name="height">Dimensions of the viewport, expressed as a value between 0 and 1. This allows the dimensions to apply irrespective of changes in the target's size: e.g. to fill the whole area, values of 0,0,1,1 are appropriate. </param>
      <param name="ZOrder">Relative Z-order on the target. Lower = further to the front. </param>
    </member>
    <member name="P:Mogre.Viewport.ZOrder">
      <summary>Gets the Z-Order of this viewport. </summary>
    </member>
    <member name="P:Mogre.Viewport.Width">
      <summary>Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0. </summary>
    </member>
    <member name="P:Mogre.Viewport.VisibilityMask">
      <summary>Gets a per-viewport visibility mask. Viewport::setVisibilityMask</summary>
    </member>
    <member name="P:Mogre.Viewport.Top">
      <summary>Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0. </summary>
    </member>
    <member name="P:Mogre.Viewport.SkiesEnabled">
      <summary>Sets/Returns whether or not skies (created in the SceneManager) are displayed in this viewport. </summary>
    </member>
    <member name="P:Mogre.Viewport.ShadowsEnabled">
      <summary>Sets/Returns whether or not shadows (defined in the SceneManager) are displayed in this viewport. </summary>
    </member>
    <member name="P:Mogre.Viewport.RenderQueueInvocationSequenceName">
      <summary>Sets/Gets the name of the render queue invocation sequence for this target. </summary>
    </member>
    <member name="P:Mogre.Viewport.OverlaysEnabled">
      <summary>Sets/Returns whether or not Overlay objects (created in the SceneManager) are displayed in this viewport. </summary>
    </member>
    <member name="P:Mogre.Viewport.OrientationMode">
      <summary>Get the orientation mode of the viewport. </summary>
    </member>
    <member name="P:Mogre.Viewport.MaterialScheme">
      <summary>Sets/Get the material scheme which the viewport should use. </summary>
    </member>
    <member name="P:Mogre.Viewport.Left">
      <summary>Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0. </summary>
    </member>
    <member name="P:Mogre.Viewport.IsAutoUpdated">
      <summary>Gets whether this viewport is automatically updated if Ogre's rendering loop or RenderTarget::update is being used. </summary>
    </member>
    <member name="P:Mogre.Viewport.Height">
      <summary>Gets one of the relative dimensions of the viewport, a value between 0.0 and 1.0. </summary>
    </member>
    <member name="P:Mogre.Viewport.DefaultOrientationMode">
      <summary>Sets/Get the initial orientation mode of viewports. </summary>
    </member>
    <member name="P:Mogre.Viewport.ClearEveryFrame">
      <summary>Determines if the viewport is cleared before every frame. </summary>
    </member>
    <member name="P:Mogre.Viewport.ClearBuffers">
      <summary>Gets which buffers are to be cleared each frame. </summary>
    </member>
    <member name="P:Mogre.Viewport.Camera">
      <summary>Sets/Retrieves a pointer to the camera for this viewport. </summary>
    </member>
    <member name="P:Mogre.Viewport.BackgroundColour">
      <summary>Sets/Gets the background colour. </summary>
    </member>
    <member name="P:Mogre.Viewport.ActualWidth">
      <summary>Gets one of the actual dimensions of the viewport, a value in pixels. </summary>
    </member>
    <member name="P:Mogre.Viewport.ActualTop">
      <summary>Gets one of the actual dimensions of the viewport, a value in pixels. </summary>
    </member>
    <member name="P:Mogre.Viewport.ActualLeft">
      <summary>Gets one of the actual dimensions of the viewport, a value in pixels. </summary>
    </member>
    <member name="P:Mogre.Viewport.ActualHeight">
      <summary>Gets one of the actual dimensions of the viewport, a value in pixels. </summary>
    </member>
    <member name="T:Mogre.Codec">
      <summary>Abstract class that defines a 'codec'. A codec class works like a two-way filter for data - data entered on one end (the decode end) gets processed and transformed into easily usable data while data passed the other way around codes it back. The codec concept is a pretty generic one - you can easily understand how it can be used for images, sounds, archives, even compressed data. </summary>
    </member>
    <member name="M:Mogre.Codec.Code(Mogre.MemoryDataStreamPtr,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input stream and saves the result in the output stream. </summary>
    </member>
    <member name="M:Mogre.Codec.CodeToFile(Mogre.MemoryDataStreamPtr,System.String,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input chunk and saves the result in the output filename provided. Provided for efficiency since coding to memory is progressive therefore memory required is unknown leading to reallocations. </summary>
      <param name="input">The input data </param>
      <param name="outFileName">The filename to write to </param>
      <param name="pData">Extra information to be passed to the codec (codec type specific) </param>
    </member>
    <member name="M:Mogre.Codec.Decode(Mogre.DataStreamPtr)">
      <summary>Codes the data from the input chunk into the output chunk. Has a variable number of arguments, which depend on the codec type. </summary>
      <param name="input">Stream containing the encoded data </param>
    </member>
    <member name="M:Mogre.Codec.MagicNumberMatch(System.SByte*,System.UInt32)">
      <summary>Returns whether a magic number header matches this codec. </summary>
      <param name="magicNumberPtr">Pointer to a stream of bytes which should identify the file. Note that this may be more than needed - each codec may be looking for a different size magic number. </param>
      <param name="maxbytes">The number of bytes passed </param>
    </member>
    <member name="M:Mogre.Codec.MagicNumberToFileExt(System.SByte*,System.UInt32)">
      <summary>Maps a magic number header to a file extension, if this codec recognises it. A blank string if the magic number was unknown, or a file extension. </summary>
      <param name="magicNumberPtr">Pointer to a stream of bytes which should identify the file. Note that this may be more than needed - each codec may be looking for a different size magic number. </param>
      <param name="maxbytes">The number of bytes passed </param>
    </member>
    <member name="M:Mogre.Codec.RegisterCodec(Mogre.Codec)">
      <summary>Registers a new codec in the database. </summary>
    </member>
    <member name="M:Mogre.Codec.IsCodecRegistered(System.String)">
      <summary>Return whether a codec is registered already. </summary>
    </member>
    <member name="M:Mogre.Codec.UnRegisterCodec(Mogre.Codec)">
      <summary>Unregisters a codec from the database. </summary>
    </member>
    <member name="M:Mogre.Codec.GetCodecIterator">
      <summary>Gets the iterator for the registered codecs. </summary>
    </member>
    <member name="M:Mogre.Codec.GetExtensions">
      <summary>Gets the file extension list for the registered codecs. </summary>
    </member>
    <member name="M:Mogre.Codec.GetCodec(System.SByte&amp;,System.UInt32)">
      <summary>Gets the codec that can handle the given 'magic' identifier. </summary>
      <param name="magicNumberPtr">Pointer to a stream of bytes which should identify the file. Note that this may be more than needed - each codec may be looking for a different size magic number. </param>
      <param name="maxbytes">The number of bytes passed </param>
    </member>
    <member name="M:Mogre.Codec.GetCodec(System.String)">
      <summary>Gets the codec registered for the passed in file extension. </summary>
    </member>
    <member name="P:Mogre.Codec.Type">
      <summary>Returns the type of the codec as a String </summary>
    </member>
    <member name="P:Mogre.Codec.DataType">
      <summary>Returns the type of the data that supported by this codec as a String </summary>
    </member>
    <member name="T:Mogre.RenderTargetViewportEvent_NativePtr">
      <summary>Struct containing information about a RenderTarget Viewport-specific event. </summary>
    </member>
    <member name="P:Mogre.RenderTargetViewportEvent_NativePtr.source">
      <summary>The source of the event being raised. </summary>
    </member>
    <member name="T:Mogre.RenderTargetEvent_NativePtr">
      <summary>Struct containing information about a RenderTarget event. </summary>
    </member>
    <member name="P:Mogre.RenderTargetEvent_NativePtr.source">
      <summary>The source of the event being raised. </summary>
    </member>
    <member name="T:Mogre.RenderTargetListener">
      <summary>A interface class defining a listener which can be used to receive notifications of RenderTarget events. A 'listener' is an interface designed to be called back when particular events are called. This class defines the interface relating to RenderTarget events. In order to receive notifications of RenderTarget events, you should create a subclass of RenderTargetListener and override the methods for which you would like to customise the resulting processing. You should then call RenderTarget::addListener passing an instance of this class. There is no limit to the number of RenderTarget listeners you can register, allowing you to register multiple listeners for different purposes.  RenderTarget events occur before and after the target is updated as a whole, and before and after each viewport on that target is updated. Each RenderTarget holds it's own set of listeners, but you can register the same listener on multiple render targets if you like since the event contains details of the originating RenderTarget. </summary>
    </member>
    <member name="T:Mogre.RenderTarget">
      <summary>A 'canvas' which can receive the results of a rendering operation. This abstract class defines a common root to all targets of rendering operations. A render target could be a window on a screen, or another offscreen surface like a texture or bump map etc. Steven Streeting 1.0 </summary>
    </member>
    <member name="M:Mogre.RenderTarget.GetCustomAttribute(System.String,System.Void*)">
      <summary>Gets a custom (maybe platform-specific) attribute. This is a nasty way of satisfying any API's need to see platform-specific details. It horrid, but D3D needs this kind of info. At least it's abstracted. </summary>
      <param name="name">The name of the attribute. </param>
      <param name="pData">Pointer to memory of the right kind of structure to receive the info. </param>
    </member>
    <member name="M:Mogre.RenderTarget.GetCustomAttribute(System.String,System.IntPtr&amp;)">
      <summary>Gets a custom (maybe platform-specific) attribute. This is a nasty way of satisfying any API's need to see platform-specific details. It horrid, but D3D needs this kind of info. At least it's abstracted. </summary>
      <param name="name">The name of the attribute. </param>
    </member>
    <member name="M:Mogre.RenderTarget.GetCustomAttribute(System.String,System.Int32&amp;)">
      <summary>Gets a custom (maybe platform-specific) attribute. This is a nasty way of satisfying any API's need to see platform-specific details. It horrid, but D3D needs this kind of info. At least it's abstracted. </summary>
      <param name="name">The name of the attribute. </param>
    </member>
    <member name="M:Mogre.RenderTarget.GetCustomAttribute(System.String,System.Boolean&amp;)">
      <summary>Gets a custom (maybe platform-specific) attribute. This is a nasty way of satisfying any API's need to see platform-specific details. It horrid, but D3D needs this kind of info. At least it's abstracted. </summary>
      <param name="name">The name of the attribute. </param>
    </member>
    <member name="M:Mogre.RenderTarget.GetMetrics(System.UInt32&amp;,System.UInt32&amp;,System.UInt32&amp;)">
      <summary>Retrieve information about the render target. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.Update">
      <summary>Tells the target to update it's contents. If OGRE is not running in an automatic rendering loop (started using Root::startRendering), the user of the library is responsible for asking each render target to refresh. This is the method used to do this. It automatically re-renders the contents of the target using whatever cameras have been pointed at it (using Camera::setRenderTarget). This allows OGRE to be used in multi-windowed utilities and for contents to be refreshed only when required, rather than constantly as with the automatic rendering loop. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.Update(System.Boolean)">
      <summary>Tells the target to update it's contents. If OGRE is not running in an automatic rendering loop (started using Root::startRendering), the user of the library is responsible for asking each render target to refresh. This is the method used to do this. It automatically re-renders the contents of the target using whatever cameras have been pointed at it (using Camera::setRenderTarget). This allows OGRE to be used in multi-windowed utilities and for contents to be refreshed only when required, rather than constantly as with the automatic rendering loop. </summary>
      <param name="swapBuffers">For targets that support double-buffering, if set to true, the target will immediately swap it's buffers after update. Otherwise, the buffers are not swapped, and you have to call swapBuffers yourself sometime later. You might want to do this on some rendersystems which pause for queued rendering commands to complete before accepting swap buffers calls - so you could do other CPU tasks whilst the queued commands complete. Or, you might do this if you want custom control over your windows, such as for externally created windows. </param>
    </member>
    <member name="M:Mogre.RenderTarget.SwapBuffers">
      <summary>Swaps the frame buffers to display the next frame. For targets that are double-buffered so that no 'in-progress' versions of the scene are displayed during rendering. Once rendering has completed (to an off-screen version of the window) the buffers are swapped to display the new frame.</summary>
    </member>
    <member name="M:Mogre.RenderTarget.SwapBuffers(System.Boolean)">
      <summary>Swaps the frame buffers to display the next frame. For targets that are double-buffered so that no 'in-progress' versions of the scene are displayed during rendering. Once rendering has completed (to an off-screen version of the window) the buffers are swapped to display the new frame.</summary>
      <param name="waitForVSync">If true, the system waits for the next vertical blank period (when the CRT beam turns off as it travels from bottom-right to top-left at the end of the pass) before flipping. If false, flipping occurs no matter what the beam position. Waiting for a vertical blank can be slower (and limits the framerate to the monitor refresh rate) but results in a steadier image with no 'tearing' (a flicker resulting from flipping buffers when the beam is in the progress of drawing the last frame). </param>
    </member>
    <member name="M:Mogre.RenderTarget.AddViewport(Mogre.Camera)">
      <summary>Adds a viewport to the rendering target. A viewport is the rectangle into which rendering output is sent. This method adds a viewport to the render target, rendering from the supplied camera. The rest of the parameters are only required if you wish to add more than one viewport to a single rendering target. Note that size information passed to this method is passed as a parametric, i.e. it is relative rather than absolute. This is to allow viewports to automatically resize along with the target. </summary>
      <param name="cam">The camera from which the viewport contents will be rendered (mandatory) </param>
    </member>
    <member name="M:Mogre.RenderTarget.AddViewport(Mogre.Camera,System.Int32)">
      <summary>Adds a viewport to the rendering target. A viewport is the rectangle into which rendering output is sent. This method adds a viewport to the render target, rendering from the supplied camera. The rest of the parameters are only required if you wish to add more than one viewport to a single rendering target. Note that size information passed to this method is passed as a parametric, i.e. it is relative rather than absolute. This is to allow viewports to automatically resize along with the target. </summary>
      <param name="cam">The camera from which the viewport contents will be rendered (mandatory) </param>
      <param name="ZOrder">The relative order of the viewport with others on the target (allows overlapping viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering) </param>
    </member>
    <member name="M:Mogre.RenderTarget.AddViewport(Mogre.Camera,System.Int32,System.Single)">
      <summary>Adds a viewport to the rendering target. A viewport is the rectangle into which rendering output is sent. This method adds a viewport to the render target, rendering from the supplied camera. The rest of the parameters are only required if you wish to add more than one viewport to a single rendering target. Note that size information passed to this method is passed as a parametric, i.e. it is relative rather than absolute. This is to allow viewports to automatically resize along with the target. </summary>
      <param name="cam">The camera from which the viewport contents will be rendered (mandatory) </param>
      <param name="ZOrder">The relative order of the viewport with others on the target (allows overlapping viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering) </param>
      <param name="left">The relative position of the left of the viewport on the target, as a value between 0 and 1. </param>
    </member>
    <member name="M:Mogre.RenderTarget.AddViewport(Mogre.Camera,System.Int32,System.Single,System.Single)">
      <summary>Adds a viewport to the rendering target. A viewport is the rectangle into which rendering output is sent. This method adds a viewport to the render target, rendering from the supplied camera. The rest of the parameters are only required if you wish to add more than one viewport to a single rendering target. Note that size information passed to this method is passed as a parametric, i.e. it is relative rather than absolute. This is to allow viewports to automatically resize along with the target. </summary>
      <param name="cam">The camera from which the viewport contents will be rendered (mandatory) </param>
      <param name="ZOrder">The relative order of the viewport with others on the target (allows overlapping viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering) </param>
      <param name="left">The relative position of the left of the viewport on the target, as a value between 0 and 1. </param>
      <param name="top">The relative position of the top of the viewport on the target, as a value between 0 and 1. </param>
    </member>
    <member name="M:Mogre.RenderTarget.AddViewport(Mogre.Camera,System.Int32,System.Single,System.Single,System.Single)">
      <summary>Adds a viewport to the rendering target. A viewport is the rectangle into which rendering output is sent. This method adds a viewport to the render target, rendering from the supplied camera. The rest of the parameters are only required if you wish to add more than one viewport to a single rendering target. Note that size information passed to this method is passed as a parametric, i.e. it is relative rather than absolute. This is to allow viewports to automatically resize along with the target. </summary>
      <param name="cam">The camera from which the viewport contents will be rendered (mandatory) </param>
      <param name="ZOrder">The relative order of the viewport with others on the target (allows overlapping viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering) </param>
      <param name="left">The relative position of the left of the viewport on the target, as a value between 0 and 1. </param>
      <param name="top">The relative position of the top of the viewport on the target, as a value between 0 and 1. </param>
      <param name="width">The relative width of the viewport on the target, as a value between 0 and 1. </param>
    </member>
    <member name="M:Mogre.RenderTarget.AddViewport(Mogre.Camera,System.Int32,System.Single,System.Single,System.Single,System.Single)">
      <summary>Adds a viewport to the rendering target. A viewport is the rectangle into which rendering output is sent. This method adds a viewport to the render target, rendering from the supplied camera. The rest of the parameters are only required if you wish to add more than one viewport to a single rendering target. Note that size information passed to this method is passed as a parametric, i.e. it is relative rather than absolute. This is to allow viewports to automatically resize along with the target. </summary>
      <param name="cam">The camera from which the viewport contents will be rendered (mandatory) </param>
      <param name="ZOrder">The relative order of the viewport with others on the target (allows overlapping viewports i.e. picture-in-picture). Higher ZOrders are on top of lower ones. The actual number is irrelevant, only the relative ZOrder matters (you can leave gaps in the numbering) </param>
      <param name="left">The relative position of the left of the viewport on the target, as a value between 0 and 1. </param>
      <param name="top">The relative position of the top of the viewport on the target, as a value between 0 and 1. </param>
      <param name="width">The relative width of the viewport on the target, as a value between 0 and 1. </param>
      <param name="height">The relative height of the viewport on the target, as a value between 0 and 1. </param>
    </member>
    <member name="M:Mogre.RenderTarget.GetViewport(System.UInt16)">
      <summary>Retrieves a pointer to the viewport with the given index. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.RemoveViewport(System.Int32)">
      <summary>Removes a viewport at a given ZOrder. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.RemoveAllViewports">
      <summary>Removes all viewports on this target. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.GetStatistics">
      <summary>Retieves details of current rendering performance. If the user application wishes to do it's own performance display, or use performance for some other means, this method allows it to retrieve the statistics. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.GetStatistics(System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;)">
      <summary>Retieves details of current rendering performance. If the user application wishes to do it's own performance display, or use performance for some other means, this method allows it to retrieve the statistics. </summary>
      <param name="lastFPS">Pointer to a float to receive the number of frames per second (FPS) based on the last frame rendered. </param>
      <param name="avgFPS">Pointer to a float to receive the FPS rating based on an average of all the frames rendered since rendering began (the call to Root::startRendering). </param>
      <param name="bestFPS">Pointer to a float to receive the best FPS rating that has been achieved since rendering began. </param>
      <param name="worstFPS">Pointer to a float to receive the worst FPS rating seen so far. </param>
    </member>
    <member name="M:Mogre.RenderTarget.ResetStatistics">
      <summary>Resets saved frame-rate statistices. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.RemoveAllListeners">
      <summary>Removes all listeners from this instance. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.CopyContentsToMemory(Mogre.PixelBox)">
      <summary>Copies the current contents of the render target to a pixelbox. See suggestPixelFormat for a tip as to the best pixel format to extract into, although you can use whatever format you like and the results will be converted. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.CopyContentsToMemory(Mogre.PixelBox,Mogre.RenderTarget+FrameBuffer)">
      <summary>Copies the current contents of the render target to a pixelbox. See suggestPixelFormat for a tip as to the best pixel format to extract into, although you can use whatever format you like and the results will be converted. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.SuggestPixelFormat">
      <summary>Suggests a pixel format to use for extracting the data in this target, when calling copyContentsToMemory. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.WriteContentsToFile(System.String)">
      <summary>Writes the current contents of the render target to the named file. </summary>
    </member>
    <member name="M:Mogre.RenderTarget.WriteContentsToTimestampedFile(System.String,System.String)">
      <summary>Writes the current contents of the render target to the (PREFIX)(time-stamp)(SUFFIX) file. the name of the file used. </summary>
    </member>
    <member name="M:Mogre.RenderTarget._notifyCameraRemoved(Mogre.Camera)">
      <summary>Utility method to notify a render target that a camera has been removed, incase it was referring to it as a viewer. </summary>
    </member>
    <member name="M:Mogre.RenderTarget._beginUpdate">
      <summary>Method for manual management of rendering : fires 'preRenderTargetUpdate' and initialises statistics etc. _beginUpdate resets statistics and fires 'preRenderTargetUpdate'. _updateViewport renders the given viewport (even if it is not autoupdated), fires preViewportUpdate and postViewportUpdate and manages statistics. _updateAutoUpdatedViewports renders only viewports that are auto updated, fires preViewportUpdate and postViewportUpdate and manages statistics. _endUpdate() ends statistics calculation and fires postRenderTargetUpdate. 
you can use it like this for example : 
			renderTarget-&gt;_beginUpdate();
			renderTarget-&gt;_updateViewport(1); // which is not auto updated
			renderTarget-&gt;_updateViewport(2); // which is not auto updated
			renderTarget-&gt;_updateAutoUpdatedViewports();
			renderTarget-&gt;_endUpdate();
			renderTarget-&gt;swapBuffers(true);
		 Please note that in that case, the zorder may not work as you expect, since you are responsible for calling _updateViewport in the correct order. </summary>
    </member>
    <member name="M:Mogre.RenderTarget._updateViewport(Mogre.Viewport)">
      <summary>Method for manual management of rendering - renders the given viewport (even if it is not autoupdated) This also fires preViewportUpdate and postViewportUpdate, and manages statistics if needed. You should call it between _beginUpdate() and _endUpdate(). _beginUpdate for more details. </summary>
      <param name="viewport">The viewport you want to update, it must be bound to the rendertarget. </param>
    </member>
    <member name="M:Mogre.RenderTarget._updateViewport(Mogre.Viewport,System.Boolean)">
      <summary>Method for manual management of rendering - renders the given viewport (even if it is not autoupdated) This also fires preViewportUpdate and postViewportUpdate, and manages statistics if needed. You should call it between _beginUpdate() and _endUpdate(). _beginUpdate for more details. </summary>
      <param name="viewport">The viewport you want to update, it must be bound to the rendertarget. </param>
      <param name="updateStatistics">Whether you want to update statistics or not. </param>
    </member>
    <member name="M:Mogre.RenderTarget._updateViewport(System.Int32)">
      <summary>Method for manual management of rendering - renders the given viewport (even if it is not autoupdated) This also fires preViewportUpdate and postViewportUpdate, and manages statistics. You should call it between _beginUpdate() and _endUpdate(). _beginUpdate for more details. </summary>
      <param name="zorder">The zorder of the viewport to update. </param>
    </member>
    <member name="M:Mogre.RenderTarget._updateViewport(System.Int32,System.Boolean)">
      <summary>Method for manual management of rendering - renders the given viewport (even if it is not autoupdated) This also fires preViewportUpdate and postViewportUpdate, and manages statistics. You should call it between _beginUpdate() and _endUpdate(). _beginUpdate for more details. </summary>
      <param name="zorder">The zorder of the viewport to update. </param>
      <param name="updateStatistics">Whether you want to update statistics or not. </param>
    </member>
    <member name="M:Mogre.RenderTarget._updateAutoUpdatedViewports">
      <summary>Method for manual management of rendering - renders only viewports that are auto updated This also fires preViewportUpdate and postViewportUpdate, and manages statistics. You should call it between _beginUpdate() and _endUpdate(). See _beginUpdate for more details. _beginUpdate()</summary>
    </member>
    <member name="M:Mogre.RenderTarget._updateAutoUpdatedViewports(System.Boolean)">
      <summary>Method for manual management of rendering - renders only viewports that are auto updated This also fires preViewportUpdate and postViewportUpdate, and manages statistics. You should call it between _beginUpdate() and _endUpdate(). See _beginUpdate for more details. _beginUpdate()</summary>
      <param name="updateStatistics">Whether you want to update statistics or not. </param>
    </member>
    <member name="M:Mogre.RenderTarget._endUpdate">
      <summary>Method for manual management of rendering - finishes statistics calculation and fires 'postRenderTargetUpdate'. You should call it after a _beginUpdate _beginUpdate for more details. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.WorstFrameTime">
      <summary>Individual stats access - gets the worst frame time </summary>
    </member>
    <member name="P:Mogre.RenderTarget.WorstFPS">
      <summary>Individual stats access - gets the worst frames per second (FPS) since call to Root::startRendering. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.TriangleCount">
      <summary>Gets the number of triangles rendered in the last update() call. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.Priority">
      <summary>Sets/Gets the priority of a render target. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.NumViewports">
      <summary>Returns the number of viewports attached to this target. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.Name">
      <summary>Retrieve target's name. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.LastFPS">
      <summary>Individual stats access - gets the number of frames per second (FPS) based on the last frame rendered. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.IsPrimary">
      <summary>Indicates whether this target is the primary window. The primary window is special in that it is destroyed when ogre is shut down, and cannot be destroyed directly. This is the case because it holds the context for vertex, index buffers and textures. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.IsHardwareGammaEnabled">
      <summary>Indicates whether on rendering, linear colour space is converted to sRGB gamma colour space. This is the exact opposite conversion of what is indicated by Texture::isHardwareGammaEnabled, and can only be enabled on creation of the render target. For render windows, it's enabled through the 'gamma' creation misc parameter. For textures, it is enabled through the hwGamma parameter to the create call. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.IsAutoUpdated">
      <summary>Sets/Gets whether this target is automatically updated if Ogre's rendering loop or Root::_updateAllRenderTargets is being used. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.IsActive">
      <summary>Sets/Used to retrieve or set the active state of the render target. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.FSAAHint">
      <summary>Gets the FSAA hint (Root::createRenderWindow) </summary>
    </member>
    <member name="P:Mogre.RenderTarget.FSAA">
      <summary>Indicates whether multisampling is performed on rendering and at what level. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.BestFrameTime">
      <summary>Individual stats access - gets the best frame time </summary>
    </member>
    <member name="P:Mogre.RenderTarget.BestFPS">
      <summary>Individual stats access - gets the best frames per second (FPS) since call to Root::startRendering. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.BatchCount">
      <summary>Gets the number of batches rendered in the last update() call. </summary>
    </member>
    <member name="P:Mogre.RenderTarget.AverageFPS">
      <summary>Individual stats access - gets the average frames per second (FPS) since call to Root::startRendering. </summary>
    </member>
    <member name="E:Mogre.RenderTarget.ViewportRemoved">
      <summary>Called to notify listener that a Viewport has been removed from the target in question. </summary>
    </member>
    <member name="E:Mogre.RenderTarget.ViewportAdded">
      <summary>Called to notify listener that a Viewport has been added to the target in question. </summary>
    </member>
    <member name="E:Mogre.RenderTarget.PostRenderTargetUpdate">
      <summary>Called just after a RenderTarget has been rendered to. This event is called just after all the viewports attached to the target in question have been rendered to. You can perform your own manual rendering commands in this event handler if you like, these will be composited with the contents of the target already there (depending on the material settings you use etc). </summary>
    </member>
    <member name="E:Mogre.RenderTarget.PreRenderTargetUpdate">
      <summary>Called just before a RenderTarget is about to be rendered into. This event is raised just before any of the viewports on the target are rendered to. You can perform manual rendering operations here if you want, but please note that if the Viewport objects attached to this target are set up to clear the background, you will lose whatever you render. If you want some kind of backdrop in this event you should turn off background clearing off on the viewports, and either clear the viewports yourself in this event handler before doing your rendering or just render over the top if you don't need to. </summary>
    </member>
    <member name="T:Mogre.RenderWindow">
      <summary>Manages the target rendering window. This class handles a window into which the contents of a scene are rendered. There is a many-to-1 relationship between instances of this class an instance of RenderSystem which controls the rendering of the scene. There may be more than one window in the case of level editor tools etc. This class is abstract since there may be different implementations for different windowing systems. Instances are created and communicated with by the render system although client programs can get a reference to it from the render system if required for resizing or moving. Note that you can have multiple viewpoints in the window for effects like rear-view mirrors and picture-in-picture views (see Viewport and Camera). Steven Streeting 1.0 </summary>
    </member>
    <member name="M:Mogre.RenderWindow.Create(System.String,System.UInt32,System.UInt32,System.Boolean,Mogre.Const_NameValuePairList)">
      <summary>Creates &amp; displays the new window. </summary>
      <param name="width">The width of the window in pixels. </param>
      <param name="height">The height of the window in pixels. </param>
      <param name="fullScreen">If true, the window fills the screen, with no title bar or border. </param>
    </member>
    <member name="M:Mogre.RenderWindow.SetFullscreen(System.Boolean,System.UInt32,System.UInt32)">
      <summary>Alter fullscreen mode options. Nothing will happen unless the settings here are different from the current settings. </summary>
      <param name="fullScreen">Whether to use fullscreen mode or not. </param>
      <param name="width">The new width to use </param>
      <param name="height">The new height to use </param>
    </member>
    <member name="M:Mogre.RenderWindow.Destroy">
      <summary>Destroys the window. </summary>
    </member>
    <member name="M:Mogre.RenderWindow.Resize(System.UInt32,System.UInt32)">
      <summary>Alter the size of the window. </summary>
    </member>
    <member name="M:Mogre.RenderWindow.WindowMovedOrResized">
      <summary>Notify that the window has been resized You don't need to call this unless you created the window externally. </summary>
    </member>
    <member name="M:Mogre.RenderWindow.Reposition(System.Int32,System.Int32)">
      <summary>Reposition the window. </summary>
    </member>
    <member name="M:Mogre.RenderWindow.SetVisible(System.Boolean)">
      <summary>Set the visibility state </summary>
    </member>
    <member name="M:Mogre.RenderWindow.GetMetrics(System.UInt32&amp;,System.UInt32&amp;,System.UInt32&amp;,System.Int32&amp;,System.Int32&amp;)">
      <summary>Overloaded version of getMetrics from RenderTarget, including extra details specific to windowing systems. </summary>
    </member>
    <member name="M:Mogre.RenderWindow.SuggestPixelFormat">
      <summary>Override since windows don't usually have alpha. </summary>
    </member>
    <member name="M:Mogre.RenderWindow.SetDeactivateOnFocusChange(System.Boolean)">
      <summary>Indicates whether the window will automatically deactivate itself when it loses focus. 'true' is the default behavior. </summary>
      <param name="deactivate">a value of 'true' will cause the window to deactivate itself when it loses focus. 'false' will allow it to continue to render even when window focus is lost. </param>
    </member>
    <member name="M:Mogre.RenderWindow.GetMetrics(System.UInt32&amp;,System.UInt32&amp;,System.UInt32&amp;)">
      <summary>Overloaded version of getMetrics from RenderTarget, including extra details specific to windowing systems. </summary>
    </member>
    <member name="M:Mogre.RenderWindow.SuggestPixelFormat">
      <summary>Override since windows don't usually have alpha. </summary>
    </member>
    <member name="P:Mogre.RenderWindow.IsVisible">
      <summary>Indicates whether the window is visible (not minimized or obscured) </summary>
    </member>
    <member name="P:Mogre.RenderWindow.IsPrimary">
      <summary>Indicates whether the window is the primary window. The primary window is special in that it is destroyed when ogre is shut down, and cannot be destroyed directly. This is the case because it holds the context for vertex, index buffers and textures. </summary>
    </member>
    <member name="P:Mogre.RenderWindow.IsFullScreen">
      <summary>Returns true if window is running in fullscreen mode. </summary>
    </member>
    <member name="P:Mogre.RenderWindow.IsDeactivatedOnFocusChange">
      <summary>Returns true if the window will automatically de-activate itself when it loses focus. </summary>
    </member>
    <member name="P:Mogre.RenderWindow.IsClosed">
      <summary>Indicates whether the window has been closed by the user. </summary>
    </member>
    <member name="P:Mogre.RenderWindow.IsActive">
      <summary>Sets/Overridden from RenderTarget, flags invisible windows as inactive </summary>
    </member>
    <member name="T:Mogre.CompositionPass">
      <summary>Object representing one pass or operation in a composition sequence. This provides a method to conveniently interleave RenderSystem commands between Render Queues. </summary>
    </member>
    <member name="M:Mogre.CompositionPass.SetMaterial(Mogre.MaterialPtr)">
      <summary>Set the material used by this pass applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="M:Mogre.CompositionPass.SetMaterialName(System.String)">
      <summary>Set the material used by this pass applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="M:Mogre.CompositionPass.GetMaterial">
      <summary>Get the material used by this pass applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="M:Mogre.CompositionPass.SetInput(System.UInt32)">
      <summary>Set an input local texture. An empty string clears the input. applies when PassType is RENDERQUAD </summary>
      <param name="id">Input to set. Must be in 0..OGRE_MAX_TEXTURE_LAYERS-1 </param>
    </member>
    <member name="M:Mogre.CompositionPass.SetInput(System.UInt32,System.String)">
      <summary>Set an input local texture. An empty string clears the input. applies when PassType is RENDERQUAD </summary>
      <param name="id">Input to set. Must be in 0..OGRE_MAX_TEXTURE_LAYERS-1 </param>
      <param name="input">Which texture to bind to this input. An empty string clears the input. </param>
    </member>
    <member name="M:Mogre.CompositionPass.SetInput(System.UInt32,System.String,System.UInt32)">
      <summary>Set an input local texture. An empty string clears the input. applies when PassType is RENDERQUAD </summary>
      <param name="id">Input to set. Must be in 0..OGRE_MAX_TEXTURE_LAYERS-1 </param>
      <param name="input">Which texture to bind to this input. An empty string clears the input. </param>
      <param name="mrtIndex">Which surface of an MRT to retrieve </param>
    </member>
    <member name="M:Mogre.CompositionPass.GetInput(System.UInt32)">
      <summary>Get the value of an input. applies when PassType is RENDERQUAD </summary>
      <param name="id">Input to get. Must be in 0..OGRE_MAX_TEXTURE_LAYERS-1. </param>
    </member>
    <member name="M:Mogre.CompositionPass.ClearAllInputs">
      <summary>Clear all inputs. applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="M:Mogre.CompositionPass._isSupported">
      <summary>Determine if this target pass is supported on the current rendering device. </summary>
    </member>
    <member name="M:Mogre.CompositionPass.SetQuadCorners(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set quad normalised positions [-1;1]x[-1;1] applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="M:Mogre.CompositionPass.GetQuadCorners(System.Single&amp;,System.Single&amp;,System.Single&amp;,System.Single&amp;)">
      <summary>Get quad normalised positions [-1;1]x[-1;1] applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="M:Mogre.CompositionPass.SetQuadFarCorners(System.Boolean,System.Boolean)">
      <summary>Sets the use of camera frustum far corners provided in the quad's normals applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="P:Mogre.CompositionPass.Type">
      <summary>Sets/Get the type of composition pass </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilTwoSidedOperation">
      <summary>Sets/Get two sided stencil operation. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilRefValue">
      <summary>Sets/Get stencil reference value. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilPassOp">
      <summary>Sets/Get stencil pass operation. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilMask">
      <summary>Sets/Get stencil mask. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilFunc">
      <summary>Sets/Get stencil compare function. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilFailOp">
      <summary>Sets/Get stencil fail operation. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilDepthFailOp">
      <summary>Sets/Get stencil depth fail operation. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.StencilCheck">
      <summary>Sets/Get stencil check enable. applies when PassType is STENCIL </summary>
    </member>
    <member name="P:Mogre.CompositionPass.QuadFarCornersViewSpace">
      <summary>Returns true if the far corners provided in the quad are in view space applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="P:Mogre.CompositionPass.QuadFarCorners">
      <summary>Returns true if camera frustum far corners are provided in the quad. applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="P:Mogre.CompositionPass.Parent">
      <summary>Get parent object applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="P:Mogre.CompositionPass.NumInputs">
      <summary>Get the number of inputs used. applies when PassType is RENDERQUAD </summary>
    </member>
    <member name="P:Mogre.CompositionPass.MaterialScheme">
      <summary>Sets/Get the material scheme used by this pass. Only applicable to passes that render the scene. Technique::setScheme. </summary>
    </member>
    <member name="P:Mogre.CompositionPass.LastRenderQueue">
      <summary>Sets/Get the last render queue to be rendered in this pass (inclusive) applies when PassType is RENDERSCENE </summary>
    </member>
    <member name="P:Mogre.CompositionPass.Identifier">
      <summary>Sets/Get the identifier for this pass </summary>
    </member>
    <member name="P:Mogre.CompositionPass.FirstRenderQueue">
      <summary>Sets/Get the first render queue to be rendered in this pass (inclusive) applies when PassType is RENDERSCENE </summary>
    </member>
    <member name="P:Mogre.CompositionPass.CustomType">
      <summary>Sets/Get the type name of this custom composition pass. applies when PassType is RENDERCUSTOM CompositorManager::registerCustomCompositionPass</summary>
    </member>
    <member name="P:Mogre.CompositionPass.ClearStencil">
      <summary>Sets/Get the viewport clear stencil value (defaults to 0) applies when PassType is CLEAR </summary>
    </member>
    <member name="P:Mogre.CompositionPass.ClearDepth">
      <summary>Sets/Get the viewport clear depth (defaults to 1.0) applies when PassType is CLEAR </summary>
    </member>
    <member name="P:Mogre.CompositionPass.ClearColour">
      <summary>Sets/Get the viewport clear colour (defaults to 0,0,0,0) applies when PassType is CLEAR </summary>
    </member>
    <member name="P:Mogre.CompositionPass.ClearBuffers">
      <summary>Sets/Get the viewport clear buffers. applies when PassType is CLEAR </summary>
    </member>
    <member name="T:Mogre.CompositionPass+PassType">
      <summary>Enumeration that enumerates the various composition pass types. </summary>
    </member>
    <member name="T:Mogre.CompositionTargetPass">
      <summary>Object representing one render to a RenderTarget or Viewport in the Ogre Composition framework. </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass.SetInputMode(Mogre.CompositionTargetPass+InputMode)">
      <summary>Set input mode of this TargetPass </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass.GetInputMode">
      <summary>Get input mode </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass.CreatePass">
      <summary>Create a new pass, and return a pointer to it. </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass.RemovePass(System.UInt32)">
      <summary>Remove a pass. It will also be destroyed. </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass.GetPass(System.UInt32)">
      <summary>Get a pass. </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass.RemoveAllPasses">
      <summary>Remove all passes </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass.GetPassIterator">
      <summary>Get an iterator over the Passes in this TargetPass. </summary>
    </member>
    <member name="M:Mogre.CompositionTargetPass._isSupported">
      <summary>Determine if this target pass is supported on the current rendering device. </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.VisibilityMask">
      <summary>Sets/Get the scene visibility mask used by this pass </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.ShadowsEnabled">
      <summary>Sets/Get whether shadows are enabled in this target pass. Only applicable to targets that render the scene as one of their passes. </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.Parent">
      <summary>Get parent object </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.OutputName">
      <summary>Sets/Get output local texture name </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.OnlyInitial">
      <summary>Sets/Get "only initial" flag. </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.NumPasses">
      <summary>Get the number of passes. </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.MaterialScheme">
      <summary>Sets/Get the material scheme used by this target pass. Only applicable to targets that render the scene as one of their passes. Technique::setScheme. </summary>
    </member>
    <member name="P:Mogre.CompositionTargetPass.LodBias">
      <summary>Sets/Get the scene LOD bias used by this pass </summary>
    </member>
    <member name="T:Mogre.CompositionTargetPass+InputMode">
      <summary>Input mode of a TargetPass </summary>
    </member>
    <member name="T:Mogre.CompositionTechnique">
      <summary>Base composition technique, can be subclassed in plugins. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.CreateTextureDefinition(System.String)">
      <summary>Create a new local texture definition, and return a pointer to it. </summary>
      <param name="name">Name of the local texture </param>
    </member>
    <member name="M:Mogre.CompositionTechnique.RemoveTextureDefinition(System.UInt32)">
      <summary>Remove and destroy a local texture definition. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.GetTextureDefinition(System.String)">
      <summary>Get a local texture definition with a specific name. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.GetTextureDefinition(System.UInt32)">
      <summary>Get a local texture definition. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.RemoveAllTextureDefinitions">
      <summary>Remove all Texture Definitions </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.GetTextureDefinitionIterator">
      <summary>Get an iterator over the TextureDefinitions in this Technique. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.CreateTargetPass">
      <summary>Create a new target pass, and return a pointer to it. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.RemoveTargetPass(System.UInt32)">
      <summary>Remove a target pass. It will also be destroyed. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.GetTargetPass(System.UInt32)">
      <summary>Get a target pass. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.RemoveAllTargetPasses">
      <summary>Remove all target passes. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.GetTargetPassIterator">
      <summary>Get an iterator over the TargetPasses in this Technique. </summary>
    </member>
    <member name="M:Mogre.CompositionTechnique.IsSupported(System.Boolean)">
      <summary>Determine if this technique is supported on the current rendering device. </summary>
      <param name="allowTextureDegradation">True to accept a reduction in texture depth </param>
    </member>
    <member name="P:Mogre.CompositionTechnique.SchemeName">
      <summary>Sets/Get the scheme name assigned to this technique. </summary>
    </member>
    <member name="P:Mogre.CompositionTechnique.Parent">
      <summary>Get parent object </summary>
    </member>
    <member name="P:Mogre.CompositionTechnique.OutputTargetPass">
      <summary>Get output (final) target pass </summary>
    </member>
    <member name="P:Mogre.CompositionTechnique.NumTextureDefinitions">
      <summary>Get the number of local texture definitions. </summary>
    </member>
    <member name="P:Mogre.CompositionTechnique.NumTargetPasses">
      <summary>Get the number of target passes. </summary>
    </member>
    <member name="P:Mogre.CompositionTechnique.CompositorLogicName">
      <summary>Sets/Get the compositor logic name assigned to this technique </summary>
    </member>
    <member name="T:Mogre.Compositor">
      <summary>Class representing a Compositor object. Compositors provide the means to flexibly "composite" the final rendering result from multiple scene renders and intermediate operations like rendering fullscreen quads. This makes it possible to apply postfilter effects, HDRI postprocessing, and shadow effects to a Viewport. </summary>
    </member>
    <member name="M:Mogre.Compositor.CreateTechnique">
      <summary>Create a new technique, and return a pointer to it. </summary>
    </member>
    <member name="M:Mogre.Compositor.RemoveTechnique(System.UInt32)">
      <summary>Remove a technique. It will also be destroyed. </summary>
    </member>
    <member name="M:Mogre.Compositor.GetTechnique(System.UInt32)">
      <summary>Get a technique. </summary>
    </member>
    <member name="M:Mogre.Compositor.RemoveAllTechniques">
      <summary>Remove all techniques </summary>
    </member>
    <member name="M:Mogre.Compositor.GetTechniqueIterator">
      <summary>Get an iterator over the Techniques in this compositor. </summary>
    </member>
    <member name="M:Mogre.Compositor.GetSupportedTechnique">
      <summary>Get a supported technique. The supported technique list is only available after this compositor has been compiled, which typically happens on loading it. Therefore, if this method returns an empty list, try calling Compositor::load. </summary>
    </member>
    <member name="M:Mogre.Compositor.GetSupportedTechnique(System.String)">
      <summary>Get a supported technique. The supported technique list is only available after this compositor has been compiled, which typically happens on loading it. Therefore, if this method returns an empty list, try calling Compositor::load. </summary>
    </member>
    <member name="M:Mogre.Compositor.GetSupportedTechnique(System.UInt32)">
      <summary>Get a supported technique. The supported technique list is only available after this compositor has been compiled, which typically happens on loading it. Therefore, if this method returns an empty list, try calling Compositor::load. </summary>
    </member>
    <member name="M:Mogre.Compositor.GetSupportedTechniqueIterator">
      <summary>Gets an iterator over all the Techniques which are supported by the current card. The supported technique list is only available after this compositor has been compiled, which typically happens on loading it. Therefore, if this method returns an empty list, try calling Compositor::load. </summary>
    </member>
    <member name="M:Mogre.Compositor.GetTextureInstanceName(System.String,System.UInt32)">
      <summary>Get the instance name for a global texture. The instance name for the texture, corresponds to a real texture </summary>
      <param name="name">The name of the texture in the original compositor definition </param>
      <param name="mrtIndex">If name identifies a MRT, which texture attachment to retrieve </param>
    </member>
    <member name="M:Mogre.Compositor.GetTextureInstance(System.String,System.UInt32)">
      <summary>Get the instance of a global texture. The texture pointer, corresponds to a real texture </summary>
      <param name="name">The name of the texture in the original compositor definition </param>
      <param name="mrtIndex">If name identifies a MRT, which texture attachment to retrieve </param>
    </member>
    <member name="M:Mogre.Compositor.GetRenderTarget(System.String)">
      <summary>Get the render target for a given render texture name. You can use this to add listeners etc, but do not use it to update the targets manually or any other modifications, the compositor instance is in charge of this. </summary>
    </member>
    <member name="P:Mogre.Compositor.NumTechniques">
      <summary>Get the number of techniques. </summary>
    </member>
    <member name="P:Mogre.Compositor.NumSupportedTechniques">
      <summary>Get the number of supported techniques. The supported technique list is only available after this compositor has been compiled, which typically happens on loading it. Therefore, if this method returns an empty list, try calling Compositor::load. </summary>
    </member>
    <member name="T:Mogre.CompositorPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to CompositorPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.ResourceManager">
      <summary>Defines a generic resource handler. A resource manager is responsible for managing a pool of resources of a particular type. It must index them, look them up, load and destroy them. It may also need to stay within a defined memory budget, and temporarily unload some resources if it needs to to stay within this budget. Resource managers use a priority system to determine what can be unloaded, and a Least Recently Used (LRU) policy within resources of the same priority. Resources can be loaded using the generalised load interface, and they can be unloaded and removed. In addition, each subclass of ResourceManager will likely define custom 'load' methods which take explicit parameters depending on the kind of resource being created. Resources can be loaded and unloaded through the Resource class, but they can only be removed (and thus eventually destroyed) using their parent ResourceManager. If OGRE_THREAD_SUPPORT is 1, this class is thread-safe. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.Create(System.String,System.String)">
      <summary>Creates a new blank resource, but does not immediately load it. Resource managers handle disparate types of resources, so if you want to get at the detailed interface of this resource, you'll have to cast the result to the subclass you know you're creating. </summary>
      <param name="name">The unique name of the resource </param>
      <param name="group">The name of the resource group to attach this new resource to </param>
    </member>
    <member name="M:Mogre.ResourceManager.Create(System.String,System.String,System.Boolean)">
      <summary>Creates a new blank resource, but does not immediately load it. Resource managers handle disparate types of resources, so if you want to get at the detailed interface of this resource, you'll have to cast the result to the subclass you know you're creating. </summary>
      <param name="name">The unique name of the resource </param>
      <param name="group">The name of the resource group to attach this new resource to </param>
      <param name="isManual">Is this resource manually loaded? If so, you should really populate the loader parameter in order that the load process can call the loader back when loading is required. </param>
    </member>
    <member name="M:Mogre.ResourceManager.Create(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Creates a new blank resource, but does not immediately load it. Resource managers handle disparate types of resources, so if you want to get at the detailed interface of this resource, you'll have to cast the result to the subclass you know you're creating. </summary>
      <param name="name">The unique name of the resource </param>
      <param name="group">The name of the resource group to attach this new resource to </param>
      <param name="isManual">Is this resource manually loaded? If so, you should really populate the loader parameter in order that the load process can call the loader back when loading is required. </param>
      <param name="loader">Pointer to a ManualLoader implementation which will be called when the Resource wishes to load (should be supplied if you set isManual to true). You can in fact leave this parameter null if you wish, but the Resource will never be able to reload if anything ever causes it to unload. Therefore provision of a proper ManualLoader instance is strongly recommended. </param>
    </member>
    <member name="M:Mogre.ResourceManager.Create(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Creates a new blank resource, but does not immediately load it. Resource managers handle disparate types of resources, so if you want to get at the detailed interface of this resource, you'll have to cast the result to the subclass you know you're creating. </summary>
      <param name="name">The unique name of the resource </param>
      <param name="group">The name of the resource group to attach this new resource to </param>
      <param name="isManual">Is this resource manually loaded? If so, you should really populate the loader parameter in order that the load process can call the loader back when loading is required. </param>
      <param name="loader">Pointer to a ManualLoader implementation which will be called when the Resource wishes to load (should be supplied if you set isManual to true). You can in fact leave this parameter null if you wish, but the Resource will never be able to reload if anything ever causes it to unload. Therefore provision of a proper ManualLoader instance is strongly recommended. </param>
      <param name="createParams">If any parameters are required to create an instance, they should be supplied here as name / value pairs </param>
    </member>
    <member name="M:Mogre.ResourceManager.CreateOrRetrieve(System.String,System.String)">
      <summary>Create a new resource, or retrieve an existing one with the same name if it already exists. This method performs the same task as calling getByName() followed by create() if that returns null. The advantage is that it does it in one call so there are no race conditions if using multiple threads that could cause getByName() to return null, but create() to fail because another thread created a resource in between. ResourceManager::createResourceManager::getByNameA pair, the first element being the pointer, and the second being an indicator specifying whether the resource was newly created. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.CreateOrRetrieve(System.String,System.String,System.Boolean)">
      <summary>Create a new resource, or retrieve an existing one with the same name if it already exists. This method performs the same task as calling getByName() followed by create() if that returns null. The advantage is that it does it in one call so there are no race conditions if using multiple threads that could cause getByName() to return null, but create() to fail because another thread created a resource in between. ResourceManager::createResourceManager::getByNameA pair, the first element being the pointer, and the second being an indicator specifying whether the resource was newly created. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Create a new resource, or retrieve an existing one with the same name if it already exists. This method performs the same task as calling getByName() followed by create() if that returns null. The advantage is that it does it in one call so there are no race conditions if using multiple threads that could cause getByName() to return null, but create() to fail because another thread created a resource in between. ResourceManager::createResourceManager::getByNameA pair, the first element being the pointer, and the second being an indicator specifying whether the resource was newly created. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Create a new resource, or retrieve an existing one with the same name if it already exists. This method performs the same task as calling getByName() followed by create() if that returns null. The advantage is that it does it in one call so there are no race conditions if using multiple threads that could cause getByName() to return null, but create() to fail because another thread created a resource in between. ResourceManager::createResourceManager::getByNameA pair, the first element being the pointer, and the second being an indicator specifying whether the resource was newly created. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.Unload(System.UInt64)">
      <summary>Unloads a single resource by handle. Unloaded resources are not removed, they simply free up their memory as much as they can and wait to be reloaded. ResourceGroupManager for unloading of resource groups. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.Unload(System.String)">
      <summary>Unloads a single resource by name. Unloaded resources are not removed, they simply free up their memory as much as they can and wait to be reloaded. ResourceGroupManager for unloading of resource groups. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.UnloadAll">
      <summary>Unloads all resources. Unloaded resources are not removed, they simply free up their memory as much as they can and wait to be reloaded. ResourceGroupManager for unloading of resource groups. Resource::isReloadable for resource is reloadable. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.UnloadAll(System.Boolean)">
      <summary>Unloads all resources. Unloaded resources are not removed, they simply free up their memory as much as they can and wait to be reloaded. ResourceGroupManager for unloading of resource groups. Resource::isReloadable for resource is reloadable. </summary>
      <param name="reloadableOnly">If true (the default), only unload the resource that is reloadable. Because some resources isn't reloadable, they will be unloaded but can't load them later. Thus, you might not want to them unloaded. Or, you might unload all of them, and then populate them manually later. </param>
    </member>
    <member name="M:Mogre.ResourceManager.ReloadAll">
      <summary>Caused all currently loaded resources to be reloaded. All resources currently being held in this manager which are also marked as currently loaded will be unloaded, then loaded again. Resource::isReloadable for resource is reloadable. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.ReloadAll(System.Boolean)">
      <summary>Caused all currently loaded resources to be reloaded. All resources currently being held in this manager which are also marked as currently loaded will be unloaded, then loaded again. Resource::isReloadable for resource is reloadable. </summary>
      <param name="reloadableOnly">If true (the default), only reload the resource that is reloadable. Because some resources isn't reloadable, they will be unloaded but can't loaded again. Thus, you might not want to them unloaded. Or, you might unload all of them, and then populate them manually later. </param>
    </member>
    <member name="M:Mogre.ResourceManager.UnloadUnreferencedResources">
      <summary>Unload all resources which are not referenced by any other object. This method behaves like unloadAll, except that it only unloads resources which are not in use, ie not referenced by other objects. This allows you to free up some memory selectively whilst still keeping the group around (and the resources present, just not using much memory). Some referenced resource may exists 'weak' pointer to their sub-components (e.g. Entity held pointer to SubMesh), in this case, unload or reload that resource will cause dangerous pointer access. Use this function instead of unloadAll allows you avoid fail in those situations. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.UnloadUnreferencedResources(System.Boolean)">
      <summary>Unload all resources which are not referenced by any other object. This method behaves like unloadAll, except that it only unloads resources which are not in use, ie not referenced by other objects. This allows you to free up some memory selectively whilst still keeping the group around (and the resources present, just not using much memory). Some referenced resource may exists 'weak' pointer to their sub-components (e.g. Entity held pointer to SubMesh), in this case, unload or reload that resource will cause dangerous pointer access. Use this function instead of unloadAll allows you avoid fail in those situations. </summary>
      <param name="reloadableOnly">If true (the default), only unloads resources which can be subsequently automatically reloaded. </param>
    </member>
    <member name="M:Mogre.ResourceManager.ReloadUnreferencedResources">
      <summary>Caused all currently loaded but not referenced by any other object resources to be reloaded. This method behaves like reloadAll, except that it only reloads resources which are not in use, i.e. not referenced by other objects. Some referenced resource may exists 'weak' pointer to their sub-components (e.g. Entity held pointer to SubMesh), in this case, unload or reload that resource will cause dangerous pointer access. Use this function instead of reloadAll allows you avoid fail in those situations. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.ReloadUnreferencedResources(System.Boolean)">
      <summary>Caused all currently loaded but not referenced by any other object resources to be reloaded. This method behaves like reloadAll, except that it only reloads resources which are not in use, i.e. not referenced by other objects. Some referenced resource may exists 'weak' pointer to their sub-components (e.g. Entity held pointer to SubMesh), in this case, unload or reload that resource will cause dangerous pointer access. Use this function instead of reloadAll allows you avoid fail in those situations. </summary>
      <param name="reloadableOnly">If true (the default), only reloads resources which can be subsequently automatically reloaded. </param>
    </member>
    <member name="M:Mogre.ResourceManager.Remove(System.UInt64)">
      <summary>Remove a single resource by handle. Removes a single resource, meaning it will be removed from the list of valid resources in this manager, also causing it to be unloaded. The word 'Destroy' is not used here, since if any other pointers are referring to this resource, it will persist until they have finished with it; however to all intents and purposes it no longer exists and will likely get destroyed imminently. If you do have shared pointers to resources hanging around after the ResourceManager is destroyed, you may get problems on destruction of these resources if they were relying on the manager (especially if it is a plugin). If you find you get problems on shutdown in the destruction of resources, try making sure you release all your shared pointers before you shutdown OGRE. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.Remove(System.String)">
      <summary>Remove a single resource by name. Removes a single resource, meaning it will be removed from the list of valid resources in this manager, also causing it to be unloaded. The word 'Destroy' is not used here, since if any other pointers are referring to this resource, it will persist until they have finished with it; however to all intents and purposes it no longer exists and will likely get destroyed imminently. If you do have shared pointers to resources hanging around after the ResourceManager is destroyed, you may get problems on destruction of these resources if they were relying on the manager (especially if it is a plugin). If you find you get problems on shutdown in the destruction of resources, try making sure you release all your shared pointers before you shutdown OGRE. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.Remove(Mogre.ResourcePtr)">
      <summary>Remove a single resource. Removes a single resource, meaning it will be removed from the list of valid resources in this manager, also causing it to be unloaded. The word 'Destroy' is not used here, since if any other pointers are referring to this resource, it will persist until they have finished with it; however to all intents and purposes it no longer exists and will likely get destroyed imminently. If you do have shared pointers to resources hanging around after the ResourceManager is destroyed, you may get problems on destruction of these resources if they were relying on the manager (especially if it is a plugin). If you find you get problems on shutdown in the destruction of resources, try making sure you release all your shared pointers before you shutdown OGRE. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.RemoveAll">
      <summary>Removes all resources. The word 'Destroy' is not used here, since if any other pointers are referring to these resources, they will persist until they have been finished with; however to all intents and purposes the resources no longer exist and will get destroyed imminently. If you do have shared pointers to resources hanging around after the ResourceManager is destroyed, you may get problems on destruction of these resources if they were relying on the manager (especially if it is a plugin). If you find you get problems on shutdown in the destruction of resources, try making sure you release all your shared pointers before you shutdown OGRE. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.RemoveUnreferencedResources">
      <summary>Remove all resources which are not referenced by any other object. This method behaves like removeAll, except that it only removes resources which are not in use, ie not referenced by other objects. This allows you to free up some memory selectively whilst still keeping the group around (and the resources present, just not using much memory). Some referenced resource may exists 'weak' pointer to their sub-components (e.g. Entity held pointer to SubMesh), in this case, remove or reload that resource will cause dangerous pointer access. Use this function instead of removeAll allows you avoid fail in those situations. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.RemoveUnreferencedResources(System.Boolean)">
      <summary>Remove all resources which are not referenced by any other object. This method behaves like removeAll, except that it only removes resources which are not in use, ie not referenced by other objects. This allows you to free up some memory selectively whilst still keeping the group around (and the resources present, just not using much memory). Some referenced resource may exists 'weak' pointer to their sub-components (e.g. Entity held pointer to SubMesh), in this case, remove or reload that resource will cause dangerous pointer access. Use this function instead of removeAll allows you avoid fail in those situations. </summary>
      <param name="reloadableOnly">If true (the default), only removes resources which can be subsequently automatically reloaded. </param>
    </member>
    <member name="M:Mogre.ResourceManager.GetByName(System.String)">
      <summary>Retrieves a pointer to a resource by name, or null if the resource does not exist. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.GetByName(System.String,System.String)">
      <summary>Retrieves a pointer to a resource by name, or null if the resource does not exist. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.GetByHandle(System.UInt64)">
      <summary>Retrieves a pointer to a resource by handle, or null if the resource does not exist. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.ResourceExists(System.UInt64)">
      <summary>Returns whether a resource with the given handle exists in this manager. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.ResourceExists(System.String)">
      <summary>Returns whether the named resource exists in this manager. </summary>
    </member>
    <member name="M:Mogre.ResourceManager._notifyResourceTouched(Mogre.Resource)">
      <summary>Notify this manager that a resource which it manages has been 'touched', i.e. used. </summary>
    </member>
    <member name="M:Mogre.ResourceManager._notifyResourceLoaded(Mogre.Resource)">
      <summary>Notify this manager that a resource which it manages has been loaded. </summary>
    </member>
    <member name="M:Mogre.ResourceManager._notifyResourceUnloaded(Mogre.Resource)">
      <summary>Notify this manager that a resource which it manages has been unloaded. </summary>
    </member>
    <member name="M:Mogre.ResourceManager.Prepare(System.String,System.String)">
      <summary>Generic prepare method, used to create a Resource specific to this ResourceManager without using one of the specialised 'prepare' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
    </member>
    <member name="M:Mogre.ResourceManager.Prepare(System.String,System.String,System.Boolean)">
      <summary>Generic prepare method, used to create a Resource specific to this ResourceManager without using one of the specialised 'prepare' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
    </member>
    <member name="M:Mogre.ResourceManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Generic prepare method, used to create a Resource specific to this ResourceManager without using one of the specialised 'prepare' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
      <param name="loader">The manual loader which is to perform the required actions when this resource is loaded; only applicable when you specify true for the previous parameter </param>
    </member>
    <member name="M:Mogre.ResourceManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Generic prepare method, used to create a Resource specific to this ResourceManager without using one of the specialised 'prepare' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
      <param name="loader">The manual loader which is to perform the required actions when this resource is loaded; only applicable when you specify true for the previous parameter </param>
      <param name="loadParams">Optional pointer to a list of name/value pairs containing loading parameters for this type of resource. </param>
    </member>
    <member name="M:Mogre.ResourceManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,System.Boolean)">
      <summary>Generic prepare method, used to create a Resource specific to this ResourceManager without using one of the specialised 'prepare' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
      <param name="loader">The manual loader which is to perform the required actions when this resource is loaded; only applicable when you specify true for the previous parameter </param>
      <param name="loadParams">Optional pointer to a list of name/value pairs containing loading parameters for this type of resource. </param>
      <param name="backgroundThread">Optional boolean which lets the load routine know if it is being run on the background resource loading thread </param>
    </member>
    <member name="M:Mogre.ResourceManager.Load(System.String,System.String)">
      <summary>Generic load method, used to create a Resource specific to this ResourceManager without using one of the specialised 'load' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
    </member>
    <member name="M:Mogre.ResourceManager.Load(System.String,System.String,System.Boolean)">
      <summary>Generic load method, used to create a Resource specific to this ResourceManager without using one of the specialised 'load' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
    </member>
    <member name="M:Mogre.ResourceManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Generic load method, used to create a Resource specific to this ResourceManager without using one of the specialised 'load' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
      <param name="loader">The manual loader which is to perform the required actions when this resource is loaded; only applicable when you specify true for the previous parameter </param>
    </member>
    <member name="M:Mogre.ResourceManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Generic load method, used to create a Resource specific to this ResourceManager without using one of the specialised 'load' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
      <param name="loader">The manual loader which is to perform the required actions when this resource is loaded; only applicable when you specify true for the previous parameter </param>
      <param name="loadParams">Optional pointer to a list of name/value pairs containing loading parameters for this type of resource. </param>
    </member>
    <member name="M:Mogre.ResourceManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,System.Boolean)">
      <summary>Generic load method, used to create a Resource specific to this ResourceManager without using one of the specialised 'load' methods (containing per-Resource-type parameters). </summary>
      <param name="name">The name of the Resource</param>
      <param name="group">The resource group to which this resource will belong </param>
      <param name="isManual">Is the resource to be manually loaded? If so, you should provide a value for the loader parameter </param>
      <param name="loader">The manual loader which is to perform the required actions when this resource is loaded; only applicable when you specify true for the previous parameter </param>
      <param name="loadParams">Optional pointer to a list of name/value pairs containing loading parameters for this type of resource. </param>
      <param name="backgroundThread">Optional boolean which lets the load routine know if it is being run on the background resource loading thread </param>
    </member>
    <member name="M:Mogre.ResourceManager.GetScriptPatterns">
      <summary>Gets the file patterns which should be used to find scripts for this ResourceManager. Some resource managers can read script files in order to define resources ahead of time. These resources are added to the available list inside the manager, but none are loaded initially. This allows you to load the items that are used on demand, or to load them all as a group if you wish (through ResourceGroupManager). This method lets you determine the file pattern which will be used to identify scripts intended for this manager. A list of file patterns, in the order they should be searched in. isScriptingSupported, parseScript</summary>
    </member>
    <member name="M:Mogre.ResourceManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>Parse the definition of a set of resources from a script file. Some resource managers can read script files in order to define resources ahead of time. These resources are added to the available list inside the manager, but none are loaded initially. This allows you to load the items that are used on demand, or to load them all as a group if you wish (through ResourceGroupManager). </summary>
      <param name="stream">Weak reference to a data stream which is the source of the script </param>
      <param name="groupName">The name of the resource group that resources which are parsed are to become a member of. If this group is loaded or unloaded, then the resources discovered in this script will be loaded / unloaded with it. </param>
    </member>
    <member name="M:Mogre.ResourceManager.DestroyAllResourcePools">
      <summary>destroy all pools </summary>
    </member>
    <member name="M:Mogre.ResourceManager.GetResourceIterator">
      <summary>Returns an iterator over all resources in this manager. Use of this iterator is NOT thread safe! </summary>
    </member>
    <member name="P:Mogre.ResourceManager.Verbose">
      <summary>Sets/Gets whether this manager and its resources habitually produce log output </summary>
    </member>
    <member name="P:Mogre.ResourceManager.ResourceType">
      <summary>Gets a string identifying the type of resource this manager handles. </summary>
    </member>
    <member name="P:Mogre.ResourceManager.MemoryUsage">
      <summary>Gets the current memory usage, in bytes. </summary>
    </member>
    <member name="P:Mogre.ResourceManager.MemoryBudget">
      <summary>Sets/Get the limit on the amount of memory this resource handler may use. </summary>
    </member>
    <member name="P:Mogre.ResourceManager.LoadingOrder">
      <summary>Gets the relative loading order of resources of this type. There are dependencies between some kinds of resource in terms of loading order, and this value enumerates that. Higher values load later during bulk loading tasks. </summary>
    </member>
    <member name="T:Mogre.CompositorChain">
      <summary>Chain of compositor effects applying to one viewport. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.AddCompositor(Mogre.CompositorPtr)">
      <summary>Apply a compositor. Initially, the filter is enabled. </summary>
      <param name="filter">Filter to apply </param>
    </member>
    <member name="M:Mogre.CompositorChain.AddCompositor(Mogre.CompositorPtr,System.UInt32)">
      <summary>Apply a compositor. Initially, the filter is enabled. </summary>
      <param name="filter">Filter to apply </param>
      <param name="addPosition">Position in filter chain to insert this filter at; defaults to the end (last applied filter) </param>
    </member>
    <member name="M:Mogre.CompositorChain.AddCompositor(Mogre.CompositorPtr,System.UInt32,System.String)">
      <summary>Apply a compositor. Initially, the filter is enabled. </summary>
      <param name="filter">Filter to apply </param>
      <param name="addPosition">Position in filter chain to insert this filter at; defaults to the end (last applied filter) </param>
      <param name="scheme">Scheme to use (blank means default) </param>
    </member>
    <member name="M:Mogre.CompositorChain.RemoveCompositor">
      <summary>Remove a compositor. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.RemoveCompositor(System.UInt32)">
      <summary>Remove a compositor. </summary>
      <param name="position">Position in filter chain of filter to remove; defaults to the end (last applied filter) </param>
    </member>
    <member name="M:Mogre.CompositorChain.RemoveAllCompositors">
      <summary>Remove all compositors. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.GetCompositor(System.String)">
      <summary>Get compositor instance by name. Returns null if not found. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.GetCompositor(System.UInt32)">
      <summary>Get compositor instance by position. </summary>
    </member>
    <member name="M:Mogre.CompositorChain._getOriginalSceneCompositor">
      <summary>Get the original scene compositor instance for this chain (internal use). </summary>
    </member>
    <member name="M:Mogre.CompositorChain.GetCompositors">
      <summary>Get an iterator over the compositor instances. The first compositor in this list is applied first, the last one is applied last. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.SetCompositorEnabled(System.UInt32,System.Boolean)">
      <summary>Enable or disable a compositor, by position. Disabling a compositor stops it from rendering but does not free any resources. This can be more efficient than using removeCompositor and addCompositor in cases the filter is switched on and off a lot. </summary>
      <param name="position">Position in filter chain of filter </param>
    </member>
    <member name="M:Mogre.CompositorChain.PreRenderTargetUpdate(Mogre.RenderTargetEvent_NativePtr)">
      <summary>RenderTargetListener::preRenderTargetUpdate</summary>
    </member>
    <member name="M:Mogre.CompositorChain.PostRenderTargetUpdate(Mogre.RenderTargetEvent_NativePtr)">
      <summary>RenderTargetListener::postRenderTargetUpdate</summary>
    </member>
    <member name="M:Mogre.CompositorChain.PreViewportUpdate(Mogre.RenderTargetViewportEvent_NativePtr)">
      <summary>RenderTargetListener::preViewportUpdate</summary>
    </member>
    <member name="M:Mogre.CompositorChain.PostViewportUpdate(Mogre.RenderTargetViewportEvent_NativePtr)">
      <summary>RenderTargetListener::postViewportUpdate</summary>
    </member>
    <member name="M:Mogre.CompositorChain.ViewportRemoved(Mogre.RenderTargetViewportEvent_NativePtr)">
      <summary>RenderTargetListener::viewportRemoved</summary>
    </member>
    <member name="M:Mogre.CompositorChain._markDirty">
      <summary>Mark state as dirty, and to be recompiled next frame. </summary>
    </member>
    <member name="M:Mogre.CompositorChain._notifyViewport(Mogre.Viewport)">
      <summary>Internal method for reconnecting with viewport </summary>
    </member>
    <member name="M:Mogre.CompositorChain._removeInstance(Mogre.CompositorInstance)">
      <summary>Remove a compositor by pointer. This is internally used by CompositionTechnique to "weak" remove any instanced of a deleted technique. </summary>
    </member>
    <member name="M:Mogre.CompositorChain._compile">
      <summary>Compile this Composition chain into a series of RenderTarget operations. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.GetPreviousInstance(Mogre.CompositorInstance)">
      <summary>Get the previous instance in this chain to the one specified. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.GetPreviousInstance(Mogre.CompositorInstance,System.Boolean)">
      <summary>Get the previous instance in this chain to the one specified. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.GetNextInstance(Mogre.CompositorInstance)">
      <summary>Get the next instance in this chain to the one specified. </summary>
    </member>
    <member name="M:Mogre.CompositorChain.GetNextInstance(Mogre.CompositorInstance,System.Boolean)">
      <summary>Get the next instance in this chain to the one specified. </summary>
    </member>
    <member name="P:Mogre.CompositorChain.Viewport">
      <summary>Get viewport that is the target of this chain </summary>
    </member>
    <member name="P:Mogre.CompositorChain.NumCompositors">
      <summary>Get the number of compositors. </summary>
    </member>
    <member name="P:Mogre.CompositorChain.BEST">
      <summary>Identifier for best technique. </summary>
    </member>
    <member name="P:Mogre.CompositorChain.LAST">
      <summary>Identifier for "last" compositor in chain. </summary>
    </member>
    <member name="T:Mogre.CompositorInstance">
      <summary>An instance of a Compositor object for one Viewport. It is part of the CompositorChain for a Viewport. </summary>
    </member>
    <member name="M:Mogre.CompositorInstance.GetTextureInstanceName(System.String,System.UInt32)">
      <summary>Get the instance name for a local texture. It is only valid to call this when local textures have been loaded, which in practice means that the compositor instance is active. Calling it at other times will cause an exception. Note that since textures are cleaned up aggressively, this name is not guaranteed to stay the same if you disable and re-enable the compositor instance. The instance name for the texture, corresponds to a real texture </summary>
      <param name="name">The name of the texture in the original compositor definition </param>
      <param name="mrtIndex">If name identifies a MRT, which texture attachment to retrieve </param>
    </member>
    <member name="M:Mogre.CompositorInstance.GetTextureInstance(System.String,System.UInt32)">
      <summary>Get the instance of a local texture. Textures are only valid when local textures have been loaded, which in practice means that the compositor instance is active. Calling this method at other times will return null pointers. Note that since textures are cleaned up aggressively, this pointer is not guaranteed to stay the same if you disable and re-enable the compositor instance. The texture pointer, corresponds to a real texture </summary>
      <param name="name">The name of the texture in the original compositor definition </param>
      <param name="mrtIndex">If name identifies a MRT, which texture attachment to retrieve </param>
    </member>
    <member name="M:Mogre.CompositorInstance.GetRenderTarget(System.String)">
      <summary>Get the render target for a given render texture name. You can use this to add listeners etc, but do not use it to update the targets manually or any other modifications, the compositor instance is in charge of this. </summary>
    </member>
    <member name="M:Mogre.CompositorInstance.SetTechnique(Mogre.CompositionTechnique)">
      <summary>Change the technique we're using to render this compositor. </summary>
      <param name="tech">The technique to use (must be supported and from the same Compositor) </param>
    </member>
    <member name="M:Mogre.CompositorInstance.SetTechnique(Mogre.CompositionTechnique,System.Boolean)">
      <summary>Change the technique we're using to render this compositor. </summary>
      <param name="tech">The technique to use (must be supported and from the same Compositor) </param>
      <param name="reuseTextures">If textures have already been created for the current technique, whether to try to re-use them if sizes &amp; formats match. </param>
    </member>
    <member name="M:Mogre.CompositorInstance.SetScheme(System.String)">
      <summary>Pick a technique to use to render this compositor based on a scheme. If there is no specific supported technique with this scheme name, then the first supported technique with no specific scheme will be used. CompositionTechnique::setSchemeName</summary>
      <param name="schemeName">The scheme to use </param>
    </member>
    <member name="M:Mogre.CompositorInstance.SetScheme(System.String,System.Boolean)">
      <summary>Pick a technique to use to render this compositor based on a scheme. If there is no specific supported technique with this scheme name, then the first supported technique with no specific scheme will be used. CompositionTechnique::setSchemeName</summary>
      <param name="schemeName">The scheme to use </param>
      <param name="reuseTextures">If textures have already been created for the current technique, whether to try to re-use them if sizes &amp; formats match. Note that for this feature to be of benefit, the textures must have been created with the 'pooled' option enabled. </param>
    </member>
    <member name="M:Mogre.CompositorInstance.NotifyResized">
      <summary>Notify this instance that the primary surface has been resized. This will allow the instance to recreate its resources that are dependent on the size. </summary>
    </member>
    <member name="M:Mogre.CompositorInstance._fireNotifyMaterialSetup(System.UInt32,Mogre.MaterialPtr)">
      <summary>Notify listeners of a material compilation. </summary>
    </member>
    <member name="M:Mogre.CompositorInstance._fireNotifyMaterialRender(System.UInt32,Mogre.MaterialPtr)">
      <summary>Notify listeners of a material render. </summary>
    </member>
    <member name="M:Mogre.CompositorInstance._fireNotifyResourcesCreated(System.Boolean)">
      <summary>Notify listeners of a material render. </summary>
    </member>
    <member name="P:Mogre.CompositorInstance.Technique">
      <summary>Get CompositionTechnique used by this instance </summary>
    </member>
    <member name="P:Mogre.CompositorInstance.Scheme">
      <summary>Returns the name of the scheme this compositor is using. </summary>
    </member>
    <member name="P:Mogre.CompositorInstance.Enabled">
      <summary>Sets/Get enabled flag. </summary>
    </member>
    <member name="P:Mogre.CompositorInstance.Compositor">
      <summary>Get Compositor of which this is an instance </summary>
    </member>
    <member name="P:Mogre.CompositorInstance.Chain">
      <summary>Get Chain that this instance is part of </summary>
    </member>
    <member name="E:Mogre.CompositorInstance.NotifyResourcesCreated">
      <summary>Notification after resources have been created (or recreated). </summary>
    </member>
    <member name="E:Mogre.CompositorInstance.NotifyMaterialRender">
      <summary>Notification before a render target operation involving a material (like rendering a quad), so that material parameters can be varied. </summary>
    </member>
    <member name="E:Mogre.CompositorInstance.NotifyMaterialSetup">
      <summary>Notification of when a render target operation involving a material (like rendering a quad) is compiled, so that miscellaneous parameters that are different per Compositor instance can be set up. </summary>
    </member>
    <member name="T:Mogre.CompositorManager">
      <summary>Class for managing Compositor settings for Ogre. Compositors provide the means to flexibly "composite" the final rendering result from multiple scene renders and intermediate operations like rendering fullscreen quads. This makes it possible to apply postfilter effects, HDRI postprocessing, and shadow effects to a Viewport. When loaded from a script, a Compositor is in an 'unloaded' state and only stores the settings required. It does not at that stage load any textures. This is because the material settings may be loaded 'en masse' from bulk material script files, but only a subset will actually be required. Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or archive added to the resource paths/archives. See ResourceManager for details. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.Initialise">
      <summary>Initialises the Compositor manager, which also triggers it to parse all available .compositor scripts. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>ScriptLoader::parseScript</summary>
    </member>
    <member name="M:Mogre.CompositorManager.GetCompositorChain(Mogre.Viewport)">
      <summary>Get the compositor chain for a Viewport. If there is none yet, a new compositor chain is registered. XXX We need a _notifyViewportRemoved to find out when this viewport disappears, so we can destroy its chain as well. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.HasCompositorChain(Mogre.Viewport)">
      <summary>Returns whether exists compositor chain for a viewport. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.RemoveCompositorChain(Mogre.Viewport)">
      <summary>Remove the compositor chain from a viewport if exists. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.AddCompositor(Mogre.Viewport,System.String)">
      <summary>Add a compositor to a viewport. By default, it is added to end of the chain, after the other compositors. pointer to instance, or 0 if it failed. </summary>
      <param name="vp">Viewport to modify </param>
      <param name="compositor">The name of the compositor to apply </param>
    </member>
    <member name="M:Mogre.CompositorManager.AddCompositor(Mogre.Viewport,System.String,System.Int32)">
      <summary>Add a compositor to a viewport. By default, it is added to end of the chain, after the other compositors. pointer to instance, or 0 if it failed. </summary>
      <param name="vp">Viewport to modify </param>
      <param name="compositor">The name of the compositor to apply </param>
      <param name="addPosition">At which position to add, defaults to the end (-1). </param>
    </member>
    <member name="M:Mogre.CompositorManager.RemoveCompositor(Mogre.Viewport,System.String)">
      <summary>Remove a compositor from a viewport </summary>
    </member>
    <member name="M:Mogre.CompositorManager.SetCompositorEnabled(Mogre.Viewport,System.String,System.Boolean)">
      <summary>Set the state of a compositor on a viewport to enabled or disabled. Disabling a compositor stops it from rendering but does not free any resources. This can be more efficient than using removeCompositor and addCompositor in cases the filter is switched on and off a lot. </summary>
    </member>
    <member name="M:Mogre.CompositorManager._getTexturedRectangle2D">
      <summary>Get a textured fullscreen 2D rectangle, for internal use. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.RemoveAll">
      <summary>Overridden from ResourceManager since we have to clean up chains too. </summary>
    </member>
    <member name="M:Mogre.CompositorManager._reconstructAllCompositorResources">
      <summary>Internal method for forcing all active compositors to recreate their resources. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.GetPooledTexture(System.String,System.String,System.UInt32,System.UInt32,Mogre.PixelFormat,System.UInt32,System.String,System.Boolean,Mogre.CompositorManager+UniqueTextureSet,Mogre.CompositorInstance,Mogre.CompositionTechnique+TextureScope)">
      <summary>Utility function to get an existing pooled texture matching a given definition, or creating one if one doesn't exist. It also takes into account whether a pooled texture has already been supplied to this same requester already, in which case it won't give the same texture twice (this is important for example if you request 2 ping-pong textures, you don't want to get the same texture for both requests! </summary>
    </member>
    <member name="M:Mogre.CompositorManager.FreePooledTextures">
      <summary>Free pooled textures from the shared pool (compositor instances still using them will keep them in memory though). </summary>
    </member>
    <member name="M:Mogre.CompositorManager.FreePooledTextures(System.Boolean)">
      <summary>Free pooled textures from the shared pool (compositor instances still using them will keep them in memory though). </summary>
    </member>
    <member name="M:Mogre.CompositorManager._relocateChain(Mogre.Viewport,Mogre.Viewport)">
      <summary>Relocates a compositor chain from one viewport to another </summary>
      <param name="sourceVP">The viewport to take the chain from </param>
      <param name="destVP">The viewport to connect the chain to </param>
    </member>
    <member name="M:Mogre.CompositorManager.RemoveAll">
      <summary>Overridden from ResourceManager since we have to clean up chains too. </summary>
    </member>
    <member name="M:Mogre.CompositorManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>ScriptLoader::parseScript</summary>
    </member>
    <member name="P:Mogre.CompositorManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.ConfigFile">
      <summary>Class for quickly loading settings from a text file. This class is designed to quickly parse a simple file containing key/value pairs, mainly for use in configuration settings. This is a very simplified approach, no multiple values per key are allowed, no grouping or context is being kept etc. By default the key/values pairs are tokenised based on a separator of Tab, the colon (:) or equals (=) character. Each key - value pair must end in a carriage return. Settings can be optionally grouped in sections, using a header beforehand of the form [SectionName]. </summary>
    </member>
    <member name="M:Mogre.ConfigFile.Load(Mogre.DataStreamPtr,System.String,System.Boolean)">
      <summary>load from a data stream </summary>
    </member>
    <member name="M:Mogre.ConfigFile.Load(System.String,System.String,System.String,System.Boolean)">
      <summary>load from a filename (using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.Load(System.String,System.String,System.Boolean)">
      <summary>load from a filename (not using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.LoadDirect(System.String)">
      <summary>load from a filename (not using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.LoadDirect(System.String,System.String)">
      <summary>load from a filename (not using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.LoadDirect(System.String,System.String,System.Boolean)">
      <summary>load from a filename (not using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.LoadFromResourceSystem(System.String,System.String)">
      <summary>load from a filename (using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.LoadFromResourceSystem(System.String,System.String,System.String)">
      <summary>load from a filename (using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.LoadFromResourceSystem(System.String,System.String,System.String,System.Boolean)">
      <summary>load from a filename (using resource group locations) </summary>
    </member>
    <member name="M:Mogre.ConfigFile.GetSetting(System.String)">
      <summary>Gets the first setting from the file with the named key. </summary>
      <param name="key">The name of the setting </param>
    </member>
    <member name="M:Mogre.ConfigFile.GetSetting(System.String,System.String)">
      <summary>Gets the first setting from the file with the named key. </summary>
      <param name="key">The name of the setting </param>
      <param name="section">The name of the section it must be in (if any) </param>
    </member>
    <member name="M:Mogre.ConfigFile.GetSetting(System.String,System.String,System.String)">
      <summary>Gets the first setting from the file with the named key. </summary>
      <param name="key">The name of the setting </param>
      <param name="section">The name of the section it must be in (if any) </param>
      <param name="defaultValue">The value to return if the setting is not found </param>
    </member>
    <member name="M:Mogre.ConfigFile.GetMultiSetting(System.String)">
      <summary>Gets all settings from the file with the named key. </summary>
    </member>
    <member name="M:Mogre.ConfigFile.GetMultiSetting(System.String,System.String)">
      <summary>Gets all settings from the file with the named key. </summary>
    </member>
    <member name="M:Mogre.ConfigFile.GetSectionIterator">
      <summary>Get an iterator over all the available sections in the config file </summary>
    </member>
    <member name="M:Mogre.ConfigFile.GetSettingsIterator">
      <summary>Get an iterator over all the available settings in a section </summary>
    </member>
    <member name="M:Mogre.ConfigFile.GetSettingsIterator(System.String)">
      <summary>Get an iterator over all the available settings in a section </summary>
    </member>
    <member name="M:Mogre.ConfigFile.Clear">
      <summary>Clear the settings </summary>
    </member>
    <member name="T:Mogre.ImageCodec">
      <summary>Codec specialized in images. The users implementing subclasses of ImageCodec are required to return a valid pointer to a ImageData class from the decode(...) function. </summary>
    </member>
    <member name="T:Mogre.DDSCodec">
      <summary>Codec specialized in loading DDS (Direct Draw Surface) images. We implement our own codec here since we need to be able to keep DXT data compressed if the card supports it. </summary>
    </member>
    <member name="M:Mogre.DDSCodec.Code(Mogre.MemoryDataStreamPtr,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input stream and saves the result in the output stream.</summary>
    </member>
    <member name="M:Mogre.DDSCodec.CodeToFile(Mogre.MemoryDataStreamPtr,System.String,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input chunk and saves the result in the output filename provided. Provided for efficiency since coding to memory is progressive therefore memory required is unknown leading to reallocations. inputThe input data outFileNameThe filename to write to pDataExtra information to be passed to the codec (codec type specific)</summary>
    </member>
    <member name="M:Mogre.DDSCodec.Decode(Mogre.DataStreamPtr)">
      <summary>Codes the data from the input chunk into the output chunk. inputStream containing the encoded data Has a variable number of arguments, which depend on the codec type.</summary>
    </member>
    <member name="M:Mogre.DDSCodec.MagicNumberToFileExt(System.SByte*,System.UInt32)">
      <summary>Maps a magic number header to a file extension, if this codec recognises it. magicNumberPtrPointer to a stream of bytes which should identify the file. Note that this may be more than needed - each codec may be looking for a different size magic number. maxbytesThe number of bytes passed A blank string if the magic number was unknown, or a file extension.</summary>
    </member>
    <member name="M:Mogre.DDSCodec.Startup">
      <summary>Static method to startup and register the DDS codec. </summary>
    </member>
    <member name="M:Mogre.DDSCodec.Shutdown">
      <summary>Static method to shutdown and unregister the DDS codec. </summary>
    </member>
    <member name="M:Mogre.DDSCodec.Code(Mogre.MemoryDataStreamPtr,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input stream and saves the result in the output stream.</summary>
    </member>
    <member name="M:Mogre.DDSCodec.CodeToFile(Mogre.MemoryDataStreamPtr,System.String,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input chunk and saves the result in the output filename provided. Provided for efficiency since coding to memory is progressive therefore memory required is unknown leading to reallocations. inputThe input data outFileNameThe filename to write to pDataExtra information to be passed to the codec (codec type specific)</summary>
    </member>
    <member name="M:Mogre.DDSCodec.Decode(Mogre.DataStreamPtr)">
      <summary>Codes the data from the input chunk into the output chunk. inputStream containing the encoded data Has a variable number of arguments, which depend on the codec type.</summary>
    </member>
    <member name="M:Mogre.DDSCodec.MagicNumberToFileExt(System.SByte*,System.UInt32)">
      <summary>Maps a magic number header to a file extension, if this codec recognises it. magicNumberPtrPointer to a stream of bytes which should identify the file. Note that this may be more than needed - each codec may be looking for a different size magic number. maxbytesThe number of bytes passed A blank string if the magic number was unknown, or a file extension.</summary>
    </member>
    <member name="T:Mogre.HardwareIndexBuffer">
      <summary>Specialisation of HardwareBuffer for vertex index buffers, still abstract. </summary>
    </member>
    <member name="P:Mogre.HardwareIndexBuffer.Type">
      <summary>Get the type of indexes used in this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwareIndexBuffer.NumIndexes">
      <summary>Get the number of indexes in this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwareIndexBuffer.Manager">
      <summary>Return the manager of this buffer, if any. </summary>
    </member>
    <member name="P:Mogre.HardwareIndexBuffer.IndexSize">
      <summary>Get the size in bytes of each index. </summary>
    </member>
    <member name="T:Mogre.HardwareIndexBufferSharedPtr">
      <summary>Shared pointer implementation used to share index buffers. </summary>
    </member>
    <member name="T:Mogre.HardwareBufferManagerBase">
      <summary>Base definition of a hardware buffer manager. This class is deliberately not a Singleton, so that multiple types can exist at once. The Singleton is wrapped via the Decorator pattern in HardwareBufferManager, below. Each concrete implementation should provide a subclass of HardwareBufferManagerBase, which does the actual work, and also a very simple subclass of HardwareBufferManager which simply constructs the instance of the HardwareBufferManagerBase subclass and passes it to the HardwareBufferManager superclass as a delegate. This subclass must also delete the implementation instance it creates. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.CreateVertexBuffer(System.UInt32,System.UInt32,Mogre.HardwareBuffer+Usage)">
      <summary>Create a hardware vertex buffer. This method creates a new vertex buffer; this will act as a source of geometry data for rendering objects. Note that because the meaning of the contents of the vertex buffer depends on the usage, this method does not specify a vertex format; the user of this buffer can actually insert whatever data they wish, in any format. However, in order to use this with a RenderOperation, the data in this vertex buffer will have to be associated with a semantic element of the rendering pipeline, e.g. a position, or texture coordinates. This is done using the VertexDeclaration class, which itself contains VertexElement structures referring to the source data. Note that because vertex buffers can be shared, they are reference counted so you do not need to worry about destroying themm this will be done automatically. </summary>
      <param name="vertexSize">The size in bytes of each vertex in this buffer; you must calculate this based on the kind of data you expect to populate this buffer with. </param>
      <param name="numVerts">The number of vertices in this buffer. </param>
      <param name="usage">One or more members of the HardwareBuffer::Usage enumeration; you are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY and useShadowBuffer=true. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.CreateVertexBuffer(System.UInt32,System.UInt32,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Create a hardware vertex buffer. This method creates a new vertex buffer; this will act as a source of geometry data for rendering objects. Note that because the meaning of the contents of the vertex buffer depends on the usage, this method does not specify a vertex format; the user of this buffer can actually insert whatever data they wish, in any format. However, in order to use this with a RenderOperation, the data in this vertex buffer will have to be associated with a semantic element of the rendering pipeline, e.g. a position, or texture coordinates. This is done using the VertexDeclaration class, which itself contains VertexElement structures referring to the source data. Note that because vertex buffers can be shared, they are reference counted so you do not need to worry about destroying themm this will be done automatically. </summary>
      <param name="vertexSize">The size in bytes of each vertex in this buffer; you must calculate this based on the kind of data you expect to populate this buffer with. </param>
      <param name="numVerts">The number of vertices in this buffer. </param>
      <param name="usage">One or more members of the HardwareBuffer::Usage enumeration; you are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY and useShadowBuffer=true. </param>
      <param name="useShadowBuffer">If set to true, this buffer will be 'shadowed' by one stored in system memory rather than GPU or AGP memory. You should set this flag if you intend to read data back from the vertex buffer, because reading data from a buffer in the GPU or AGP memory is very expensive, and is in fact impossible if you specify HBU_WRITE_ONLY for the main buffer. If you use this option, all reads and writes will be done to the shadow buffer, and the shadow buffer will be synchronised with the real buffer at an appropriate time. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.CreateIndexBuffer(Mogre.HardwareIndexBuffer+IndexType,System.UInt32,Mogre.HardwareBuffer+Usage)">
      <summary>Create a hardware index buffer. Note that because buffers can be shared, they are reference counted so you do not need to worry about destroying them this will be done automatically. </summary>
      <param name="itype">The type in index, either 16- or 32-bit, depending on how many vertices you need to be able to address </param>
      <param name="numIndexes">The number of indexes in the buffer </param>
      <param name="usage">One or more members of the HardwareBuffer::Usage enumeration. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.CreateIndexBuffer(Mogre.HardwareIndexBuffer+IndexType,System.UInt32,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Create a hardware index buffer. Note that because buffers can be shared, they are reference counted so you do not need to worry about destroying them this will be done automatically. </summary>
      <param name="itype">The type in index, either 16- or 32-bit, depending on how many vertices you need to be able to address </param>
      <param name="numIndexes">The number of indexes in the buffer </param>
      <param name="usage">One or more members of the HardwareBuffer::Usage enumeration. </param>
      <param name="useShadowBuffer">If set to true, this buffer will be 'shadowed' by one stored in system memory rather than GPU or AGP memory. You should set this flag if you intend to read data back from the index buffer, because reading data from a buffer in the GPU or AGP memory is very expensive, and is in fact impossible if you specify HBU_WRITE_ONLY for the main buffer. If you use this option, all reads and writes will be done to the shadow buffer, and the shadow buffer will be synchronised with the real buffer at an appropriate time. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.CreateRenderToVertexBuffer">
      <summary>Create a render to vertex buffer. The parameters (such as vertex size etc) are determined later and are allocated when needed. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.CreateVertexDeclaration">
      <summary>Creates a new vertex declaration. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.DestroyVertexDeclaration(Mogre.VertexDeclaration)">
      <summary>Destroys a vertex declaration. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.CreateVertexBufferBinding">
      <summary>Creates a new VertexBufferBinding. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.DestroyVertexBufferBinding(Mogre.VertexBufferBinding)">
      <summary>Destroys a VertexBufferBinding. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.RegisterVertexBufferSourceAndCopy(Mogre.HardwareVertexBufferSharedPtr,Mogre.HardwareVertexBufferSharedPtr)">
      <summary>Registers a vertex buffer as a copy of another. This is useful for registering an existing buffer as a temporary buffer which can be allocated just like a copy. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.ReleaseVertexBufferCopy(Mogre.HardwareVertexBufferSharedPtr)">
      <summary>Manually release a vertex buffer copy for others to subsequently use. Only required if the original call to allocateVertexBufferCopy included a licenseType of BLT_MANUAL_RELEASE. </summary>
      <param name="bufferCopy">The buffer copy. The caller is expected to delete or at least no longer use this reference, since another user may well begin to modify the contents of the buffer. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase.TouchVertexBufferCopy(Mogre.HardwareVertexBufferSharedPtr)">
      <summary>Tell engine that the vertex buffer copy intent to reuse. Ogre internal keep an expired delay counter of BLT_AUTOMATIC_RELEASE buffers, when the counter count down to zero, it'll release for other purposes later. But you can use this function to reset the counter to the internal configured value, keep the buffer not get released for some frames. </summary>
      <param name="bufferCopy">The buffer copy. The caller is expected to keep this buffer copy for use. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase._freeUnusedBufferCopies">
      <summary>Free all unused vertex buffer copies. This method free all temporary vertex buffers that not in used. In normally, temporary vertex buffers are subsequently stored and can be made available for other purposes later without incurring the cost of construction / destruction. But in some cases you want to free them to save hardware memory (e.g. application was runs in a long time, you might free temporary buffers periodically to avoid memory overload). </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase._releaseBufferCopies">
      <summary>Internal method for releasing all temporary buffers which have been allocated using BLT_AUTOMATIC_RELEASE; is called by OGRE. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase._releaseBufferCopies(System.Boolean)">
      <summary>Internal method for releasing all temporary buffers which have been allocated using BLT_AUTOMATIC_RELEASE; is called by OGRE. </summary>
      <param name="forceFreeUnused">If true, free all unused temporary buffers. If false, auto detect and free all unused temporary buffers based on temporary buffers utilization. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase._forceReleaseBufferCopies(Mogre.HardwareVertexBuffer)">
      <summary>Internal method that forces the release of copies of a given buffer. This usually means that the buffer which the copies are based on has been changed in some fundamental way, and the owner of the original wishes to make that known so that new copies will reflect the changes. </summary>
      <param name="sourceBuffer">the source buffer as a shared pointer. Any buffer copies created from the source buffer are deleted. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase._forceReleaseBufferCopies(Mogre.HardwareVertexBufferSharedPtr)">
      <summary>Internal method that forces the release of copies of a given buffer. This usually means that the buffer which the copies are based on has been changed in some fundamental way, and the owner of the original wishes to make that known so that new copies will reflect the changes. </summary>
      <param name="sourceBuffer">the source buffer as a shared pointer. Any buffer copies created from the source buffer are deleted. </param>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase._notifyVertexBufferDestroyed(Mogre.HardwareVertexBuffer)">
      <summary>Notification that a hardware vertex buffer has been destroyed. </summary>
    </member>
    <member name="M:Mogre.HardwareBufferManagerBase._notifyIndexBufferDestroyed(Mogre.HardwareIndexBuffer)">
      <summary>Notification that a hardware index buffer has been destroyed. </summary>
    </member>
    <member name="F:Mogre.HardwareBufferManagerBase+BufferLicenseType.BLT_MANUAL_RELEASE">
      <summary>Licensee will only release buffer when it says so. </summary>
    </member>
    <member name="F:Mogre.HardwareBufferManagerBase+BufferLicenseType.BLT_AUTOMATIC_RELEASE">
      <summary>Licensee can have license revoked. </summary>
    </member>
    <member name="T:Mogre.HardwareBufferManager">
      <summary>Singleton wrapper for hardware buffer manager. </summary>
    </member>
    <member name="T:Mogre.DefaultHardwareBufferManagerBase">
      <summary>Specialisation of HardwareBufferManagerBase to emulate hardware buffers. You might want to instantiate this class if you want to utilise classes like MeshSerializer without having initialised the rendering system (which is required to create a 'real' hardware buffer manager. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateVertexBuffer(System.UInt32,System.UInt32,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateVertexBuffer(System.UInt32,System.UInt32,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Creates a vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateIndexBuffer(Mogre.HardwareIndexBuffer+IndexType,System.UInt32,Mogre.HardwareBuffer+Usage)">
      <summary>Create a hardware vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateIndexBuffer(Mogre.HardwareIndexBuffer+IndexType,System.UInt32,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Create a hardware vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateRenderToVertexBuffer">
      <summary>Create a hardware vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateVertexBuffer(System.UInt32,System.UInt32,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateVertexBuffer(System.UInt32,System.UInt32,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Creates a vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateIndexBuffer(Mogre.HardwareIndexBuffer+IndexType,System.UInt32,Mogre.HardwareBuffer+Usage)">
      <summary>Create a hardware vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateIndexBuffer(Mogre.HardwareIndexBuffer+IndexType,System.UInt32,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Create a hardware vertex buffer. </summary>
    </member>
    <member name="M:Mogre.DefaultHardwareBufferManagerBase.CreateRenderToVertexBuffer">
      <summary>Create a hardware vertex buffer. </summary>
    </member>
    <member name="T:Mogre.RenderToVertexBuffer">
      <summary>An object which renders geometry to a vertex. This is especially useful together with geometry shaders, as you can render procedural geometry which will get saved to a vertex buffer for reuse later, without regenerating it again. You can also create shaders that run on previous results of those shaders, creating stateful shaders. </summary>
    </member>
    <member name="M:Mogre.RenderToVertexBuffer.GetRenderOperation(Mogre.RenderOperation)">
      <summary>Get the render operation for this buffer </summary>
    </member>
    <member name="M:Mogre.RenderToVertexBuffer.Update(Mogre.SceneManager)">
      <summary>Update the contents of this vertex buffer by rendering </summary>
    </member>
    <member name="M:Mogre.RenderToVertexBuffer.Reset">
      <summary>Reset the vertex buffer to the initial state. In the next update, the source renderable will be used as input. </summary>
    </member>
    <member name="M:Mogre.RenderToVertexBuffer.GetRenderToBufferMaterial">
      <summary>Get the material which is used to render the geometry into the vertex buffer. </summary>
    </member>
    <member name="M:Mogre.RenderToVertexBuffer.SetRenderToBufferMaterialName(System.String)">
      <summary>Set the material name which is used to render the geometry into the vertex buffer </summary>
    </member>
    <member name="P:Mogre.RenderToVertexBuffer.VertexDeclaration">
      <summary>Get the vertex declaration that the pass will output. Use this object to set the elements of the buffer. Object will calculate buffers on its own. Only one source allowed! </summary>
    </member>
    <member name="P:Mogre.RenderToVertexBuffer.SourceRenderable">
      <summary>Sets/Get the source renderable of this object </summary>
    </member>
    <member name="P:Mogre.RenderToVertexBuffer.ResetsEveryUpdate">
      <summary>Sets/Does this object reset its buffer each time it updates? </summary>
    </member>
    <member name="P:Mogre.RenderToVertexBuffer.OperationType">
      <summary>Sets/What type of primitives does this object generate? </summary>
    </member>
    <member name="P:Mogre.RenderToVertexBuffer.MaxVertexCount">
      <summary>Sets/Get the maximum number of vertices that the buffer will hold </summary>
    </member>
    <member name="T:Mogre.VertexBoneAssignment">
      <summary>Records the assignment of a single vertex to a single bone with the corresponding weight. This simple struct simply holds a vertex index, bone index and weight representing the assignment of a vertex to a bone for skeletal animation. There may be many of these per vertex if blended vertex assignments are allowed. </summary>
    </member>
    <member name="T:Mogre.ProgressiveMesh">
      <summary>This class reduces the complexity of the geometry it is given. This class is dedicated to reducing the number of triangles in a given mesh taking into account seams in both geometry and texture co-ordinates and meshes which have multiple frames. The primary use for this is generating LOD versions of Mesh objects, but it can be used by any geometry provider. The only limitation at the moment is that the provider uses a common vertex buffer for all LODs and one index buffer per LOD. Therefore at the moment this class can only handle indexed geometry. NB the interface of this class will certainly change when compiled vertex buffers are supported. </summary>
    </member>
    <member name="M:Mogre.ProgressiveMesh.AddExtraVertexPositionBuffer(Mogre.VertexData)">
      <summary>Adds an extra vertex position buffer. As well as the main vertex buffer, the client of this class may add extra versions of the vertex buffer which will also be taken into account when the cost of simplifying the mesh is taken into account. This is because the cost of simplifying an animated mesh cannot be calculated from just the reference position, multiple positions needs to be assessed in order to find the best simplification option. DO NOT pass write-only, unshadowed buffers to this method! They will not work. Pass only shadowed buffers, or better yet perform mesh reduction as an offline process using DefaultHardwareBufferManager to manage vertex buffers in system memory. </summary>
    </member>
    <member name="M:Mogre.ProgressiveMesh.Build(System.UInt16,Mogre.ProgressiveMesh+LODFaceList)">
      <summary>Builds the progressive mesh with the specified number of levels. </summary>
      <param name="numLevels">The number of levels to include in the output excluding the full detail version. </param>
      <param name="outList">Pointer to a list of LOD geometry data which will be completed by the application. Each entry is a reduced form of the mesh, in decreasing order of detail. </param>
    </member>
    <member name="M:Mogre.ProgressiveMesh.Build(System.UInt16,Mogre.ProgressiveMesh+LODFaceList,Mogre.ProgressiveMesh+VertexReductionQuota)">
      <summary>Builds the progressive mesh with the specified number of levels. </summary>
      <param name="numLevels">The number of levels to include in the output excluding the full detail version. </param>
      <param name="outList">Pointer to a list of LOD geometry data which will be completed by the application. Each entry is a reduced form of the mesh, in decreasing order of detail. </param>
      <param name="quota">The way to derive the number of vertices removed at each LOD </param>
    </member>
    <member name="M:Mogre.ProgressiveMesh.Build(System.UInt16,Mogre.ProgressiveMesh+LODFaceList,Mogre.ProgressiveMesh+VertexReductionQuota,System.Single)">
      <summary>Builds the progressive mesh with the specified number of levels. </summary>
      <param name="numLevels">The number of levels to include in the output excluding the full detail version. </param>
      <param name="outList">Pointer to a list of LOD geometry data which will be completed by the application. Each entry is a reduced form of the mesh, in decreasing order of detail. </param>
      <param name="quota">The way to derive the number of vertices removed at each LOD </param>
      <param name="reductionValue">Either the proportion of vertices to remove at each level, or a fixed number of vertices to remove at each level, depending on the value of quota </param>
    </member>
    <member name="M:Mogre.ProgressiveMesh.#ctor(Mogre.VertexData,Mogre.IndexData)">
      <summary>Constructor, takes the geometry data and index buffer. DO NOT pass write-only, unshadowed buffers to this method! They will not work. Pass only shadowed buffers, or better yet perform mesh reduction as an offline process using DefaultHardwareBufferManager to manage vertex buffers in system memory. </summary>
    </member>
    <member name="T:Mogre.ProgressiveMesh+VertexReductionQuota">
      <summary>The way to derive the quota of vertices which are reduced at each LOD. </summary>
    </member>
    <member name="F:Mogre.ProgressiveMesh+VertexReductionQuota.VRQ_CONSTANT">
      <summary>A set number of vertices are removed at each reduction. </summary>
    </member>
    <member name="F:Mogre.ProgressiveMesh+VertexReductionQuota.VRQ_PROPORTIONAL">
      <summary>A proportion of the remaining number of vertices are removed at each reduction. </summary>
    </member>
    <member name="M:Mogre.Mesh.CreateSubMesh(System.String)">
      <summary>Creates a new SubMesh and gives it a name </summary>
    </member>
    <member name="M:Mogre.Mesh.CreateSubMesh">
      <summary>Creates a new SubMesh. Method for manually creating geometry for the mesh. Note - use with extreme caution - you must be sure that you have set up the geometry properly. </summary>
    </member>
    <member name="M:Mogre.Mesh.NameSubMesh(System.String,System.UInt16)">
      <summary>Gives a name to a SubMesh</summary>
    </member>
    <member name="M:Mogre.Mesh.UnnameSubMesh(System.String)">
      <summary>Removes a name from a SubMesh</summary>
    </member>
    <member name="M:Mogre.Mesh._getSubMeshIndex(System.String)">
      <summary>Gets the index of a submesh with a given name. Useful if you identify the SubMeshes by name (using nameSubMesh) but wish to have faster repeat access. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetSubMesh(System.String)">
      <summary>Gets a pointer to the submesh indicated by the index. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetSubMesh(System.UInt16)">
      <summary>Gets a pointer to the submesh indicated by the index. </summary>
    </member>
    <member name="M:Mogre.Mesh.DestroySubMesh(System.String)">
      <summary>Destroy a SubMesh with the given name. This will invalidate the contents of any existing Entity, or any other object that is referring to the SubMesh list. Entity will detect this and reinitialise, but it is still a disruptive action. </summary>
    </member>
    <member name="M:Mogre.Mesh.DestroySubMesh(System.UInt16)">
      <summary>Destroy a SubMesh with the given index. This will invalidate the contents of any existing Entity, or any other object that is referring to the SubMesh list. Entity will detect this and reinitialise, but it is still a disruptive action. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetSubMeshIterator">
      <summary>Gets an iterator over the available submeshes. </summary>
    </member>
    <member name="M:Mogre.Mesh.Clone(System.String)">
      <summary>Makes a copy of this mesh object and gives it a new name. This is useful if you want to tweak an existing mesh without affecting the original one. The newly cloned mesh is registered with the MeshManager under the new name. </summary>
      <param name="newName">The name to give the clone </param>
    </member>
    <member name="M:Mogre.Mesh.Clone(System.String,System.String)">
      <summary>Makes a copy of this mesh object and gives it a new name. This is useful if you want to tweak an existing mesh without affecting the original one. The newly cloned mesh is registered with the MeshManager under the new name. </summary>
      <param name="newName">The name to give the clone </param>
      <param name="newGroup">Optional name of the new group to assign the clone to; if you leave this blank, the clone will be assigned to the same group as this Mesh. </param>
    </member>
    <member name="M:Mogre.Mesh._setBounds(Mogre.AxisAlignedBox)">
      <summary>Manually set the bounding box for this Mesh. Calling this method is required when building manual meshes now, because OGRE can no longer update the bounds for you, because it cannot necessarily read vertex data back from the vertex buffers which this mesh uses (they very well might be write-only, and even if they are not, reading data from a hardware buffer is a bottleneck). </summary>
    </member>
    <member name="M:Mogre.Mesh._setBounds(Mogre.AxisAlignedBox,System.Boolean)">
      <summary>Manually set the bounding box for this Mesh. Calling this method is required when building manual meshes now, because OGRE can no longer update the bounds for you, because it cannot necessarily read vertex data back from the vertex buffers which this mesh uses (they very well might be write-only, and even if they are not, reading data from a hardware buffer is a bottleneck). </summary>
      <param name="pad">If true, a certain padding will be added to the bounding box to separate it from the mesh </param>
    </member>
    <member name="M:Mogre.Mesh._setBoundingSphereRadius(System.Single)">
      <summary>Manually set the bounding radius. Calling this method is required when building manual meshes now, because OGRE can no longer update the bounds for you, because it cannot necessarily read vertex data back from the vertex buffers which this mesh uses (they very well might be write-only, and even if they are not, reading data from a hardware buffer is a bottleneck). </summary>
    </member>
    <member name="M:Mogre.Mesh.GetSkeleton">
      <summary>Gets a pointer to any linked Skeleton. Weak reference to the skeleton - copy this if you want to hold a strong pointer. </summary>
    </member>
    <member name="M:Mogre.Mesh._initAnimationState(Mogre.AnimationStateSet)">
      <summary>Initialise an animation set suitable for use with this mesh. Only recommended for use inside the engine, not by applications. </summary>
    </member>
    <member name="M:Mogre.Mesh._refreshAnimationState(Mogre.AnimationStateSet)">
      <summary>Refresh an animation set suitable for use with this mesh. Only recommended for use inside the engine, not by applications. </summary>
    </member>
    <member name="M:Mogre.Mesh.AddBoneAssignment(Mogre.VertexBoneAssignment)">
      <summary>Assigns a vertex to a bone with a given weight, for skeletal animation. This method is only valid after calling setSkeletonName. Since this is a one-off process there exists only 'addBoneAssignment' and 'clearBoneAssignments' methods, no 'editBoneAssignment'. You should not need to modify bone assignments during rendering (only the positions of bones) and OGRE reserves the right to do some internal data reformatting of this information, depending on render system requirements. This method is for assigning weights to the shared geometry of the Mesh. To assign weights to the per-SubMesh geometry, see the equivalent methods on SubMesh. </summary>
    </member>
    <member name="M:Mogre.Mesh.ClearBoneAssignments">
      <summary>Removes all bone assignments for this mesh. This method is for modifying weights to the shared geometry of the Mesh. To assign weights to the per-SubMesh geometry, see the equivalent methods on SubMesh. </summary>
    </member>
    <member name="M:Mogre.Mesh._notifySkeleton(Mogre.SkeletonPtr)">
      <summary>Internal notification, used to tell the Mesh which Skeleton to use without loading it. This is only here for unusual situation where you want to manually set up a Skeleton. Best to let OGRE deal with this, don't call it yourself unless you really know what you're doing. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetBoneAssignmentIterator">
      <summary>Gets an iterator for access all bone assignments. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetBoneAssignments">
      <summary>Gets a const reference to the list of bone assignments </summary>
    </member>
    <member name="M:Mogre.Mesh.GenerateLodLevels(Mogre.Mesh+Const_LodValueList,Mogre.ProgressiveMesh+VertexReductionQuota,System.Single)">
      <summary>Automatically generates lower level of detail versions of this mesh for use when a simpler version of the model is acceptable for rendering. There are 2 ways that you can create level-of-detail (LOD) versions of a mesh; the first is to call this method, which does fairly extensive calculations to work out how to simplify the mesh whilst having the minimum affect on the model. The alternative is to actually create simpler versions of the mesh yourself in a modelling tool, and having exported them, tell the 'master' mesh to use these alternative meshes for lower detail versions; this is done by calling the createManualLodLevel method. As well as creating the lower detail versions of the mesh, this method will also associate them with depth values. As soon as an object is at least as far away from the camera as the depth value associated with it's LOD, it will drop to that level of detail. I recommend calling this method before mesh export, not at runtime. </summary>
      <param name="lodValues">A list of lod values indicating the values at which new lods should be generated. These are 'user values', before being potentially transformed by the strategy, so for the distance strategy this is an unsquared distance for example. </param>
      <param name="reductionMethod">The way to determine the number of vertices collapsed per LOD </param>
      <param name="reductionValue">Meaning depends on reductionMethod, typically either the proportion of remaining vertices to collapse or a fixed number of vertices. </param>
    </member>
    <member name="M:Mogre.Mesh.GetLodLevel(System.UInt16)">
      <summary>Gets details of the numbered level of detail entry. </summary>
    </member>
    <member name="M:Mogre.Mesh.CreateManualLodLevel(System.Single,System.String)">
      <summary>Adds a new manual level-of-detail entry to this Mesh. As an alternative to generating lower level of detail versions of a mesh, you can use your own manually modelled meshes as lower level versions. This lets you have complete control over the LOD, and in addition lets you scale down other aspects of the model which cannot be done using the generated method; for example, you could use less detailed materials and / or use less bones in the skeleton if this is an animated mesh. Therefore for complex models you are likely to be better off modelling your LODs yourself and using this method, whilst for models with fairly simple materials and no animation you can just use the generateLodLevels method. </summary>
      <param name="value">The value from which this Lod will apply. </param>
      <param name="meshName">The name of the mesh which will be the lower level detail version. </param>
    </member>
    <member name="M:Mogre.Mesh.CreateManualLodLevel(System.Single,System.String,System.String)">
      <summary>Adds a new manual level-of-detail entry to this Mesh. As an alternative to generating lower level of detail versions of a mesh, you can use your own manually modelled meshes as lower level versions. This lets you have complete control over the LOD, and in addition lets you scale down other aspects of the model which cannot be done using the generated method; for example, you could use less detailed materials and / or use less bones in the skeleton if this is an animated mesh. Therefore for complex models you are likely to be better off modelling your LODs yourself and using this method, whilst for models with fairly simple materials and no animation you can just use the generateLodLevels method. </summary>
      <param name="value">The value from which this Lod will apply. </param>
      <param name="meshName">The name of the mesh which will be the lower level detail version. </param>
    </member>
    <member name="M:Mogre.Mesh.UpdateManualLodLevel(System.UInt16,System.String)">
      <summary>Changes the alternate mesh to use as a manual LOD at the given index. Note that the index of a LOD may change if you insert other LODs. If in doubt, use getLodIndex(). </summary>
      <param name="index">The index of the level to be changed </param>
      <param name="meshName">The name of the mesh which will be the lower level detail version. </param>
    </member>
    <member name="M:Mogre.Mesh.GetLodIndex(System.Single)">
      <summary>Retrieves the level of detail index for the given lod value. The value passed in is the 'transformed' value. If you are dealing with an original source value (e.g. distance), use LodStrategy::transformUserValue to turn this into a lookup value. </summary>
    </member>
    <member name="M:Mogre.Mesh._setLodInfo(System.UInt16,System.Boolean)">
      <summary>Internal methods for loading LOD, do not use. </summary>
    </member>
    <member name="M:Mogre.Mesh._setLodUsage(System.UInt16,Mogre.MeshLodUsage)">
      <summary>Internal methods for loading LOD, do not use. </summary>
    </member>
    <member name="M:Mogre.Mesh._setSubMeshLodFaceList(System.UInt16,System.UInt16,Mogre.IndexData)">
      <summary>Internal methods for loading LOD, do not use. </summary>
    </member>
    <member name="M:Mogre.Mesh.RemoveLodLevels">
      <summary>Removes all LOD data from this Mesh. </summary>
    </member>
    <member name="M:Mogre.Mesh.SetVertexBufferPolicy(Mogre.HardwareBuffer+Usage)">
      <summary>Sets the policy for the vertex buffers to be used when loading this Mesh. By default, when loading the Mesh, static, write-only vertex and index buffers will be used where possible in order to improve rendering performance. However, such buffers cannot be manipulated on the fly by CPU code (although shader code can). If you wish to use the CPU to modify these buffers, you should call this method. Note, however, that it only takes effect after the Mesh has been reloaded. Note that you still have the option of manually repacing the buffers in this mesh with your own if you see fit too, in which case you don't need to call this method since it only affects buffers created by the mesh itself. You can define the approach to a Mesh by changing the default parameters to MeshManager::load if you wish; this means the Mesh is loaded with those options the first time instead of you having to reload the mesh after changing these options. </summary>
      <param name="usage">The usage flags, which by default are HardwareBuffer::HBU_STATIC_WRITE_ONLY</param>
    </member>
    <member name="M:Mogre.Mesh.SetVertexBufferPolicy(Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Sets the policy for the vertex buffers to be used when loading this Mesh. By default, when loading the Mesh, static, write-only vertex and index buffers will be used where possible in order to improve rendering performance. However, such buffers cannot be manipulated on the fly by CPU code (although shader code can). If you wish to use the CPU to modify these buffers, you should call this method. Note, however, that it only takes effect after the Mesh has been reloaded. Note that you still have the option of manually repacing the buffers in this mesh with your own if you see fit too, in which case you don't need to call this method since it only affects buffers created by the mesh itself. You can define the approach to a Mesh by changing the default parameters to MeshManager::load if you wish; this means the Mesh is loaded with those options the first time instead of you having to reload the mesh after changing these options. </summary>
      <param name="usage">The usage flags, which by default are HardwareBuffer::HBU_STATIC_WRITE_ONLY</param>
      <param name="shadowBuffer">If set to true, the vertex buffers will be created with a system memory shadow buffer. You should set this if you want to be able to read from the buffer, because reading from a hardware buffer is a no-no. </param>
    </member>
    <member name="M:Mogre.Mesh.SetIndexBufferPolicy(Mogre.HardwareBuffer+Usage)">
      <summary>Sets the policy for the index buffers to be used when loading this Mesh. By default, when loading the Mesh, static, write-only vertex and index buffers will be used where possible in order to improve rendering performance. However, such buffers cannot be manipulated on the fly by CPU code (although shader code can). If you wish to use the CPU to modify these buffers, you should call this method. Note, however, that it only takes effect after the Mesh has been reloaded. Note that you still have the option of manually repacing the buffers in this mesh with your own if you see fit too, in which case you don't need to call this method since it only affects buffers created by the mesh itself. You can define the approach to a Mesh by changing the default parameters to MeshManager::load if you wish; this means the Mesh is loaded with those options the first time instead of you having to reload the mesh after changing these options. </summary>
      <param name="usage">The usage flags, which by default are HardwareBuffer::HBU_STATIC_WRITE_ONLY</param>
    </member>
    <member name="M:Mogre.Mesh.SetIndexBufferPolicy(Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Sets the policy for the index buffers to be used when loading this Mesh. By default, when loading the Mesh, static, write-only vertex and index buffers will be used where possible in order to improve rendering performance. However, such buffers cannot be manipulated on the fly by CPU code (although shader code can). If you wish to use the CPU to modify these buffers, you should call this method. Note, however, that it only takes effect after the Mesh has been reloaded. Note that you still have the option of manually repacing the buffers in this mesh with your own if you see fit too, in which case you don't need to call this method since it only affects buffers created by the mesh itself. You can define the approach to a Mesh by changing the default parameters to MeshManager::load if you wish; this means the Mesh is loaded with those options the first time instead of you having to reload the mesh after changing these options. </summary>
      <param name="usage">The usage flags, which by default are HardwareBuffer::HBU_STATIC_WRITE_ONLY</param>
      <param name="shadowBuffer">If set to true, the index buffers will be created with a system memory shadow buffer. You should set this if you want to be able to read from the buffer, because reading from a hardware buffer is a no-no. </param>
    </member>
    <member name="M:Mogre.Mesh._rationaliseBoneAssignments(System.UInt32,Mogre.Mesh+VertexBoneAssignmentList)">
      <summary>Rationalises the passed in bone assignment list. OGRE supports up to 4 bone assignments per vertex. The reason for this limit is that this is the maximum number of assignments that can be passed into a hardware-assisted blending algorithm. This method identifies where there are more than 4 bone assignments for a given vertex, and eliminates the bone assignments with the lowest weights to reduce to this limit. The remaining weights are then re-balanced to ensure that they sum to 1.0. The maximum number of bone assignments per vertex found, clamped to [1-4] </summary>
      <param name="vertexCount">The number of vertices. </param>
      <param name="assignments">The bone assignment list to rationalise. This list will be modified and entries will be removed where the limits are exceeded. </param>
    </member>
    <member name="M:Mogre.Mesh._compileBoneAssignments">
      <summary>Internal method, be called once to compile bone assignments into geometry buffer. The OGRE engine calls this method automatically. It compiles the information submitted as bone assignments into a format usable in realtime. It also eliminates excessive bone assignments (max is OGRE_MAX_BLEND_WEIGHTS) and re-normalises the remaining assignments. </summary>
    </member>
    <member name="M:Mogre.Mesh._updateCompiledBoneAssignments">
      <summary>Internal method, be called once to update the compiled bone assignments. The OGRE engine calls this method automatically. It updates the compiled bone assignments if requested. </summary>
    </member>
    <member name="M:Mogre.Mesh.BuildTangentVectors">
      <summary>This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. Tangent vectors are vectors representing the local 'X' axis for a given vertex based on the orientation of the 2D texture on the geometry. They are built from a combination of existing normals, and from the 2D texture coordinates already baked into the model. They can be used for a number of things, but most of all they are useful for vertex and fragment programs, when you wish to arrive at a common space for doing per-pixel calculations. The prerequisites for calling this method include that the vertex data used by every SubMesh has both vertex normals and 2D texture coordinates. TangentSpaceCalc::setSplitMirroredsplitRotatedSets whether or not to split vertices when a rotated tangent space is detected.TangentSpaceCalc::setSplitRotatedstoreParityInWIf true, store tangents as a 4-vector and include parity in w </summary>
    </member>
    <member name="M:Mogre.Mesh.BuildTangentVectors(Mogre.VertexElementSemantic)">
      <summary>This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. Tangent vectors are vectors representing the local 'X' axis for a given vertex based on the orientation of the 2D texture on the geometry. They are built from a combination of existing normals, and from the 2D texture coordinates already baked into the model. They can be used for a number of things, but most of all they are useful for vertex and fragment programs, when you wish to arrive at a common space for doing per-pixel calculations. The prerequisites for calling this method include that the vertex data used by every SubMesh has both vertex normals and 2D texture coordinates. TangentSpaceCalc::setSplitMirroredsplitRotatedSets whether or not to split vertices when a rotated tangent space is detected.TangentSpaceCalc::setSplitRotatedstoreParityInWIf true, store tangents as a 4-vector and include parity in w </summary>
      <param name="targetSemantic">The semantic to store the tangents in. Defaults to the explicit tangent binding, but note that this is only usable on more modern hardware (Shader Model 2), so if you need portability with older cards you should change this to a texture coordinate binding instead. </param>
    </member>
    <member name="M:Mogre.Mesh.BuildTangentVectors(Mogre.VertexElementSemantic,System.UInt16)">
      <summary>This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. Tangent vectors are vectors representing the local 'X' axis for a given vertex based on the orientation of the 2D texture on the geometry. They are built from a combination of existing normals, and from the 2D texture coordinates already baked into the model. They can be used for a number of things, but most of all they are useful for vertex and fragment programs, when you wish to arrive at a common space for doing per-pixel calculations. The prerequisites for calling this method include that the vertex data used by every SubMesh has both vertex normals and 2D texture coordinates. TangentSpaceCalc::setSplitMirroredsplitRotatedSets whether or not to split vertices when a rotated tangent space is detected.TangentSpaceCalc::setSplitRotatedstoreParityInWIf true, store tangents as a 4-vector and include parity in w </summary>
      <param name="targetSemantic">The semantic to store the tangents in. Defaults to the explicit tangent binding, but note that this is only usable on more modern hardware (Shader Model 2), so if you need portability with older cards you should change this to a texture coordinate binding instead. </param>
      <param name="sourceTexCoordSet">The texture coordinate index which should be used as the source of 2D texture coordinates, with which to calculate the tangents. </param>
    </member>
    <member name="M:Mogre.Mesh.BuildTangentVectors(Mogre.VertexElementSemantic,System.UInt16,System.UInt16)">
      <summary>This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. Tangent vectors are vectors representing the local 'X' axis for a given vertex based on the orientation of the 2D texture on the geometry. They are built from a combination of existing normals, and from the 2D texture coordinates already baked into the model. They can be used for a number of things, but most of all they are useful for vertex and fragment programs, when you wish to arrive at a common space for doing per-pixel calculations. The prerequisites for calling this method include that the vertex data used by every SubMesh has both vertex normals and 2D texture coordinates. TangentSpaceCalc::setSplitMirroredsplitRotatedSets whether or not to split vertices when a rotated tangent space is detected.TangentSpaceCalc::setSplitRotatedstoreParityInWIf true, store tangents as a 4-vector and include parity in w </summary>
      <param name="targetSemantic">The semantic to store the tangents in. Defaults to the explicit tangent binding, but note that this is only usable on more modern hardware (Shader Model 2), so if you need portability with older cards you should change this to a texture coordinate binding instead. </param>
      <param name="sourceTexCoordSet">The texture coordinate index which should be used as the source of 2D texture coordinates, with which to calculate the tangents. </param>
      <param name="index">The element index, ie the texture coordinate set which should be used to store the 3D coordinates representing a tangent vector per vertex, if targetSemantic is VES_TEXTURE_COORDINATES. If this already exists, it will be overwritten. </param>
    </member>
    <member name="M:Mogre.Mesh.BuildTangentVectors(Mogre.VertexElementSemantic,System.UInt16,System.UInt16,System.Boolean)">
      <summary>This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. Tangent vectors are vectors representing the local 'X' axis for a given vertex based on the orientation of the 2D texture on the geometry. They are built from a combination of existing normals, and from the 2D texture coordinates already baked into the model. They can be used for a number of things, but most of all they are useful for vertex and fragment programs, when you wish to arrive at a common space for doing per-pixel calculations. The prerequisites for calling this method include that the vertex data used by every SubMesh has both vertex normals and 2D texture coordinates. TangentSpaceCalc::setSplitMirroredsplitRotatedSets whether or not to split vertices when a rotated tangent space is detected.TangentSpaceCalc::setSplitRotatedstoreParityInWIf true, store tangents as a 4-vector and include parity in w </summary>
      <param name="targetSemantic">The semantic to store the tangents in. Defaults to the explicit tangent binding, but note that this is only usable on more modern hardware (Shader Model 2), so if you need portability with older cards you should change this to a texture coordinate binding instead. </param>
      <param name="sourceTexCoordSet">The texture coordinate index which should be used as the source of 2D texture coordinates, with which to calculate the tangents. </param>
      <param name="index">The element index, ie the texture coordinate set which should be used to store the 3D coordinates representing a tangent vector per vertex, if targetSemantic is VES_TEXTURE_COORDINATES. If this already exists, it will be overwritten. </param>
      <param name="splitMirrored">Sets whether or not to split vertices when a mirrored tangent space transition is detected (matrix parity differs).</param>
    </member>
    <member name="M:Mogre.Mesh.BuildTangentVectors(Mogre.VertexElementSemantic,System.UInt16,System.UInt16,System.Boolean,System.Boolean)">
      <summary>This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. Tangent vectors are vectors representing the local 'X' axis for a given vertex based on the orientation of the 2D texture on the geometry. They are built from a combination of existing normals, and from the 2D texture coordinates already baked into the model. They can be used for a number of things, but most of all they are useful for vertex and fragment programs, when you wish to arrive at a common space for doing per-pixel calculations. The prerequisites for calling this method include that the vertex data used by every SubMesh has both vertex normals and 2D texture coordinates. TangentSpaceCalc::setSplitMirroredsplitRotatedSets whether or not to split vertices when a rotated tangent space is detected.TangentSpaceCalc::setSplitRotatedstoreParityInWIf true, store tangents as a 4-vector and include parity in w </summary>
      <param name="targetSemantic">The semantic to store the tangents in. Defaults to the explicit tangent binding, but note that this is only usable on more modern hardware (Shader Model 2), so if you need portability with older cards you should change this to a texture coordinate binding instead. </param>
      <param name="sourceTexCoordSet">The texture coordinate index which should be used as the source of 2D texture coordinates, with which to calculate the tangents. </param>
      <param name="index">The element index, ie the texture coordinate set which should be used to store the 3D coordinates representing a tangent vector per vertex, if targetSemantic is VES_TEXTURE_COORDINATES. If this already exists, it will be overwritten. </param>
      <param name="splitMirrored">Sets whether or not to split vertices when a mirrored tangent space transition is detected (matrix parity differs).</param>
    </member>
    <member name="M:Mogre.Mesh.BuildTangentVectors(Mogre.VertexElementSemantic,System.UInt16,System.UInt16,System.Boolean,System.Boolean,System.Boolean)">
      <summary>This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. Tangent vectors are vectors representing the local 'X' axis for a given vertex based on the orientation of the 2D texture on the geometry. They are built from a combination of existing normals, and from the 2D texture coordinates already baked into the model. They can be used for a number of things, but most of all they are useful for vertex and fragment programs, when you wish to arrive at a common space for doing per-pixel calculations. The prerequisites for calling this method include that the vertex data used by every SubMesh has both vertex normals and 2D texture coordinates. TangentSpaceCalc::setSplitMirroredsplitRotatedSets whether or not to split vertices when a rotated tangent space is detected.TangentSpaceCalc::setSplitRotatedstoreParityInWIf true, store tangents as a 4-vector and include parity in w </summary>
      <param name="targetSemantic">The semantic to store the tangents in. Defaults to the explicit tangent binding, but note that this is only usable on more modern hardware (Shader Model 2), so if you need portability with older cards you should change this to a texture coordinate binding instead. </param>
      <param name="sourceTexCoordSet">The texture coordinate index which should be used as the source of 2D texture coordinates, with which to calculate the tangents. </param>
      <param name="index">The element index, ie the texture coordinate set which should be used to store the 3D coordinates representing a tangent vector per vertex, if targetSemantic is VES_TEXTURE_COORDINATES. If this already exists, it will be overwritten. </param>
      <param name="splitMirrored">Sets whether or not to split vertices when a mirrored tangent space transition is detected (matrix parity differs).</param>
    </member>
    <member name="M:Mogre.Mesh.SuggestTangentVectorBuildParams(Mogre.VertexElementSemantic,System.UInt16&amp;,System.UInt16&amp;)">
      <summary>Ask the mesh to suggest parameters to a future buildTangentVectors call, should you wish to use texture coordinates to store the tangents. This helper method will suggest source and destination texture coordinate sets for a call to buildTangentVectors. It will detect when there are inappropriate conditions (such as multiple geometry sets which don't agree). Moreover, it will return 'true' if it detects that there are aleady 3D coordinates in the mesh, and therefore tangents may have been prepared already. </summary>
      <param name="targetSemantic">The semantic you intend to use to store the tangents if they are not already present; most likely options are VES_TEXTURE_COORDINATES or VES_TANGENT; you should use texture coordinates if you want compatibility with older, pre-SM2 graphics cards, and the tangent binding otherwise. </param>
      <param name="outSourceCoordSet">Reference to a source texture coordinate set which will be populated </param>
      <param name="outIndex">Reference to a destination element index (e.g. texture coord set) which will be populated </param>
    </member>
    <member name="M:Mogre.Mesh.BuildEdgeList">
      <summary>Builds an edge list for this mesh, which can be used for generating a shadow volume among other things. </summary>
    </member>
    <member name="M:Mogre.Mesh.FreeEdgeList">
      <summary>Destroys and frees the edge lists this mesh has built. </summary>
    </member>
    <member name="M:Mogre.Mesh.PrepareForShadowVolume">
      <summary>This method prepares the mesh for generating a renderable shadow volume. Preparing a mesh to generate a shadow volume involves firstly ensuring that the vertex buffer containing the positions for the mesh is a standalone vertex buffer, with no other components in it. This method will therefore break apart any existing vertex buffers this mesh holds if position is sharing a vertex buffer. Secondly, it will double the size of this vertex buffer so that there are 2 copies of the position data for the mesh. The first half is used for the original, and the second half is used for the 'extruded' version of the mesh. The vertex count of the main VertexData used to render the mesh will remain the same though, so as not to add any overhead to regular rendering of the object. Both copies of the position are required in one buffer because shadow volumes stretch from the original mesh to the extruded version. Because shadow volumes are rendered in turn, no additional index buffer space is allocated by this method, a shared index buffer allocated by the shadow rendering algorithm is used for addressing this extended vertex buffer. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetEdgeList">
      <summary>Return the edge list for this mesh, building it if required. You must ensure that the Mesh as been prepared for shadow volume rendering if you intend to use this information for that purpose.  The LOD at which to get the edge list, 0 being the highest. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetEdgeList(System.UInt16)">
      <summary>Return the edge list for this mesh, building it if required. You must ensure that the Mesh as been prepared for shadow volume rendering if you intend to use this information for that purpose.  The LOD at which to get the edge list, 0 being the highest. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetSubMeshNameMap">
      <summary>Gets a reference to the optional name assignments of the SubMeshes. </summary>
    </member>
    <member name="M:Mogre.Mesh.CreateAnimation(System.String,System.Single)">
      <summary>Creates a new Animation object for vertex animating this mesh. </summary>
      <param name="name">The name of this animation </param>
      <param name="length">The length of the animation in seconds </param>
    </member>
    <member name="M:Mogre.Mesh.GetAnimation(System.UInt16)">
      <summary>Returns the named vertex Animation object. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetAnimation(System.String)">
      <summary>Returns the named vertex Animation object. </summary>
      <param name="name">The name of the animation </param>
    </member>
    <member name="M:Mogre.Mesh._getAnimationImpl(System.String)">
      <summary>Internal access to the named vertex Animation object - returns null if it does not exist. </summary>
      <param name="name">The name of the animation </param>
    </member>
    <member name="M:Mogre.Mesh.HasAnimation(System.String)">
      <summary>Returns whether this mesh contains the named vertex animation. </summary>
    </member>
    <member name="M:Mogre.Mesh.RemoveAnimation(System.String)">
      <summary>Removes vertex Animation from this mesh. </summary>
    </member>
    <member name="M:Mogre.Mesh.RemoveAllAnimations">
      <summary>Removes all morph Animations from this mesh. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetVertexDataByTrackHandle(System.UInt16)">
      <summary>Gets a pointer to a vertex data element based on a morph animation track handle. 0 means the shared vertex data, 1+ means a submesh vertex data (index+1) </summary>
    </member>
    <member name="M:Mogre.Mesh.UpdateMaterialForAllSubMeshes">
      <summary>Iterates through all submeshes and requests them to apply their texture aliases to the material they use. The submesh will only apply texture aliases to the material if matching texture alias names are found in the material. If a match is found, the submesh will automatically clone the original material and then apply its texture to the new material. This method is normally called by the protected method loadImpl when a mesh if first loaded. </summary>
    </member>
    <member name="M:Mogre.Mesh._determineAnimationTypes">
      <summary>Internal method which, if animation types have not been determined, scans any vertex animations and determines the type for each set of vertex data (cannot have 2 different types). </summary>
    </member>
    <member name="M:Mogre.Mesh._getAnimationTypesDirty">
      <summary>Are the derived animation types out of date? </summary>
    </member>
    <member name="M:Mogre.Mesh.CreatePose(System.UInt16)">
      <summary>Create a new Pose for this mesh or one of its submeshes. A new Pose ready for population </summary>
      <param name="target">The target geometry index; 0 is the shared Mesh geometry, 1+ is the dedicated SubMesh geometry belonging to submesh index + 1. </param>
    </member>
    <member name="M:Mogre.Mesh.CreatePose(System.UInt16,System.String)">
      <summary>Create a new Pose for this mesh or one of its submeshes. A new Pose ready for population </summary>
      <param name="target">The target geometry index; 0 is the shared Mesh geometry, 1+ is the dedicated SubMesh geometry belonging to submesh index + 1. </param>
      <param name="name">Name to give the pose, which is optional </param>
    </member>
    <member name="M:Mogre.Mesh.GetPose(System.String)">
      <summary>Retrieve an existing Pose by name. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetPose(System.UInt16)">
      <summary>Retrieve an existing Pose by index. </summary>
    </member>
    <member name="M:Mogre.Mesh.RemovePose(System.String)">
      <summary>Destroy a pose by name. This will invalidate any animation tracks referring to this pose or those after it. </summary>
    </member>
    <member name="M:Mogre.Mesh.RemovePose(System.UInt16)">
      <summary>Destroy a pose by index. This will invalidate any animation tracks referring to this pose or those after it. </summary>
    </member>
    <member name="M:Mogre.Mesh.RemoveAllPoses">
      <summary>Destroy all poses </summary>
    </member>
    <member name="M:Mogre.Mesh.GetPoseIterator">
      <summary>Get an iterator over all the poses defined. </summary>
    </member>
    <member name="M:Mogre.Mesh.GetPoseList">
      <summary>Get pose list </summary>
    </member>
    <member name="M:Mogre.Mesh.SoftwareVertexMorph(System.Single,Mogre.HardwareVertexBufferSharedPtr,Mogre.HardwareVertexBufferSharedPtr,Mogre.VertexData)">
      <summary>Performs a software vertex morph, of the kind used for morph animation although it can be used for other purposes. This function will linearly interpolate positions between two source buffers, into a third buffer. </summary>
      <param name="t">Parametric distance between the start and end buffer positions </param>
      <param name="b1">Vertex buffer containing VET_FLOAT3 entries for the start positions </param>
      <param name="b2">Vertex buffer containing VET_FLOAT3 entries for the end positions </param>
      <param name="targetVertexData">VertexData destination; assumed to have a separate position buffer already bound, and the number of vertices must agree with the number in start and end </param>
    </member>
    <member name="M:Mogre.Mesh.SoftwareVertexPoseBlend(System.Single,System.Collections.Generic.SortedList`2[[System.UInt32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[Mogre.Vector3, Mogre, Version=1.7.0.0, Culture=neutral, PublicKeyToken=null]],Mogre.VertexData)">
      <summary>Performs a software vertex pose blend, of the kind used for morph animation although it can be used for other purposes. This function will apply a weighted offset to the positions in the incoming vertex data (therefore this is a read/write operation, and if you expect to call it more than once with the same data, then you would be best to suppress hardware uploads of the position buffer for the duration) </summary>
      <param name="weight">Parametric weight to scale the offsets by </param>
      <param name="vertexOffsetMap">Potentially sparse map of vertex index -&gt; offset </param>
      <param name="targetVertexData">VertexData destination; assumed to have a separate position buffer already bound, and the number of vertices must agree with the number in start and end </param>
    </member>
    <member name="M:Mogre.Mesh.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String)">
      <summary>Default constructor - used by MeshManagerDo not call this method directly. </summary>
    </member>
    <member name="M:Mogre.Mesh.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean)">
      <summary>Default constructor - used by MeshManagerDo not call this method directly. </summary>
    </member>
    <member name="M:Mogre.Mesh.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Default constructor - used by MeshManagerDo not call this method directly. </summary>
    </member>
    <member name="P:Mogre.Mesh.VertexBufferUsage">
      <summary>Gets the usage setting for this meshes vertex buffers. </summary>
    </member>
    <member name="P:Mogre.Mesh.SkeletonName">
      <summary>Sets/Gets the name of any linked Skeleton</summary>
    </member>
    <member name="P:Mogre.Mesh.SharedVertexDataAnimationType">
      <summary>Gets the type of vertex animation the shared vertex data of this mesh supports. </summary>
    </member>
    <member name="P:Mogre.Mesh.PoseCount">
      <summary>Get the number of poses. </summary>
    </member>
    <member name="P:Mogre.Mesh.NumSubMeshes">
      <summary>Gets the number of sub meshes which comprise this mesh. </summary>
    </member>
    <member name="P:Mogre.Mesh.NumLodLevels">
      <summary>Returns the number of levels of detail that this mesh supports. This number includes the original model. </summary>
    </member>
    <member name="P:Mogre.Mesh.NumAnimations">
      <summary>Gets the number of morph animations in this mesh. </summary>
    </member>
    <member name="P:Mogre.Mesh.LodStrategy">
      <summary>Sets/Get lod strategy used by this mesh. </summary>
    </member>
    <member name="P:Mogre.Mesh.IsVertexBufferShadowed">
      <summary>Gets whether or not this meshes vertex buffers are shadowed. </summary>
    </member>
    <member name="P:Mogre.Mesh.IsPreparedForShadowVolumes">
      <summary>Returns whether this mesh has already had it's geometry prepared for use in rendering shadow volumes. </summary>
    </member>
    <member name="P:Mogre.Mesh.IsLodManual">
      <summary>Returns true if this mesh is using manual LOD. A mesh can either use automatically generated LOD, or it can use alternative meshes as provided by an artist. A mesh can only use either all manual LODs or all generated LODs, not a mixture of both. </summary>
    </member>
    <member name="P:Mogre.Mesh.IsIndexBufferShadowed">
      <summary>Gets whether or not this meshes index buffers are shadowed. </summary>
    </member>
    <member name="P:Mogre.Mesh.IsEdgeListBuilt">
      <summary>Returns whether this mesh has an attached edge list. </summary>
    </member>
    <member name="P:Mogre.Mesh.IndexBufferUsage">
      <summary>Gets the usage setting for this meshes index buffers. </summary>
    </member>
    <member name="P:Mogre.Mesh.HasVertexAnimation">
      <summary>Returns whether or not this mesh has some kind of vertex animation. </summary>
    </member>
    <member name="P:Mogre.Mesh.HasSkeleton">
      <summary>Returns true if this Mesh has a linked Skeleton. </summary>
    </member>
    <member name="P:Mogre.Mesh.Bounds">
      <summary>Get the axis-aligned bounding box for this mesh. </summary>
    </member>
    <member name="P:Mogre.Mesh.BoundingSphereRadius">
      <summary>Gets the radius of the bounding sphere surrounding this mesh. </summary>
    </member>
    <member name="P:Mogre.Mesh.AutoBuildEdgeLists">
      <summary>Sets/Sets whether or not this Mesh should automatically build edge lists when asked for them, or whether it should never build them if they are not already provided. </summary>
    </member>
    <member name="P:Mogre.Mesh.sharedBlendIndexToBoneIndexMap">
      <summary>Shared index map for translating blend index to bone index. This index map can be shared among multiple submeshes. SubMeshes might not have their own IndexMap, they might share this one. We collect actually used bones of all bone assignments, and build the blend index in 'packed' form, then the range of the blend index in vertex data VES_BLEND_INDICES element is continuous, with no gaps. Thus, by minimising the world matrix array constants passing to GPU, we can support more bones for a mesh when hardware skinning is used. The hardware skinning support limit is applied to each set of vertex data in the mesh, in other words, the hardware skinning support limit is applied only to the actually used bones of each SubMeshes, not all bones across the entire Mesh. Because the blend index is different to the bone index, therefore, we use the index map to translate the blend index to bone index. The use of shared or non-shared index map is determined when model data is converted to the OGRE .mesh format. </summary>
    </member>
    <member name="P:Mogre.Mesh.sharedVertexData">
      <summary>Sets/Shared vertex data. This vertex data can be shared among multiple submeshes. SubMeshes may not have their own VertexData, they may share this one. The use of shared or non-shared buffers is determined when model data is converted to the OGRE .mesh format. </summary>
    </member>
    <member name="T:Mogre.MeshPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to MeshPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.MeshLodUsage">
      <summary>A way of recording the way each LODs is recorded this Mesh. </summary>
    </member>
    <member name="P:Mogre.MeshLodUsage.edgeData">
      <summary>Sets/Edge list for this LOD level (may be derived from manual mesh). </summary>
    </member>
    <member name="P:Mogre.MeshLodUsage.manualMesh">
      <summary>Sets/Hard link to mesh to avoid looking up each time. </summary>
    </member>
    <member name="P:Mogre.MeshLodUsage.manualGroup">
      <summary>Sets/Only relevant if mIsLodManual is true, the name of the group of the alternative mesh. </summary>
    </member>
    <member name="P:Mogre.MeshLodUsage.manualName">
      <summary>Sets/Only relevant if mIsLodManual is true, the name of the alternative mesh to use. </summary>
    </member>
    <member name="P:Mogre.MeshLodUsage.value">
      <summary>Sets/Value used by to determine when this lod applies. May be interpretted differently by different strategies. Transformed from user-supplied values with LodStrategy::transformUserValue. </summary>
    </member>
    <member name="P:Mogre.MeshLodUsage.userValue">
      <summary>Sets/User-supplied values used to determine when th is lod applies. This is required in case the lod strategy changes. </summary>
    </member>
    <member name="T:Mogre.LodStrategy">
      <summary>Strategy for determining level of detail. Generally, to create a new lod strategy, all of the following will need to be implemented: getValueImpl, getBaseValue, transformBias, getIndex, sort, and isSorted. In addition, transformUserValue may be overridden. </summary>
    </member>
    <member name="M:Mogre.LodStrategy.TransformBias(System.Single)">
      <summary>Transform lod bias so it only needs to be multiplied by the lod value. </summary>
    </member>
    <member name="M:Mogre.LodStrategy.TransformUserValue(System.Single)">
      <summary>Transforum user supplied value to internal value. By default, performs no transformation. Do not throw exceptions for invalid values here, as the lod strategy may be changed such that the values become valid. </summary>
    </member>
    <member name="M:Mogre.LodStrategy.GetValue(Mogre.MovableObject,Mogre.Camera)">
      <summary>Compute the lod value for a given movable object relative to a given camera. </summary>
    </member>
    <member name="M:Mogre.LodStrategy.GetIndex(System.Single,Mogre.Material+Const_LodValueList)">
      <summary>Get the index of the lod usage which applies to a given value. </summary>
    </member>
    <member name="M:Mogre.LodStrategy.GetIndex(System.Single,Mogre.Mesh+Const_MeshLodUsageList)">
      <summary>Get the index of the lod usage which applies to a given value. </summary>
    </member>
    <member name="M:Mogre.LodStrategy.Sort(Mogre.Mesh+MeshLodUsageList)">
      <summary>Sort mesh lod usage list from greatest to least detail </summary>
    </member>
    <member name="M:Mogre.LodStrategy.IsSorted(Mogre.Mesh+Const_LodValueList)">
      <summary>Determine if the lod values are sorted from greatest detail to least detail. </summary>
    </member>
    <member name="M:Mogre.LodStrategy.AssertSorted(Mogre.Mesh+Const_LodValueList)">
      <summary>Assert that the lod values are sorted from greatest detail to least detail. </summary>
    </member>
    <member name="P:Mogre.LodStrategy.Name">
      <summary>Get the name of this strategy. </summary>
    </member>
    <member name="P:Mogre.LodStrategy.BaseValue">
      <summary>Get the value of the first (highest) level of detail. </summary>
    </member>
    <member name="T:Mogre.DistanceLodStrategy">
      <summary>Level of detail strategy based on distance from camera. </summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.TransformBias(System.Single)">
      <summary>Transform lod bias so it only needs to be multiplied by the lod value.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.TransformUserValue(System.Single)">
      <summary>Transforum user supplied value to internal value. By default, performs no transformation. Do not throw exceptions for invalid values here, as the lod strategy may be changed such that the values become valid.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.GetIndex(System.Single,Mogre.Material+Const_LodValueList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.GetIndex(System.Single,Mogre.Mesh+Const_MeshLodUsageList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.Sort(Mogre.Mesh+MeshLodUsageList)">
      <summary>Sort mesh lod usage list from greatest to least detail</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.IsSorted(Mogre.Mesh+Const_LodValueList)">
      <summary>Determine if the lod values are sorted from greatest detail to least detail.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.SetReferenceView(System.Single,System.Single,Mogre.Radian)">
      <summary>Sets the reference view upon which the distances were based. This automatically enables use of the reference view. There is no corresponding get method for these values as they are not saved, but used to compute a reference value. </summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.TransformBias(System.Single)">
      <summary>Transform lod bias so it only needs to be multiplied by the lod value.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.TransformUserValue(System.Single)">
      <summary>Transforum user supplied value to internal value. By default, performs no transformation. Do not throw exceptions for invalid values here, as the lod strategy may be changed such that the values become valid.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.GetIndex(System.Single,Mogre.Material+Const_LodValueList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.GetIndex(System.Single,Mogre.Mesh+Const_MeshLodUsageList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.Sort(Mogre.Mesh+MeshLodUsageList)">
      <summary>Sort mesh lod usage list from greatest to least detail</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.IsSorted(Mogre.Mesh+Const_LodValueList)">
      <summary>Determine if the lod values are sorted from greatest detail to least detail.</summary>
    </member>
    <member name="M:Mogre.DistanceLodStrategy.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.DistanceLodStrategy.ReferenceViewEnabled">
      <summary>Sets/Determine if use of the reference view is enabled </summary>
    </member>
    <member name="P:Mogre.DistanceLodStrategy.BaseValue">
      <summary>Get the value of the first (highest) level of detail.</summary>
    </member>
    <member name="T:Mogre.EdgeData">
      <summary>This class contains the information required to describe the edge connectivity of a given set of vertices and indexes. This information is built using the EdgeListBuilder class. Note that for a given mesh, which can be made up of multiple submeshes, there are separate edge lists for when </summary>
    </member>
    <member name="M:Mogre.EdgeData.UpdateTriangleLightFacing(Mogre.Vector4)">
      <summary>Calculate the light facing state of the triangles in this edge list This is normally the first stage of calculating a silhouette, i.e. establishing which tris are facing the light and which are facing away. This state is stored in the 'triangleLightFacings'. </summary>
      <param name="lightPos">4D position of the light in object space, note that for directional lights (which have no position), the w component is 0 and the x/y/z position are the direction. </param>
    </member>
    <member name="M:Mogre.EdgeData.UpdateFaceNormals(System.UInt32,Mogre.HardwareVertexBufferSharedPtr)">
      <summary>Updates the face normals for this edge list based on (changed) position information, useful for animated objects. </summary>
      <param name="vertexSet">The vertex set we are updating </param>
      <param name="positionBuffer">The updated position buffer, must contain ONLY xyz </param>
    </member>
    <member name="P:Mogre.EdgeData.isClosed">
      <summary>Sets/Flag indicate the mesh is manifold. </summary>
    </member>
    <member name="P:Mogre.EdgeData.edgeGroups">
      <summary>All edge groups of this edge list. </summary>
    </member>
    <member name="P:Mogre.EdgeData.triangleLightFacings">
      <summary>Triangle light facing states. It should be 1:1 with triangles. </summary>
    </member>
    <member name="P:Mogre.EdgeData.triangles">
      <summary>Main triangles array, stores all triangles of this edge list. Note that triangles are grouping against edge group. </summary>
    </member>
    <member name="T:Mogre.LogListener">
      <summary>Pure Abstract class, derive this class and register to the Log to listen to log messages </summary>
    </member>
    <member name="T:Mogre.Log">
      <summary>Log class for writing debug/log data to files. 
Should not be used directly, but trough the LogManager class. </summary>
    </member>
    <member name="M:Mogre.Log.LogMessage(System.String)">
      <summary>Log a message to the debugger and to log file (the default is "&lt;code&gt;OGRE.log&lt;/code&gt;"), </summary>
    </member>
    <member name="M:Mogre.Log.LogMessage(System.String,Mogre.LogMessageLevel)">
      <summary>Log a message to the debugger and to log file (the default is "&lt;code&gt;OGRE.log&lt;/code&gt;"), </summary>
    </member>
    <member name="M:Mogre.Log.LogMessage(System.String,Mogre.LogMessageLevel,System.Boolean)">
      <summary>Log a message to the debugger and to log file (the default is "&lt;code&gt;OGRE.log&lt;/code&gt;"), </summary>
    </member>
    <member name="M:Mogre.Log.SetDebugOutputEnabled(System.Boolean)">
      <summary>Enable or disable outputting log messages to the debugger. </summary>
    </member>
    <member name="M:Mogre.Log.SetTimeStampEnabled(System.Boolean)">
      <summary>Enable or disable time stamps. </summary>
    </member>
    <member name="M:Mogre.Log.#ctor(System.String)">
      <summary>Usual constructor - called by LogManager. </summary>
    </member>
    <member name="M:Mogre.Log.#ctor(System.String,System.Boolean)">
      <summary>Usual constructor - called by LogManager. </summary>
    </member>
    <member name="M:Mogre.Log.#ctor(System.String,System.Boolean,System.Boolean)">
      <summary>Usual constructor - called by LogManager. </summary>
    </member>
    <member name="P:Mogre.Log.Name">
      <summary>Return the name of the log. </summary>
    </member>
    <member name="P:Mogre.Log.LogDetail">
      <summary>Sets/Gets the level of the log detail. </summary>
    </member>
    <member name="P:Mogre.Log.IsTimeStampEnabled">
      <summary>Get whether time stamps are printed for this log. </summary>
    </member>
    <member name="P:Mogre.Log.IsFileOutputSuppressed">
      <summary>Get whether file output is suppressed for this log. </summary>
    </member>
    <member name="P:Mogre.Log.IsDebugOutputEnabled">
      <summary>Get whether debug output is enabled for this log. </summary>
    </member>
    <member name="E:Mogre.Log.MessageLogged">
      <summary>This is called whenever the log receives a message and is about to write it out </summary>
    </member>
    <member name="T:Mogre.LogMessageLevel">
      <summary>The importance of a logged message. </summary>
    </member>
    <member name="T:Mogre.LoggingLevel">
      <summary>The level of detail to which the log will go into. </summary>
    </member>
    <member name="T:Mogre.SkeletonInstance">
      <summary>A SkeletonInstance is a single instance of a Skeleton used by a world object. The difference between a Skeleton and a SkeletonInstance is that the Skeleton is the 'master' version much like Mesh is a 'master' version of Entity. Many SkeletonInstance objects can be based on a single Skeleton, and are copies of it when created. Any changes made to this are not reflected in the master copy. The exception is animations; these are shared on the Skeleton itself and may not be modified here. </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetAnimation(System.String)">
      <summary>Returns the named Animation object. </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetAnimation(System.String,Mogre.LinkedSkeletonAnimationSource_NativePtr&amp;)">
      <summary>Returns the named Animation object. </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetAnimation(System.UInt16)">
      <summary>Gets a single animation by index. </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._getAnimationImpl(System.String)">
      <summary>Internal accessor for animations (returns null if animation does not exist). </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._getAnimationImpl(System.String,Mogre.LinkedSkeletonAnimationSource_NativePtr&amp;)">
      <summary>Internal accessor for animations (returns null if animation does not exist). </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.CreateAnimation(System.String,System.Single)">
      <summary>Creates a new Animation object for animating this skeleton. This method updates the reference skeleton, not just this instance! </summary>
      <param name="name">The name of this animation </param>
      <param name="length">The length of the animation in seconds </param>
    </member>
    <member name="M:Mogre.SkeletonInstance.RemoveAnimation(System.String)">
      <summary>Removes an Animation from this skeleton. This method updates the reference skeleton, not just this instance! </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.CreateTagPointOnBone(Mogre.Bone)">
      <summary>Creates a TagPoint ready to be attached to a bone </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.CreateTagPointOnBone(Mogre.Bone,Mogre.Quaternion)">
      <summary>Creates a TagPoint ready to be attached to a bone </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.CreateTagPointOnBone(Mogre.Bone,Mogre.Quaternion,Mogre.Vector3)">
      <summary>Creates a TagPoint ready to be attached to a bone </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.FreeTagPoint(Mogre.TagPoint)">
      <summary>Frees a TagPoint that already attached to a bone </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.AddLinkedSkeletonAnimationSource(System.String)">
      <summary>Allows you to use the animations from another Skeleton object to animate this skeleton. If you have skeletons of identical structure (that means identically named bones with identical handles, and with the same hierarchy), but slightly different proportions or binding poses, you can re-use animations from one in the other. Because animations are actually stored as changes to bones from their bind positions, it's possible to use the same animation data for different skeletons, provided the skeletal structure matches and the 'deltas' stored in the keyframes apply equally well to the other skeletons bind position (so they must be roughly similar, but don't have to be identical). You can use the 'scale' option to adjust the translation and scale keyframes where there are large differences in size between the skeletons. This method takes a skeleton name, rather than a more specific animation name, for two reasons; firstly it allows some validation of compatibility of skeletal structure, and secondly skeletons are the unit of loading. Linking a skeleton to another in this way means that the linkee will be prevented from being destroyed until the linker is destroyed.
You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's animations, and SkeletonB uses SkeletonA's animations. This is because it would set up a circular dependency which would prevent proper unloading - make one of the skeletons the 'master' in this case. skelNameName of the skeleton to link animations from. This skeleton will be loaded immediately if this skeleton is already loaded, otherwise it will be loaded when this skeleton is. scaleA scale factor to apply to translation and scaling elements of the keyframes in the other skeleton when applying the animations to this one. Compensates for skeleton size differences.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.AddLinkedSkeletonAnimationSource(System.String,System.Single)">
      <summary>Allows you to use the animations from another Skeleton object to animate this skeleton. If you have skeletons of identical structure (that means identically named bones with identical handles, and with the same hierarchy), but slightly different proportions or binding poses, you can re-use animations from one in the other. Because animations are actually stored as changes to bones from their bind positions, it's possible to use the same animation data for different skeletons, provided the skeletal structure matches and the 'deltas' stored in the keyframes apply equally well to the other skeletons bind position (so they must be roughly similar, but don't have to be identical). You can use the 'scale' option to adjust the translation and scale keyframes where there are large differences in size between the skeletons. This method takes a skeleton name, rather than a more specific animation name, for two reasons; firstly it allows some validation of compatibility of skeletal structure, and secondly skeletons are the unit of loading. Linking a skeleton to another in this way means that the linkee will be prevented from being destroyed until the linker is destroyed.
You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's animations, and SkeletonB uses SkeletonA's animations. This is because it would set up a circular dependency which would prevent proper unloading - make one of the skeletons the 'master' in this case. skelNameName of the skeleton to link animations from. This skeleton will be loaded immediately if this skeleton is already loaded, otherwise it will be loaded when this skeleton is. scaleA scale factor to apply to translation and scaling elements of the keyframes in the other skeleton when applying the animations to this one. Compensates for skeleton size differences.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.RemoveAllLinkedSkeletonAnimationSources">
      <summary>Remove all links to other skeletons for the purposes of sharing animation.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetLinkedSkeletonAnimationSourceIterator">
      <summary>Get an iterator over the linked skeletons used as animation sources.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._initAnimationState(Mogre.AnimationStateSet)">
      <summary>Initialise an animation set suitable for use with this skeleton. Only recommended for use inside the engine, not by applications.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._refreshAnimationState(Mogre.AnimationStateSet)">
      <summary>Refresh an animation set suitable for use with this skeleton. Only recommended for use inside the engine, not by applications.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.CreateAnimation(System.String,System.Single)">
      <summary>Creates a new Animation object for animating this skeleton. This method updates the reference skeleton, not just this instance! </summary>
      <param name="name">The name of this animation </param>
      <param name="length">The length of the animation in seconds </param>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetAnimation(System.UInt16)">
      <summary>Gets a single animation by index. </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetAnimation(System.String)">
      <summary>Returns the named Animation object. </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetAnimation(System.String,Mogre.LinkedSkeletonAnimationSource_NativePtr&amp;)">
      <summary>Returns the named Animation object. </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._getAnimationImpl(System.String)">
      <summary>Internal accessor for animations (returns null if animation does not exist). </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._getAnimationImpl(System.String,Mogre.LinkedSkeletonAnimationSource_NativePtr&amp;)">
      <summary>Internal accessor for animations (returns null if animation does not exist). </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.RemoveAnimation(System.String)">
      <summary>Removes an Animation from this skeleton. This method updates the reference skeleton, not just this instance! </summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._initAnimationState(Mogre.AnimationStateSet)">
      <summary>Initialise an animation set suitable for use with this skeleton. Only recommended for use inside the engine, not by applications.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance._refreshAnimationState(Mogre.AnimationStateSet)">
      <summary>Refresh an animation set suitable for use with this skeleton. Only recommended for use inside the engine, not by applications.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.AddLinkedSkeletonAnimationSource(System.String)">
      <summary>Allows you to use the animations from another Skeleton object to animate this skeleton. If you have skeletons of identical structure (that means identically named bones with identical handles, and with the same hierarchy), but slightly different proportions or binding poses, you can re-use animations from one in the other. Because animations are actually stored as changes to bones from their bind positions, it's possible to use the same animation data for different skeletons, provided the skeletal structure matches and the 'deltas' stored in the keyframes apply equally well to the other skeletons bind position (so they must be roughly similar, but don't have to be identical). You can use the 'scale' option to adjust the translation and scale keyframes where there are large differences in size between the skeletons. This method takes a skeleton name, rather than a more specific animation name, for two reasons; firstly it allows some validation of compatibility of skeletal structure, and secondly skeletons are the unit of loading. Linking a skeleton to another in this way means that the linkee will be prevented from being destroyed until the linker is destroyed.
You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's animations, and SkeletonB uses SkeletonA's animations. This is because it would set up a circular dependency which would prevent proper unloading - make one of the skeletons the 'master' in this case. skelNameName of the skeleton to link animations from. This skeleton will be loaded immediately if this skeleton is already loaded, otherwise it will be loaded when this skeleton is. scaleA scale factor to apply to translation and scaling elements of the keyframes in the other skeleton when applying the animations to this one. Compensates for skeleton size differences.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.AddLinkedSkeletonAnimationSource(System.String,System.Single)">
      <summary>Allows you to use the animations from another Skeleton object to animate this skeleton. If you have skeletons of identical structure (that means identically named bones with identical handles, and with the same hierarchy), but slightly different proportions or binding poses, you can re-use animations from one in the other. Because animations are actually stored as changes to bones from their bind positions, it's possible to use the same animation data for different skeletons, provided the skeletal structure matches and the 'deltas' stored in the keyframes apply equally well to the other skeletons bind position (so they must be roughly similar, but don't have to be identical). You can use the 'scale' option to adjust the translation and scale keyframes where there are large differences in size between the skeletons. This method takes a skeleton name, rather than a more specific animation name, for two reasons; firstly it allows some validation of compatibility of skeletal structure, and secondly skeletons are the unit of loading. Linking a skeleton to another in this way means that the linkee will be prevented from being destroyed until the linker is destroyed.
You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's animations, and SkeletonB uses SkeletonA's animations. This is because it would set up a circular dependency which would prevent proper unloading - make one of the skeletons the 'master' in this case. skelNameName of the skeleton to link animations from. This skeleton will be loaded immediately if this skeleton is already loaded, otherwise it will be loaded when this skeleton is. scaleA scale factor to apply to translation and scaling elements of the keyframes in the other skeleton when applying the animations to this one. Compensates for skeleton size differences.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.RemoveAllLinkedSkeletonAnimationSources">
      <summary>Remove all links to other skeletons for the purposes of sharing animation.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.GetLinkedSkeletonAnimationSourceIterator">
      <summary>Get an iterator over the linked skeletons used as animation sources.</summary>
    </member>
    <member name="M:Mogre.SkeletonInstance.#ctor(Mogre.SkeletonPtr)">
      <summary>Constructor, don't call directly, this will be created automatically when you create an Entity based on a skeletally animated Mesh. </summary>
    </member>
    <member name="P:Mogre.SkeletonInstance.NumAnimations">
      <summary>Gets the number of animations on this skeleton. </summary>
    </member>
    <member name="P:Mogre.SkeletonInstance.Name">
      <summary>Gets resource name.</summary>
    </member>
    <member name="P:Mogre.SkeletonInstance.Group">
      <summary>Gets the group which this resource is a member of.</summary>
    </member>
    <member name="T:Mogre.SubEntity">
      <summary>Utility class which defines the sub-parts of an Entity. Just as meshes are split into submeshes, an Entity is made up of potentially multiple SubMeshes. These are mainly here to provide the link between the Material which the SubEntity uses (which may be the default Material for the SubMesh or may have been changed for this object) and the SubMesh data. The SubEntity also allows the application some flexibility in the material properties for this section of a particular instance of this Mesh, e.g. tinting the windows on a car model. SubEntity instances are never created manually. They are created at the same time as their parent Entity by the SceneManager method createEntity. </summary>
    </member>
    <member name="M:Mogre.SubEntity.SetMaterialName(System.String)">
      <summary>Sets the name of the Material to be used. By default a SubEntity uses the default Material that the SubMesh uses. This call can alter that so that the Material is different for this instance. </summary>
    </member>
    <member name="M:Mogre.SubEntity.SetMaterialName(System.String,System.String)">
      <summary>Sets the name of the Material to be used. By default a SubEntity uses the default Material that the SubMesh uses. This call can alter that so that the Material is different for this instance. </summary>
    </member>
    <member name="M:Mogre.SubEntity.SetMaterial(Mogre.MaterialPtr)">
      <summary>Sets a Material to be used. By default a SubEntity uses the default Material that the SubMesh uses. This call can alter that so that the Material is different for this instance. </summary>
    </member>
    <member name="M:Mogre.SubEntity.SetVisible(System.Boolean)">
      <summary>Tells this SubEntity whether to be visible or not. </summary>
    </member>
    <member name="M:Mogre.SubEntity.GetMaterial">
      <summary>Overridden - see Renderable. </summary>
    </member>
    <member name="M:Mogre.SubEntity.GetRenderOperation(Mogre.RenderOperation)">
      <summary>Overridden - see Renderable. </summary>
    </member>
    <member name="M:Mogre.SubEntity.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>Overridden - see Renderable. </summary>
    </member>
    <member name="M:Mogre.SubEntity.GetSquaredViewDepth(Mogre.Camera)">
      <summary>Overridden, see Renderable</summary>
    </member>
    <member name="M:Mogre.SubEntity.GetLights">
      <summary>Gets a list of lights, ordered relative to how close they are to this renderable. Directional lights, which have no position, will always be first on this list.</summary>
    </member>
    <member name="M:Mogre.SubEntity._getSkelAnimVertexData">
      <summary>Advanced method to get the temporarily blended vertex information for entities which are software skinned. Internal engine will eliminate software animation if possible, this information is unreliable unless added request for software animation via Entity::addSoftwareAnimationRequest. The positions/normals of the returned vertex data is in object space. </summary>
    </member>
    <member name="M:Mogre.SubEntity._getSoftwareVertexAnimVertexData">
      <summary>Advanced method to get the temporarily blended software morph vertex information Internal engine will eliminate software animation if possible, this information is unreliable unless added request for software animation via Entity::addSoftwareAnimationRequest. The positions/normals of the returned vertex data is in object space. </summary>
    </member>
    <member name="M:Mogre.SubEntity._getHardwareVertexAnimVertexData">
      <summary>Advanced method to get the hardware morph vertex information The positions/normals of the returned vertex data is in object space. </summary>
    </member>
    <member name="M:Mogre.SubEntity._markBuffersUnusedForAnimation">
      <summary>Mark all vertex data as so far unanimated. </summary>
    </member>
    <member name="M:Mogre.SubEntity._markBuffersUsedForAnimation">
      <summary>Mark all vertex data as animated. </summary>
    </member>
    <member name="M:Mogre.SubEntity._getBuffersMarkedForAnimation">
      <summary>Are buffers already marked as vertex animated? </summary>
    </member>
    <member name="M:Mogre.SubEntity._restoreBuffersForUnusedAnimation(System.Boolean)">
      <summary>Internal method to copy original vertex data to the morph structures should there be no active animation in use. </summary>
    </member>
    <member name="M:Mogre.SubEntity._updateCustomGpuParameter(Mogre.GpuProgramParameters+AutoConstantEntry_NativePtr,Mogre.GpuProgramParameters)">
      <summary>Overridden from Renderable to provide some custom behaviour. </summary>
    </member>
    <member name="M:Mogre.SubEntity._invalidateCameraCache">
      <summary>Invalidate the camera distance cache </summary>
    </member>
    <member name="P:Mogre.SubEntity.VertexDataForBinding">
      <summary>Retrieve the VertexData which should be used for GPU binding. </summary>
    </member>
    <member name="P:Mogre.SubEntity.Technique">
      <summary>Overridden - see Renderable. </summary>
    </member>
    <member name="P:Mogre.SubEntity.SubMesh">
      <summary>Accessor method to read mesh data. </summary>
    </member>
    <member name="P:Mogre.SubEntity.Parent">
      <summary>Accessor to get parent Entity</summary>
    </member>
    <member name="P:Mogre.SubEntity.NumWorldTransforms">
      <summary>Overridden - see Renderable. </summary>
    </member>
    <member name="P:Mogre.SubEntity.MaterialName">
      <summary>Gets the name of the Material in use by this instance. </summary>
    </member>
    <member name="P:Mogre.SubEntity.IsVisible">
      <summary>Returns whether or not this SubEntity is supposed to be visible. </summary>
    </member>
    <member name="P:Mogre.SubEntity.CastsShadows">
      <summary>Method which reports whether this renderable would normally cast a shadow. Subclasses should override this if they could have been used to generate a shadow.</summary>
    </member>
    <member name="T:Mogre.TagPoint">
      <summary>A tagged point on a skeleton, which can be used to attach entities to on specific other entities. A Skeleton, like a Mesh, is shared between Entity objects and simply updated as required when it comes to rendering. However there are times when you want to attach another object to an animated entity, and make sure that attachment follows the parent entity's animation (for example, a character holding a gun in his / her hand). This class simply identifies attachment points on a skeleton which can be used to attach child objects. The child objects themselves are not physically attached to this class; as it's name suggests this class just 'tags' the area. The actual child objects are attached to the Entity using the skeleton which has this tag point. Use the Entity::attachMovableObjectToBone method to attach the objects, which creates a new TagPoint on demand. </summary>
    </member>
    <member name="M:Mogre.TagPoint._getFullLocalTransform">
      <summary>Gets the transform of this node just for the skeleton (not entity) </summary>
    </member>
    <member name="M:Mogre.TagPoint.NeedUpdate">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. forceParentUpdateEven if the node thinks it has already told it's parent, tell it anyway</summary>
    </member>
    <member name="M:Mogre.TagPoint.NeedUpdate(System.Boolean)">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. forceParentUpdateEven if the node thinks it has already told it's parent, tell it anyway</summary>
    </member>
    <member name="M:Mogre.TagPoint.UpdateFromParentImpl">
      <summary>Overridden from Node in order to include parent Entity transform. </summary>
    </member>
    <member name="M:Mogre.TagPoint.GetLights">
      <summary>Gets a list of lights, ordered relative to how close they are to this renderable. Directional lights, which have no position, will always be first on this list.</summary>
    </member>
    <member name="M:Mogre.TagPoint.NeedUpdate">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. forceParentUpdateEven if the node thinks it has already told it's parent, tell it anyway</summary>
    </member>
    <member name="M:Mogre.TagPoint.NeedUpdate(System.Boolean)">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. forceParentUpdateEven if the node thinks it has already told it's parent, tell it anyway</summary>
    </member>
    <member name="M:Mogre.TagPoint.NeedUpdate">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. forceParentUpdateEven if the node thinks it has already told it's parent, tell it anyway</summary>
    </member>
    <member name="M:Mogre.TagPoint.NeedUpdate(System.Boolean)">
      <summary>To be called in the event of transform changes to this node that require it's recalculation. This not only tags the node state as being 'dirty', it also requests it's parent to know about it's dirtiness so it will get an update next time. forceParentUpdateEven if the node thinks it has already told it's parent, tell it anyway</summary>
    </member>
    <member name="P:Mogre.TagPoint.ParentEntityTransform">
      <summary>Gets the transform of parent entity. </summary>
    </member>
    <member name="P:Mogre.TagPoint.InheritParentEntityScale">
      <summary>Sets/Returns true if this TagPoint is affected by scaling factors applied to the parent entity. </summary>
    </member>
    <member name="P:Mogre.TagPoint.InheritParentEntityOrientation">
      <summary>Sets/Returns true if this TagPoint is affected by orientation applied to the parent entity. </summary>
    </member>
    <member name="T:Mogre.ExternalTextureSource">
      <summary>IMPORTANT: **Plugins must override default dictionary name!** Base class that texture plugins derive from. Any specific requirements that the plugin needs to have defined before texture/material creation must be define using the stringinterface before calling create defined texture... or it will fail, though, it is up to the plugin to report errors to the log file, or raise an exception if need be. </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.SetFPS(System.Int32)">
      <summary>Sets the frames per second - plugin may or may not use this. </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.SetTextureTecPassStateLevel(System.Int32,System.Int32,System.Int32)">
      <summary>Used for attaching texture to Technique, State, and texture unit layer. </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.GetTextureTecPassStateLevel(System.Int32&amp;,System.Int32&amp;,System.Int32&amp;)">
      <summary>Get currently selected Textute attribs. </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.AddBaseParams">
      <summary>Call from derived classes to ensure the dictionary is setup </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.Initialise">
      <summary>Call this function from manager to init system </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.ShutDown">
      <summary>Shuts down PlugIn </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.CreateDefinedTexture(System.String)">
      <summary>Creates a texture into an already defined material or one that is created new (it's up to plugin to use a material or create one) Before calling, ensure that needed params have been defined via the stringInterface or regular methods </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.CreateDefinedTexture(System.String,System.String)">
      <summary>Creates a texture into an already defined material or one that is created new (it's up to plugin to use a material or create one) Before calling, ensure that needed params have been defined via the stringInterface or regular methods </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.DestroyAdvancedTexture(System.String)">
      <summary>What this destroys is dependent on the plugin... See specific plugin doc to know what is all destroyed (normally, plugins will destroy only what they created, or used directly - ie. just texture unit) </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSource.DestroyAdvancedTexture(System.String,System.String)">
      <summary>What this destroys is dependent on the plugin... See specific plugin doc to know what is all destroyed (normally, plugins will destroy only what they created, or used directly - ie. just texture unit) </summary>
    </member>
    <member name="P:Mogre.ExternalTextureSource.PlugInStringName">
      <summary>Returns the string name of this PlugIn (as set by the PlugIn) </summary>
    </member>
    <member name="P:Mogre.ExternalTextureSource.PlayMode">
      <summary>Sets/Gets currently set play mode. </summary>
    </member>
    <member name="P:Mogre.ExternalTextureSource.InputName">
      <summary>Sets/Gets currently set input file name. </summary>
    </member>
    <member name="P:Mogre.ExternalTextureSource.FPS">
      <summary>Gets currently set frames per second. </summary>
    </member>
    <member name="P:Mogre.ExternalTextureSource.DictionaryStringName">
      <summary>Returns dictionary name </summary>
    </member>
    <member name="T:Mogre.eTexturePlayMode">
      <summary>Enum for type of texture play mode </summary>
    </member>
    <member name="F:Mogre.eTexturePlayMode.TextureEffectPlay_ASAP">
      <summary>Video starts out paused. </summary>
    </member>
    <member name="F:Mogre.eTexturePlayMode.TextureEffectPlay_Looping">
      <summary>Video starts playing as soon as possible. </summary>
    </member>
    <member name="T:Mogre.ExternalTextureSourceManager">
      <summary>Singleton Class which handles the registering and control of texture plugins. The plugins will be mostly controlled via a string interface. </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSourceManager.SetCurrentPlugIn(System.String)">
      <summary>Sets active plugin (ie. "video", "effect", "generic", etc..) </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSourceManager.DestroyAdvancedTexture(System.String)">
      <summary>Calls the destroy method of all registered plugins... Only the owner plugin should perform the destroy action. </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSourceManager.DestroyAdvancedTexture(System.String,System.String)">
      <summary>Calls the destroy method of all registered plugins... Only the owner plugin should perform the destroy action. </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSourceManager.GetExternalTextureSource(System.String)">
      <summary>Returns the plugin which reistered itself with a specific name (eg. "video"), or null if specified plugin not found </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSourceManager.SetExternalTextureSource(System.String,Mogre.ExternalTextureSource)">
      <summary>Called from plugin to register itself </summary>
    </member>
    <member name="M:Mogre.ExternalTextureSourceManager.#ctor">
      <summary>Constructor </summary>
    </member>
    <member name="P:Mogre.ExternalTextureSourceManager.CurrentPlugIn">
      <summary>Returns currently selected plugin, may be null if none selected </summary>
    </member>
    <member name="P:Mogre.ExternalTextureSourceManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.FileSystemArchive">
      <summary>Specialisation of the Archive class to allow reading of files from filesystem folders / directories. </summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Load">
      <summary>Loads the archive. This initializes all the internal data of the class. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Unload">
      <summary>Unloads the archive. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Open(System.String)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Open(System.String,System.Boolean)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Create(System.String)">
      <summary>Create a new file (or overwrite one already there). If the archive is read-only then this method will fail. filenameThe fully qualified name of the file A shared pointer to a DataStream which can be used to read / write the file. </summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.List">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.List(System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.List(System.Boolean,System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.ListFileInfo">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.ListFileInfo(System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.ListFileInfo(System.Boolean,System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Find(System.String)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Find(System.String,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Find(System.String,System.Boolean,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.FindFileInfo(System.String)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.FindFileInfo(System.String,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.FindFileInfo(System.String,System.Boolean,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Exists(System.String)">
      <summary>Find out if the named file exists (note: fully qualified filename required)</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.GetModifiedTime(System.String)">
      <summary>Retrieve the modification time of a given file</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Load">
      <summary>Loads the archive. This initializes all the internal data of the class. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Unload">
      <summary>Unloads the archive. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Open(System.String)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Open(System.String,System.Boolean)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Create(System.String)">
      <summary>Create a new file (or overwrite one already there). If the archive is read-only then this method will fail. filenameThe fully qualified name of the file A shared pointer to a DataStream which can be used to read / write the file. </summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.List">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.List(System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.List(System.Boolean,System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.ListFileInfo">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.ListFileInfo(System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.ListFileInfo(System.Boolean,System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Find(System.String)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Find(System.String,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Find(System.String,System.Boolean,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.Exists(System.String)">
      <summary>Find out if the named file exists (note: fully qualified filename required)</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.GetModifiedTime(System.String)">
      <summary>Retrieve the modification time of a given file</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.FindFileInfo(System.String)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.FindFileInfo(System.String,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.FileSystemArchive.FindFileInfo(System.String,System.Boolean,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="P:Mogre.FileSystemArchive.IsCaseSensitive">
      <summary>Returns whether this archive is case sensitive in the way it matches files.</summary>
    </member>
    <member name="P:Mogre.FileSystemArchive.IgnoreHidden">
      <summary>Sets/Get whether hidden files are ignored during filesystem enumeration. </summary>
    </member>
    <member name="T:Mogre.Font">
      <summary>Class representing a font in the system. This class is simply a way of getting a font texture into the OGRE system and to easily retrieve the texture coordinates required to accurately render them. Fonts can either be loaded from precreated textures, or the texture can be generated using a truetype font. You can either create the texture manually in code, or you can use a .fontdef script to define it (probably more practical since you can reuse the definition more easily) This class extends both Resource and ManualResourceLoader since it is both a resource in it's own right, but it also provides the manual load implementation for the Texture it creates. </summary>
    </member>
    <member name="M:Mogre.Font.GetGlyphTexCoords(System.UInt32)">
      <summary>Returns the texture coordinates of the associated glyph. Parameter is a short to allow both ASCII and wide chars. A rectangle with the UV coordinates, or null UVs if the code point was not present </summary>
      <param name="id">The code point (unicode) </param>
    </member>
    <member name="M:Mogre.Font.SetGlyphTexCoords(System.UInt32,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the texture coordinates of a glyph. You only need to call this if you're setting up a font loaded from a texture manually. Also sets the aspect ratio (width / height) of this character. textureAspect is the width/height of the texture (may be non-square) </summary>
    </member>
    <member name="M:Mogre.Font.GetGlyphAspectRatio(System.UInt32)">
      <summary>Gets the aspect ratio (width / height) of this character. </summary>
    </member>
    <member name="M:Mogre.Font.SetGlyphAspectRatio(System.UInt32,System.Single)">
      <summary>Sets the aspect ratio (width / height) of this character. You only need to call this if you're setting up a font loaded from a texture manually. </summary>
    </member>
    <member name="M:Mogre.Font.GetGlyphInfo(System.UInt32)">
      <summary>Gets the information available for a glyph corresponding to a given code point, or throws an exception if it doesn't exist; </summary>
    </member>
    <member name="M:Mogre.Font.AddCodePointRange(Mogre.Pair`2[[System.UInt32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.UInt32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]])">
      <summary>Adds a range of code points to the list of code point ranges to generate glyphs for, if this is a truetype based font. In order to save texture space, only the glyphs which are actually needed by the application are generated into the texture. Before this object is loaded you must call this method as many times as necessary to define the code point range that you need. </summary>
    </member>
    <member name="M:Mogre.Font.ClearCodePointRanges">
      <summary>Clear the list of code point ranges. </summary>
    </member>
    <member name="M:Mogre.Font.GetCodePointRangeList">
      <summary>Get a const reference to the list of code point ranges to be used to generate glyphs from a truetype font. </summary>
    </member>
    <member name="M:Mogre.Font.GetMaterial">
      <summary>Gets the material generated for this font, as a weak reference. This will only be valid after the Font has been loaded. </summary>
    </member>
    <member name="M:Mogre.Font.LoadResource(Mogre.Resource)">
      <summary>Implementation of ManualResourceLoader::loadResource, called when the Texture that this font creates needs to (re)load. </summary>
    </member>
    <member name="M:Mogre.Font.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String)">
      <summary>Constructor. Resource</summary>
    </member>
    <member name="M:Mogre.Font.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean)">
      <summary>Constructor. Resource</summary>
    </member>
    <member name="M:Mogre.Font.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Constructor. Resource</summary>
    </member>
    <member name="P:Mogre.Font.Type">
      <summary>Sets/Gets the type of font. </summary>
    </member>
    <member name="P:Mogre.Font.TrueTypeSize">
      <summary>Sets/Gets the point size of the font used to generate the texture. Only applicable for FT_TRUETYPE Font objects. Note that the size of the font does not affect how big it is on the screen, just how large it is in the texture and thus how detailed it is. </summary>
    </member>
    <member name="P:Mogre.Font.TrueTypeResolution">
      <summary>Sets/Gets the resolution (dpi) of the font used to generate the texture. Only applicable for FT_TRUETYPE Font objects. </summary>
    </member>
    <member name="P:Mogre.Font.TrueTypeMaxBearingY">
      <summary>Gets the maximum baseline distance of all glyphs used in the texture. Only applicable for FT_TRUETYPE Font objects. The baseline is the vertical origin of horizontal based glyphs. The bearingY attribute is the distance from the baseline (origin) to the top of the glyph's bounding box. This value is only available after the font has been loaded. </summary>
    </member>
    <member name="P:Mogre.Font.Source">
      <summary>Sets/Gets the source this font (either an image or a truetype font). </summary>
    </member>
    <member name="P:Mogre.Font.AntialiasColour">
      <summary>Sets/Gets whether or not the colour of this font is antialiased as it is generated from a true type font. </summary>
    </member>
    <member name="T:Mogre.FontPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to FontPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.FontType">
      <summary>Enumerates the types of Font usable in the engine. </summary>
    </member>
    <member name="F:Mogre.FontType.FT_TRUETYPE">
      <summary>Generated from a truetype (.ttf) font. </summary>
    </member>
    <member name="F:Mogre.FontType.FT_IMAGE">
      <summary>Loaded from an image created by an artist. </summary>
    </member>
    <member name="T:Mogre.FontManager">
      <summary>Manages Font resources, parsing .fontdef files and generally organising them. </summary>
    </member>
    <member name="M:Mogre.FontManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>Parse a script file. streamWeak reference to a data stream which is the source of the script groupNameThe name of a resource group which should be used if any resources are created during the parse of this script.</summary>
    </member>
    <member name="M:Mogre.FontManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>Parse a script file. streamWeak reference to a data stream which is the source of the script groupNameThe name of a resource group which should be used if any resources are created during the parse of this script.</summary>
    </member>
    <member name="P:Mogre.FontManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.FrameEvent">
      <summary>Struct containing information about a frame event. </summary>
    </member>
    <member name="F:Mogre.FrameEvent.timeSinceLastEvent">
      <summary>Elapsed time in seconds since the last event. This gives you time between frame start &amp; frame end, and between frame end and next frame start. This may not be the elapsed time but the average elapsed time between recently fired events. </summary>
    </member>
    <member name="F:Mogre.FrameEvent.timeSinceLastFrame">
      <summary>Elapsed time in seconds since the last event of the same type, i.e. time for a complete frame. This may not be the elapsed time but the average elapsed time between recently fired events of the same type. </summary>
    </member>
    <member name="T:Mogre.FrameListener">
      <summary>A interface class defining a listener which can be used to receive notifications of frame events. A 'listener' is an interface designed to be called back when particular events are called. This class defines the interface relating to frame events. In order to receive notifications of frame events, you should create a subclass of FrameListener and override the methods for which you would like to customise the resulting processing. You should then call Root::addFrameListener passing an instance of this class. There is no limit to the number of frame listeners you can register, allowing you to register multiple listeners for different purposes. Frame events only occur when Ogre is in continuous rendering mode, i.e. after Root::startRendering is called. If the application is doing ad-hoc rendering without entering a rendering loop, frame events are not generated. Note that a frame event occurs once for all rendering targets, not once per target. </summary>
    </member>
    <member name="T:Mogre.MovablePlane">
      <summary>Definition of a Plane that may be attached to a node, and the derived details of it retrieved simply. This plane is not here for rendering purposes, it's to allow you to attach planes to the scene in order to have them move and follow nodes on their own, which is useful if you're using the plane for some kind of calculation, e.g. reflection. </summary>
    </member>
    <member name="M:Mogre.MovablePlane._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObject. </summary>
    </member>
    <member name="M:Mogre.MovablePlane._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObject. </summary>
    </member>
    <member name="M:Mogre.MovablePlane._getDerivedPlane">
      <summary>Get the derived plane as transformed by its parent node. </summary>
    </member>
    <member name="M:Mogre.MovablePlane._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObject. </summary>
    </member>
    <member name="M:Mogre.MovablePlane._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObject. </summary>
    </member>
    <member name="M:Mogre.MovablePlane.#ctor(Mogre.Vector3,System.Single)">
      <summary>Construct a plane through a normal, and a distance to move the plane along the normal. </summary>
    </member>
    <member name="P:Mogre.MovablePlane.MovableType">
      <summary>Overridden from MovableObject. </summary>
    </member>
    <member name="P:Mogre.MovablePlane.BoundingRadius">
      <summary>Overridden from MovableObject. </summary>
    </member>
    <member name="P:Mogre.MovablePlane.BoundingBox">
      <summary>Overridden from MovableObject. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.Load(System.String,System.String,System.String,Mogre.GpuProgramType,System.String)">
      <summary>Loads a GPU program from a file of assembly. This method creates a new program of the type specified as the second parameter. As with all types of ResourceManager, this class will search for the file in all resource locations it has been configured to look in. </summary>
      <param name="name">The name of the GpuProgram</param>
      <param name="groupName">The name of the resource group </param>
      <param name="filename">The file to load </param>
      <param name="gptype">The type of program to create </param>
      <param name="syntaxCode">The name of the syntax to be used for this program e.g. arbvp1, vs_1_1 </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.LoadFromString(System.String,System.String,System.String,Mogre.GpuProgramType,System.String)">
      <summary>Loads a GPU program from a string of assembly code. The assembly code must be compatible with this manager - call the getSupportedSyntax method for details of the supported syntaxes </summary>
      <param name="name">The identifying name to give this program, which can be used to retrieve this program later with getByName. </param>
      <param name="groupName">The name of the resource group </param>
      <param name="code">A string of assembly code which will form the program to run </param>
      <param name="gptype">The type of program to create. </param>
      <param name="syntaxCode">The name of the syntax to be used for this program e.g. arbvp1, vs_1_1 </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.GetSupportedSyntax">
      <summary>Returns the syntaxes that this manager supports. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.IsSyntaxSupported(System.String)">
      <summary>Returns whether a given syntax code (e.g. "ps_1_3", "fp20", "arbvp1") is supported. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.CreateParameters">
      <summary>Creates a new GpuProgramParameters instance which can be used to bind parameters to your programs. Program parameters can be shared between multiple programs if you wish. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.CreateProgram(System.String,System.String,System.String,Mogre.GpuProgramType,System.String)">
      <summary>Create a new, unloaded GpuProgram from a file of assembly. Use this method in preference to the 'load' methods if you wish to define a GpuProgram, but not load it yet; useful for saving memory. This method creates a new program of the type specified as the second parameter. As with all types of ResourceManager, this class will search for the file in all resource locations it has been configured to look in. </summary>
      <param name="name">The name of the program </param>
      <param name="groupName">The name of the resource group </param>
      <param name="filename">The file to load </param>
      <param name="syntaxCode">The name of the syntax to be used for this program e.g. arbvp1, vs_1_1 </param>
      <param name="gptype">The type of program to create </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.CreateProgramFromString(System.String,System.String,System.String,Mogre.GpuProgramType,System.String)">
      <summary>Create a GPU program from a string of assembly code. Use this method in preference to the 'load' methods if you wish to define a GpuProgram, but not load it yet; useful for saving memory. The assembly code must be compatible with this manager - call the getSupportedSyntax method for details of the supported syntaxes </summary>
      <param name="name">The identifying name to give this program, which can be used to retrieve this program later with getByName. </param>
      <param name="groupName">The name of the resource group </param>
      <param name="code">A string of assembly code which will form the program to run </param>
      <param name="gptype">The type of program to create. </param>
      <param name="syntaxCode">The name of the syntax to be used for this program e.g. arbvp1, vs_1_1 </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.Create(System.String,System.String,Mogre.GpuProgramType,System.String)">
      <summary>General create method, using specific create parameters instead of name / value pairs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.Create(System.String,System.String,Mogre.GpuProgramType,System.String,System.Boolean)">
      <summary>General create method, using specific create parameters instead of name / value pairs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.Create(System.String,System.String,Mogre.GpuProgramType,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>General create method, using specific create parameters instead of name / value pairs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.GetByName(System.String)">
      <summary>Overrides the standard ResourceManager getByName method. </summary>
      <param name="name">The name of the program to retrieve </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.GetByName(System.String,System.Boolean)">
      <summary>Overrides the standard ResourceManager getByName method. </summary>
      <param name="name">The name of the program to retrieve </param>
      <param name="preferHighLevelPrograms">If set to true (the default), high level programs will be returned in preference to low-level programs. </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.CreateSharedParameters(System.String)">
      <summary>Create a new set of shared parameters, which can be used across many GpuProgramParameters objects of different structures. </summary>
      <param name="name">The name to give the shared parameters so you can refer to them later. </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.GetSharedParameters(System.String)">
      <summary>Retrieve a set of shared parameters, which can be used across many GpuProgramParameters objects of different structures. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.GetAvailableSharedParameters">
      <summary>Get (const) access to the available shared parameter sets. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.Create(System.String,System.String)">
      <summary>General create method, using specific create parameters instead of name / value pairs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.Create(System.String,System.String,System.Boolean)">
      <summary>General create method, using specific create parameters instead of name / value pairs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.Create(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>General create method, using specific create parameters instead of name / value pairs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.Create(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>General create method, using specific create parameters instead of name / value pairs. </summary>
    </member>
    <member name="M:Mogre.GpuProgramManager.GetByName(System.String)">
      <summary>Overrides the standard ResourceManager getByName method. </summary>
      <param name="name">The name of the program to retrieve </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.GetByName(System.String,System.String)">
      <summary>Overrides the standard ResourceManager getByName method. </summary>
      <param name="name">The name of the program to retrieve </param>
    </member>
    <member name="M:Mogre.GpuProgramManager.Load(System.String,System.String)">
      <summary>Loads a GPU program from a file of assembly. This method creates a new program of the type specified as the second parameter. As with all types of ResourceManager, this class will search for the file in all resource locations it has been configured to look in. </summary>
      <param name="name">The name of the GpuProgram</param>
    </member>
    <member name="M:Mogre.GpuProgramManager.Load(System.String,System.String,System.Boolean)">
      <summary>Loads a GPU program from a file of assembly. This method creates a new program of the type specified as the second parameter. As with all types of ResourceManager, this class will search for the file in all resource locations it has been configured to look in. </summary>
      <param name="name">The name of the GpuProgram</param>
    </member>
    <member name="M:Mogre.GpuProgramManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Loads a GPU program from a file of assembly. This method creates a new program of the type specified as the second parameter. As with all types of ResourceManager, this class will search for the file in all resource locations it has been configured to look in. </summary>
      <param name="name">The name of the GpuProgram</param>
    </member>
    <member name="M:Mogre.GpuProgramManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Loads a GPU program from a file of assembly. This method creates a new program of the type specified as the second parameter. As with all types of ResourceManager, this class will search for the file in all resource locations it has been configured to look in. </summary>
      <param name="name">The name of the GpuProgram</param>
    </member>
    <member name="M:Mogre.GpuProgramManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,System.Boolean)">
      <summary>Loads a GPU program from a file of assembly. This method creates a new program of the type specified as the second parameter. As with all types of ResourceManager, this class will search for the file in all resource locations it has been configured to look in. </summary>
      <param name="name">The name of the GpuProgram</param>
    </member>
    <member name="P:Mogre.GpuProgramManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.HardwareOcclusionQuery">
      <summary>This is a abstract class that that provides the interface for the query class for hardware occlusion.</summary>
    </member>
    <member name="M:Mogre.HardwareOcclusionQuery.BeginOcclusionQuery">
      <summary>Starts the hardware occlusion query Simple usage: Create one or more OcclusionQuery object one per outstanding query or one per tested object OcclusionQuery* m_pOcclusionQuery; createOcclusionQuery( &amp;m_pOcclusionQuery ); In the rendering loop: Draw all occluders m_pOcclusionQuery-&gt;startOcclusionQuery(); Draw the polygons to be tested m_pOcclusionQuery-&gt;endOcclusionQuery();
Results must be pulled using: UINT m_uintNumberOfPixelsVisable; pullOcclusionQuery( &amp;m_dwNumberOfPixelsVisable ); </summary>
    </member>
    <member name="M:Mogre.HardwareOcclusionQuery.EndOcclusionQuery">
      <summary>Ends the hardware occlusion test </summary>
    </member>
    <member name="M:Mogre.HardwareOcclusionQuery.PullOcclusionQuery(System.UInt32&amp;)">
      <summary>Pulls the hardware occlusion query. Waits until the query result is available; use isStillOutstanding if just want to test if the result is available. True if success or false if not. </summary>
      <param name="NumOfFragments">will get the resulting number of fragments. </param>
    </member>
    <member name="P:Mogre.HardwareOcclusionQuery.LastQuerysPixelcount">
      <summary>Let's you get the last pixel count with out doing the hardware occlusion test The last fragment count from the last test. Remarks This function won't give you new values, just the old value. </summary>
    </member>
    <member name="P:Mogre.HardwareOcclusionQuery.IsStillOutstanding">
      <summary>Lets you know when query is done, or still be processed by the Hardware true if query isn't finished. </summary>
    </member>
    <member name="T:Mogre.HardwarePixelBuffer">
      <summary>Specialisation of HardwareBuffer for a pixel buffer. The HardwarePixelbuffer abstracts an 1D, 2D or 3D quantity of pixels stored by the rendering API. The buffer can be located on the card or in main memory depending on its usage. One mipmap level of a texture is an example of a HardwarePixelBuffer. </summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.Lock(System.UInt32,System.UInt32,Mogre.HardwareBuffer+LockOptions)">
      <summary>Lock the buffer for (potentially) reading / writing. offsetThe byte offset from the start of the buffer to lock lengthThe size of the area to lock, in bytes optionsLocking options Pointer to the locked memory</summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.Lock(Mogre.Box,Mogre.HardwareBuffer+LockOptions)">
      <summary>Lock the buffer for (potentially) reading / writing. PixelBox containing the locked region, the pitches and the pixel format </summary>
      <param name="lockBox">Region of the buffer to lock </param>
      <param name="options">Locking options </param>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.ReadData(System.UInt32,System.UInt32,System.Void*)">
      <summary>Reads data from the buffer and places it in the memory pointed to by pDest. offsetThe byte offset from the start of the buffer to read lengthThe size of the area to read, in bytes pDestThe area of memory in which to place the data, must be large enough to accommodate the data!</summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.WriteData(System.UInt32,System.UInt32,System.Void*)">
      <summary>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. offsetThe byte offset from the start of the buffer to start writing lengthThe size of the data to write to, in bytes pSourceThe source of the data to be written discardWholeBufferIf true, this allows the driver to discard the entire buffer when writing, such that DMA stalls can be avoided; use if you can.</summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.WriteData(System.UInt32,System.UInt32,System.Void*,System.Boolean)">
      <summary>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. offsetThe byte offset from the start of the buffer to start writing lengthThe size of the data to write to, in bytes pSourceThe source of the data to be written discardWholeBufferIf true, this allows the driver to discard the entire buffer when writing, such that DMA stalls can be avoided; use if you can.</summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.Blit(Mogre.HardwarePixelBufferSharedPtr)">
      <summary>Copies a box from another PixelBuffer to a region of the this PixelBuffer. The source and destination regions dimensions don't have to match, in which case scaling is done. This scaling is generally done using a bilinear filter in hardware, but it is faster to pass the source image in the right dimensions. Only call this function when both buffers are unlocked. </summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.Blit(Mogre.HardwarePixelBufferSharedPtr,Mogre.Box,Mogre.Box)">
      <summary>Copies a box from another PixelBuffer to a region of the this PixelBuffer. The source and destination regions dimensions don't have to match, in which case scaling is done. This scaling is generally done using a bilinear filter in hardware, but it is faster to pass the source image in the right dimensions. Only call this function when both buffers are unlocked. </summary>
      <param name="srcBox">Image::Box describing the source region in src </param>
      <param name="dstBox">Image::Box describing the destination region in this buffer </param>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.BlitFromMemory(Mogre.PixelBox)">
      <summary>Copies a region from normal memory to a region of this pixelbuffer. The source image can be in any pixel format supported by OGRE, and in any size. The source and destination regions dimensions don't have to match, in which case scaling is done. This scaling is generally done using a bilinear filter in hardware, but it is faster to pass the source image in the right dimensions. Only call this function when the buffer is unlocked. </summary>
      <param name="src">PixelBox containing the source pixels and format in memory </param>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.BlitFromMemory(Mogre.PixelBox,Mogre.Box)">
      <summary>Copies a region from normal memory to a region of this pixelbuffer. The source image can be in any pixel format supported by OGRE, and in any size. The source and destination regions dimensions don't have to match, in which case scaling is done. This scaling is generally done using a bilinear filter in hardware, but it is faster to pass the source image in the right dimensions. Only call this function when the buffer is unlocked. </summary>
      <param name="src">PixelBox containing the source pixels and format in memory </param>
      <param name="dstBox">Image::Box describing the destination region in this buffer </param>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.BlitToMemory(Mogre.PixelBox)">
      <summary>Convience function that blits this entire buffer to a pixelbox. The image is scaled as needed. Only call this function when the buffer is unlocked. </summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.BlitToMemory(Mogre.Box,Mogre.PixelBox)">
      <summary>Copies a region of this pixelbuffer to normal memory. The source and destination regions don't have to match, in which case scaling is done. Only call this function when the buffer is unlocked. </summary>
      <param name="srcBox">Image::Box describing the source region of this buffer </param>
      <param name="dst">PixelBox describing the destination pixels and format in memory </param>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.GetRenderTarget">
      <summary>Get a render target for this PixelBuffer, or a slice of it. The texture this was acquired from must have TU_RENDERTARGET set, otherwise it is possible to render to it and this method will throw an ERR_RENDERSYSTEM exception. A pointer to the render target. This pointer has the lifespan of this PixelBuffer. </summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.GetRenderTarget(System.UInt32)">
      <summary>Get a render target for this PixelBuffer, or a slice of it. The texture this was acquired from must have TU_RENDERTARGET set, otherwise it is possible to render to it and this method will throw an ERR_RENDERSYSTEM exception. A pointer to the render target. This pointer has the lifespan of this PixelBuffer. </summary>
      <param name="slice">Which slice </param>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.Lock(Mogre.HardwareBuffer+LockOptions)">
      <summary>Lock the buffer for (potentially) reading / writing. PixelBox containing the locked region, the pitches and the pixel format </summary>
      <param name="options">Locking options </param>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.Lock(System.UInt32,System.UInt32,Mogre.HardwareBuffer+LockOptions)">
      <summary>Lock the buffer for (potentially) reading / writing. offsetThe byte offset from the start of the buffer to lock lengthThe size of the area to lock, in bytes optionsLocking options Pointer to the locked memory</summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.ReadData(System.UInt32,System.UInt32,System.Void*)">
      <summary>Reads data from the buffer and places it in the memory pointed to by pDest. offsetThe byte offset from the start of the buffer to read lengthThe size of the area to read, in bytes pDestThe area of memory in which to place the data, must be large enough to accommodate the data!</summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.WriteData(System.UInt32,System.UInt32,System.Void*)">
      <summary>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. offsetThe byte offset from the start of the buffer to start writing lengthThe size of the data to write to, in bytes pSourceThe source of the data to be written discardWholeBufferIf true, this allows the driver to discard the entire buffer when writing, such that DMA stalls can be avoided; use if you can.</summary>
    </member>
    <member name="M:Mogre.HardwarePixelBuffer.WriteData(System.UInt32,System.UInt32,System.Void*,System.Boolean)">
      <summary>Writes data to the buffer from an area of system memory; note that you must ensure that your buffer is big enough. offsetThe byte offset from the start of the buffer to start writing lengthThe size of the data to write to, in bytes pSourceThe source of the data to be written discardWholeBufferIf true, this allows the driver to discard the entire buffer when writing, such that DMA stalls can be avoided; use if you can.</summary>
    </member>
    <member name="P:Mogre.HardwarePixelBuffer.Width">
      <summary>Gets the width of this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwarePixelBuffer.Height">
      <summary>Gets the height of this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwarePixelBuffer.Format">
      <summary>Gets the native pixel format of this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwarePixelBuffer.Depth">
      <summary>Gets the depth of this buffer. </summary>
    </member>
    <member name="P:Mogre.HardwarePixelBuffer.CurrentLock">
      <summary>Get the current locked region. This is the same value as returned by lock(const Image::Box, LockOptions) PixelBox containing the locked region </summary>
    </member>
    <member name="T:Mogre.HardwarePixelBufferSharedPtr">
      <summary>Shared pointer implementation used to share pixel buffers. </summary>
    </member>
    <member name="T:Mogre.RenderTexture">
      <summary>This class represents a RenderTarget that renders to a Texture. There is no 1 on 1 relation between Textures and RenderTextures, as there can be multiple RenderTargets rendering to different mipmaps, faces (for cubemaps) or slices (for 3D textures) of the same Texture. </summary>
    </member>
    <member name="T:Mogre.MultiRenderTarget">
      <summary>This class represents a render target that renders to multiple RenderTextures at once. Surfaces can be bound and unbound at will, as long as the following constraints are met:All bound surfaces have the same sizeAll bound surfaces have the same bit depthTarget 0 is bound </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.BindSurface(System.UInt32,Mogre.RenderTexture)">
      <summary>Bind a surface to a certain attachment point. 
It does not bind the surface and fails with an exception (ERR_INVALIDPARAMS) if:Not all bound surfaces have the same sizeNot all bound surfaces have the same internal format </summary>
      <param name="attachment">0 .. mCapabilities-&gt;getNumMultiRenderTargets()-1 </param>
      <param name="target">RenderTexture to bind.</param>
    </member>
    <member name="M:Mogre.MultiRenderTarget.UnbindSurface(System.UInt32)">
      <summary>Unbind attachment. </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.CopyContentsToMemory(Mogre.PixelBox,Mogre.RenderTarget+FrameBuffer)">
      <summary>Error throwing implementation, it's not possible to write a MultiRenderTarget to disk. </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.SuggestPixelFormat">
      <summary>Irrelevant implementation since cannot copy. </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.GetBoundSurfaceList">
      <summary>Get a list of the surfaces which have been bound. </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.GetBoundSurface(System.UInt32)">
      <summary>Get a pointer to a bound surface </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.CopyContentsToMemory(Mogre.PixelBox)">
      <summary>Error throwing implementation, it's not possible to write a MultiRenderTarget to disk. </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.CopyContentsToMemory(Mogre.PixelBox,Mogre.RenderTarget+FrameBuffer)">
      <summary>Error throwing implementation, it's not possible to write a MultiRenderTarget to disk. </summary>
    </member>
    <member name="M:Mogre.MultiRenderTarget.SuggestPixelFormat">
      <summary>Irrelevant implementation since cannot copy. </summary>
    </member>
    <member name="T:Mogre.HighLevelGpuProgram">
      <summary>Abstract base class representing a high-level program (a vertex or fragment program). High-level programs are vertex and fragment programs written in a high-level language such as Cg or HLSL, and as such do not require you to write assembler code like GpuProgram does. However, the high-level program does eventually get converted (compiled) into assembler and then eventually microcode which is what runs on the GPU. As well as the convenience, some high-level languages like Cg allow you to write a program which will operate under both Direct3D and OpenGL, something which you cannot do with just GpuProgram (which requires you to write 2 programs and use each in a Technique to provide cross-API compatibility). Ogre will be creating a GpuProgram for you based on the high-level program, which is compiled specifically for the API being used at the time, but this process is transparent. You cannot create high-level programs direct - use HighLevelGpuProgramManager instead. Plugins can register new implementations of HighLevelGpuProgramFactory in order to add support for new languages without requiring changes to the core Ogre API. To allow custom parameters to be set, this class extends StringInterface - the application can query on the available custom parameters and get/set them without having to link specifically with it. </summary>
    </member>
    <member name="M:Mogre.HighLevelGpuProgram.CreateParameters">
      <summary>Creates a new parameters object compatible with this program definition. Unlike low-level assembly programs, parameters objects are specific to the program and therefore must be created from it rather than by the HighLevelGpuProgramManager. This method creates a new instance of a parameters object containing the definition of the parameters this program understands. </summary>
    </member>
    <member name="M:Mogre.HighLevelGpuProgram.CreateParameters">
      <summary>Creates a new parameters object compatible with this program definition. Unlike low-level assembly programs, parameters objects are specific to the program and therefore must be created from it rather than by the HighLevelGpuProgramManager. This method creates a new instance of a parameters object containing the definition of the parameters this program understands. </summary>
    </member>
    <member name="P:Mogre.HighLevelGpuProgram.NamedConstants">
      <summary>Override GpuProgram::getNamedConstants to ensure built. </summary>
    </member>
    <member name="P:Mogre.HighLevelGpuProgram.ConstantDefinitions">
      <summary>Get the full list of GpuConstantDefinition instances. Only available if this parameters object has named parameters. </summary>
    </member>
    <member name="T:Mogre.HighLevelGpuProgramPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to HighLevelGpuProgramPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.HighLevelGpuProgramManager">
      <summary>This ResourceManager manages high-level vertex and fragment programs. High-level vertex and fragment programs can be used instead of assembler programs as managed by GpuProgramManager; however they typically result in a GpuProgram being created as a derivative of the high-level program. High-level programs are easier to write, and can often be API-independent, unlike assembler programs. This class not only manages the programs themselves, it also manages the factory classes which allow the creation of high-level programs using a variety of high-level syntaxes. Plugins can be created which register themselves as high-level program factories and as such the engine can be extended to accept virtually any kind of program provided a plugin is written. </summary>
    </member>
    <member name="M:Mogre.HighLevelGpuProgramManager.IsLanguageSupported(System.String)">
      <summary>Returns whether a given high-level language is supported. </summary>
    </member>
    <member name="M:Mogre.HighLevelGpuProgramManager.CreateProgram(System.String,System.String,System.String,Mogre.GpuProgramType)">
      <summary>Create a new, unloaded HighLevelGpuProgram. This method creates a new program of the type specified as the second and third parameters. You will have to call further methods on the returned program in order to define the program fully before you can load it. </summary>
      <param name="name">The identifying name of the program </param>
      <param name="groupName">The name of the resource group which this program is to be a member of </param>
      <param name="language">Code of the language to use (e.g. "cg") </param>
      <param name="gptype">The type of program to create </param>
    </member>
    <member name="P:Mogre.HighLevelGpuProgramManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.InstancedGeometry">
      <summary>Pre-transforms and batches up meshes for efficient use as instanced geometry in a scene Shader instancing allows to save both memory and draw calls. While StaticGeometry stores 500 times the same object in a batch to display 500 objects, this shader instancing implementation stores only 80 times the object, and then re-uses the vertex data with different shader parameter. Although you save memory, you make more draw call. However, you still make less draw calls than if you were rendering each object independently. Plus, you can move the batched objects independently of one another which you cannot do with StaticGeometry. Therefore it is important when you are rendering a lot of geometry to batch things up into as few rendering calls as possible. This class allows you to build a batched object from a series of entities in order to benefit from this behaviour. Batching has implications of it's own though: Batched geometry cannot be subdivided; that means that the whole group will be displayed, or none of it will. This obivously has culling issues. A single material must apply for each batch. In fact this class allows you to use multiple materials, but you should be aware that internally this means that there is one batch per material. Therefore you won't gain as much benefit from the batching if you use many different materials; try to keep the number down. The bounding box information is computed whith object position only. It doesn't take account of the object orientation. The LOD settings of both the Mesh and the Materials used in constructing this instanced geometry will be respected. This means that if you use meshes/materials which have LOD, batches in the distance will have a lower polygon count or material detail to those in the foreground. Since each mesh might have different LOD distances, during build the furthest distance at each LOD level from all meshes in that BatchInstance is used. This means all the LOD levels change at the same time, but at the furthest distance of any of them (so quality is not degraded). Be aware that using Mesh LOD in this class will further increase the memory required. Only generated LOD is supported for meshes. There are 2 ways you can add geometry to this class; you can add Entity objects directly with predetermined positions, scales and orientations, or you can add an entire SceneNode and it's subtree, including all the objects attached to it. Once you've added everthing you need to, you have to call build() the fix the geometry in place. You should not construct instances of this class directly; instead, call SceneManager::createInstancedGeometry, which gives the SceneManager the option of providing you with a specialised version of this class if it wishes, and also handles the memory management for you like other classes. Warning: this class only works with indexed triangle lists at the moment, do not pass it triangle strips, fans or lines / points, or unindexed geometry. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.AddEntity(Mogre.Entity,Mogre.Vector3)">
      <summary>Adds an Entity to the static geometry. This method takes an existing Entity and adds its details to the list of elements to include when building. Note that the Entity itself is not copied or referenced in this method; an Entity is passed simply so that you can change the materials of attached SubEntity objects if you want. You can add the same Entity instance multiple times with different material settings completely safely, and destroy the Entity before destroying this InstancedGeometry if you like. The Entity passed in is simply used as a definition. Must be called before 'build'. All added entities must use the same lod strategy. </summary>
      <param name="ent">The Entity to use as a definition (the Mesh and Materials referenced will be recorded for the build call). </param>
      <param name="position">The world position at which to add this Entity</param>
    </member>
    <member name="M:Mogre.InstancedGeometry.AddEntity(Mogre.Entity,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Adds an Entity to the static geometry. This method takes an existing Entity and adds its details to the list of elements to include when building. Note that the Entity itself is not copied or referenced in this method; an Entity is passed simply so that you can change the materials of attached SubEntity objects if you want. You can add the same Entity instance multiple times with different material settings completely safely, and destroy the Entity before destroying this InstancedGeometry if you like. The Entity passed in is simply used as a definition. Must be called before 'build'. All added entities must use the same lod strategy. </summary>
      <param name="ent">The Entity to use as a definition (the Mesh and Materials referenced will be recorded for the build call). </param>
      <param name="position">The world position at which to add this Entity</param>
      <param name="orientation">The world orientation at which to add this Entity</param>
    </member>
    <member name="M:Mogre.InstancedGeometry.AddEntity(Mogre.Entity,Mogre.Vector3,Mogre.Quaternion,Mogre.Vector3)">
      <summary>Adds an Entity to the static geometry. This method takes an existing Entity and adds its details to the list of elements to include when building. Note that the Entity itself is not copied or referenced in this method; an Entity is passed simply so that you can change the materials of attached SubEntity objects if you want. You can add the same Entity instance multiple times with different material settings completely safely, and destroy the Entity before destroying this InstancedGeometry if you like. The Entity passed in is simply used as a definition. Must be called before 'build'. All added entities must use the same lod strategy. </summary>
      <param name="ent">The Entity to use as a definition (the Mesh and Materials referenced will be recorded for the build call). </param>
      <param name="position">The world position at which to add this Entity</param>
      <param name="orientation">The world orientation at which to add this Entity</param>
      <param name="scale">The scale at which to add this entity </param>
    </member>
    <member name="M:Mogre.InstancedGeometry.AddSceneNode(Mogre.SceneNode)">
      <summary>Adds all the Entity objects attached to a SceneNode and all it's children to the static geometry. This method performs just like addEntity, except it adds all the entities attached to an entire sub-tree to the geometry. The position / orientation / scale parameters are taken from the node structure instead of being specified manually. The SceneNode you pass in will not be automatically detached from it's parent, so if you have this node already attached to the scene graph, you will need to remove it if you wish to avoid the overhead of rendering both the original objects and their new static versions! We don't do this for you incase you are preparing this in advance and so don't want the originals detached yet. Must be called before 'build'. All added entities must use the same lod strategy. </summary>
      <param name="node">Pointer to the node to use to provide a set of Entity templates </param>
    </member>
    <member name="M:Mogre.InstancedGeometry.Build">
      <summary>Build the geometry. Based on all the entities which have been added, and the batching options which have been set, this method constructs the batched geometry structures required. The batches are added to the scene and will be rendered unless you specifically hide them. Once you have called this method, you can no longer add any more entities. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.AddBatchInstance">
      <summary>Add a new batch instance This method add a new instance of the whole batch, by creating a new BatchInstance, containing new lod buckets, material buckets and geometry buckets. The new geometry buckets will use the same buffers as the base bucket. no note </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.Destroy">
      <summary>Destroys all the built geometry state (reverse of build). You can call build() again after this and it will pick up all the same entities / nodes you queued last time. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.Reset">
      <summary>Clears any of the entities / nodes added to this geometry and destroys anything which has already been built. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.SetVisible(System.Boolean)">
      <summary>Hides or shows all the batches. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.GetBatchInstanceIterator">
      <summary>Get an iterator over the BatchInstances in this geometry. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.GetRenderOperationVector">
      <summary>get the mRenderOps vector. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.Dump(System.String)">
      <summary>Dump the contents of this InstancedGeometry to a file for diagnostic purposes. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.GetBaseSkeleton">
      <summary>Return the skeleton that is shared by all instanced objects. </summary>
    </member>
    <member name="M:Mogre.InstancedGeometry.#ctor(Mogre.SceneManager,System.String)">
      <summary>Constructor; do not use directly (. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.SquaredRenderingDistance">
      <summary>Gets the squared distance at which batches are no longer rendered. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.RenderQueueGroup">
      <summary>Sets/Gets the queue group for this entity, see setRenderQueueGroup for full details. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.RenderingDistance">
      <summary>Sets/Gets the distance at which batches are no longer rendered. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.ProvideWorldInverses">
      <summary>Sets/Returns the toggle state indicating whether the World Transform INVERSE matrices would be passed to the shaders. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.Origin">
      <summary>Sets/Gets the origin of this geometry. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.ObjectCount">
      <summary>return the total number of object that are in all the batches </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.Name">
      <summary>Get the name of this object. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.IsVisible">
      <summary>Are the batches visible? </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.CastShadows">
      <summary>Sets/Will the geometry from this object cast shadows? </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.BatchInstanceDimensions">
      <summary>Sets/Gets the size of a single batch of geometry. </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.BaseSkeletonInstance">
      <summary>Return the skeletonInstance that will be used </summary>
    </member>
    <member name="P:Mogre.InstancedGeometry.BaseAnimationState">
      <summary>Return the animation state that will be cloned each time an InstancedObject is made </summary>
    </member>
    <member name="T:Mogre.ShadowCameraSetup">
      <summary>This class allows you to plug in new ways to define the camera setup when rendering and projecting shadow textures. The default projection used when rendering shadow textures is a uniform frustum. This is pretty straight forward but doesn't make the best use of the space in the shadow map since texels closer to the camera will be larger, resulting in 'jaggies'. There are several ways to distribute the texels in the shadow texture differently, and this class allows you to override that. Ogre is provided with several alternative shadow camera setups, including LiSPSM (LiSPSMShadowCameraSetup) and Plane Optimal (PlaneOptimalShadowCameraSetup). Others can of course be written to incorporate other algorithms. All you have to do is instantiate one of these classes and enable it using SceneManager::setShadowCameraSetup (global) or Light::setCustomShadowCameraSetup (per light). In both cases the instance is wrapped in a SharedPtr which means it will be deleted automatically when no more references to it exist. Shadow map matrices, being projective matrices, have 15 degrees of freedom. 3 of these degrees of freedom are fixed by the light's position. 4 are used to affinely affect z values. 6 affinely affect u,v sampling. 2 are projective degrees of freedom. This class is meant to allow custom methods for handling optimization. </summary>
    </member>
    <member name="M:Mogre.ShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Function to implement -- must set the shadow camera properties. </summary>
    </member>
    <member name="T:Mogre.DefaultShadowCameraSetup">
      <summary>Implements default shadow camera setup This implements the default shadow camera setup algorithm. This is what might be referred to as "normal" shadow mapping. </summary>
    </member>
    <member name="M:Mogre.DefaultShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Default shadow camera setup. </summary>
    </member>
    <member name="M:Mogre.DefaultShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Default shadow camera setup. </summary>
    </member>
    <member name="M:Mogre.DefaultShadowCameraSetup.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="T:Mogre.LodStrategyManager">
      <summary>Manager for lod strategies. </summary>
    </member>
    <member name="M:Mogre.LodStrategyManager.AddStrategy(Mogre.LodStrategy)">
      <summary>Add a strategy to the manager. </summary>
    </member>
    <member name="M:Mogre.LodStrategyManager.RemoveStrategy(System.String)">
      <summary>Remove a strategy from the manager with a specified name. The removed strategy is returned so the user can control how it is destroyed. </summary>
    </member>
    <member name="M:Mogre.LodStrategyManager.RemoveAllStrategies">
      <summary>Remove and delete all strategies from the manager. All strategies are deleted. If finer control is required over strategy destruction, use removeStrategy. </summary>
    </member>
    <member name="M:Mogre.LodStrategyManager.GetStrategy(System.String)">
      <summary>Get the strategy with the specified name. </summary>
    </member>
    <member name="M:Mogre.LodStrategyManager.SetDefaultStrategy(System.String)">
      <summary>Set the default strategy by name. </summary>
    </member>
    <member name="M:Mogre.LodStrategyManager.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.LodStrategyManager.DefaultStrategy">
      <summary>Sets/Get the current default strategy. </summary>
    </member>
    <member name="P:Mogre.LodStrategyManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.LogManager">
      <summary>The log manager handles the creation and retrieval of logs for the application. This class will create new log files and will retrieve instances of existing ones. Other classes wishing to log output can either create a fresh log or retrieve an existing one to output to. One log is the default log, and is the one written to when the logging methods of this class are called. By default, Root will instantiate a LogManager (which becomes the Singleton instance) on construction, and will create a default log based on the Root construction parameters. If you want more control, for example redirecting log output right from the start or suppressing debug output, you need to create a LogManager yourself before creating a Root instance, then create a default log. Root will detect that you've created one yourself and won't create one of its own, thus using all your logging preferences from the first instance. </summary>
    </member>
    <member name="M:Mogre.LogManager.CreateLog(System.String)">
      <summary>Creates a new log with the given name. </summary>
      <param name="name">The name to give the log e.g. 'Ogre.log' </param>
    </member>
    <member name="M:Mogre.LogManager.CreateLog(System.String,System.Boolean)">
      <summary>Creates a new log with the given name. </summary>
      <param name="name">The name to give the log e.g. 'Ogre.log' </param>
      <param name="defaultLog">If true, this is the default log output will be sent to if the generic logging methods on this class are used. The first log created is always the default log unless this parameter is set. </param>
    </member>
    <member name="M:Mogre.LogManager.CreateLog(System.String,System.Boolean,System.Boolean)">
      <summary>Creates a new log with the given name. </summary>
      <param name="name">The name to give the log e.g. 'Ogre.log' </param>
      <param name="defaultLog">If true, this is the default log output will be sent to if the generic logging methods on this class are used. The first log created is always the default log unless this parameter is set. </param>
      <param name="debuggerOutput">If true, output to this log will also be routed to the debugger's output window. </param>
    </member>
    <member name="M:Mogre.LogManager.CreateLog(System.String,System.Boolean,System.Boolean,System.Boolean)">
      <summary>Creates a new log with the given name. </summary>
      <param name="name">The name to give the log e.g. 'Ogre.log' </param>
      <param name="defaultLog">If true, this is the default log output will be sent to if the generic logging methods on this class are used. The first log created is always the default log unless this parameter is set. </param>
      <param name="debuggerOutput">If true, output to this log will also be routed to the debugger's output window. </param>
      <param name="suppressFileOutput">If true, this is a logical rather than a physical log and no file output will be written. If you do this you should register a LogListener so log output is not lost. </param>
    </member>
    <member name="M:Mogre.LogManager.GetLog(System.String)">
      <summary>Retrieves a log managed by this class. </summary>
    </member>
    <member name="M:Mogre.LogManager.DestroyLog(Mogre.Log)">
      <summary>Closes and removes a log. </summary>
    </member>
    <member name="M:Mogre.LogManager.DestroyLog(System.String)">
      <summary>Closes and removes a named log. </summary>
    </member>
    <member name="M:Mogre.LogManager.SetDefaultLog(Mogre.Log)">
      <summary>Sets the passed in log as the default log. The previous default log. </summary>
    </member>
    <member name="M:Mogre.LogManager.LogMessage(Mogre.LogMessageLevel,System.String)">
      <summary>Log a message to the default log (signature for backward compatibility). </summary>
    </member>
    <member name="M:Mogre.LogManager.LogMessage(Mogre.LogMessageLevel,System.String,System.Boolean)">
      <summary>Log a message to the default log (signature for backward compatibility). </summary>
    </member>
    <member name="M:Mogre.LogManager.LogMessage(System.String)">
      <summary>Log a message to the default log. </summary>
    </member>
    <member name="M:Mogre.LogManager.LogMessage(System.String,Mogre.LogMessageLevel)">
      <summary>Log a message to the default log. </summary>
    </member>
    <member name="M:Mogre.LogManager.LogMessage(System.String,Mogre.LogMessageLevel,System.Boolean)">
      <summary>Log a message to the default log. </summary>
    </member>
    <member name="M:Mogre.LogManager.Stream">
      <summary>Get a stream on the default log. </summary>
    </member>
    <member name="M:Mogre.LogManager.Stream(Mogre.LogMessageLevel)">
      <summary>Get a stream on the default log. </summary>
    </member>
    <member name="M:Mogre.LogManager.Stream(Mogre.LogMessageLevel,System.Boolean)">
      <summary>Get a stream on the default log. </summary>
    </member>
    <member name="M:Mogre.LogManager.SetLogDetail(Mogre.LoggingLevel)">
      <summary>Sets the level of detail of the default log. </summary>
    </member>
    <member name="P:Mogre.LogManager.DefaultLog">
      <summary>Returns a pointer to the default log. </summary>
    </member>
    <member name="P:Mogre.LogManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.ManualObject">
      <summary>Class providing a much simplified interface to generating manual objects with custom geometry. Building one-off geometry objects manually usually requires getting down and dirty with the vertex buffer and vertex declaration API, which some people find a steep learning curve. This class gives you a simpler interface specifically for the purpose of building a 3D object simply and quickly. Note that if you intend to instance your object you will still need to become familiar with the Mesh class. This class draws heavily on the interface for OpenGL immediate-mode (glBegin, glVertex, glNormal etc), since this is generally well-liked by people. There are a couple of differences in the results though - internally this class still builds hardware buffers which can be re-used, so you can render the resulting object multiple times without re-issuing all the same commands again. Secondly, the rendering is not immediate, it is still queued just like all OGRE objects. This makes this object more efficient than the equivalent GL immediate-mode commands, so it's feasible to use it for large objects if you really want to. To construct some geometry with this object:If you know roughly how many vertices (and indices, if you use them) you're going to submit, call estimateVertexCount and estimateIndexCount. This is not essential but will make the process more efficient by saving memory reallocations.Call begin() to begin entering dataFor each vertex, call position(), normal(), textureCoord(), colour() to define your vertex data. Note that each time you call position() you start a new vertex. Note that the first vertex defines the components of the vertex - you can't add more after that. For example if you didn't call normal() in the first vertex, you cannot call it in any others. You ought to call the same combination of methods per vertex.If you want to define triangles (or lines/points) by indexing into the vertex list, you can call index() as many times as you need to define them. If you don't do this, the class will assume you want triangles drawn directly as defined by the vertex list, i.e. non-indexed geometry. Note that stencil shadows are only supported on indexed geometry, and that indexed geometry is a little faster; so you should try to use it.Call end() to finish entering data.Optionally repeat the begin-end cycle if you want more geometry using different rendering operation types, or different materials After calling end(), the class will organise the data for that section internally and make it ready to render with. Like any other MovableObject you should attach the object to a SceneNode to make it visible. Other aspects like the relative render order can be controlled using standard MovableObject methods like setRenderQueueGroup. You can also use beginUpdate() to alter the geometry later on if you wish. If you do this, you should call setDynamic(true) before your first call to begin(), and also consider using estimateVertexCount / estimateIndexCount if your geometry is going to be growing, to avoid buffer recreation during growth. Note that like all OGRE geometry, triangles should be specified in anti-clockwise winding order (whether you're doing it with just vertices, or using indexes too). That is to say that the front of the face is the one where the vertices are listed in anti-clockwise order. </summary>
    </member>
    <member name="M:Mogre.ManualObject.Clear">
      <summary>Completely clear the contents of the object. Clearing the contents of this object and rebuilding from scratch is not the optimal way to manage dynamic vertex data, since the buffers are recreated. If you want to keep the same structure but update the content within that structure, use beginUpdate() instead of clear()begin(). However if you do want to modify the structure from time to time you can do so by clearing and re-specifying the data. </summary>
    </member>
    <member name="M:Mogre.ManualObject.EstimateVertexCount(System.UInt32)">
      <summary>Estimate the number of vertices ahead of time. Calling this helps to avoid memory reallocation when you define vertices. Also very handy when using beginUpdate() to manage dynamic data - you can make the vertex buffers a little larger than their initial needs to allow for growth later with this method. </summary>
    </member>
    <member name="M:Mogre.ManualObject.EstimateIndexCount(System.UInt32)">
      <summary>Estimate the number of indices ahead of time. Calling this helps to avoid memory reallocation when you define indices. Also very handy when using beginUpdate() to manage dynamic data - you can make the index buffer a little larger than the initial need to allow for growth later with this method. </summary>
    </member>
    <member name="M:Mogre.ManualObject.Begin(System.String)">
      <summary>Start defining a part of the object. Each time you call this method, you start a new section of the object with its own material and potentially its own type of rendering operation (triangles, points or lines for example). </summary>
      <param name="materialName">The name of the material to render this part of the object with. </param>
    </member>
    <member name="M:Mogre.ManualObject.Begin(System.String,Mogre.RenderOperation+OperationTypes)">
      <summary>Start defining a part of the object. Each time you call this method, you start a new section of the object with its own material and potentially its own type of rendering operation (triangles, points or lines for example). </summary>
      <param name="materialName">The name of the material to render this part of the object with. </param>
      <param name="opType">The type of operation to use to render. </param>
    </member>
    <member name="M:Mogre.ManualObject.BeginUpdate(System.UInt32)">
      <summary>Start the definition of an update to a part of the object. Using this method, you can update an existing section of the object efficiently. You do not have the option of changing the operation type obviously, since it must match the one that was used before. If your sections are changing size, particularly growing, use estimateVertexCount and estimateIndexCount to pre-size the buffers a little larger than the initial needs to avoid buffer reconstruction. </summary>
      <param name="sectionIndex">The index of the section you want to update. The first call to begin() would have created section 0, the second section 1, etc. </param>
    </member>
    <member name="M:Mogre.ManualObject.Position(System.Single,System.Single,System.Single)">
      <summary>Add a vertex position, starting a new vertex at the same time. A vertex position is slightly special among the other vertex data methods like normal() and textureCoord(), since calling it indicates the start of a new vertex. All other vertex data methods you call after this are assumed to be adding more information (like normals or texture coordinates) to the last vertex started with position().</summary>
    </member>
    <member name="M:Mogre.ManualObject.Position(Mogre.Vector3)">
      <summary>Add a vertex position, starting a new vertex at the same time. A vertex position is slightly special among the other vertex data methods like normal() and textureCoord(), since calling it indicates the start of a new vertex. All other vertex data methods you call after this are assumed to be adding more information (like normals or texture coordinates) to the last vertex started with position(). </summary>
    </member>
    <member name="M:Mogre.ManualObject.Normal(System.Single,System.Single,System.Single)">
      <summary>Add a vertex normal to the current vertex. Vertex normals are most often used for dynamic lighting, and their components should be normalised.</summary>
    </member>
    <member name="M:Mogre.ManualObject.Normal(Mogre.Vector3)">
      <summary>Add a vertex normal to the current vertex. Vertex normals are most often used for dynamic lighting, and their components should be normalised. </summary>
    </member>
    <member name="M:Mogre.ManualObject.TextureCoord(Mogre.Vector4)">
      <summary>Add a texture coordinate to the current vertex. You can call this method multiple times between position() calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions.</summary>
    </member>
    <member name="M:Mogre.ManualObject.TextureCoord(Mogre.Vector3)">
      <summary>Add a texture coordinate to the current vertex. You can call this method multiple times between position() calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions.</summary>
    </member>
    <member name="M:Mogre.ManualObject.TextureCoord(Mogre.Vector2)">
      <summary>Add a texture coordinate to the current vertex. You can call this method multiple times between position() calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions.</summary>
    </member>
    <member name="M:Mogre.ManualObject.TextureCoord(System.Single,System.Single,System.Single,System.Single)">
      <summary>Add a texture coordinate to the current vertex. You can call this method multiple times between position() calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions.</summary>
    </member>
    <member name="M:Mogre.ManualObject.TextureCoord(System.Single,System.Single,System.Single)">
      <summary>Add a texture coordinate to the current vertex. You can call this method multiple times between position() calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions.</summary>
    </member>
    <member name="M:Mogre.ManualObject.TextureCoord(System.Single,System.Single)">
      <summary>Add a texture coordinate to the current vertex. You can call this method multiple times between position() calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions.</summary>
    </member>
    <member name="M:Mogre.ManualObject.TextureCoord(System.Single)">
      <summary>Add a texture coordinate to the current vertex. You can call this method multiple times between position() calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions. </summary>
    </member>
    <member name="M:Mogre.ManualObject.Colour(System.Single,System.Single,System.Single)">
      <summary>Add a vertex colour to a vertex. </summary>
      <param name="r">Colour components expressed as floating point numbers from 0-1 </param>
    </member>
    <member name="M:Mogre.ManualObject.Colour(System.Single,System.Single,System.Single,System.Single)">
      <summary>Add a vertex colour to a vertex. </summary>
      <param name="r">Colour components expressed as floating point numbers from 0-1 </param>
    </member>
    <member name="M:Mogre.ManualObject.Colour(Mogre.ColourValue)">
      <summary>Add a vertex colour to a vertex. </summary>
    </member>
    <member name="M:Mogre.ManualObject.Index(System.UInt32)">
      <summary>Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list of vertices. You will have to call this 3 times for each face for a triangle list, or use the alternative 3-parameter version. Other operation types require different numbers of indexes,RenderOperation::OperationType. 32-bit indexes are not supported on all cards and will only be used when required, if an index is &gt; 65535. </summary>
      <param name="idx">A vertex index from 0 to 4294967295. </param>
    </member>
    <member name="M:Mogre.ManualObject.Triangle(System.UInt32,System.UInt32,System.UInt32)">
      <summary>Add a set of 3 vertex indices to construct a triangle; this is a shortcut to calling index() 3 times. It is only valid for triangle lists. 32-bit indexes are not supported on all cards and will only be used when required, if an index is &gt; 65535. </summary>
      <param name="i1">3 vertex indices from 0 to 4294967295 defining a face. </param>
    </member>
    <member name="M:Mogre.ManualObject.Quad(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Add a set of 4 vertex indices to construct a quad (out of 2 triangles); this is a shortcut to calling index() 6 times, or triangle() twice. It's only valid for triangle list operations. 32-bit indexes are not supported on all cards and will only be used when required, if an index is &gt; 65535. </summary>
      <param name="i1">3 vertex indices from 0 to 4294967295 defining a face. </param>
    </member>
    <member name="M:Mogre.ManualObject.End">
      <summary>Finish defining the object and compile the final renderable version. Will return a pointer to the finished section or NULL if the section was discarded (i.e. has zero vertices/indices). </summary>
    </member>
    <member name="M:Mogre.ManualObject.SetMaterialName(System.UInt32,System.String)">
      <summary>Alter the material for a subsection of this object after it has been specified. You specify the material to use on a section of this object during the call to begin(), however if you want to change the material afterwards you can do so by calling this method. </summary>
      <param name="subIndex">The index of the subsection to alter </param>
      <param name="name">The name of the new material to use </param>
    </member>
    <member name="M:Mogre.ManualObject.ConvertToMesh(System.String)">
      <summary>Convert this object to a Mesh. After you've finished building this object, you may convert it to a Mesh if you want in order to be able to create many instances of it in the world (via Entity). This is optional, since this instance can be directly attached to a SceneNode itself, but of course only one instance of it can exist that way. Only objects which use indexed geometry may be converted to a mesh. </summary>
      <param name="meshName">The name to give the mesh </param>
    </member>
    <member name="M:Mogre.ManualObject.ConvertToMesh(System.String,System.String)">
      <summary>Convert this object to a Mesh. After you've finished building this object, you may convert it to a Mesh if you want in order to be able to create many instances of it in the world (via Entity). This is optional, since this instance can be directly attached to a SceneNode itself, but of course only one instance of it can exist that way. Only objects which use indexed geometry may be converted to a mesh. </summary>
      <param name="meshName">The name to give the mesh </param>
      <param name="groupName">The resource group to create the mesh in </param>
    </member>
    <member name="M:Mogre.ManualObject.GetSection(System.UInt32)">
      <summary>Gets a pointer to a ManualObjectSection, i.e. a part of a ManualObject. </summary>
    </member>
    <member name="M:Mogre.ManualObject._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Internal method by which the movable object must add Renderable subclass instances to the rendering queue. The engine will call this method when this object is to be rendered. The object must then create one or more Renderable subclass instances which it places on the passed in Queue for rendering.
. </summary>
    </member>
    <member name="M:Mogre.ManualObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Implement this method to enable stencil shadows. </summary>
    </member>
    <member name="M:Mogre.ManualObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Implement this method to enable stencil shadows. </summary>
    </member>
    <member name="M:Mogre.ManualObject._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Internal method by which the movable object must add Renderable subclass instances to the rendering queue. The engine will call this method when this object is to be rendered. The object must then create one or more Renderable subclass instances which it places on the passed in Queue for rendering.
. </summary>
    </member>
    <member name="M:Mogre.ManualObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Implement this method to enable stencil shadows. </summary>
    </member>
    <member name="M:Mogre.ManualObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Implement this method to enable stencil shadows. </summary>
    </member>
    <member name="M:Mogre.ManualObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single)">
      <summary>Implement this method to enable stencil shadows. </summary>
    </member>
    <member name="M:Mogre.ManualObject.GetShadowVolumeRenderableIterator(Mogre.ShadowTechnique,Mogre.Light,Mogre.HardwareIndexBufferSharedPtr,System.Boolean,System.Single,System.UInt32)">
      <summary>Implement this method to enable stencil shadows. </summary>
    </member>
    <member name="P:Mogre.ManualObject.UseIdentityView">
      <summary>Sets/Returns whether or not to use an 'identity' view. Usually ManualObjects will use a view matrix as determined by the active camera. However, if they want they can cancel this out and use an identity matrix, which means all geometry is assumed to be relative to camera space already. Useful for overlay rendering. Normally you don't need to change this. ManualObject::setUseIdentityView</summary>
    </member>
    <member name="P:Mogre.ManualObject.UseIdentityProjection">
      <summary>Sets/Returns whether or not to use an 'identity' projection. Usually ManualObjects will use a projection matrix as determined by the active camera. However, if they want they can cancel this out and use an identity projection, which effectively projects in 2D using a {-1, 1} view space. Useful for overlay rendering. Normally you don't need to change this. ManualObject::setUseIdentityProjection</summary>
    </member>
    <member name="P:Mogre.ManualObject.NumSections">
      <summary>Retrieves the number of ManualObjectSection objects making up this ManualObject. </summary>
    </member>
    <member name="P:Mogre.ManualObject.MovableType">
      <summary>Returns the type name of this object.
. </summary>
    </member>
    <member name="P:Mogre.ManualObject.KeepDeclarationOrder">
      <summary>Sets/Gets whether or not the declaration order is to be kept or not. A flag indication if the declaration order will be kept when queuing the renderables. </summary>
    </member>
    <member name="P:Mogre.ManualObject.HasEdgeList">
      <summary>Overridden member from ShadowCaster. </summary>
    </member>
    <member name="P:Mogre.ManualObject.EdgeList">
      <summary>Implement this method to enable stencil shadows. </summary>
    </member>
    <member name="P:Mogre.ManualObject.Dynamic">
      <summary>Sets/Gets whether this object is marked as dynamic </summary>
    </member>
    <member name="P:Mogre.ManualObject.BoundingRadius">
      <summary>Retrieves the radius of the origin-centered bounding sphere for this object.
. </summary>
    </member>
    <member name="P:Mogre.ManualObject.BoundingBox">
      <summary>Sets/Retrieves the local axis-aligned bounding box for this object. This bounding box is in local coordinates.
. </summary>
    </member>
    <member name="T:Mogre.ManualObjectFactory">
      <summary>Factory object for creating ManualObject instances </summary>
    </member>
    <member name="T:Mogre.MaterialManager">
      <summary>Class for managing Material settings for Ogre. Materials control the eventual surface rendering properties of geometry. This class manages the library of materials, dealing with programmatic registrations and lookups, as well as loading predefined Material settings from scripts. When loaded from a script, a Material is in an 'unloaded' state and only stores the settings required. It does not at that stage load any textures. This is because the material settings may be loaded 'en masse' from bulk material script files, but only a subset will actually be required. Because this is a subclass of ResourceManager, any files loaded will be searched for in any path or archive added to the resource paths/archives. See ResourceManager for details. For a definition of the material script format, see the Tutorials/MaterialScript.html file. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.Initialise">
      <summary>Initialises the material manager, which also triggers it to parse all available .program and .material scripts. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>ScriptLoader::parseScript</summary>
    </member>
    <member name="M:Mogre.MaterialManager.SetDefaultTextureFiltering(Mogre.FilterOptions,Mogre.FilterOptions,Mogre.FilterOptions)">
      <summary>Sets the default texture filtering to be used for loaded textures, for when textures are loaded automatically (e.g. by Material class) or when 'load' is called with the default parameters by the application. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.SetDefaultTextureFiltering(Mogre.FilterType,Mogre.FilterOptions)">
      <summary>Sets the default texture filtering to be used for loaded textures, for when textures are loaded automatically (e.g. by Material class) or when 'load' is called with the default parameters by the application. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.SetDefaultTextureFiltering(Mogre.TextureFilterOptions)">
      <summary>Sets the default texture filtering to be used for loaded textures, for when textures are loaded automatically (e.g. by Material class) or when 'load' is called with the default parameters by the application. The default value is TFO_BILINEAR. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.GetDefaultTextureFiltering(Mogre.FilterType)">
      <summary>get the default texture filtering </summary>
    </member>
    <member name="M:Mogre.MaterialManager.GetDefaultSettings">
      <summary>Returns a pointer to the default Material settings. Ogre comes configured with a set of defaults for newly created materials. If you wish to have a different set of defaults, simply call this method and change the returned Material's settings. All materials created from then on will be configured with the new defaults you have specified. The default settings begin as a single Technique with a single, non-programmable Pass: ambient = ColourValue::Whitediffuse = ColourValue::Whitespecular = ColourValue::Blackemmissive = ColourValue::Blackshininess = 0 No texture unit settings (&amp; hence no textures) SourceBlendFactor = SBF_ONE DestBlendFactor = SBF_ZERO (no blend, replace with new colour) Depth buffer checking on Depth buffer writing on Depth buffer comparison function = CMPF_LESS_EQUAL Colour buffer writing on for all channels Culling mode = CULL_CLOCKWISE Ambient lighting = ColourValue(0.5, 0.5, 0.5) (mid-grey) Dynamic lighting enabled Gourad shading mode Bilinear texture filtering </summary>
    </member>
    <member name="M:Mogre.MaterialManager._getSchemeIndex(System.String)">
      <summary>Internal method - returns index for a given material scheme name. Technique::setSchemeName</summary>
    </member>
    <member name="M:Mogre.MaterialManager._getSchemeName(System.UInt16)">
      <summary>Internal method - returns name for a given material scheme index. Technique::setSchemeName</summary>
    </member>
    <member name="M:Mogre.MaterialManager._getActiveSchemeIndex">
      <summary>Internal method - returns the active scheme index. Technique::setSchemeName</summary>
    </member>
    <member name="M:Mogre.MaterialManager.AddListener(Mogre.MaterialManager+IListener)">
      <summary>Add a listener to handle material events. If schemeName is supplied, the listener will only receive events for that certain scheme. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.AddListener(Mogre.MaterialManager+IListener,System.String)">
      <summary>Add a listener to handle material events. If schemeName is supplied, the listener will only receive events for that certain scheme. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.RemoveListener(Mogre.MaterialManager+IListener)">
      <summary>Remove a listener handling material events. If the listener was added with a custom scheme name, it needs to be supplied here as well. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.RemoveListener(Mogre.MaterialManager+IListener,System.String)">
      <summary>Remove a listener handling material events. If the listener was added with a custom scheme name, it needs to be supplied here as well. </summary>
    </member>
    <member name="M:Mogre.MaterialManager._arbitrateMissingTechniqueForActiveScheme(Mogre.Material,System.UInt16,Mogre.IRenderable)">
      <summary>Internal method for sorting out missing technique for a scheme. </summary>
    </member>
    <member name="M:Mogre.MaterialManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>ScriptLoader::parseScript</summary>
    </member>
    <member name="M:Mogre.MaterialManager.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.MaterialManager.DefaultAnisotropy">
      <summary>Sets/get the default maxAnisotropy </summary>
    </member>
    <member name="P:Mogre.MaterialManager.ActiveScheme">
      <summary>Sets/Returns the name of the active material scheme. Technique::setSchemeName</summary>
    </member>
    <member name="P:Mogre.MaterialManager.DEFAULT_SCHEME_NAME">
      <summary>Sets/Default material scheme. </summary>
    </member>
    <member name="P:Mogre.MaterialManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.MaterialSerializer">
      <summary>Class for serializing Materials to / from a .material script. </summary>
    </member>
    <member name="M:Mogre.MaterialSerializer.QueueForExport(Mogre.MaterialPtr)">
      <summary>Queue an in-memory Material to the internal buffer for export. </summary>
      <param name="pMat">Material pointer </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.QueueForExport(Mogre.MaterialPtr,System.Boolean)">
      <summary>Queue an in-memory Material to the internal buffer for export. </summary>
      <param name="pMat">Material pointer </param>
      <param name="clearQueued">If true, any materials already queued will be removed </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.QueueForExport(Mogre.MaterialPtr,System.Boolean,System.Boolean)">
      <summary>Queue an in-memory Material to the internal buffer for export. </summary>
      <param name="pMat">Material pointer </param>
      <param name="clearQueued">If true, any materials already queued will be removed </param>
      <param name="exportDefaults">If true, attributes which are defaulted will be included in the script exported, otherwise they will be omitted </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.QueueForExport(Mogre.MaterialPtr,System.Boolean,System.Boolean,System.String)">
      <summary>Queue an in-memory Material to the internal buffer for export. </summary>
      <param name="pMat">Material pointer </param>
      <param name="clearQueued">If true, any materials already queued will be removed </param>
      <param name="exportDefaults">If true, attributes which are defaulted will be included in the script exported, otherwise they will be omitted </param>
      <param name="materialName">Allow exporting the given material under a different name. In case of empty string the original material name will be used. </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportQueued(System.String)">
      <summary>Exports queued material(s) to a named material script file. </summary>
      <param name="filename">the file name of the material script to be exported </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportQueued(System.String,System.Boolean)">
      <summary>Exports queued material(s) to a named material script file. </summary>
      <param name="filename">the file name of the material script to be exported </param>
      <param name="includeProgDef">If true, vertex program and fragment program definitions will be written at the top of the material script </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportQueued(System.String,System.Boolean,System.String)">
      <summary>Exports queued material(s) to a named material script file. </summary>
      <param name="filename">the file name of the material script to be exported </param>
      <param name="includeProgDef">If true, vertex program and fragment program definitions will be written at the top of the material script </param>
      <param name="programFilename">the file name of the vertex / fragment program script to be exported. This is only used if there are program definitions to be exported and includeProgDef is false when calling queueForExport. </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportMaterial(Mogre.MaterialPtr,System.String)">
      <summary>Exports a single in-memory Material to the named material script file. </summary>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportMaterial(Mogre.MaterialPtr,System.String,System.Boolean)">
      <summary>Exports a single in-memory Material to the named material script file. </summary>
      <param name="exportDefaults">if true then exports all values including defaults </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportMaterial(Mogre.MaterialPtr,System.String,System.Boolean,System.Boolean)">
      <summary>Exports a single in-memory Material to the named material script file. </summary>
      <param name="exportDefaults">if true then exports all values including defaults </param>
      <param name="includeProgDef">if true includes Gpu shader program definitions in the export material script otherwise if false then program definitions will be exported to a separate file with name programFilename if programFilename is not empty </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportMaterial(Mogre.MaterialPtr,System.String,System.Boolean,System.Boolean,System.String)">
      <summary>Exports a single in-memory Material to the named material script file. </summary>
      <param name="exportDefaults">if true then exports all values including defaults </param>
      <param name="includeProgDef">if true includes Gpu shader program definitions in the export material script otherwise if false then program definitions will be exported to a separate file with name programFilename if programFilename is not empty </param>
      <param name="programFilename">the file name of the vertex / fragment program script to be exported. This is only used if includeProgDef is false. </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ExportMaterial(Mogre.MaterialPtr,System.String,System.Boolean,System.Boolean,System.String,System.String)">
      <summary>Exports a single in-memory Material to the named material script file. </summary>
      <param name="exportDefaults">if true then exports all values including defaults </param>
      <param name="includeProgDef">if true includes Gpu shader program definitions in the export material script otherwise if false then program definitions will be exported to a separate file with name programFilename if programFilename is not empty </param>
      <param name="programFilename">the file name of the vertex / fragment program script to be exported. This is only used if includeProgDef is false. </param>
      <param name="materialName">Allow exporting the given material under a different name. In case of empty string the original material name will be used. </param>
    </member>
    <member name="M:Mogre.MaterialSerializer.ClearQueue">
      <summary>Clears the internal buffer </summary>
    </member>
    <member name="M:Mogre.MaterialSerializer.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>Parses a Material script file passed as a stream. </summary>
    </member>
    <member name="M:Mogre.MaterialSerializer.#ctor">
      <summary>default constructor </summary>
    </member>
    <member name="P:Mogre.MaterialSerializer.QueuedAsString">
      <summary>Returns a string representing the parsed material(s) </summary>
    </member>
    <member name="T:Mogre.MaterialScriptSection">
      <summary>Enum to identify material sections. </summary>
    </member>
    <member name="T:Mogre.SubMesh">
      <summary>Defines a part of a complete mesh. Meshes which make up the definition of a discrete 3D object are made up of potentially multiple parts. This is because different parts of the mesh may use different materials or use different vertex formats, such that a rendering state change is required between them. Like the Mesh class, instantiations of 3D objects in the scene share the SubMesh instances, and have the option of overriding their material differences on a per-object basis if required. See the SubEntity class for more information. </summary>
    </member>
    <member name="M:Mogre.SubMesh.SetMaterialName(System.String)">
      <summary>Sets the name of the Material which this SubMesh will use. </summary>
    </member>
    <member name="M:Mogre.SubMesh.SetMaterialName(System.String,System.String)">
      <summary>Sets the name of the Material which this SubMesh will use. </summary>
    </member>
    <member name="M:Mogre.SubMesh._getRenderOperation(Mogre.RenderOperation)">
      <summary>Returns a RenderOperation structure required to render this mesh. </summary>
      <param name="rend">Reference to a RenderOperation structure to populate. </param>
    </member>
    <member name="M:Mogre.SubMesh._getRenderOperation(Mogre.RenderOperation,System.UInt16)">
      <summary>Returns a RenderOperation structure required to render this mesh. </summary>
      <param name="rend">Reference to a RenderOperation structure to populate. </param>
      <param name="lodIndex">The index of the LOD to use. </param>
    </member>
    <member name="M:Mogre.SubMesh.AddBoneAssignment(Mogre.VertexBoneAssignment)">
      <summary>Assigns a vertex to a bone with a given weight, for skeletal animation. This method is only valid after calling setSkeletonName. Since this is a one-off process there exists only 'addBoneAssignment' and 'clearBoneAssignments' methods, no 'editBoneAssignment'. You should not need to modify bone assignments during rendering (only the positions of bones) and OGRE reserves the right to do some internal data reformatting of this information, depending on render system requirements. This method is for assigning weights to the dedicated geometry of the SubMesh. To assign weights to the shared Mesh geometry, see the equivalent methods on Mesh. </summary>
    </member>
    <member name="M:Mogre.SubMesh.ClearBoneAssignments">
      <summary>Removes all bone assignments for this mesh. This method is for assigning weights to the dedicated geometry of the SubMesh. To assign weights to the shared Mesh geometry, see the equivalent methods on Mesh. </summary>
    </member>
    <member name="M:Mogre.SubMesh.GetBoneAssignmentIterator">
      <summary>Gets an iterator for access all bone assignments. Only valid if this SubMesh has dedicated geometry. </summary>
    </member>
    <member name="M:Mogre.SubMesh.GetBoneAssignments">
      <summary>Gets a const reference to the list of bone assignments </summary>
    </member>
    <member name="M:Mogre.SubMesh._compileBoneAssignments">
      <summary>Must be called once to compile bone assignments into geometry buffer. </summary>
    </member>
    <member name="M:Mogre.SubMesh.GetAliasTextureIterator">
      <summary>Gets an constant iterator to access all texture alias names assigned to this submesh. </summary>
    </member>
    <member name="M:Mogre.SubMesh.AddTextureAlias(System.String,System.String)">
      <summary>Adds the alias or replaces an existing one and associates the texture name to it. The submesh uses the texture alias to replace textures used in the material applied to the submesh. </summary>
      <param name="aliasName">is the name of the alias. </param>
      <param name="textureName">is the name of the texture to be associated with the alias </param>
    </member>
    <member name="M:Mogre.SubMesh.RemoveTextureAlias(System.String)">
      <summary>Remove a specific texture alias name from the sub mesh </summary>
      <param name="aliasName">is the name of the alias to be removed. If it is not found then it is ignored. </param>
    </member>
    <member name="M:Mogre.SubMesh.RemoveAllTextureAliases">
      <summary>removes all texture aliases from the sub mesh </summary>
    </member>
    <member name="M:Mogre.SubMesh.UpdateMaterialUsingTextureAliases">
      <summary>The current material used by the submesh is copied into a new material and the submesh's texture aliases are applied if the current texture alias names match those found in the original material. The submesh's texture aliases must be setup prior to calling this method. If a new material has to be created, the subMesh autogenerates the new name. The new name is the old name + "_" + number. True if texture aliases were applied and a new material was created. </summary>
    </member>
    <member name="M:Mogre.SubMesh.GenerateExtremes(System.UInt32)">
      <summary>Generate the submesh extremes (extremityPoints). </summary>
      <param name="count">Number of extreme points to compute for the submesh. </param>
    </member>
    <member name="P:Mogre.SubMesh.VertexAnimationType">
      <summary>Get the type of any vertex animation used by dedicated geometry. </summary>
    </member>
    <member name="P:Mogre.SubMesh.TextureAliasCount">
      <summary>Gets the number of texture aliases assigned to the sub mesh. </summary>
    </member>
    <member name="P:Mogre.SubMesh.IsMatInitialised">
      <summary>Returns true if a material has been assigned to the submesh, otherwise returns false. </summary>
    </member>
    <member name="P:Mogre.SubMesh.IsBuildEdgesEnabled">
      <summary>Returns true(by default) if the submesh should be included in the mesh EdgeList, otherwise returns false. </summary>
    </member>
    <member name="P:Mogre.SubMesh.HasTextureAliases">
      <summary>returns true if the sub mesh has texture aliases </summary>
    </member>
    <member name="P:Mogre.SubMesh.parent">
      <summary>Sets/Reference to parent Mesh (not a smart pointer so child does not keep parent alive). </summary>
    </member>
    <member name="P:Mogre.SubMesh.indexData">
      <summary>Sets/Face index data. </summary>
    </member>
    <member name="P:Mogre.SubMesh.vertexData">
      <summary>Sets/Dedicated vertex data (only valid if useSharedVertices = false). This data is completely owned by this submesh. The use of shared or non-shared buffers is determined when model data is converted to the OGRE .mesh format. </summary>
    </member>
    <member name="P:Mogre.SubMesh.operationType">
      <summary>Sets/The render operation type used to render this submesh. </summary>
    </member>
    <member name="P:Mogre.SubMesh.useSharedVertices">
      <summary>Sets/Indicates if this submesh shares vertex data with other meshes or whether it has it's own vertices. </summary>
    </member>
    <member name="T:Mogre.PatchSurface">
      <summary>A surface which is defined by curves of some kind to form a patch, e.g. a Bezier patch. This object will take a list of control points with various assorted data, and will subdivide it into a patch mesh. Currently only Bezier curves are supported for defining the surface, but other techniques such as NURBS would follow the same basic approach. </summary>
    </member>
    <member name="M:Mogre.PatchSurface.DefineSurface(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32)">
      <summary>Sets up the surface by defining it's control points, type and initial subdivision level. This method initialises the surface by passing it a set of control points. The type of curves to be used are also defined here, although the only supported option currently is a bezier patch. You can also specify a global subdivision level here if you like, although it is recommended that the parameter is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the curvature of the surface) </summary>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. </param>
      <param name="height">Specifies the height of the patch in control points. </param>
    </member>
    <member name="M:Mogre.PatchSurface.DefineSurface(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,Mogre.PatchSurface+PatchSurfaceType)">
      <summary>Sets up the surface by defining it's control points, type and initial subdivision level. This method initialises the surface by passing it a set of control points. The type of curves to be used are also defined here, although the only supported option currently is a bezier patch. You can also specify a global subdivision level here if you like, although it is recommended that the parameter is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the curvature of the surface) </summary>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. </param>
      <param name="height">Specifies the height of the patch in control points. </param>
      <param name="pType">The type of surface - currently only PST_BEZIER is supported </param>
    </member>
    <member name="M:Mogre.PatchSurface.DefineSurface(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,Mogre.PatchSurface+PatchSurfaceType,System.UInt32)">
      <summary>Sets up the surface by defining it's control points, type and initial subdivision level. This method initialises the surface by passing it a set of control points. The type of curves to be used are also defined here, although the only supported option currently is a bezier patch. You can also specify a global subdivision level here if you like, although it is recommended that the parameter is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the curvature of the surface) </summary>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. </param>
      <param name="height">Specifies the height of the patch in control points. </param>
      <param name="pType">The type of surface - currently only PST_BEZIER is supported </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
    </member>
    <member name="M:Mogre.PatchSurface.DefineSurface(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,Mogre.PatchSurface+PatchSurfaceType,System.UInt32,System.UInt32)">
      <summary>Sets up the surface by defining it's control points, type and initial subdivision level. This method initialises the surface by passing it a set of control points. The type of curves to be used are also defined here, although the only supported option currently is a bezier patch. You can also specify a global subdivision level here if you like, although it is recommended that the parameter is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the curvature of the surface) </summary>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. </param>
      <param name="height">Specifies the height of the patch in control points. </param>
      <param name="pType">The type of surface - currently only PST_BEZIER is supported </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
    </member>
    <member name="M:Mogre.PatchSurface.DefineSurface(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,Mogre.PatchSurface+PatchSurfaceType,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide)">
      <summary>Sets up the surface by defining it's control points, type and initial subdivision level. This method initialises the surface by passing it a set of control points. The type of curves to be used are also defined here, although the only supported option currently is a bezier patch. You can also specify a global subdivision level here if you like, although it is recommended that the parameter is left as AUTO_LEVEL, which means the system decides how much subdivision is required (based on the curvature of the surface) </summary>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. </param>
      <param name="height">Specifies the height of the patch in control points. </param>
      <param name="pType">The type of surface - currently only PST_BEZIER is supported </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
      <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for. </param>
    </member>
    <member name="M:Mogre.PatchSurface.Build(Mogre.HardwareVertexBufferSharedPtr,System.UInt32,Mogre.HardwareIndexBufferSharedPtr,System.UInt32)">
      <summary>Tells the system to build the mesh relating to the surface into externally created buffers. The VertexDeclaration of the vertex buffer must be identical to the one passed into defineSurface. In addition, there must be enough space in the buffer to accommodate the patch at full detail level; you should call getRequiredVertexCount and getRequiredIndexCount to determine this. This method does not create an internal mesh for this patch and so getMesh will return null if you call it after building the patch this way. </summary>
      <param name="destVertexBuffer">The destination vertex buffer in which to build the patch. </param>
      <param name="vertexStart">The offset at which to start writing vertices for this patch </param>
      <param name="destIndexBuffer">The destination index buffer in which to build the patch. </param>
      <param name="vertexStart">The offset at which to start writing indexes for this patch </param>
    </member>
    <member name="M:Mogre.PatchSurface.NotifyControlPointBufferDeallocated">
      <summary>Convenience method for telling the patch that the control points have been deleted, since once the patch has been built they are not required. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.VertexOffset">
      <summary>Returns the vertex offset used by this buffer to write data into the buffer. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.SubdivisionFactor">
      <summary>Sets/Gets the current level of subdivision. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.RequiredVertexCount">
      <summary>Based on a previous call to defineSurface, establishes the number of vertices required to hold this patch at the maximum detail level. This is useful when you wish to build the patch into external vertex / index buffers. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.RequiredIndexCount">
      <summary>Based on a previous call to defineSurface, establishes the number of indexes required to hold this patch at the maximum detail level. This is useful when you wish to build the patch into external vertex / index buffers. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.IndexOffset">
      <summary>Returns the index offset used by this buffer to write data into the buffer. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.CurrentIndexCount">
      <summary>Gets the current index count based on the current subdivision level. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.Bounds">
      <summary>Gets the bounds of this patch, only valid after calling defineSurface. </summary>
    </member>
    <member name="P:Mogre.PatchSurface.BoundingSphereRadius">
      <summary>Gets the radius of the bounding sphere for this patch, only valid after defineSurface has been called. </summary>
    </member>
    <member name="F:Mogre.PatchSurface+PatchSurfaceType.PST_BEZIER">
      <summary>A patch defined by a set of bezier curves. </summary>
    </member>
    <member name="F:Mogre.PatchSurface+VisibleSide.VS_FRONT">
      <summary>The side from which u goes right and v goes up (as in texture coords). </summary>
    </member>
    <member name="F:Mogre.PatchSurface+VisibleSide.VS_BACK">
      <summary>The side from which u goes right and v goes down (reverse of texture coords). </summary>
    </member>
    <member name="F:Mogre.PatchSurface+VisibleSide.VS_BOTH">
      <summary>Both sides are visible - warning this creates 2x the number of triangles and adds extra overhead for calculating normals. </summary>
    </member>
    <member name="T:Mogre.MeshManager">
      <summary>Handles the management of mesh resources. This class deals with the runtime management of mesh data; like other resource managers it handles the creation of resources (in this case mesh data), working within a fixed memory budget. </summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
      <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
      <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for. </param>
      <param name="vbUsage">Vertex buffer usage flags. Recommend the default since vertex buffer should be static. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
      <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for. </param>
      <param name="vbUsage">Vertex buffer usage flags. Recommend the default since vertex buffer should be static. </param>
      <param name="ibUsage">Index buffer usage flags. Recommend the default since index buffer should be dynamic to change levels but not readable. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
      <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for. </param>
      <param name="vbUsage">Vertex buffer usage flags. Recommend the default since vertex buffer should be static. </param>
      <param name="ibUsage">Index buffer usage flags. Recommend the default since index buffer should be dynamic to change levels but not readable. </param>
      <param name="vbUseShadow">Flag to determine if a shadow buffer is generated for the vertex buffer. See HardwareBuffer for full details. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="controlPointBuffer">A pointer to a buffer containing the vertex data which defines control points of the curves rather than actual vertices. Note that you are expected to provide not just position information, but potentially normals and texture coordinates too. The format of the buffer is defined in the VertexDeclaration parameter </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
      <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for. </param>
      <param name="vbUsage">Vertex buffer usage flags. Recommend the default since vertex buffer should be static. </param>
      <param name="ibUsage">Index buffer usage flags. Recommend the default since index buffer should be dynamic to change levels but not readable. </param>
      <param name="vbUseShadow">Flag to determine if a shadow buffer is generated for the vertex buffer. See HardwareBuffer for full details. </param>
      <param name="ibUseShadow">Flag to determine if a shadow buffer is generated for the index buffer. See HardwareBuffer for full details. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateBezierPatch(System.String,System.String,,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Creates a Bezier patch based on an array of control vertices. </summary>
      <param name="name">The name to give the newly created mesh. </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="declaration">VertexDeclaration describing the contents of the buffer. Note this declaration must _only_ draw on buffer source 0! </param>
      <param name="width">Specifies the width of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="height">Specifies the height of the patch in control points. Note this parameter must greater than or equal to 3. </param>
      <param name="uMaxSubdivisionLevel">If you want to manually set the top level of subdivision, do it here, otherwise let the system decide. </param>
      <param name="visibleSide">Determines which side of the patch (or both) triangles are generated for. </param>
      <param name="vbUsage">Vertex buffer usage flags. Recommend the default since vertex buffer should be static. </param>
      <param name="ibUsage">Index buffer usage flags. Recommend the default since index buffer should be dynamic to change levels but not readable. </param>
      <param name="vbUseShadow">Flag to determine if a shadow buffer is generated for the vertex buffer. See HardwareBuffer for full details. </param>
      <param name="ibUseShadow">Flag to determine if a shadow buffer is generated for the index buffer. See HardwareBuffer for full details. </param>
    </member>
    <member name="M:Mogre.MeshManager._initialise">
      <summary>Initialises the manager, only to be called by OGRE internally. </summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.HardwareBuffer+Usage)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
      <param name="vertexBufferShadowed">If true, the vertex buffers will be shadowed by system memory copies for faster read access </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
      <param name="vertexBufferShadowed">If true, the vertex buffers will be shadowed by system memory copies for faster read access </param>
      <param name="indexBufferShadowed">If true, the index buffers will be shadowed by system memory copies for faster read access </param>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,Mogre.HardwareBuffer+Usage)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
      <param name="vertexBufferShadowed">If true, the vertex buffers will be shadowed by system memory copies for faster read access </param>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
      <param name="vertexBufferShadowed">If true, the vertex buffers will be shadowed by system memory copies for faster read access </param>
      <param name="indexBufferShadowed">If true, the index buffers will be shadowed by system memory copies for faster read access </param>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,Mogre.HardwareBuffer+Usage)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
      <param name="vertexBufferShadowed">If true, the vertex buffers will be shadowed by system memory copies for faster read access </param>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
      <param name="filename">The name of the .mesh file </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="vertexBufferUsage">The usage flags with which the vertex buffer(s) will be created </param>
      <param name="indexBufferUsage">The usage flags with which the index buffer(s) created for this mesh will be created with. </param>
      <param name="vertexBufferShadowed">If true, the vertex buffers will be shadowed by system memory copies for faster read access </param>
      <param name="indexBufferShadowed">If true, the index buffers will be shadowed by system memory copies for faster read access </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateManual(System.String,System.String)">
      <summary>Creates a new Mesh specifically for manual definition rather than loading from an object file. Note that once you've defined your mesh, you must call Mesh::_setBounds and Mesh::_setBoundingRadius in order to define the bounds of your mesh. In previous versions of OGRE you could call Mesh::_updateBounds, but OGRE's support of write-only vertex buffers makes this no longer appropriate. </summary>
      <param name="name">The name to give the new mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateManual(System.String,System.String,Mogre.IManualResourceLoader)">
      <summary>Creates a new Mesh specifically for manual definition rather than loading from an object file. Note that once you've defined your mesh, you must call Mesh::_setBounds and Mesh::_setBoundingRadius in order to define the bounds of your mesh. In previous versions of OGRE you could call Mesh::_updateBounds, but OGRE's support of write-only vertex buffers makes this no longer appropriate. </summary>
      <param name="name">The name to give the new mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="loader">ManualResourceLoader which will be called to load this mesh when the time comes. It is recommended that you populate this field in order that the mesh can be rebuilt should the need arise </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
      <param name="vertexShadowBuffer">If this flag is set to true, the vertex buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
    </member>
    <member name="M:Mogre.MeshManager.CreatePlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Creates a basic plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
      <param name="vertexShadowBuffer">If this flag is set to true, the vertex buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
      <param name="indexShadowBuffer">If this flag is set to true, the index buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="orientation">The orientation of the overall sphere that's used to create the illusion </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.Quaternion,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="orientation">The orientation of the overall sphere that's used to create the illusion </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.Quaternion,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="orientation">The orientation of the overall sphere that's used to create the illusion </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.Quaternion,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="orientation">The orientation of the overall sphere that's used to create the illusion </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
      <param name="vertexShadowBuffer">If this flag is set to true, the vertex buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.Quaternion,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="orientation">The orientation of the overall sphere that's used to create the illusion </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
      <param name="vertexShadowBuffer">If this flag is set to true, the vertex buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
      <param name="indexShadowBuffer">If this flag is set to true, the index buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedIllusionPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.Quaternion,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean,System.Int32)">
      <summary>Creates a plane, which because of it's texture coordinates looks like a curved surface, useful for skies in a skybox. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="curvature">The curvature of the plane. Good values are between 2 and 65. Higher values are more curved leading to a smoother effect, lower values are less curved meaning more distortion at the horizons but a better distance effect. </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="uTile">The number of times the texture should be repeated in the u direction </param>
      <param name="vTile">The number of times the texture should be repeated in the v direction </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="orientation">The orientation of the overall sphere that's used to create the illusion </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
      <param name="vertexShadowBuffer">If this flag is set to true, the vertex buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
      <param name="indexShadowBuffer">If this flag is set to true, the index buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
      <param name="ySegmentsToKeep">The number of segments from the top of the dome downwards to keep. -1 keeps all of them. This can save fillrate if you cannot see much of the sky lower down. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
      <param name="vertexShadowBuffer">If this flag is set to true, the vertex buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
    </member>
    <member name="M:Mogre.MeshManager.CreateCurvedPlane(System.String,System.String,Mogre.Plane,System.Single,System.Single,System.Single,System.Int32,System.Int32,System.Boolean,System.UInt16,System.Single,System.Single,Mogre.Vector3,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Creates a genuinely curved plane, by default majoring on the x/y axes facing positive Z. </summary>
      <param name="name">The name to give the resulting mesh </param>
      <param name="groupName">The name of the resource group to assign the mesh to </param>
      <param name="plane">The orientation of the plane and distance from the origin </param>
      <param name="width">The width of the plane in world coordinates </param>
      <param name="height">The height of the plane in world coordinates </param>
      <param name="bow">The amount of 'bow' in the curved plane. (Could also be considered the depth.) </param>
      <param name="xsegments">The number of segments to the plane in the x direction </param>
      <param name="ysegments">The number of segments to the plane in the y direction </param>
      <param name="normals">If true, normals are created perpendicular to the plane </param>
      <param name="numTexCoordSets">The number of 2D texture coordinate sets created - by default the corners are created to be the corner of the texture. </param>
      <param name="upVector">The 'Up' direction of the plane. </param>
      <param name="vertexBufferUsage">The usage flag with which the vertex buffer for this plane will be created </param>
      <param name="indexBufferUsage">The usage flag with which the index buffer for this plane will be created </param>
      <param name="vertexShadowBuffer">If this flag is set to true, the vertex buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
      <param name="indexShadowBuffer">If this flag is set to true, the index buffer will be created with a system memory shadow buffer, allowing you to read it back more efficiently than if it is in hardware </param>
    </member>
    <member name="M:Mogre.MeshManager.LoadResource(Mogre.Resource)">
      <summary>ManualResourceLoader::loadResource</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Create a new mesh, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,System.Boolean)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,System.Boolean)">
      <summary>Prepares a mesh for loading from a file. This does the IO in advance of the call to load(). If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,System.Boolean)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="M:Mogre.MeshManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,System.Boolean)">
      <summary>Loads a mesh from a file, making it immediately available for use. If the model has already been created (prepared or loaded), the existing instance will be returned. Ogre loads model files from it's own proprietary format called .mesh. This is because having a single file format is better for runtime performance, and we also have control over pre-processed data (such as collision boxes, LOD reductions etc). </summary>
    </member>
    <member name="P:Mogre.MeshManager.PrepareAllMeshesForShadowVolumes">
      <summary>Sets/Retrieves whether all Meshes should prepare themselves for shadow volumes. </summary>
    </member>
    <member name="P:Mogre.MeshManager.Listener">
      <summary>Sets/Gets the listener used to control mesh loading through the serializer. </summary>
    </member>
    <member name="P:Mogre.MeshManager.BoundsPaddingFactor">
      <summary>Sets/Gets the factor by which the bounding box of an entity is padded. Default is 0.01 </summary>
    </member>
    <member name="P:Mogre.MeshManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.MeshSerializer">
      <summary>Class for serialising mesh data to/from an OGRE .mesh file. This class allows exporters to write OGRE .mesh files easily, and allows the OGRE engine to import .mesh files into instantiated OGRE Meshes. Note that a .mesh file can include not only the Mesh, but also definitions of any Materials it uses (although this is optional, the .mesh can rely on the Material being loaded from another source, especially useful if you want to take advantage of OGRE's advanced Material properties which may not be available in your modeller). To export a Mesh:Use the MaterialManager methods to create any dependent Material objects, if you want to export them with the Mesh. Create a Mesh object and populate it using it's methods. Call the exportMesh method It's important to realise that this exporter uses OGRE terminology. In this context, 'Mesh' means a top-level mesh structure which can actually contain many SubMeshes, each of which has only one Material. Modelling packages may refer to these differently, for example in Milkshape, it says 'Model' instead of 'Mesh' and 'Mesh' instead of 'SubMesh', but the theory is the same. </summary>
    </member>
    <member name="M:Mogre.MeshSerializer.ExportMesh(Mogre.Mesh,System.String)">
      <summary>Exports a mesh to the file specified. This method takes an externally created Mesh object, and exports both it and optionally the Materials it uses to a .mesh file. </summary>
      <param name="pMesh">Pointer to the Mesh to export </param>
      <param name="filename">The destination filename </param>
    </member>
    <member name="M:Mogre.MeshSerializer.ExportMesh(Mogre.Mesh,System.String,Mogre.Serializer+Endian)">
      <summary>Exports a mesh to the file specified. This method takes an externally created Mesh object, and exports both it and optionally the Materials it uses to a .mesh file. </summary>
      <param name="pMesh">Pointer to the Mesh to export </param>
      <param name="filename">The destination filename </param>
      <param name="endianMode">The endian mode of the written file </param>
    </member>
    <member name="M:Mogre.MeshSerializer.ImportMesh(Mogre.DataStreamPtr,Mogre.Mesh)">
      <summary>Imports Mesh and (optionally) Material data from a .mesh file DataStream. This method imports data from a DataStream opened from a .mesh file and places it's contents into the Mesh object which is passed in. </summary>
      <param name="stream">The DataStream holding the .mesh data. Must be initialised (pos at the start of the buffer). </param>
      <param name="pDest">Pointer to the Mesh object which will receive the data. Should be blank already. </param>
    </member>
    <member name="P:Mogre.MeshSerializer.Listener">
      <summary>Sets/Returns the current listener. </summary>
    </member>
    <member name="T:Mogre.MeshSerializerListener">
      <summary>This class allows users to hook into the mesh loading process and modify references within the mesh as they are loading. Material and skeletal references can be processed using this interface which allows finer control over resources. </summary>
    </member>
    <member name="M:Mogre.MeshSerializerListener.ProcessMaterialName(Mogre.Mesh,System.String[])">
      <summary>Called to override the loading of the given named material. </summary>
    </member>
    <member name="M:Mogre.MeshSerializerListener.ProcessSkeletonName(Mogre.Mesh,System.String[])">
      <summary>Called to override the reference to a skeleton. </summary>
    </member>
    <member name="T:Mogre.PatchMesh">
      <summary>Patch specialisation of Mesh. Instances of this class should be created by calling MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.Define(System.Void*,Mogre.VertexDeclaration,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Mogre.PatchSurface+VisibleSide,Mogre.HardwareBuffer+Usage,Mogre.HardwareBuffer+Usage,System.Boolean,System.Boolean)">
      <summary>Define the patch, as defined in MeshManager::createBezierPatch. </summary>
    </member>
    <member name="M:Mogre.PatchMesh.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String)">
      <summary>Constructor. </summary>
    </member>
    <member name="T:Mogre.PatchMeshPtr">
      <summary>Specialisation of SharedPtr to allow SharedPtr to be assigned to PatchMeshPtrHas to be a subclass since we need operator=. We could templatise this instead of repeating per Resource subclass, except to do so requires a form VC6 does not support i.e. ResourceSubclassPtr&lt;T&gt; : public SharedPtr&lt;T&gt; </summary>
    </member>
    <member name="T:Mogre.Overlay">
      <summary>Represents a layer which is rendered on top of the 'normal' scene contents. An overlay is a container for visual components (2D and 3D) which will be rendered after the main scene in order to composite heads-up-displays, menus or other layers on top of the contents of the scene. An overlay always takes up the entire size of the viewport, although the components attached to it do not have to. An overlay has no visual element in itself, it it merely a container for visual elements. Overlays are created by calling OverlayManager::create, or by defining them in special text scripts (.overlay files). As many overlays as you like can be defined; after creation an overlay is hidden i.e. not visible until you specifically enable it by calling 'show'. This allows you to have multiple overlays predefined (menus etc) which you make visible only when you want. It is possible to have multiple overlays enabled at once; in this case the relative 'zorder' parameter of the overlays determine which one is displayed on top. By default overlays are rendered into all viewports. This is fine when you only have fullscreen viewports, but if you have picture-in-picture views, you probably don't want the overlay displayed in the smaller viewports. You turn this off for a specific viewport by calling the Viewport::setDisplayOverlays method. </summary>
    </member>
    <member name="M:Mogre.Overlay.Show">
      <summary>Shows the overlay if it was hidden. </summary>
    </member>
    <member name="M:Mogre.Overlay.Hide">
      <summary>Hides the overlay if it was visible. </summary>
    </member>
    <member name="M:Mogre.Overlay.Add2D(Mogre.OverlayContainer)">
      <summary>Adds a 2D 'container' to the overlay. Containers are created and managed using the OverlayManager. A container could be as simple as a square panel, or something more complex like a grid or tree view. Containers group collections of other elements, giving them a relative coordinate space and a common z-order. If you want to attach a GUI widget to an overlay, you have to do it via a container. </summary>
      <param name="cont">Pointer to a container to add, created using OverlayManager. </param>
    </member>
    <member name="M:Mogre.Overlay.Remove2D(Mogre.OverlayContainer)">
      <summary>Removes a 2D container from the overlay. NOT FAST. Consider OverlayElement::hide. </summary>
    </member>
    <member name="M:Mogre.Overlay.Add3D(Mogre.SceneNode)">
      <summary>Adds a node capable of holding 3D objects to the overlay. Although overlays are traditionally associated with 2D elements, there are reasons why you might want to attach 3D elements to the overlay too. For example, if you wanted to have a 3D cockpit, which was overlaid with a HUD, then you would create 2 overlays, one with a 3D object attached for the cockpit, and one with the HUD elements attached (the zorder of the HUD overlay would be higher than the cockpit to ensure it was always on top). A SceneNode can have any number of 3D objects attached to it. SceneNodes are usually created using SceneManager::createSceneNode, but in this case you should create a standard SceneNode instance manually; this is because these scene nodes are not managed by the SceneManager and some custom SceneManager plugins will rely on specialist behaviour the overlay does not support. By attaching a SceneNode to an overlay, you indicate that:You want the contents of this node to only appear when the overlay is active You want the node to inherit a coordinate space relative to the camera, rather than relative to the root scene node You want these objects to be rendered after the contents of the main scene to ensure they are rendered on top 
One major consideration when using 3D objects in overlays is the behaviour of the depth buffer. Overlays should use materials with depth checking off, to ensure that their contents are always displayed on top of the main scene (to do otherwise would result in objects 'poking through' the overlay). The problem with using 3D objects is that if they are concave, or self-overlap, then you can get artefacts because of the lack of depth buffer checking. So you should ensure that any 3D objects you us in the overlay are convex, and don't overlap each other. If they must overlap, split them up and put them in 2 overlays. Alternatively, use a 2D element underneath them which will clear the depth buffer values underneath ready for the 3D element to be rendered correctly. </summary>
    </member>
    <member name="M:Mogre.Overlay.Remove3D(Mogre.SceneNode)">
      <summary>Removes a 3D element from the overlay. </summary>
    </member>
    <member name="M:Mogre.Overlay.Clear">
      <summary>Clears the overlay of all attached items. </summary>
    </member>
    <member name="M:Mogre.Overlay.SetScroll(System.Single,System.Single)">
      <summary>Sets the scrolling factor of this overlay. You can use this to set an offset to be used to scroll an overlay around the screen. </summary>
      <param name="x">Horizontal scroll value, where 0 = normal, -0.5 = scroll so that only the right half the screen is visible etc </param>
      <param name="y">Vertical scroll value, where 0 = normal, 0.5 = scroll down by half a screen etc. </param>
    </member>
    <member name="M:Mogre.Overlay.Scroll(System.Single,System.Single)">
      <summary>Scrolls the overlay by the offsets provided. This method moves the overlay by the amounts provided. As with other methods on this object, a full screen width / height is represented by the value 1.0. </summary>
    </member>
    <member name="M:Mogre.Overlay.SetRotate(Mogre.Radian)">
      <summary>Sets the rotation applied to this overlay. </summary>
    </member>
    <member name="M:Mogre.Overlay.GetRotate">
      <summary>Gets the rotation applied to this overlay, in degrees. </summary>
    </member>
    <member name="M:Mogre.Overlay.Rotate(Mogre.Radian)">
      <summary>Adds the passed in angle to the rotation applied to this overlay. </summary>
    </member>
    <member name="M:Mogre.Overlay.SetScale(System.Single,System.Single)">
      <summary>Sets the scaling factor of this overlay. You can use this to set an scale factor to be used to zoom an overlay. </summary>
      <param name="x">Horizontal scale value, where 1.0 = normal, 0.5 = half size etc </param>
      <param name="y">Vertical scale value, where 1.0 = normal, 0.5 = half size etc </param>
    </member>
    <member name="M:Mogre.Overlay._findVisibleObjects(Mogre.Camera,Mogre.RenderQueue)">
      <summary>Internal method to put the overlay contents onto the render queue. </summary>
    </member>
    <member name="M:Mogre.Overlay.FindElementAt(System.Single,System.Single)">
      <summary>This returns a OverlayElement at position x,y. </summary>
    </member>
    <member name="M:Mogre.Overlay._notifyOrigin(System.String)">
      <summary>Notify this overlay of it's origin. </summary>
    </member>
    <member name="M:Mogre.Overlay.#ctor(System.String)">
      <summary>Constructor: do not call direct, use OverlayManager::create. </summary>
    </member>
    <member name="P:Mogre.Overlay.ZOrder">
      <summary>Sets/Gets the ZOrder of this overlay. </summary>
    </member>
    <member name="P:Mogre.Overlay.ScrollY">
      <summary>Gets the current Y scroll value </summary>
    </member>
    <member name="P:Mogre.Overlay.ScrollX">
      <summary>Gets the current X scroll value </summary>
    </member>
    <member name="P:Mogre.Overlay.ScaleY">
      <summary>Gets the current Y scale value </summary>
    </member>
    <member name="P:Mogre.Overlay.ScaleX">
      <summary>Gets the current X scale value </summary>
    </member>
    <member name="P:Mogre.Overlay.Origin">
      <summary>Get the origin of this overlay, e.g. a script file name. This property will only contain something if the creator of this overlay chose to populate it. Script loaders are advised to populate it. </summary>
    </member>
    <member name="P:Mogre.Overlay.Name">
      <summary>Gets the name of this overlay. </summary>
    </member>
    <member name="P:Mogre.Overlay.IsVisible">
      <summary>Gets whether the overlay is displayed or not. </summary>
    </member>
    <member name="P:Mogre.Overlay.IsInitialised">
      <summary>Gets whether the overlay is initialised or not. </summary>
    </member>
    <member name="T:Mogre.OverlayElementFactory">
      <summary>Defines the interface which all components wishing to supply OverlayElement subclasses must implement. To allow the OverlayElement types available for inclusion on overlays to be extended, OGRE allows external apps or plugins to register their ability to create custom OverlayElements with the OverlayManager, using the addOverlayElementFactory method. Classes wanting to do this must implement this interface. Each OverlayElementFactory creates a single type of OverlayElement, identified by a 'type name' which must be unique. </summary>
    </member>
    <member name="M:Mogre.OverlayElementFactory.CreateOverlayElement(System.String)">
      <summary>Creates a new OverlayElement instance with the name supplied. </summary>
    </member>
    <member name="M:Mogre.OverlayElementFactory.DestroyOverlayElement(Mogre.OverlayElement)">
      <summary>Destroys a OverlayElement which this factory created previously. </summary>
    </member>
    <member name="P:Mogre.OverlayElementFactory.TypeName">
      <summary>Gets the string uniquely identifying the type of element this factory creates. </summary>
    </member>
    <member name="T:Mogre.PanelOverlayElementFactory">
      <summary>Factory for creating PanelOverlayElement instances. </summary>
    </member>
    <member name="M:Mogre.PanelOverlayElementFactory.CreateOverlayElement(System.String)">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="M:Mogre.PanelOverlayElementFactory.CreateOverlayElement(System.String)">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="P:Mogre.PanelOverlayElementFactory.TypeName">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="T:Mogre.BorderPanelOverlayElementFactory">
      <summary>Factory for creating BorderPanelOverlayElement instances. </summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElementFactory.CreateOverlayElement(System.String)">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="M:Mogre.BorderPanelOverlayElementFactory.CreateOverlayElement(System.String)">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="P:Mogre.BorderPanelOverlayElementFactory.TypeName">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="T:Mogre.TextAreaOverlayElementFactory">
      <summary>Factory for creating TextAreaOverlayElement instances. </summary>
    </member>
    <member name="M:Mogre.TextAreaOverlayElementFactory.CreateOverlayElement(System.String)">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="M:Mogre.TextAreaOverlayElementFactory.CreateOverlayElement(System.String)">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="P:Mogre.TextAreaOverlayElementFactory.TypeName">
      <summary>See OverlayElementFactory</summary>
    </member>
    <member name="T:Mogre.OverlayManager">
      <summary>Manages Overlay objects, parsing them from .overlay files and storing a lookup library of them. Alo manages the creation of OverlayContainers and OverlayElements, used for non-interactive 2D elements such as HUDs. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.GetScriptPatterns">
      <summary>Gets the file patterns which should be used to find scripts for this class. This method is called when a resource group is loaded if you use ResourceGroupManager::_registerScriptLoader. A list of file patterns, in the order they should be searched in.</summary>
    </member>
    <member name="M:Mogre.OverlayManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>Parse a script file. streamWeak reference to a data stream which is the source of the script groupNameThe name of a resource group which should be used if any resources are created during the parse of this script.</summary>
    </member>
    <member name="M:Mogre.OverlayManager.Create(System.String)">
      <summary>Create a new Overlay. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.GetByName(System.String)">
      <summary>Retrieve an Overlay by name A pointer to the Overlay, or 0 if not found </summary>
    </member>
    <member name="M:Mogre.OverlayManager.Destroy(Mogre.Overlay)">
      <summary>Destroys an existing overlay </summary>
    </member>
    <member name="M:Mogre.OverlayManager.Destroy(System.String)">
      <summary>Destroys an existing overlay by name </summary>
    </member>
    <member name="M:Mogre.OverlayManager.DestroyAll">
      <summary>Destroys all existing overlays </summary>
    </member>
    <member name="M:Mogre.OverlayManager._queueOverlaysForRendering(Mogre.Camera,Mogre.RenderQueue,Mogre.Viewport)">
      <summary>Internal method for queueing the visible overlays for rendering. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.CreateOverlayElement(System.String,System.String)">
      <summary>Creates a new OverlayElement of the type requested. The type of element to create is passed in as a string because this allows plugins to register new types of component. </summary>
      <param name="typeName">The type of element to create. </param>
      <param name="instanceName">The name to give the new instance. </param>
    </member>
    <member name="M:Mogre.OverlayManager.CreateOverlayElement(System.String,System.String,System.Boolean)">
      <summary>Creates a new OverlayElement of the type requested. The type of element to create is passed in as a string because this allows plugins to register new types of component. </summary>
      <param name="typeName">The type of element to create. </param>
      <param name="instanceName">The name to give the new instance. </param>
    </member>
    <member name="M:Mogre.OverlayManager.GetOverlayElement(System.String)">
      <summary>Gets a reference to an existing element. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.GetOverlayElement(System.String,System.Boolean)">
      <summary>Gets a reference to an existing element. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.HasOverlayElement(System.String)">
      <summary>Tests if an element exists. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.HasOverlayElement(System.String,System.Boolean)">
      <summary>Tests if an element exists. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.DestroyOverlayElement(Mogre.OverlayElement)">
      <summary>Destroys a OverlayElement. Make sure you're not still using this in an Overlay. If in doubt, let OGRE destroy elements on shutdown. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.DestroyOverlayElement(Mogre.OverlayElement,System.Boolean)">
      <summary>Destroys a OverlayElement. Make sure you're not still using this in an Overlay. If in doubt, let OGRE destroy elements on shutdown. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.DestroyOverlayElement(System.String)">
      <summary>Destroys a OverlayElement. Make sure you're not still using this in an Overlay. If in doubt, let OGRE destroy elements on shutdown. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.DestroyOverlayElement(System.String,System.Boolean)">
      <summary>Destroys a OverlayElement. Make sure you're not still using this in an Overlay. If in doubt, let OGRE destroy elements on shutdown. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.DestroyAllOverlayElements">
      <summary>Destroys all the OverlayElement created so far. Best to leave this to the engine to call internally, there should rarely be a need to call it yourself. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.DestroyAllOverlayElements(System.Boolean)">
      <summary>Destroys all the OverlayElement created so far. Best to leave this to the engine to call internally, there should rarely be a need to call it yourself. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.AddOverlayElementFactory(Mogre.OverlayElementFactory)">
      <summary>Registers a new OverlayElementFactory with this manager. Should be used by plugins or other apps wishing to provide a new OverlayElement subclass. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.GetOverlayElementFactoryMap">
      <summary>Get const access to the list of registered OverlayElement factories. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.CloneOverlayElementFromTemplate(System.String,System.String)">
      <summary>Creates a new OverlayElement object from the specified template name. The new object's name, and all of it's children, will be instanceName/orignalName. </summary>
    </member>
    <member name="M:Mogre.OverlayManager.GetTemplateIterator">
      <summary>Returns an iterator over all templates in this manager. </summary>
    </member>
    <member name="P:Mogre.OverlayManager.ViewportWidth">
      <summary>Gets the width of the destination viewport in pixels. </summary>
    </member>
    <member name="P:Mogre.OverlayManager.ViewportOrientationMode">
      <summary>Gets the orientation mode of the destination viewport. </summary>
    </member>
    <member name="P:Mogre.OverlayManager.ViewportHeight">
      <summary>Gets the height of the destination viewport in pixels. </summary>
    </member>
    <member name="P:Mogre.OverlayManager.LoadingOrder">
      <summary>Gets the relative loading order of scripts of this type. There are dependencies between some kinds of scripts, and to enforce this all implementors of this interface must define a loading order. A value representing the relative loading order of these scripts compared to other script users, where higher values load later.</summary>
    </member>
    <member name="P:Mogre.OverlayManager.HasViewportChanged">
      <summary>Method for determining if the viewport has changed dimensions. This is used by pixel-based OverlayElements to work out if they need to recalculate their sizes. </summary>
    </member>
    <member name="P:Mogre.OverlayManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.Particle">
      <summary>Class representing a single particle instance. </summary>
    </member>
    <member name="M:Mogre.Particle.SetDimensions(System.Single,System.Single)">
      <summary>Sets the width and height for this particle. Note that it is most efficient for every particle in a ParticleSystem to have the same dimensions. If you choose to alter the dimensions of an individual particle the set will be less efficient. Do not call this method unless you really need to have different particle dimensions within the same set. Otherwise just call the ParticleSystem::setDefaultDimensions method instead. </summary>
    </member>
    <member name="M:Mogre.Particle._notifyOwner(Mogre.ParticleSystem)">
      <summary>Internal method for notifying the particle of it's owner. </summary>
    </member>
    <member name="M:Mogre.Particle.ResetDimensions">
      <summary>Utility method to reset this particle. </summary>
    </member>
    <member name="P:Mogre.Particle.Rotation">
      <summary>Sets/Current rotation value. </summary>
    </member>
    <member name="P:Mogre.Particle.OwnWidth">
      <summary>Retrieves the particle's personal width, if hasOwnDimensions is true. </summary>
    </member>
    <member name="P:Mogre.Particle.OwnHeight">
      <summary>Retrieves the particle's personal width, if hasOwnDimensions is true. </summary>
    </member>
    <member name="P:Mogre.Particle.HasOwnDimensions">
      <summary>Returns true if this particle deviates from the ParticleSystem's default dimensions (i.e. if the particle::setDimensions method has been called for this instance). particle::setDimensions </summary>
    </member>
    <member name="P:Mogre.Particle.particleType">
      <summary>Sets/Type of particle. </summary>
    </member>
    <member name="P:Mogre.Particle.rotationSpeed">
      <summary>Sets/Speed of rotation in radians/sec. </summary>
    </member>
    <member name="P:Mogre.Particle.totalTimeToLive">
      <summary>Sets/Total Time to live, number of seconds of particles natural life. </summary>
    </member>
    <member name="P:Mogre.Particle.timeToLive">
      <summary>Sets/Time to live, number of seconds left of particles natural life. </summary>
    </member>
    <member name="P:Mogre.Particle.colour">
      <summary>Sets/Current colour. </summary>
    </member>
    <member name="P:Mogre.Particle.direction">
      <summary>Sets/Direction (and speed). </summary>
    </member>
    <member name="P:Mogre.Particle.position">
      <summary>Sets/World position. </summary>
    </member>
    <member name="P:Mogre.Particle.rotation">
      <summary>Sets/Current rotation value. </summary>
    </member>
    <member name="P:Mogre.Particle.mHeight">
      <summary>Sets/Personal height if mOwnDimensions == true. </summary>
    </member>
    <member name="P:Mogre.Particle.mWidth">
      <summary>Sets/Personal width if mOwnDimensions == true. </summary>
    </member>
    <member name="P:Mogre.Particle.mOwnDimensions">
      <summary>Sets/Does this particle have it's own dimensions? </summary>
    </member>
    <member name="T:Mogre.Particle+ParticleType">
      <summary>Type of particle. </summary>
    </member>
    <member name="T:Mogre.ParticleSystem">
      <summary>Class defining particle system based special effects. Particle systems are special effects generators which are based on a number of moving points to create the impression of things like like sparkles, smoke, blood spurts, dust etc. This class simply manages a single collection of particles in world space with a shared local origin for emission. The visual aspect of the particles is handled by a ParticleSystemRenderer instance. Particle systems are created using the SceneManager, never directly. In addition, like all subclasses of MovableObject, the ParticleSystem will only be considered for rendering once it has been attached to a SceneNode. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.SetRenderer(System.String)">
      <summary>Sets the ParticleRenderer to be used to render this particle system. The main ParticleSystem just manages the creation and movement of particles; they are rendered using functions in ParticleRenderer and the ParticleVisual instances they create. </summary>
      <param name="typeName">String identifying the type of renderer to use; a new instance of this type will be created; a factory must have been registered with ParticleSystemManager. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.AddEmitter(System.String)">
      <summary>Adds an emitter to this particle system. Particles are created in a particle system by emitters - see the ParticleEmitter class for more details. </summary>
      <param name="emitterType">String identifying the emitter type to create. Emitter types are defined by registering new factories with the manager - see ParticleEmitterFactory for more details. Emitter types can be extended by OGRE, plugin authors or application developers. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.GetEmitter(System.UInt16)">
      <summary>Retrieves an emitter by it's index (zero-based). Used to retrieve a pointer to an emitter for a particle system to procedurally change emission parameters etc. You should check how many emitters are registered against this system before calling this method with an arbitrary index using getNumEmitters. </summary>
      <param name="index">Zero-based index of the emitter to retrieve. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.RemoveEmitter(System.UInt16)">
      <summary>Removes an emitter from the system. Drops the emitter with the index specified from this system. You should check how many emitters are registered against this system before calling this method with an arbitrary index using getNumEmitters. </summary>
      <param name="index">Zero-based index of the emitter to retrieve. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.RemoveAllEmitters">
      <summary>Removes all the emitters from this system. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.AddAffector(System.String)">
      <summary>Adds an affector to this particle system. Particles are modified over time in a particle system by affectors - see the ParticleAffector class for more details. </summary>
      <param name="affectorType">String identifying the affector type to create. Affector types are defined by registering new factories with the manager - see ParticleAffectorFactory for more details. Affector types can be extended by OGRE, plugin authors or application developers. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.GetAffector(System.UInt16)">
      <summary>Retrieves an affector by it's index (zero-based). Used to retrieve a pointer to an affector for a particle system to procedurally change affector parameters etc. You should check how many affectors are registered against this system before calling this method with an arbitrary index using getNumAffectors. </summary>
      <param name="index">Zero-based index of the affector to retrieve. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.RemoveAffector(System.UInt16)">
      <summary>Removes an affector from the system. Drops the affector with the index specified from this system. You should check how many affectors are registered against this system before calling this method with an arbitrary index using getNumAffectors. </summary>
      <param name="index">Zero-based index of the affector to retrieve. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.RemoveAllAffectors">
      <summary>Removes all the affectors from this system. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.Clear">
      <summary>Empties this set of all particles. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.CreateParticle">
      <summary>Manually add a particle to the system. Instead of using an emitter, you can manually add a particle to the system. You must initialise the returned particle instance immediately with the 'emission' state. There is no corresponding 'destroyParticle' method - if you want to dispose of a particle manually (say, if you've used setSpeedFactor(0) to make particles live forever) you should use getParticle() and modify it's timeToLive to zero, meaning that it will get cleaned up in the next update. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.CreateEmitterParticle(System.String)">
      <summary>Manually add an emitter particle to the system. The purpose of a particle emitter is to emit particles. Besides visual particles, also other other particle types can be emitted, other emitters for example. The emitted emitters have a double role; they behave as particles and can be influenced by affectors, but they are still emitters and capable to emit other particles (or emitters). It is possible to create a chain of emitters - emitters emitting other emitters, which also emit emitters. </summary>
      <param name="emitterName">The name of a particle emitter that must be emitted. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.GetParticle(System.UInt32)">
      <summary>Retrieve a particle from the system for manual tweaking. Normally you use an affector to alter particles in flight, but for small manually controlled particle systems you might want to use this method. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem._update(System.Single)">
      <summary>Updates the particles in the system based on time elapsed. This is called automatically every frame by OGRE. </summary>
      <param name="timeElapsed">The amount of time, in seconds, since the last frame. </param>
    </member>
    <member name="M:Mogre.ParticleSystem._getIterator">
      <summary>Returns an iterator for stepping through all particles in this system. This method is designed to be used by people providing new ParticleAffector subclasses, this is the easiest way to step through all the particles in a system and apply the changes the affector wants to make. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.SetMaterialName(System.String)">
      <summary>Sets the name of the material to be used for this billboard set. </summary>
      <param name="name">The new name of the material to use for this set. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.SetMaterialName(System.String,System.String)">
      <summary>Sets the name of the material to be used for this billboard set. </summary>
      <param name="name">The new name of the material to use for this set. </param>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyAttached(Mogre.Node)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem.FastForward(System.Single)">
      <summary>Fast-forwards this system by the required number of seconds. This method allows you to fast-forward a system so that it effectively looks like it has already been running for the time you specify. This is useful to avoid the 'startup sequence' of a system, when you want the system to be fully populated right from the start. </summary>
      <param name="time">The number of seconds to fast-forward by. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.FastForward(System.Single,System.Single)">
      <summary>Fast-forwards this system by the required number of seconds. This method allows you to fast-forward a system so that it effectively looks like it has already been running for the time you specify. This is useful to avoid the 'startup sequence' of a system, when you want the system to be fully populated right from the start. </summary>
      <param name="time">The number of seconds to fast-forward by. </param>
      <param name="interval">The sampling interval used to generate particles, apply affectors etc. The lower this is the more realistic the fast-forward, but it takes more iterations to do it. </param>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyParticleResized">
      <summary>Internal callback used by Particles to notify their parent that they have been resized. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyParticleRotated">
      <summary>Internal callback used by Particles to notify their parent that they have been rotated. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.SetDefaultDimensions(System.Single,System.Single)">
      <summary>Sets the default dimensions of the particles in this set. All particles in a set are created with these default dimensions. The set will render most efficiently if all the particles in the set are the default size. It is possible to alter the size of individual particles at the expense of extra calculation. See the Particle class for more info. </summary>
      <param name="width">The new default width for the particles in this set. </param>
      <param name="height">The new default height for the particles in this set. </param>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyOrigin(System.String)">
      <summary>Notify this particle system of it's origin. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.SetBounds(Mogre.AxisAlignedBox)">
      <summary>Set the (initial) bounds of the particle system manually. If you can, set the bounds of a particle system up-front and call setBoundsAutoUpdated(false); this is the most efficient way to organise it. Otherwise, set an initial bounds and let the bounds increase for a little while (the default is 5 seconds), after which time the AABB is fixed to save time. </summary>
      <param name="aabb">Bounds in local space. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.SetBoundsAutoUpdated(System.Boolean)">
      <summary>Sets whether the bounds will be automatically updated for the life of the particle system If you have a stationary particle system, it would be a good idea to call this method and set the value to 'false', since the maximum bounds of the particle system will eventually be static. If you do this, you can either set the bounds manually using the setBounds() method, or set the second parameter of this method to a positive number of seconds, so that the bounds are calculated for a few seconds and then frozen. </summary>
      <param name="autoUpdate">If true (the default), the particle system will update it's bounds every frame. If false, the bounds update will cease after the 'stopIn' number of seconds have passed. </param>
    </member>
    <member name="M:Mogre.ParticleSystem.SetBoundsAutoUpdated(System.Boolean,System.Single)">
      <summary>Sets whether the bounds will be automatically updated for the life of the particle system If you have a stationary particle system, it would be a good idea to call this method and set the value to 'false', since the maximum bounds of the particle system will eventually be static. If you do this, you can either set the bounds manually using the setBounds() method, or set the second parameter of this method to a positive number of seconds, so that the bounds are calculated for a few seconds and then frozen. </summary>
      <param name="autoUpdate">If true (the default), the particle system will update it's bounds every frame. If false, the bounds update will cease after the 'stopIn' number of seconds have passed. </param>
      <param name="stopIn">Only applicable if the first parameter is true, this is the number of seconds after which the automatic update will cease. </param>
    </member>
    <member name="M:Mogre.ParticleSystem._updateBounds">
      <summary>Internal method for updating the bounds of the particle system. This is called automatically for a period of time after the system's creation (10 seconds by default, settable by setBoundsAutoUpdated) to increase (and only increase) the bounds of the system according to the emitted and affected particles. After this period, the system is assumed to achieved its maximum size, and the bounds are no longer computed for efficiency. You can tweak the behaviour by either setting the bounds manually (setBounds, preferred), or changing the time over which the bounds are updated (performance cost). You can also call this method manually if you need to update the bounds on an ad-hoc basis. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyAttached(Mogre.Node)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyAttached(Mogre.Node,System.Boolean)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem._notifyCurrentCamera(Mogre.Camera)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem._updateRenderQueue(Mogre.RenderQueue)">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="M:Mogre.ParticleSystem.#ctor(System.String,System.String)">
      <summary>Creates a particle system with no emitters or affectors. You should use the ParticleSystemManager to create particle systems rather than creating them directly. </summary>
    </member>
    <member name="M:Mogre.ParticleSystem.#ctor">
      <summary>Default constructor required for STL creation in manager. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.TypeFlags">
      <summary>Override to return specific type flag. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.SpeedFactor">
      <summary>Sets/Gets the 'speed factor' on this particle system. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.SortingEnabled">
      <summary>Sets/Gets whether particles are sorted relative to the camera. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.ResourceGroupName">
      <summary>Return the resource group to be used to load dependent resources. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.RendererName">
      <summary>Gets the name of the ParticleRenderer to be used to render this particle system. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.Renderer">
      <summary>Gets the ParticleRenderer to be used to render this particle system. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.ParticleQuota">
      <summary>Sets/Returns the maximum number of particles this system is allowed to have active at once. See ParticleSystem::setParticleQuota for more info. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.Origin">
      <summary>Get the origin of this particle system, e.g. a script file name. This property will only contain something if the creator of this particle system chose to populate it. Script loaders are advised to populate it. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.NumParticles">
      <summary>Gets the number of individual particles in the system right now. The number of particles active in a system at a point in time depends on the number of emitters, their emission rates, the time-to-live (TTL) each particle is given on emission (and whether any affectors modify that TTL) and the maximum number of particles allowed in this system at once (particle quota). </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.NumEmitters">
      <summary>Returns the number of emitters for this particle system. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.NumAffectors">
      <summary>Returns the number of affectors for this particle system. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.NonVisibleUpdateTimeout">
      <summary>Sets/Gets when the particle system should stop updating after it hasn't been visible for a while. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="P:Mogre.ParticleSystem.MaterialName">
      <summary>Sets the name of the material to be used for this billboard set. The name of the material that is used for this set. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.KeepParticlesInLocalSpace">
      <summary>Sets/Gets whether particles (and any affector effects) remain relative to the node the particle system is attached to. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.IterationInterval">
      <summary>Sets/Gets a 'iteration interval' on this particle system. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.Emitting">
      <summary>Sets/Returns true if the particle system emitting flag is turned on. This function will not actually return whether the particles are being emitted. It only returns the value of emitting flag. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.EmittedEmitterQuota">
      <summary>Sets/Returns the maximum number of emitted emitters this system is allowed to have active at once. See ParticleSystem::setEmittedEmitterQuota for more info. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.DefaultWidth">
      <summary>Sets/See setDefaultDimensions - this gets 1 component individually. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.DefaultNonVisibleUpdateTimeout">
      <summary>Sets/Get the default nonvisible timeout for all ParticleSystem instances. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.DefaultIterationInterval">
      <summary>Sets/Get the default iteration interval for all ParticleSystem instances. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.DefaultHeight">
      <summary>Sets/See setDefaultDimensions - this gets 1 component individually. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.CullIndividually">
      <summary>Sets/Returns whether or not particles in this are tested individually for culling. </summary>
    </member>
    <member name="P:Mogre.ParticleSystem.BoundingRadius">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="P:Mogre.ParticleSystem.BoundingBox">
      <summary>Overridden from MovableObjectMovableObject</summary>
    </member>
    <member name="T:Mogre.ParticleAffector">
      <summary>Abstract class defining the interface to be implemented by particle affectors. Particle affectors modify particles in a particle system over their lifetime. They can be grouped into types, e.g. 'vector force' affectors, 'fader' affectors etc; each type will modify particles in a different way, using different parameters. Because there are so many types of affectors you could use, OGRE chooses not to dictate the available types. It comes with some in-built, but allows plugins or applications to extend the affector types available. This is done by subclassing ParticleAffector to have the appropriate emission behaviour you want, and also creating a subclass of ParticleAffectorFactory which is responsible for creating instances of your new affector type. You register this factory with the ParticleSystemManager using addAffectorFactory, and from then on affectors of this type can be created either from code or through text particle scripts by naming the type. This same approach is used for ParticleEmitters (which are the source of particles in a system). This means that OGRE is particularly flexible when it comes to creating particle system effects, with literally infinite combinations of affector and affector types, and parameters within those types. </summary>
    </member>
    <member name="M:Mogre.ParticleAffector._initParticle(Mogre.Particle)">
      <summary>Method called to allow the affector to initialize all newly created particles in the system. This is where the affector gets the chance to initialize it's effects to the particles of a system. The affector is expected to initialize some or all of the particles in the system passed to it, depending on the affector's approach. </summary>
      <param name="pParticle">Pointer to a Particle to initialize. </param>
    </member>
    <member name="M:Mogre.ParticleAffector._affectParticles(Mogre.ParticleSystem,System.Single)">
      <summary>Method called to allow the affector to 'do it's stuff' on all active particles in the system. This is where the affector gets the chance to apply it's effects to the particles of a system. The affector is expected to apply it's effect to some or all of the particles in the system passed to it, depending on the affector's approach. </summary>
      <param name="pSystem">Pointer to a ParticleSystem to affect. </param>
      <param name="timeElapsed">The number of seconds which have elapsed since the last call. </param>
    </member>
    <member name="P:Mogre.ParticleAffector.Type">
      <summary>Returns the name of the type of affector. This property is useful for determining the type of affector procedurally so another can be created. </summary>
    </member>
    <member name="T:Mogre.ParticleAffectorFactory">
      <summary>Abstract class defining the interface to be implemented by creators of ParticleAffector subclasses. Plugins or 3rd party applications can add new types of particle affectors to Ogre by creating subclasses of the ParticleAffector class. Because multiple instances of these affectors may be required, a factory class to manage the instances is also required. ParticleAffectorFactory subclasses must allow the creation and destruction of ParticleAffector subclasses. They must also be registered with the ParticleSystemManager. All factories have a name which identifies them, examples might be 'force_vector', 'attractor', or 'fader', and these can be also be used from particle system scripts. </summary>
    </member>
    <member name="M:Mogre.ParticleAffectorFactory.CreateAffector(Mogre.ParticleSystem)">
      <summary>Creates a new affector instance. The subclass MUST add a pointer to the created instance to mAffectors. </summary>
    </member>
    <member name="M:Mogre.ParticleAffectorFactory.DestroyAffector(Mogre.ParticleAffector)">
      <summary>Destroys the affector pointed to by the parameter (for early clean up if required). </summary>
    </member>
    <member name="P:Mogre.ParticleAffectorFactory.Name">
      <summary>Returns the name of the factory, the name which identifies the particle affector type this factory creates. </summary>
    </member>
    <member name="T:Mogre.ParticleEmitter">
      <summary>Abstract class defining the interface to be implemented by particle emitters. Particle emitters are the sources of particles in a particle system. This class defines the ParticleEmitter interface, and provides a basic implementation for tasks which most emitters will do (these are of course overridable). Particle emitters can be grouped into types, e.g. 'point' emitters, 'box' emitters etc; each type will create particles with a different starting point, direction and velocity (although within the types you can configure the ranges of these parameters). Because there are so many types of emitters you could use, OGRE chooses not to dictate the available types. It comes with some in-built, but allows plugins or applications to extend the emitter types available. This is done by subclassing ParticleEmitter to have the appropriate emission behaviour you want, and also creating a subclass of ParticleEmitterFactory which is responsible for creating instances of your new emitter type. You register this factory with the ParticleSystemManager using addEmitterFactory, and from then on emitters of this type can be created either from code or through text particle scripts by naming the type. This same approach is used for ParticleAffectors (which modify existing particles per frame). This means that OGRE is particularly flexible when it comes to creating particle system effects, with literally infinite combinations of emitter and affector types, and paramters within those types. </summary>
    </member>
    <member name="M:Mogre.ParticleEmitter.SetParticleVelocity(System.Single,System.Single)">
      <summary>Sets the initial velocity range of particles emitted. This method sets the range of starting speeds for emitted particles. See the alternate version of this method which takes 1 parameter if you want a constant speed. This emitter will randomly choose a speed between the minimum and maximum for each particle. </summary>
      <param name="max">The maximum speed in world units per second for the initial particle speed on emission. </param>
      <param name="min">The minimum speed in world units per second for the initial particle speed on emission. </param>
    </member>
    <member name="M:Mogre.ParticleEmitter.SetTimeToLive(System.Single,System.Single)">
      <summary>Sets the range of lifetime for particles emitted. The emitter initialises particles with a time-to-live (TTL), the number of seconds a particle will exist before being destroyed. This method sets a range for the TTL for all particles emitted; the ttl may be randomised between these 2 extremes or will vary some other way depending on the emitter. Note that affectors are able to modify the TTL of particles later. Also see the alternate version of this method which takes a single TTL in order to set a constant TTL for all particles. </summary>
      <param name="minTtl">The minimum number of seconds each particle will live for. </param>
      <param name="maxTtl">The maximum number of seconds each particle will live for. </param>
    </member>
    <member name="M:Mogre.ParticleEmitter.SetColour(Mogre.ColourValue,Mogre.ColourValue)">
      <summary>Sets the range of colours for emitted particles. Particles have an initial colour on emission which the emitter sets. This method sets the range of this colour. See the alternate version of this method which takes a single colour in order to set a constant colour for all particles. Emitters may choose to randomly assign a colour in this range, or may use some other method to vary the colour. </summary>
      <param name="colourStart">The start of the colour range </param>
      <param name="colourEnd">The end of the colour range </param>
    </member>
    <member name="M:Mogre.ParticleEmitter._getEmissionCount(System.Single)">
      <summary>Gets the number of particles which this emitter would like to emit based on the time elapsed. For efficiency the emitter does not actually create new Particle instances (these are reused by the ParticleSystem as existing particles 'die'). The implementation for this method must return the number of particles the emitter would like to emit given the number of seconds which have elapsed (passed in as a parameter). Based on the return value from this method, the ParticleSystem class will call _initParticle once for each particle it chooses to allow to be emitted by this emitter. The emitter should not track these _initParticle calls, it should assume all emissions requested were made (even if they could not be because of particle quotas). </summary>
    </member>
    <member name="M:Mogre.ParticleEmitter._initParticle(Mogre.Particle)">
      <summary>Initialises a particle based on the emitter's approach and parameters. See the _getEmissionCount method for details of why there is a separation between 'requested' emissions and actual initialised particles. </summary>
      <param name="pParticle">Pointer to a particle which must be initialised based on how this emitter starts particles. This is passed as a pointer rather than being created by the emitter so the ParticleSystem can reuse Particle instances, and can also set defaults itself. </param>
    </member>
    <member name="M:Mogre.ParticleEmitter.SetDuration(System.Single,System.Single)">
      <summary>Sets the range of random duration for this emitter. By default emitters run indefinitely (unless you manually disable them). By setting this parameter, you can make an emitter turn off on it's own after a random number of seconds. It will then remain disabled until either setEnabled(true) is called, or if the 'repeatAfter' parameter has been set it will also repeat after a number of seconds. Also see the alternative version of this method which allows you to set a constant duration. </summary>
      <param name="min">The minimum duration in seconds. </param>
      <param name="max">The minimum duration in seconds. </param>
    </member>
    <member name="M:Mogre.ParticleEmitter.SetRepeatDelay(System.Single,System.Single)">
      <summary>Sets the range of random duration for this emitter. By default emitters run indefinitely (unless you manually disable them). By setting this parameter, you can make an emitter turn off on it's own after a random number of seconds. It will then remain disabled until either setEnabled(true) is called, or if the 'repeatAfter' parameter has been set it will also repeat after a number of seconds. Also see the alternative version of this method which allows you to set a constant duration. </summary>
      <param name="min">The minimum duration in seconds. </param>
      <param name="max">The minimum duration in seconds. </param>
    </member>
    <member name="M:Mogre.ParticleEmitter.SetEmitted(System.Boolean)">
      <summary>Set the indication (true/false) to indicate that the emitter is emitted by another emitter </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Type">
      <summary>Returns the name of the type of emitter. This property is useful for determining the type of emitter procedurally so another can be created. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.TimeToLive">
      <summary>Sets/Gets the time each particle will live for. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.StartTime">
      <summary>Sets/Gets the start time of the emitter. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.RepeatDelay">
      <summary>Sets/Gets the duration of the emitter from when it is created or re-enabled. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Position">
      <summary>Sets/Returns the position of this emitter relative to the center of the particle system. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.ParticleVelocity">
      <summary>Sets/Returns the initial velocity of particles emitted. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Name">
      <summary>Sets/Returns the name of the emitter </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MinTimeToLive">
      <summary>Sets/Gets the minimum time each particle will live for. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MinRepeatDelay">
      <summary>Sets/Gets the minimum duration of this emitter in seconds (see setRepeatDelay for more details) </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MinParticleVelocity">
      <summary>Sets/Returns the minimum particle velocity. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MinDuration">
      <summary>Sets/Gets the minimum duration of this emitter in seconds (see setDuration for more details) </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MaxTimeToLive">
      <summary>Sets/Gets the maximum time each particle will live for. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MaxRepeatDelay">
      <summary>Sets/Gets the maximum duration of this emitter in seconds (see setRepeatDelay for more details) </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MaxParticleVelocity">
      <summary>Sets/Returns the maximum particle velocity. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.MaxDuration">
      <summary>Sets/Gets the maximum duration of this emitter in seconds (see setDuration for more details) </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.IsEmitted">
      <summary>Return true if the emitter is emitted by another emitter </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Enabled">
      <summary>Sets/Gets the flag indicating if this emitter is enabled or not. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.EmittedEmitter">
      <summary>Sets/Returns the name of the emitter to be emitted </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.EmissionRate">
      <summary>Sets/Returns the emission rate set for this emitter. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Duration">
      <summary>Sets/Gets the duration of the emitter from when it is created or re-enabled. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Direction">
      <summary>Sets/Returns the base direction of the emitter. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.ColourRangeStart">
      <summary>Sets/Gets the minimum colour of particles to be emitted. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.ColourRangeEnd">
      <summary>Sets/Gets the maximum colour of particles to be emitted. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Colour">
      <summary>Sets/Gets the colour of particles to be emitted. </summary>
    </member>
    <member name="P:Mogre.ParticleEmitter.Angle">
      <summary>Sets/Returns the maximum angle which the initial particle direction can deviate from the emitters base direction. </summary>
    </member>
    <member name="T:Mogre.ParticleEmitterFactory">
      <summary>Abstract class defining the interface to be implemented by creators of ParticleEmitter subclasses. Plugins or 3rd party applications can add new types of particle emitters to Ogre by creating subclasses of the ParticleEmitter class. Because multiple instances of these emitters may be required, a factory class to manage the instances is also required. ParticleEmitterFactory subclasses must allow the creation and destruction of ParticleEmitter subclasses. They must also be registered with the ParticleSystemManager. All factories have a name which identifies them, examples might be 'point', 'cone', or 'box', and these can be also be used from particle system scripts. </summary>
    </member>
    <member name="M:Mogre.ParticleEmitterFactory.CreateEmitter(Mogre.ParticleSystem)">
      <summary>Creates a new emitter instance. The subclass MUST add a pointer to the created instance to mEmitters. </summary>
    </member>
    <member name="M:Mogre.ParticleEmitterFactory.DestroyEmitter(Mogre.ParticleEmitter)">
      <summary>Destroys the emitter pointed to by the parameter (for early clean up if required). </summary>
    </member>
    <member name="P:Mogre.ParticleEmitterFactory.Name">
      <summary>Returns the name of the factory, the name which identifies the particle emitter type this factory creates. </summary>
    </member>
    <member name="T:Mogre.ParticleIterator">
      <summary>Convenience class to make it easy to step through all particles in a ParticleSystem. </summary>
    </member>
    <member name="P:Mogre.ParticleIterator.Next">
      <summary>Returns a pointer to the next particle, and moves the iterator on by 1 element. </summary>
    </member>
    <member name="T:Mogre.ParticleSystemManager">
      <summary>Manages particle systems, particle system scripts (templates) and the available emitter &amp; affector factories. This singleton class is responsible for creating and managing particle systems. All particle systems must be created and destroyed using this object, although the user interface to creating them is via SceneManager. Remember that like all other MovableObject subclasses, ParticleSystems do not get rendered until they are attached to a SceneNode object. This class also manages factories for ParticleEmitter and ParticleAffector classes. To enable easy extensions to the types of emitters (particle sources) and affectors (particle modifiers), the ParticleSystemManager lets plugins or applications register factory classes which submit new subclasses to ParticleEmitter and ParticleAffector. Ogre comes with a number of them already provided, such as cone, sphere and box-shaped emitters, and simple affectors such as constant directional force and colour faders. However using this registration process, a plugin can create any behaviour required. This class also manages the loading and parsing of particle system scripts, which are text files describing named particle system templates. Instances of particle systems using these templates can then be created easily through the createParticleSystem method. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager.AddEmitterFactory(Mogre.ParticleEmitterFactory)">
      <summary>Adds a new 'factory' object for emitters to the list of available emitter types. This method allows plugins etc to add new particle emitter types to Ogre. Particle emitters are sources of particles, and generate new particles with their start positions, colours and momentums appropriately. Plugins would create new subclasses of ParticleEmitter which emit particles a certain way, and register a subclass of ParticleEmitterFactory to create them (since multiple emitters can be created for different particle systems). All particle emitter factories have an assigned name which is used to identify the emitter type. This must be unique. Note that the object passed to this function will not be destroyed by the ParticleSystemManager, since it may have been allocated on a different heap in the case of plugins. The caller must destroy the object later on, probably on plugin shutdown. </summary>
      <param name="factory">Pointer to a ParticleEmitterFactory subclass created by the plugin or application code. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.AddAffectorFactory(Mogre.ParticleAffectorFactory)">
      <summary>Adds a new 'factory' object for affectors to the list of available affector types. This method allows plugins etc to add new particle affector types to Ogre. Particle affectors modify the particles in a system a certain way such as affecting their direction or changing their colour, lifespan etc. Plugins would create new subclasses of ParticleAffector which affect particles a certain way, and register a subclass of ParticleAffectorFactory to create them. All particle affector factories have an assigned name which is used to identify the affector type. This must be unique. Note that the object passed to this function will not be destroyed by the ParticleSystemManager, since it may have been allocated on a different heap in the case of plugins. The caller must destroy the object later on, probably on plugin shutdown. </summary>
      <param name="factory">Pointer to a ParticleAffectorFactory subclass created by the plugin or application code. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.AddTemplate(System.String,Mogre.ParticleSystem)">
      <summary>Adds a new particle system template to the list of available templates. Instances of particle systems in a scene are not normally unique - often you want to place the same effect in many places. This method allows you to register a ParticleSystem as a named template, which can subsequently be used to create instances using the createSystem method. Note that particle system templates can either be created programmatically by an application and registered using this method, or they can be defined in a script file (*.particle) which is loaded by the engine at startup, very much like Material scripts. </summary>
      <param name="name">The name of the template. Must be unique across all templates. </param>
      <param name="sysTemplate">A pointer to a particle system to be used as a template. The manager will take over ownership of this pointer. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.RemoveTemplate(System.String)">
      <summary>Removes a specified template from the ParticleSystemManager. This method removes a given template from the particle system manager, optionally deleting the template if the deleteTemplate method is called. Throws an exception if the template could not be found. </summary>
      <param name="name">The name of the template to remove. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.RemoveTemplate(System.String,System.Boolean)">
      <summary>Removes a specified template from the ParticleSystemManager. This method removes a given template from the particle system manager, optionally deleting the template if the deleteTemplate method is called. Throws an exception if the template could not be found. </summary>
      <param name="name">The name of the template to remove. </param>
      <param name="deleteTemplate">Whether or not to delete the template before removing it. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.RemoveAllTemplates">
      <summary>Removes a specified template from the ParticleSystemManager. This method removes all templates from the ParticleSystemManager. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager.RemoveAllTemplates(System.Boolean)">
      <summary>Removes a specified template from the ParticleSystemManager. This method removes all templates from the ParticleSystemManager. </summary>
      <param name="deleteTemplate">Whether or not to delete the templates before removing them. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.RemoveTemplatesByResourceGroup(System.String)">
      <summary>Removes all templates that belong to a secific Resource Group from the ParticleSystemManager. This method removes all templates that belong in a particular resource group from the ParticleSystemManager. </summary>
      <param name="resourceGroup">to delete templates for </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.CreateTemplate(System.String,System.String)">
      <summary>Create a new particle system template. This method is similar to the addTemplate method, except this just creates a new template and returns a pointer to it to be populated. Use this when you don't already have a system to add as a template and just want to create a new template which you will build up in-place. </summary>
      <param name="name">The name of the template. Must be unique across all templates. </param>
      <param name="resourceGroup">The name of the resource group which will be used to load any dependent resources. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager.GetTemplate(System.String)">
      <summary>Retrieves a particle system template for possible modification. Modifying a template does not affect the settings on any ParticleSystems already created from this template. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager._createEmitter(System.String,Mogre.ParticleSystem)">
      <summary>Internal method for creating a new emitter from a factory. Used internally by the engine to create new ParticleEmitter instances from named factories. Applications should use the ParticleSystem::addEmitter method instead, which calls this method to create an instance. </summary>
      <param name="emitterType">String name of the emitter type to be created. A factory of this type must have been registered. </param>
      <param name="psys">The particle system this is being created for </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager._destroyEmitter(Mogre.ParticleEmitter)">
      <summary>Internal method for destroying an emitter. Because emitters are created by factories which may allocate memory from separate heaps, the memory allocated must be freed from the same place. This method is used to ask the factory to destroy the instance passed in as a pointer. </summary>
      <param name="emitter">Pointer to emitter to be destroyed. On return this pointer will point to invalid (freed) memory. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager._createAffector(System.String,Mogre.ParticleSystem)">
      <summary>Internal method for creating a new affector from a factory. Used internally by the engine to create new ParticleAffector instances from named factories. Applications should use the ParticleSystem::addAffector method instead, which calls this method to create an instance. </summary>
      <param name="psys">The particle system it is being created for </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager._destroyAffector(Mogre.ParticleAffector)">
      <summary>Internal method for destroying an affector. Because affectors are created by factories which may allocate memory from separate heaps, the memory allocated must be freed from the same place. This method is used to ask the factory to destroy the instance passed in as a pointer. </summary>
      <param name="affector">Pointer to affector to be destroyed. On return this pointer will point to invalid (freed) memory. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager._createRenderer(System.String)">
      <summary>Internal method for creating a new renderer from a factory. Used internally by the engine to create new ParticleSystemRenderer instances from named factories. Applications should use the ParticleSystem::setRenderer method instead, which calls this method to create an instance. </summary>
      <param name="rendererType">String name of the renderer type to be created. A factory of this type must have been registered. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager._destroyRenderer(Mogre.ParticleSystemRenderer)">
      <summary>Internal method for destroying a renderer. Because renderer are created by factories which may allocate memory from separate heaps, the memory allocated must be freed from the same place. This method is used to ask the factory to destroy the instance passed in as a pointer. </summary>
      <param name="renderer">Pointer to renderer to be destroyed. On return this pointer will point to invalid (freed) memory. </param>
    </member>
    <member name="M:Mogre.ParticleSystemManager._initialise">
      <summary>Init method to be called by OGRE system. Due to dependencies between various objects certain initialisation tasks cannot be done on construction. OGRE will call this method when the rendering subsystem is initialised. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager.GetScriptPatterns">
      <summary>Gets the file patterns which should be used to find scripts for this class. This method is called when a resource group is loaded if you use ResourceGroupManager::_registerScriptLoader. A list of file patterns, in the order they should be searched in.</summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager.ParseScript(Mogre.DataStreamPtr,System.String)">
      <summary>Parse a script file. streamWeak reference to a data stream which is the source of the script groupNameThe name of a resource group which should be used if any resources are created during the parse of this script.</summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager.GetAffectorFactoryIterator">
      <summary>Return an iterator over the affector factories currently registered </summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager.GetEmitterFactoryIterator">
      <summary>Return an iterator over the emitter factories currently registered </summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager.GetTemplateIterator">
      <summary>Gets an iterator over the list of particle system templates. </summary>
    </member>
    <member name="M:Mogre.ParticleSystemManager._getFactory">
      <summary>Get an instance of ParticleSystemFactory (internal use). </summary>
    </member>
    <member name="P:Mogre.ParticleSystemManager.LoadingOrder">
      <summary>Gets the relative loading order of scripts of this type. There are dependencies between some kinds of scripts, and to enforce this all implementors of this interface must define a loading order. A value representing the relative loading order of these scripts compared to other script users, where higher values load later.</summary>
    </member>
    <member name="P:Mogre.ParticleSystemManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.ParticleSystemFactory">
      <summary>Factory object for creating ParticleSystem instances </summary>
    </member>
    <member name="T:Mogre.PixelCountLodStrategy">
      <summary>Level of detail strategy based on pixel count approximation from bounding sphere projection. </summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.TransformBias(System.Single)">
      <summary>Transform lod bias so it only needs to be multiplied by the lod value.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.GetIndex(System.Single,Mogre.Material+Const_LodValueList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.GetIndex(System.Single,Mogre.Mesh+Const_MeshLodUsageList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.Sort(Mogre.Mesh+MeshLodUsageList)">
      <summary>Sort mesh lod usage list from greatest to least detail</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.IsSorted(Mogre.Mesh+Const_LodValueList)">
      <summary>Determine if the lod values are sorted from greatest detail to least detail.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.TransformBias(System.Single)">
      <summary>Transform lod bias so it only needs to be multiplied by the lod value.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.GetIndex(System.Single,Mogre.Material+Const_LodValueList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.GetIndex(System.Single,Mogre.Mesh+Const_MeshLodUsageList)">
      <summary>Get the index of the lod usage which applies to a given value.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.Sort(Mogre.Mesh+MeshLodUsageList)">
      <summary>Sort mesh lod usage list from greatest to least detail</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.IsSorted(Mogre.Mesh+Const_LodValueList)">
      <summary>Determine if the lod values are sorted from greatest detail to least detail.</summary>
    </member>
    <member name="M:Mogre.PixelCountLodStrategy.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.PixelCountLodStrategy.BaseValue">
      <summary>Get the value of the first (highest) level of detail.</summary>
    </member>
    <member name="T:Mogre.Plugin">
      <summary>Class defining a generic OGRE plugin. OGRE is very plugin-oriented and you can customise much of its behaviour by registering new plugins, dynamically if you are using dynamic linking. This class abstracts the generic interface that all plugins must support. Within the implementations of this interface, the plugin must call other OGRE classes in order to register the detailed customisations it is providing, e.g. registering a new SceneManagerFactory, a new MovableObjectFactory, or a new RenderSystem. Plugins can be linked statically or dynamically. If they are linked dynamically (ie the plugin is in a DLL or Shared Object file), then you load the plugin by calling the Root::loadPlugin method (or some other mechanism which leads to that call, e.g. plugins.cfg), passing the name of the DLL. OGRE will then call a global init function on that DLL, and it will be expected to register one or more Plugin implementations using Root::installPlugin. The procedure is very similar if you use a static linked plugin, except that you simply instantiate the Plugin implementation yourself and pass it to Root::installPlugin. Lifecycle of a Plugin instance is very important. The Plugin instance must remain valid until the Plugin is uninstalled. Here are the things you must bear in mind: If your plugin is in a DLL: Create the Plugin instance and call Root::installPlugin in dllStartPlugin Call Root::uninstallPlugin, then delete it in dllStopPluginIf your plugin is statically linked in your app: Create the Plugin anytime you like Call Root::installPlugin any time whilst Root is valid Call Root::uninstallPlugin if you like so long as Root is valid. However, it will be done for you when Root is destroyed, so the Plugin instance must still be valid at that point if you haven't manually uninstalled it.
The install and uninstall methods will be called when the plugin is installed or uninstalled. The initialise and shutdown will be called when there is a system initialisation or shutdown, e.g. when Root::initialise or Root::shutdown are called. </summary>
    </member>
    <member name="M:Mogre.Plugin.Install">
      <summary>Perform the plugin initial installation sequence. An implementation must be supplied for this method. It must perform the startup tasks necessary to install any rendersystem customisations or anything else that is not dependent on system initialisation, ie only dependent on the core of Ogre. It must not perform any operations that would create rendersystem-specific objects at this stage, that should be done in initialise(). </summary>
    </member>
    <member name="M:Mogre.Plugin.Initialise">
      <summary>Perform any tasks the plugin needs to perform on full system initialisation. An implementation must be supplied for this method. It is called just after the system is fully initialised (either after Root::initialise if a window is created then, or after the first window is created) and therefore all rendersystem functionality is available at this time. You can use this hook to create any resources which are dependent on a rendersystem or have rendersystem-specific implementations. </summary>
    </member>
    <member name="M:Mogre.Plugin.Shutdown">
      <summary>Perform any tasks the plugin needs to perform when the system is shut down. An implementation must be supplied for this method. This method is called just before key parts of the system are unloaded, such as rendersystems being shut down. You should use this hook to free up resources and decouple custom objects from the OGRE system, whilst all the instances of other plugins (e.g. rendersystems) still exist. </summary>
    </member>
    <member name="M:Mogre.Plugin.Uninstall">
      <summary>Perform the final plugin uninstallation sequence. An implementation must be supplied for this method. It must perform the cleanup tasks which haven't already been performed in shutdown() (e.g. final deletion of custom instances, if you kept them around incase the system was reinitialised). At this stage you cannot be sure what other plugins are still loaded or active. It must therefore not perform any operations that would reference any rendersystem-specific objects - those should have been sorted out in the 'shutdown' method. </summary>
    </member>
    <member name="P:Mogre.Plugin.Name">
      <summary>Get the name of the plugin. An implementation must be supplied for this method to uniquely identify the plugin. </summary>
    </member>
    <member name="T:Mogre.Profiler">
      <summary>The profiler allows you to measure the performance of your code Do not create profiles directly from this unless you want a profile to last outside of its scope (i.e. the main game loop). For most cases, use the macro OgreProfile(name) and braces to limit the scope. You must enable the Profile before you can used it with setEnabled(true). If you want to disable profiling in Ogre, simply set the macro OGRE_PROFILING to 0. Amit Mathew (amitmathew (at) yahoo (dot) com) </summary>
    </member>
    <member name="M:Mogre.Profiler.BeginProfile(System.String)">
      <summary>Begins a profile Use the macro OgreProfileBegin(name) instead of calling this directly so that profiling can be ignored in the release version of your app. You only use the macro (or this) if you want a profile to last outside of its scope (i.e. the main game loop). If you use this function, make sure you use a corresponding OgreProfileEnd(name). Usually you would use the macro OgreProfile(name). This function will be ignored for a profile that has been disabled or if the profiler is disabled. </summary>
      <param name="profileName">Must be unique and must not be an empty string </param>
    </member>
    <member name="M:Mogre.Profiler.BeginProfile(System.String,System.UInt32)">
      <summary>Begins a profile Use the macro OgreProfileBegin(name) instead of calling this directly so that profiling can be ignored in the release version of your app. You only use the macro (or this) if you want a profile to last outside of its scope (i.e. the main game loop). If you use this function, make sure you use a corresponding OgreProfileEnd(name). Usually you would use the macro OgreProfile(name). This function will be ignored for a profile that has been disabled or if the profiler is disabled. </summary>
      <param name="profileName">Must be unique and must not be an empty string </param>
      <param name="groupID">A profile group identifier, which can allow you to mask profiles </param>
    </member>
    <member name="M:Mogre.Profiler.EndProfile(System.String)">
      <summary>Ends a profile Use the macro OgreProfileEnd(name) instead of calling this directly so that profiling can be ignored in the release version of your app. This function is usually not called directly unless you want a profile to last outside of its scope. In most cases, using the macro OgreProfile(name) which will call this function automatically when it goes out of scope. Make sure the name of this profile matches its corresponding beginProfile name. This function will be ignored for a profile that has been disabled or if the profiler is disabled. </summary>
      <param name="profileName">Must be unique and must not be an empty string </param>
    </member>
    <member name="M:Mogre.Profiler.EndProfile(System.String,System.UInt32)">
      <summary>Ends a profile Use the macro OgreProfileEnd(name) instead of calling this directly so that profiling can be ignored in the release version of your app. This function is usually not called directly unless you want a profile to last outside of its scope. In most cases, using the macro OgreProfile(name) which will call this function automatically when it goes out of scope. Make sure the name of this profile matches its corresponding beginProfile name. This function will be ignored for a profile that has been disabled or if the profiler is disabled. </summary>
      <param name="profileName">Must be unique and must not be an empty string </param>
      <param name="groupID">A profile group identifier, which can allow you to mask profiles </param>
    </member>
    <member name="M:Mogre.Profiler.EnableProfile(System.String)">
      <summary>Enables a previously disabled profile Only enables the profile if this function is not called during the profile it is trying to enable. </summary>
    </member>
    <member name="M:Mogre.Profiler.DisableProfile(System.String)">
      <summary>Disables a profile Only disables the profile if this function is not called during the profile it is trying to disable. </summary>
    </member>
    <member name="M:Mogre.Profiler.WatchForMax(System.String)">
      <summary>Returns true if the specified profile reaches a new frame time maximum If this is called during a frame, it will be reading the results from the previous frame. Therefore, it is best to use this after the frame has ended. </summary>
    </member>
    <member name="M:Mogre.Profiler.WatchForMin(System.String)">
      <summary>Returns true if the specified profile reaches a new frame time minimum If this is called during a frame, it will be reading the results from the previous frame. Therefore, it is best to use this after the frame has ended. </summary>
    </member>
    <member name="M:Mogre.Profiler.WatchForLimit(System.String,System.Single)">
      <summary>Returns true if the specified profile goes over or under the given limit frame time If this is called during a frame, it will be reading the results from the previous frame. Therefore, it is best to use this after the frame has ended. </summary>
      <param name="limit">A number between 0 and 1 representing the percentage of frame time </param>
    </member>
    <member name="M:Mogre.Profiler.WatchForLimit(System.String,System.Single,System.Boolean)">
      <summary>Returns true if the specified profile goes over or under the given limit frame time If this is called during a frame, it will be reading the results from the previous frame. Therefore, it is best to use this after the frame has ended. </summary>
      <param name="limit">A number between 0 and 1 representing the percentage of frame time </param>
      <param name="greaterThan">If true, this will return whether the limit is exceeded. Otherwise, it will return if the frame time has gone under this limit. </param>
    </member>
    <member name="M:Mogre.Profiler.LogResults">
      <summary>Outputs current profile statistics to the log </summary>
    </member>
    <member name="M:Mogre.Profiler.Reset">
      <summary>Clears the profiler statistics </summary>
    </member>
    <member name="M:Mogre.Profiler.SetDisplayMode(Mogre.Profiler+DisplayMode)">
      <summary>Set the display mode for the overlay. </summary>
    </member>
    <member name="M:Mogre.Profiler.GetDisplayMode">
      <summary>Get the display mode for the overlay. </summary>
    </member>
    <member name="M:Mogre.Profiler.SetOverlayDimensions(System.Single,System.Single)">
      <summary>Set the size of the profiler overlay, in pixels. </summary>
    </member>
    <member name="M:Mogre.Profiler.SetOverlayPosition(System.Single,System.Single)">
      <summary>Set the position of the profiler overlay, in pixels. </summary>
    </member>
    <member name="P:Mogre.Profiler.UpdateDisplayFrequency">
      <summary>Sets/Gets the frequency that the Profiler display is updated </summary>
    </member>
    <member name="P:Mogre.Profiler.Timer">
      <summary>Sets/Retrieves the timer for the profiler </summary>
    </member>
    <member name="P:Mogre.Profiler.ProfileGroupMask">
      <summary>Sets/Get the mask which all profiles must pass to be enabled. </summary>
    </member>
    <member name="P:Mogre.Profiler.Enabled">
      <summary>Sets/Gets whether this profiler is enabled </summary>
    </member>
    <member name="P:Mogre.Profiler.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="F:Mogre.Profiler+DisplayMode.DISPLAY_PERCENTAGE">
      <summary>Display % frame usage on the overlay. </summary>
    </member>
    <member name="F:Mogre.Profiler+DisplayMode.DISPLAY_MILLISECONDS">
      <summary>Display milliseconds on the overlay. </summary>
    </member>
    <member name="T:Mogre.ProfileGroupMask">
      <summary>List of reserved profiling masks </summary>
    </member>
    <member name="F:Mogre.ProfileGroupMask.OGREPROF_USER_DEFAULT">
      <summary>User default profile. </summary>
    </member>
    <member name="F:Mogre.ProfileGroupMask.OGREPROF_ALL">
      <summary>All in-built Ogre profiling will match this mask. </summary>
    </member>
    <member name="F:Mogre.ProfileGroupMask.OGREPROF_GENERAL">
      <summary>General processing. </summary>
    </member>
    <member name="F:Mogre.ProfileGroupMask.OGREPROF_CULLING">
      <summary>Culling. </summary>
    </member>
    <member name="F:Mogre.ProfileGroupMask.OGREPROF_RENDERING">
      <summary>Rendering. </summary>
    </member>
    <member name="T:Mogre.PVRTCCodec">
      <summary>Codec specialized in loading PVRTC (PowerVR) images. We implement our own codec here since we need to be able to keep PVRTC data compressed if the card supports it. </summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.Code(Mogre.MemoryDataStreamPtr,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input stream and saves the result in the output stream.</summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.CodeToFile(Mogre.MemoryDataStreamPtr,System.String,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input chunk and saves the result in the output filename provided. Provided for efficiency since coding to memory is progressive therefore memory required is unknown leading to reallocations. inputThe input data outFileNameThe filename to write to pDataExtra information to be passed to the codec (codec type specific)</summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.Decode(Mogre.DataStreamPtr)">
      <summary>Codes the data from the input chunk into the output chunk. inputStream containing the encoded data Has a variable number of arguments, which depend on the codec type.</summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.MagicNumberToFileExt(System.SByte*,System.UInt32)">
      <summary>Maps a magic number header to a file extension, if this codec recognises it. magicNumberPtrPointer to a stream of bytes which should identify the file. Note that this may be more than needed - each codec may be looking for a different size magic number. maxbytesThe number of bytes passed A blank string if the magic number was unknown, or a file extension.</summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.Startup">
      <summary>Static method to startup and register the PVRTC codec. </summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.Shutdown">
      <summary>Static method to shutdown and unregister the PVRTC codec. </summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.Code(Mogre.MemoryDataStreamPtr,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input stream and saves the result in the output stream.</summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.CodeToFile(Mogre.MemoryDataStreamPtr,System.String,Mogre.Codec+CodecDataPtr)">
      <summary>Codes the data in the input chunk and saves the result in the output filename provided. Provided for efficiency since coding to memory is progressive therefore memory required is unknown leading to reallocations. inputThe input data outFileNameThe filename to write to pDataExtra information to be passed to the codec (codec type specific)</summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.Decode(Mogre.DataStreamPtr)">
      <summary>Codes the data from the input chunk into the output chunk. inputStream containing the encoded data Has a variable number of arguments, which depend on the codec type.</summary>
    </member>
    <member name="M:Mogre.PVRTCCodec.MagicNumberToFileExt(System.SByte*,System.UInt32)">
      <summary>Maps a magic number header to a file extension, if this codec recognises it. magicNumberPtrPointer to a stream of bytes which should identify the file. Note that this may be more than needed - each codec may be looking for a different size magic number. maxbytesThe number of bytes passed A blank string if the magic number was unknown, or a file extension.</summary>
    </member>
    <member name="T:Mogre.SimpleRenderable">
      <summary>Simple implementation of MovableObject and Renderable for single-part custom objects. ManualObject for a simpler interface with more flexibility </summary>
    </member>
    <member name="M:Mogre.SimpleRenderable.GetLights">
      <summary>Gets a list of lights, ordered relative to how close they are to this renderable. Directional lights, which have no position, will always be first on this list.</summary>
    </member>
    <member name="P:Mogre.SimpleRenderable.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="T:Mogre.Rectangle2D">
      <summary>Allows the rendering of a simple 2D rectangle This class renders a simple 2D rectangle; this rectangle has no depth and therefore is best used with specific render queue and depth settings, like RENDER_QUEUE_BACKGROUND and 'depth_write off' for backdrops, and RENDER_QUEUE_OVERLAY and 'depth_check off' for fullscreen quads. </summary>
    </member>
    <member name="M:Mogre.Rectangle2D.SetCorners(System.Single,System.Single,System.Single,System.Single)">
      <summary>Sets the corners of the rectangle, in relative coordinates. </summary>
      <param name="left">Left position in screen relative coordinates, -1 = left edge, 1.0 = right edge </param>
      <param name="top">Top position in screen relative coordinates, 1 = top edge, -1 = bottom edge </param>
      <param name="right">Right position in screen relative coordinates </param>
      <param name="bottom">Bottom position in screen relative coordinates </param>
    </member>
    <member name="M:Mogre.Rectangle2D.SetCorners(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
      <summary>Sets the corners of the rectangle, in relative coordinates. </summary>
      <param name="left">Left position in screen relative coordinates, -1 = left edge, 1.0 = right edge </param>
      <param name="top">Top position in screen relative coordinates, 1 = top edge, -1 = bottom edge </param>
      <param name="right">Right position in screen relative coordinates </param>
      <param name="bottom">Bottom position in screen relative coordinates </param>
      <param name="updateAABB">Tells if you want to recalculate the AABB according to the new corners. If false, the axis aligned bounding box will remain identical. </param>
    </member>
    <member name="M:Mogre.Rectangle2D.SetNormals(Mogre.Vector3,Mogre.Vector3,Mogre.Vector3,Mogre.Vector3)">
      <summary>Sets the normals of the rectangle </summary>
    </member>
    <member name="M:Mogre.Rectangle2D.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>Override this method to prevent parent transforms (rotation,translation,scale) </summary>
    </member>
    <member name="T:Mogre.RenderObjectListener">
      <summary>Abstract interface which classes must implement if they wish to receive events from the scene manager when single object is about to be rendered. </summary>
    </member>
    <member name="T:Mogre.RenderQueueInvocation">
      <summary>Class representing the invocation of queue groups in a RenderQueue. The default behaviour for OGRE's render queue is to render each queue group in turn, dealing with shadows automatically, and rendering solids in grouped passes, followed by transparent objects in descending order. This class, together with RenderQueueInvocationSequence and the ability to associate one with a Viewport, allows you to change that behaviour and render queue groups in arbitrary sequence, repeatedly, and to skip shadows, change the ordering of solids, or even prevent OGRE controlling the render state during a particular invocation for special effects. Note that whilst you can change the ordering of rendering solids, you can't change the ordering on transparent objects, since to do this would cause them to render incorrectly. As well as using this class directly and using the options it provides you with, you can also provide subclasses of it to a RenderQueueInvocationSequence instance if you want to gain ultimate control. Invocations will be skipped if there are scene-level options preventing them being rendered - for example special-case render queues and render queue listeners that dictate this. </summary>
    </member>
    <member name="M:Mogre.RenderQueueInvocation.Invoke(Mogre.RenderQueueGroup,Mogre.SceneManager)">
      <summary>Invoke this class on a concrete queue group. Implementation will send the queue group to the target scene manager after doing what it needs to do. </summary>
    </member>
    <member name="M:Mogre.RenderQueueInvocation.#ctor(System.Byte)">
      <summary>Constructor </summary>
      <param name="renderQueueGroupID">ID of the queue this will target </param>
    </member>
    <member name="M:Mogre.RenderQueueInvocation.#ctor(System.Byte,System.String)">
      <summary>Constructor </summary>
      <param name="renderQueueGroupID">ID of the queue this will target </param>
      <param name="invocationName">Optional name to uniquely identify this invocation from others in a RenderQueueListener</param>
    </member>
    <member name="P:Mogre.RenderQueueInvocation.SuppressShadows">
      <summary>Sets/Gets whether shadows are suppressed when invoking this queue. </summary>
    </member>
    <member name="P:Mogre.RenderQueueInvocation.SuppressRenderStateChanges">
      <summary>Sets/Gets whether shadows are suppressed when invoking this queue. </summary>
    </member>
    <member name="P:Mogre.RenderQueueInvocation.SolidsOrganisation">
      <summary>Sets/Get the organisation mode being used for solids in this queue group invocation. </summary>
    </member>
    <member name="P:Mogre.RenderQueueInvocation.RenderQueueGroupID">
      <summary>Get the render queue group id. </summary>
    </member>
    <member name="P:Mogre.RenderQueueInvocation.InvocationName">
      <summary>Get the invocation name (may be blank if not set by creator). </summary>
    </member>
    <member name="P:Mogre.RenderQueueInvocation.RENDER_QUEUE_INVOCATION_SHADOWS">
      <summary>Sets/Invocation identifier for shadows. </summary>
    </member>
    <member name="T:Mogre.RenderQueueInvocationSequence">
      <summary>Class to hold a linear sequence of RenderQueueInvocation objects. This is just a simple data holder class which contains a list of RenderQueueInvocation objects representing the sequence of invocations made for a viewport. It's only real purpose is to ensure that RenderQueueInvocation instances are deleted on shutdown, since you can provide your own subclass instances on RenderQueueInvocation. Remember that any invocation instances you give to this class will be deleted by it when it is cleared / destroyed. </summary>
    </member>
    <member name="M:Mogre.RenderQueueInvocationSequence.Add(Mogre.RenderQueueInvocation)">
      <summary>Add a custom invocation to the sequence. Use this to add your own custom subclasses of RenderQueueInvocation to the sequence; just remember that this class takes ownership of deleting this pointer when it is cleared / destroyed. </summary>
    </member>
    <member name="M:Mogre.RenderQueueInvocationSequence.Add(System.Byte,System.String)">
      <summary>Add a standard invocation to the sequence. A new RenderQueueInvocatin instance which you may customise </summary>
      <param name="renderQueueGroupID">The ID of the render queue group </param>
      <param name="invocationName">Optional name to identify the invocation, useful for listeners if a single queue group is invoked more than once </param>
    </member>
    <member name="M:Mogre.RenderQueueInvocationSequence.Size">
      <summary>Get the number of invocations in this sequence. </summary>
    </member>
    <member name="M:Mogre.RenderQueueInvocationSequence.Clear">
      <summary>Clear and delete all invocations in this sequence. </summary>
    </member>
    <member name="M:Mogre.RenderQueueInvocationSequence.Get(System.UInt32)">
      <summary>Gets the details of an invocation at a given index. </summary>
    </member>
    <member name="M:Mogre.RenderQueueInvocationSequence.Remove(System.UInt32)">
      <summary>Removes (and deletes) an invocation by index. </summary>
    </member>
    <member name="P:Mogre.RenderQueueInvocationSequence.Name">
      <summary>Get the name of this sequence. </summary>
    </member>
    <member name="T:Mogre.RenderQueueInvocationList">
      <summary>List of RenderQueueInvocations. </summary>
    </member>
    <member name="T:Mogre.Const_RenderQueueInvocationList">
      <summary>List of RenderQueueInvocations. </summary>
    </member>
    <member name="T:Mogre.RenderSystemCapabilitiesManager">
      <summary>Class for managing RenderSystemCapabilities database for Ogre. This class behaves similarly to other ResourceManager, although .rendercaps are not resources. It contains and abstract a .rendercaps Serializer</summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilitiesManager.ParseCapabilitiesFromArchive(System.String,System.String)">
      <summary>ScriptLoader::parseScript</summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilitiesManager.ParseCapabilitiesFromArchive(System.String,System.String,System.Boolean)">
      <summary>ScriptLoader::parseScript</summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilitiesManager.LoadParsedCapabilities(System.String)">
      <summary>Returns a capability loaded with RenderSystemCapabilitiesManager::parseCapabilitiesFromArchive method NULL if the name is invalid, a parsed RenderSystemCapabilities otherwise. </summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilitiesManager._addRenderSystemCapabilities(System.String,Mogre.RenderSystemCapabilities)">
      <summary>Method used by RenderSystemCapabilitiesSerializer::parseScript</summary>
    </member>
    <member name="M:Mogre.RenderSystemCapabilitiesManager.#ctor">
      <summary>Default constructor. </summary>
    </member>
    <member name="P:Mogre.RenderSystemCapabilitiesManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.BackgroundProcessResult">
      <summary>Encapsulates the result of a background queue request </summary>
    </member>
    <member name="P:Mogre.BackgroundProcessResult.Message">
      <summary>Sets/Any messages from the process. </summary>
    </member>
    <member name="P:Mogre.BackgroundProcessResult.Error">
      <summary>Sets/Whether an error occurred. </summary>
    </member>
    <member name="T:Mogre.ResourceGroupListener">
      <summary>This abstract class defines an interface which is called back during resource group loading to indicate the progress of the load. Resource group loading is in 2 phases - creating resources from declarations (which includes parsing scripts), and loading resources. Note that you don't necessarily have to have both; it is quite possible to just parse all the scripts for a group (see ResourceGroupManager::initialiseResourceGroup, but not to load the resource group. The sequence of events is (* signifies a repeating item): resourceGroupScriptingStarted scriptParseStarted (*) scriptParseEnded (*) resourceGroupScriptingEnded resourceGroupLoadStarted resourceLoadStarted (*) resourceLoadEnded (*) worldGeometryStageStarted (*) worldGeometryStageEnded (*) resourceGroupLoadEnded resourceGroupPrepareStarted resourcePrepareStarted (*) resourcePrepareEnded (*) resourceGroupPrepareEnded If OGRE_THREAD_SUPPORT is 1, this class is thread-safe. </summary>
    </member>
    <member name="T:Mogre.ResourceLoadingListener">
      <summary>This class allows users to override resource loading behavior. By overriding this class' methods, you can change how resources are loaded and the behavior for resource name collisions. </summary>
    </member>
    <member name="M:Mogre.ResourceLoadingListener.ResourceLoading(System.String,System.String,Mogre.Resource)">
      <summary>This event is called when a resource beings loading. </summary>
    </member>
    <member name="M:Mogre.ResourceLoadingListener.ResourceStreamOpened(System.String,System.String,Mogre.Resource,Mogre.DataStreamPtr)">
      <summary>This event is called when a resource stream has been opened, but not processed yet. You may alter the stream if you wish or alter the incoming pointer to point at another stream if you wish. </summary>
    </member>
    <member name="M:Mogre.ResourceLoadingListener.ResourceCollision(Mogre.Resource,Mogre.ResourceManager)">
      <summary>This event is called when a resource collides with another existing one in a resource manager </summary>
    </member>
    <member name="T:Mogre.ResourceGroupManager">
      <summary>This singleton class manages the list of resource groups, and notifying the various resource managers of their obligations to load / unload resources in a group. It also provides facilities to monitor resource loading per group (to do progress bars etc), provided the resources that are required are pre-registered. Defining new resource groups, and declaring the resources you intend to use in advance is optional, however it is a very useful feature. In addition, if a ResourceManager supports the definition of resources through scripts, then this is the class which drives the locating of the scripts and telling the ResourceManager to parse them. There are several states that a resource can be in (the concept, not the object instance in this case): Undefined. Nobody knows about this resource yet. It might be in the filesystem, but Ogre is oblivious to it at the moment - there is no Resource instance. This might be because it's never been declared (either in a script, or using ResourceGroupManager::declareResource), or it may have previously been a valid Resource instance but has been removed, either individually through ResourceManager::remove or as a group through ResourceGroupManager::clearResourceGroup. Declared. Ogre has some forewarning of this resource, either through calling ResourceGroupManager::declareResource, or by declaring the resource in a script file which is on one of the resource locations which has been defined for a group. There is still no instance of Resource, but Ogre will know to create this resource when ResourceGroupManager::initialiseResourceGroup is called (which is automatic if you declare the resource group before Root::initialise). Unloaded. There is now a Resource instance for this resource, although it is not loaded. This means that code which looks for this named resource will find it, but the Resource is not using a lot of memory because it is in an unloaded state. A Resource can get into this state by having just been created by ResourceGroupManager::initialiseResourceGroup (either from a script, or from a call to declareResource), by being created directly from code (ResourceManager::create), or it may have previously been loaded and has been unloaded, either individually through Resource::unload, or as a group through ResourceGroupManager::unloadResourceGroup. LoadedThe Resource instance is fully loaded. This may have happened implicitly because something used it, or it may have been loaded as part of a group. ResourceGroupManager::declareResourceResourceGroupManager::initialiseResourceGroupResourceGroupManager::loadResourceGroupResourceGroupManager::unloadResourceGroupResourceGroupManager::clearResourceGroup</summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.CreateResourceGroup(System.String)">
      <summary>Create a resource group. A resource group allows you to define a set of resources that can be loaded / unloaded as a unit. For example, it might be all the resources used for the level of a game. There is always one predefined resource group called ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, which is typically used to hold all resources which do not need to be unloaded until shutdown. There is another predefined resource group called ResourceGroupManager::INTERNAL_RESOURCE_GROUP_NAME too, which should be used by OGRE internal only, the resources created in this group aren't supposed to modify, unload or remove by user. You can create additional ones so that you can control the life of your resources in whichever way you wish. There is one other predefined value, ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME; using this causes the group name to be derived at load time by searching for the resource in the resource locations of each group in turn. Once you have defined a resource group, resources which will be loaded as part of it are defined in one of 3 ways: Manually through declareResource(); this is useful for scripted declarations since it is entirely generalised, and does not create Resource instances right away Through the use of scripts; some ResourceManager subtypes have script formats (e.g. .material, .overlay) which can be used to declare resources By calling ResourceManager::create to create a resource manually. This resource will go on the list for it's group and will be loaded and unloaded with that group 
You must remember to call initialiseResourceGroup if you intend to use the first 2 types. </summary>
      <param name="name">The name to give the resource group. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.CreateResourceGroup(System.String,System.Boolean)">
      <summary>Create a resource group. A resource group allows you to define a set of resources that can be loaded / unloaded as a unit. For example, it might be all the resources used for the level of a game. There is always one predefined resource group called ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, which is typically used to hold all resources which do not need to be unloaded until shutdown. There is another predefined resource group called ResourceGroupManager::INTERNAL_RESOURCE_GROUP_NAME too, which should be used by OGRE internal only, the resources created in this group aren't supposed to modify, unload or remove by user. You can create additional ones so that you can control the life of your resources in whichever way you wish. There is one other predefined value, ResourceGroupManager::AUTODETECT_RESOURCE_GROUP_NAME; using this causes the group name to be derived at load time by searching for the resource in the resource locations of each group in turn. Once you have defined a resource group, resources which will be loaded as part of it are defined in one of 3 ways: Manually through declareResource(); this is useful for scripted declarations since it is entirely generalised, and does not create Resource instances right away Through the use of scripts; some ResourceManager subtypes have script formats (e.g. .material, .overlay) which can be used to declare resources By calling ResourceManager::create to create a resource manually. This resource will go on the list for it's group and will be loaded and unloaded with that group 
You must remember to call initialiseResourceGroup if you intend to use the first 2 types. </summary>
      <param name="name">The name to give the resource group. </param>
      <param name="inGlobalPool">if true the resource will be loaded even a different group was requested in the load method as a parameter. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.InitialiseResourceGroup(System.String)">
      <summary>Initialises a resource group. After creating a resource group, adding some resource locations, and perhaps pre-declaring some resources using declareResource(), but before you need to use the resources in the group, you should call this method to initialise the group. By calling this, you are triggering the following processes: Scripts for all resource types which support scripting are parsed from the resource locations, and resources within them are created (but not loaded yet). Creates all the resources which have just pre-declared using declareResource (again, these are not loaded yet) 
So what this essentially does is create a bunch of unloaded Resource entries in the respective ResourceManagers based on scripts, and resources you've pre-declared. That means that code looking for these resources will find them, but they won't be taking up much memory yet, until they are either used, or they are loaded in bulk using loadResourceGroup. Loading the resource group in bulk is entirely optional, but has the advantage of coming with progress reporting as resources are loaded. Failure to call this method means that loadResourceGroup will do nothing, and any resources you define in scripts will not be found. Similarly, once you have called this method you won't be able to pick up any new scripts or pre-declared resources, unless you call clearResourceGroup, set up declared resources, and call this method again. When you call Root::initialise, all resource groups that have already been created are automatically initialised too. Therefore you do not need to call this method for groups you define and set up before you call Root::initialise. However, since one of the most useful features of resource groups is to set them up after the main system initialisation has occurred (e.g. a group per game level), you must remember to call this method for the groups you create after this.</summary>
      <param name="name">The name of the resource group to initialise </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.InitialiseAllResourceGroups">
      <summary>Initialise all resource groups which are yet to be initialised. ResourceGroupManager::intialiseResourceGroup </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.PrepareResourceGroup(System.String)">
      <summary>Prepares a resource group. Prepares any created resources which are part of the named group. Note that resources must have already been created by calling ResourceManager::create, or declared using declareResource() or in a script (such as .material and .overlay). The latter requires that initialiseResourceGroup has been called.
When this method is called, this class will callback any ResourceGroupListeners which have been registered to update them on progress. ResourceGroupManager::linkWorldGeometryToResourceGroup</summary>
      <param name="name">The name of the resource group to prepare. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.PrepareResourceGroup(System.String,System.Boolean)">
      <summary>Prepares a resource group. Prepares any created resources which are part of the named group. Note that resources must have already been created by calling ResourceManager::create, or declared using declareResource() or in a script (such as .material and .overlay). The latter requires that initialiseResourceGroup has been called.
When this method is called, this class will callback any ResourceGroupListeners which have been registered to update them on progress. ResourceGroupManager::linkWorldGeometryToResourceGroup</summary>
      <param name="name">The name of the resource group to prepare. </param>
      <param name="prepareMainResources">If true, prepares normal resources associated with the group (you might want to set this to false if you wanted to just prepare world geometry in bulk) </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.PrepareResourceGroup(System.String,System.Boolean,System.Boolean)">
      <summary>Prepares a resource group. Prepares any created resources which are part of the named group. Note that resources must have already been created by calling ResourceManager::create, or declared using declareResource() or in a script (such as .material and .overlay). The latter requires that initialiseResourceGroup has been called.
When this method is called, this class will callback any ResourceGroupListeners which have been registered to update them on progress. ResourceGroupManager::linkWorldGeometryToResourceGroup</summary>
      <param name="name">The name of the resource group to prepare. </param>
      <param name="prepareMainResources">If true, prepares normal resources associated with the group (you might want to set this to false if you wanted to just prepare world geometry in bulk) </param>
      <param name="prepareWorldGeom">If true, prepares any linked world geometry </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.LoadResourceGroup(System.String)">
      <summary>Loads a resource group. Loads any created resources which are part of the named group. Note that resources must have already been created by calling ResourceManager::create, or declared using declareResource() or in a script (such as .material and .overlay). The latter requires that initialiseResourceGroup has been called.
When this method is called, this class will callback any ResourceGroupListeners which have been registered to update them on progress. ResourceGroupManager::linkWorldGeometryToResourceGroup</summary>
      <param name="name">The name of the resource group to load. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.LoadResourceGroup(System.String,System.Boolean)">
      <summary>Loads a resource group. Loads any created resources which are part of the named group. Note that resources must have already been created by calling ResourceManager::create, or declared using declareResource() or in a script (such as .material and .overlay). The latter requires that initialiseResourceGroup has been called.
When this method is called, this class will callback any ResourceGroupListeners which have been registered to update them on progress. ResourceGroupManager::linkWorldGeometryToResourceGroup</summary>
      <param name="name">The name of the resource group to load. </param>
      <param name="loadMainResources">If true, loads normal resources associated with the group (you might want to set this to false if you wanted to just load world geometry in bulk) </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.LoadResourceGroup(System.String,System.Boolean,System.Boolean)">
      <summary>Loads a resource group. Loads any created resources which are part of the named group. Note that resources must have already been created by calling ResourceManager::create, or declared using declareResource() or in a script (such as .material and .overlay). The latter requires that initialiseResourceGroup has been called.
When this method is called, this class will callback any ResourceGroupListeners which have been registered to update them on progress. ResourceGroupManager::linkWorldGeometryToResourceGroup</summary>
      <param name="name">The name of the resource group to load. </param>
      <param name="loadMainResources">If true, loads normal resources associated with the group (you might want to set this to false if you wanted to just load world geometry in bulk) </param>
      <param name="loadWorldGeom">If true, loads any linked world geometry </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.UnloadResourceGroup(System.String)">
      <summary>Unloads a resource group. This method unloads all the resources that have been declared as being part of the named resource group. Note that these resources will still exist in their respective ResourceManager classes, but will be in an unloaded state. If you want to remove them entirely, you should use clearResourceGroup or destroyResourceGroup. Resource::isReloadable for resource is reloadable. </summary>
      <param name="name">The name to of the resource group to unload. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.UnloadResourceGroup(System.String,System.Boolean)">
      <summary>Unloads a resource group. This method unloads all the resources that have been declared as being part of the named resource group. Note that these resources will still exist in their respective ResourceManager classes, but will be in an unloaded state. If you want to remove them entirely, you should use clearResourceGroup or destroyResourceGroup. Resource::isReloadable for resource is reloadable. </summary>
      <param name="name">The name to of the resource group to unload. </param>
      <param name="reloadableOnly">If set to true, only unload the resource that is reloadable. Because some resources isn't reloadable, they will be unloaded but can't load them later. Thus, you might not want to them unloaded. Or, you might unload all of them, and then populate them manually later. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.UnloadUnreferencedResourcesInGroup(System.String)">
      <summary>Unload all resources which are not referenced by any other object. This method behaves like unloadResourceGroup, except that it only unloads resources in the group which are not in use, ie not referenced by other objects. This allows you to free up some memory selectively whilst still keeping the group around (and the resources present, just not using much memory). </summary>
      <param name="name">The name of the group to check for unreferenced resources </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.UnloadUnreferencedResourcesInGroup(System.String,System.Boolean)">
      <summary>Unload all resources which are not referenced by any other object. This method behaves like unloadResourceGroup, except that it only unloads resources in the group which are not in use, ie not referenced by other objects. This allows you to free up some memory selectively whilst still keeping the group around (and the resources present, just not using much memory). </summary>
      <param name="name">The name of the group to check for unreferenced resources </param>
      <param name="reloadableOnly">If true (the default), only unloads resources which can be subsequently automatically reloaded </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ClearResourceGroup(System.String)">
      <summary>Clears a resource group. This method unloads all resources in the group, but in addition it removes all those resources from their ResourceManagers, and then clears all the members from the list. That means after calling this method, there are no resources declared as part of the named group any more. Resource locations still persist though. </summary>
      <param name="name">The name to of the resource group to clear. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DestroyResourceGroup(System.String)">
      <summary>Destroys a resource group, clearing it first, destroying the resources which are part of it, and then removing it from the list of resource groups. </summary>
      <param name="name">The name of the resource group to destroy. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.IsResourceGroupInitialised(System.String)">
      <summary>Checks the status of a resource group. Looks at the state of a resource group. If initialiseResourceGroup has been called for the resource group return true, otherwise return false. </summary>
      <param name="name">The name to of the resource group to access. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.IsResourceGroupLoaded(System.String)">
      <summary>Checks the status of a resource group. Looks at the state of a resource group. If loadResourceGroup has been called for the resource group return true, otherwise return false. </summary>
      <param name="name">The name to of the resource group to access. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.AddResourceLocation(System.String,System.String)">
      <summary>Method to add a resource location to for a given resource group. Resource locations are places which are searched to load resource files. When you choose to load a file, or to search for valid files to load, the resource locations are used. </summary>
      <param name="name">The name of the resource location; probably a directory, zip file, URL etc. </param>
      <param name="locType">The codename for the resource type, which must correspond to the Archive factory which is providing the implementation. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.AddResourceLocation(System.String,System.String,System.String)">
      <summary>Method to add a resource location to for a given resource group. Resource locations are places which are searched to load resource files. When you choose to load a file, or to search for valid files to load, the resource locations are used. </summary>
      <param name="name">The name of the resource location; probably a directory, zip file, URL etc. </param>
      <param name="locType">The codename for the resource type, which must correspond to the Archive factory which is providing the implementation. </param>
      <param name="resGroup">The name of the resource group for which this location is to apply. ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME is the default group which always exists, and can be used for resources which are unlikely to be unloaded until application shutdown. Otherwise it must be the name of a group; if it has not already been created with createResourceGroup then it is created automatically. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.AddResourceLocation(System.String,System.String,System.String,System.Boolean)">
      <summary>Method to add a resource location to for a given resource group. Resource locations are places which are searched to load resource files. When you choose to load a file, or to search for valid files to load, the resource locations are used. </summary>
      <param name="name">The name of the resource location; probably a directory, zip file, URL etc. </param>
      <param name="locType">The codename for the resource type, which must correspond to the Archive factory which is providing the implementation. </param>
      <param name="resGroup">The name of the resource group for which this location is to apply. ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME is the default group which always exists, and can be used for resources which are unlikely to be unloaded until application shutdown. Otherwise it must be the name of a group; if it has not already been created with createResourceGroup then it is created automatically. </param>
      <param name="recursive">Whether subdirectories will be searched for files when using a pattern match (such as *.material), and whether subdirectories will be indexed. This can slow down initial loading of the archive and searches. When opening a resource you still need to use the fully qualified name, this allows duplicate names in alternate paths. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.RemoveResourceLocation(System.String)">
      <summary>Removes a resource location from the search path. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.RemoveResourceLocation(System.String,System.String)">
      <summary>Removes a resource location from the search path. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ResourceLocationExists(System.String)">
      <summary>Verify if a resource location exists for the given group. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ResourceLocationExists(System.String,System.String)">
      <summary>Verify if a resource location exists for the given group. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeclareResource(System.String,System.String,System.String,Mogre.IManualResourceLoader)">
      <summary>Declares a resource to be a part of a resource group, allowing you to load and unload it as part of the group. By declaring resources before you attempt to use them, you can more easily control the loading and unloading of those resources by their group. Declaring them also allows them to be enumerated, which means events can be raised to indicate the loading progress (ResourceGroupListener). Note that another way of declaring resources is to use a script specific to the resource type, if available (e.g. .material). Declared resources are not created as Resource instances (and thus are not available through their ResourceManager) until initialiseResourceGroup is called, at which point all declared resources will become created (but unloaded) Resource instances, along with any resources declared in scripts in resource locations associated with the group. We don't support declare manually loaded resource without loader here, since it's meaningless. loadParametersA list of name / value pairs which supply custom parameters to the resource which will be required before it can be loaded. These are specific to the resource type. </summary>
      <param name="name">The resource name. </param>
      <param name="resourceType">The type of the resource. Ogre comes preconfigured with a number of resource types: FontGpuProgramHighLevelGpuProgramMaterialMeshSkeletonTexture
.. but more can be added by plugin ResourceManager classes. </param>
      <param name="groupName">The name of the group to which it will belong. </param>
      <param name="loader">Pointer to a ManualResourceLoader implementation which will be called when the Resource wishes to load. If supplied, the resource is manually loaded, otherwise it'll loading from file automatic. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeclareResource(System.String,System.String,System.String,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Declares a resource to be a part of a resource group, allowing you to load and unload it as part of the group. By declaring resources before you attempt to use them, you can more easily control the loading and unloading of those resources by their group. Declaring them also allows them to be enumerated, which means events can be raised to indicate the loading progress (ResourceGroupListener). Note that another way of declaring resources is to use a script specific to the resource type, if available (e.g. .material). Declared resources are not created as Resource instances (and thus are not available through their ResourceManager) until initialiseResourceGroup is called, at which point all declared resources will become created (but unloaded) Resource instances, along with any resources declared in scripts in resource locations associated with the group. We don't support declare manually loaded resource without loader here, since it's meaningless. loadParametersA list of name / value pairs which supply custom parameters to the resource which will be required before it can be loaded. These are specific to the resource type. </summary>
      <param name="name">The resource name. </param>
      <param name="resourceType">The type of the resource. Ogre comes preconfigured with a number of resource types: FontGpuProgramHighLevelGpuProgramMaterialMeshSkeletonTexture
.. but more can be added by plugin ResourceManager classes. </param>
      <param name="groupName">The name of the group to which it will belong. </param>
      <param name="loader">Pointer to a ManualResourceLoader implementation which will be called when the Resource wishes to load. If supplied, the resource is manually loaded, otherwise it'll loading from file automatic. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeclareResource(System.String,System.String)">
      <summary>Declares a resource to be a part of a resource group, allowing you to load and unload it as part of the group. By declaring resources before you attempt to use them, you can more easily control the loading and unloading of those resources by their group. Declaring them also allows them to be enumerated, which means events can be raised to indicate the loading progress (ResourceGroupListener). Note that another way of declaring resources is to use a script specific to the resource type, if available (e.g. .material). Declared resources are not created as Resource instances (and thus are not available through their ResourceManager) until initialiseResourceGroup is called, at which point all declared resources will become created (but unloaded) Resource instances, along with any resources declared in scripts in resource locations associated with the group. </summary>
      <param name="name">The resource name. </param>
      <param name="resourceType">The type of the resource. Ogre comes preconfigured with a number of resource types: FontGpuProgramHighLevelGpuProgramMaterialMeshSkeletonTexture
.. but more can be added by plugin ResourceManager classes. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeclareResource(System.String,System.String,System.String)">
      <summary>Declares a resource to be a part of a resource group, allowing you to load and unload it as part of the group. By declaring resources before you attempt to use them, you can more easily control the loading and unloading of those resources by their group. Declaring them also allows them to be enumerated, which means events can be raised to indicate the loading progress (ResourceGroupListener). Note that another way of declaring resources is to use a script specific to the resource type, if available (e.g. .material). Declared resources are not created as Resource instances (and thus are not available through their ResourceManager) until initialiseResourceGroup is called, at which point all declared resources will become created (but unloaded) Resource instances, along with any resources declared in scripts in resource locations associated with the group. </summary>
      <param name="name">The resource name. </param>
      <param name="resourceType">The type of the resource. Ogre comes preconfigured with a number of resource types: FontGpuProgramHighLevelGpuProgramMaterialMeshSkeletonTexture
.. but more can be added by plugin ResourceManager classes. </param>
      <param name="groupName">The name of the group to which it will belong. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeclareResource(System.String,System.String,System.String,Mogre.Const_NameValuePairList)">
      <summary>Declares a resource to be a part of a resource group, allowing you to load and unload it as part of the group. By declaring resources before you attempt to use them, you can more easily control the loading and unloading of those resources by their group. Declaring them also allows them to be enumerated, which means events can be raised to indicate the loading progress (ResourceGroupListener). Note that another way of declaring resources is to use a script specific to the resource type, if available (e.g. .material). Declared resources are not created as Resource instances (and thus are not available through their ResourceManager) until initialiseResourceGroup is called, at which point all declared resources will become created (but unloaded) Resource instances, along with any resources declared in scripts in resource locations associated with the group. </summary>
      <param name="name">The resource name. </param>
      <param name="resourceType">The type of the resource. Ogre comes preconfigured with a number of resource types: FontGpuProgramHighLevelGpuProgramMaterialMeshSkeletonTexture
.. but more can be added by plugin ResourceManager classes. </param>
      <param name="groupName">The name of the group to which it will belong. </param>
      <param name="loadParameters">A list of name / value pairs which supply custom parameters to the resource which will be required before it can be loaded. These are specific to the resource type. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.UndeclareResource(System.String,System.String)">
      <summary>Undeclare a resource. Note that this will not cause it to be unloaded if it is already loaded, nor will it destroy a resource which has already been created if initialiseResourceGroup has been called already. Only unloadResourceGroup / clearResourceGroup / destroyResourceGroup will do that. </summary>
      <param name="name">The name of the resource. </param>
      <param name="groupName">The name of the group this resource was declared in. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.OpenResource(System.String)">
      <summary>Open a single resource by name and return a DataStream pointing at the source of the data. Shared pointer to data stream containing the data, will be destroyed automatically when no longer referenced </summary>
      <param name="resourceName">The name of the resource to locate. Even if resource locations are added recursively, you must provide a fully qualified name to this method. You can find out the matching fully qualified names by using the find() method if you need to. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.OpenResource(System.String,System.String)">
      <summary>Open a single resource by name and return a DataStream pointing at the source of the data. Shared pointer to data stream containing the data, will be destroyed automatically when no longer referenced </summary>
      <param name="resourceName">The name of the resource to locate. Even if resource locations are added recursively, you must provide a fully qualified name to this method. You can find out the matching fully qualified names by using the find() method if you need to. </param>
      <param name="groupName">The name of the resource group; this determines which locations are searched. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.OpenResource(System.String,System.String,System.Boolean)">
      <summary>Open a single resource by name and return a DataStream pointing at the source of the data. Shared pointer to data stream containing the data, will be destroyed automatically when no longer referenced </summary>
      <param name="resourceName">The name of the resource to locate. Even if resource locations are added recursively, you must provide a fully qualified name to this method. You can find out the matching fully qualified names by using the find() method if you need to. </param>
      <param name="groupName">The name of the resource group; this determines which locations are searched. </param>
      <param name="searchGroupsIfNotFound">If true, if the resource is not found in the group specified, other groups will be searched. If you're loading a real Resource using this option, you must also provide the resourceBeingLoaded parameter to enable the group membership to be changed </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.OpenResource(System.String,System.String,System.Boolean,Mogre.Resource)">
      <summary>Open a single resource by name and return a DataStream pointing at the source of the data. Shared pointer to data stream containing the data, will be destroyed automatically when no longer referenced </summary>
      <param name="resourceName">The name of the resource to locate. Even if resource locations are added recursively, you must provide a fully qualified name to this method. You can find out the matching fully qualified names by using the find() method if you need to. </param>
      <param name="groupName">The name of the resource group; this determines which locations are searched. </param>
      <param name="searchGroupsIfNotFound">If true, if the resource is not found in the group specified, other groups will be searched. If you're loading a real Resource using this option, you must also provide the resourceBeingLoaded parameter to enable the group membership to be changed </param>
      <param name="resourceBeingLoaded">Optional pointer to the resource being loaded, which you should supply if you want </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.OpenResources(System.String)">
      <summary>Open all resources matching a given pattern (which can contain the character '*' as a wildcard), and return a collection of DataStream objects on them. Shared pointer to a data stream list , will be destroyed automatically when no longer referenced </summary>
      <param name="pattern">The pattern to look for. If resource locations have been added recursively, subdirectories will be searched too so this does not need to be fully qualified. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.OpenResources(System.String,System.String)">
      <summary>Open all resources matching a given pattern (which can contain the character '*' as a wildcard), and return a collection of DataStream objects on them. Shared pointer to a data stream list , will be destroyed automatically when no longer referenced </summary>
      <param name="pattern">The pattern to look for. If resource locations have been added recursively, subdirectories will be searched too so this does not need to be fully qualified. </param>
      <param name="groupName">The resource group; this determines which locations are searched. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ListResourceNames(System.String)">
      <summary>List all file or directory names in a resource group. This method only returns filenames, you can also retrieve other information using listFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="groupName">The name of the group </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ListResourceNames(System.String,System.Boolean)">
      <summary>List all file or directory names in a resource group. This method only returns filenames, you can also retrieve other information using listFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="groupName">The name of the group </param>
      <param name="dirs">If true, directory names will be returned instead of file names </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ListResourceFileInfo(System.String)">
      <summary>List all files in a resource group with accompanying information. A list of structures detailing quite a lot of information about all the files in the archive. </summary>
      <param name="groupName">The name of the group </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ListResourceFileInfo(System.String,System.Boolean)">
      <summary>List all files in a resource group with accompanying information. A list of structures detailing quite a lot of information about all the files in the archive. </summary>
      <param name="groupName">The name of the group </param>
      <param name="dirs">If true, directory names will be returned instead of file names </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.FindResourceNames(System.String,System.String)">
      <summary>Find all file or directory names matching a given pattern in a resource group. This method only returns filenames, you can also retrieve other information using findFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="groupName">The name of the group </param>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.FindResourceNames(System.String,System.String,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in a resource group. This method only returns filenames, you can also retrieve other information using findFileInfo. A list of filenames matching the criteria, all are fully qualified </summary>
      <param name="groupName">The name of the group </param>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
      <param name="dirs">Set to true if you want the directories to be listed instead of files </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ResourceExists(System.String,System.String)">
      <summary>Find out if the named file exists in a group. </summary>
      <param name="group">The name of the resource group </param>
      <param name="filename">Fully qualified name of the file to test for </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ResourceExistsInAnyGroup(System.String)">
      <summary>Find out if the named file exists in any group. </summary>
      <param name="filename">Fully qualified name of the file to test for </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.FindGroupContainingResource(System.String)">
      <summary>Find the group in which a resource exists. Name of the resource group the resource was found in. An exception is thrown if the group could not be determined. </summary>
      <param name="filename">Fully qualified name of the file the resource should be found as </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.FindResourceFileInfo(System.String,System.String)">
      <summary>Find all files or directories matching a given pattern in a group and get some detailed information about them. A list of file information structures for all files matching the criteria. </summary>
      <param name="group">The name of the resource group </param>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.FindResourceFileInfo(System.String,System.String,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in a group and get some detailed information about them. A list of file information structures for all files matching the criteria. </summary>
      <param name="group">The name of the resource group </param>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
      <param name="dirs">Set to true if you want the directories to be listed instead of files </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ResourceModifiedTime(System.String,System.String)">
      <summary>Retrieve the modification time of a given file </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ListResourceLocations(System.String)">
      <summary>List all resource locations in a resource group. A list of resource locations matching the criteria </summary>
      <param name="groupName">The name of the group </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.FindResourceLocation(System.String,System.String)">
      <summary>Find all resource location names matching a given pattern in a resource group. A list of resource locations matching the criteria </summary>
      <param name="groupName">The name of the group </param>
      <param name="pattern">The pattern to search for; wildcards (*) are allowed </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.CreateResource(System.String)">
      <summary>Create a new resource file in a given group. This method creates a new file in a resource group and passes you back a writeable stream. </summary>
      <param name="filename">The name of the file to create </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.CreateResource(System.String,System.String)">
      <summary>Create a new resource file in a given group. This method creates a new file in a resource group and passes you back a writeable stream. </summary>
      <param name="filename">The name of the file to create </param>
      <param name="groupName">The name of the group in which to create the file </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.CreateResource(System.String,System.String,System.Boolean)">
      <summary>Create a new resource file in a given group. This method creates a new file in a resource group and passes you back a writeable stream. </summary>
      <param name="filename">The name of the file to create </param>
      <param name="groupName">The name of the group in which to create the file </param>
      <param name="overwrite">If true, an existing file will be overwritten, if false an error will occur if the file already exists </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.CreateResource(System.String,System.String,System.Boolean,System.String)">
      <summary>Create a new resource file in a given group. This method creates a new file in a resource group and passes you back a writeable stream. </summary>
      <param name="filename">The name of the file to create </param>
      <param name="groupName">The name of the group in which to create the file </param>
      <param name="overwrite">If true, an existing file will be overwritten, if false an error will occur if the file already exists </param>
      <param name="locationPattern">If the resource group contains multiple locations, then usually the file will be created in the first writable location. If you want to be more specific, you can include a location pattern here and only locations which match that pattern (as determined by StringUtil::match) will be considered candidates for creation. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeleteResource(System.String)">
      <summary>Delete a single resource file. </summary>
      <param name="filename">The name of the file to delete. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeleteResource(System.String,System.String)">
      <summary>Delete a single resource file. </summary>
      <param name="filename">The name of the file to delete. </param>
      <param name="groupName">The name of the group in which to search </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeleteResource(System.String,System.String,System.String)">
      <summary>Delete a single resource file. </summary>
      <param name="filename">The name of the file to delete. </param>
      <param name="groupName">The name of the group in which to search </param>
      <param name="locationPattern">If the resource group contains multiple locations, then usually first matching file found in any location will be deleted. If you want to be more specific, you can include a location pattern here and only locations which match that pattern (as determined by StringUtil::match) will be considered candidates for deletion. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeleteMatchingResources(System.String)">
      <summary>Delete all matching resource files. </summary>
      <param name="filePattern">The pattern (see StringUtil::match) of the files to delete. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeleteMatchingResources(System.String,System.String)">
      <summary>Delete all matching resource files. </summary>
      <param name="filePattern">The pattern (see StringUtil::match) of the files to delete. </param>
      <param name="groupName">The name of the group in which to search </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.DeleteMatchingResources(System.String,System.String,System.String)">
      <summary>Delete all matching resource files. </summary>
      <param name="filePattern">The pattern (see StringUtil::match) of the files to delete. </param>
      <param name="groupName">The name of the group in which to search </param>
      <param name="locationPattern">If the resource group contains multiple locations, then usually all matching files in any location will be deleted. If you want to be more specific, you can include a location pattern here and only locations which match that pattern (as determined by StringUtil::match) will be considered candidates for deletion. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.LinkWorldGeometryToResourceGroup(System.String,System.String,Mogre.SceneManager)">
      <summary>Associates some world geometry with a resource group, causing it to be loaded / unloaded with the resource group. You would use this method to essentially defer a call to SceneManager::setWorldGeometry to the time when the resource group is loaded. The advantage of this is that compatible scene managers will include the estimate of the number of loading stages for that world geometry when the resource group begins loading, allowing you to include that in a loading progress report. </summary>
      <param name="group">The name of the resource group </param>
      <param name="worldGeometry">The parameter which should be passed to setWorldGeometry </param>
      <param name="sceneManager">The SceneManager which should be called </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.UnlinkWorldGeometryFromResourceGroup(System.String)">
      <summary>Clear any link to world geometry from a resource group. Basically undoes a previous call to linkWorldGeometryToResourceGroup. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.IsResourceGroupInGlobalPool(System.String)">
      <summary>Checks the status of a resource group. Looks at the state of a resource group. If loadResourceGroup has been called for the resource group return true, otherwise return false. </summary>
      <param name="name">The name to of the resource group to access. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.ShutdownAll">
      <summary>Shutdown all ResourceManagers, performed as part of clean-up. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager._registerResourceManager(System.String,Mogre.ResourceManager)">
      <summary>Internal method for registering a ResourceManager (which should be a singleton). Creators of plugins can register new ResourceManagers this way if they wish. ResourceManagers that wish to parse scripts must also call _registerScriptLoader. </summary>
      <param name="resourceType">String identifying the resource type, must be unique. </param>
      <param name="rm">Pointer to the ResourceManager instance. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager._unregisterResourceManager(System.String)">
      <summary>Internal method for unregistering a ResourceManager. ResourceManagers that wish to parse scripts must also call _unregisterScriptLoader. </summary>
      <param name="resourceType">String identifying the resource type. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.GetResourceManagerIterator">
      <summary>Get an iterator over the registered resource managers. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager._getResourceManager(System.String)">
      <summary>Internal method for getting a registered ResourceManager. </summary>
      <param name="resourceType">String identifying the resource type. </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager._notifyResourceCreated(Mogre.ResourcePtr)">
      <summary>Internal method called by ResourceManager when a resource is created. </summary>
      <param name="res">Weak reference to resource </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager._notifyResourceRemoved(Mogre.ResourcePtr)">
      <summary>Internal method called by ResourceManager when a resource is removed. </summary>
      <param name="res">Weak reference to resource </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager._notifyResourceGroupChanged(System.String,Mogre.Resource)">
      <summary>Internal method to notify the group manager that a resource has changed group (only applicable for autodetect group) </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager._notifyAllResourcesRemoved(Mogre.ResourceManager)">
      <summary>Internal method called by ResourceManager when all resources for that manager are removed. </summary>
      <param name="manager">Pointer to the manager for which all resources are being removed </param>
    </member>
    <member name="M:Mogre.ResourceGroupManager.GetResourceGroups">
      <summary>Get a list of the currently defined resource groups. This method intentionally returns a copy rather than a reference in order to avoid any contention issues in multithreaded applications. A copy of list of currently defined groups. </summary>
    </member>
    <member name="M:Mogre.ResourceGroupManager.GetResourceDeclarationList(System.String)">
      <summary>Get the list of resource declarations for the specified group name. This method intentionally returns a copy rather than a reference in order to avoid any contention issues in multithreaded applications. A copy of list of currently defined resources. </summary>
      <param name="groupName">The name of the group </param>
    </member>
    <member name="P:Mogre.ResourceGroupManager.WorldResourceGroupName">
      <summary>Sets/Gets the resource group that 'world' resources will use. </summary>
    </member>
    <member name="P:Mogre.ResourceGroupManager.LoadingListener">
      <summary>Sets/Returns the current loading listener. </summary>
    </member>
    <member name="P:Mogre.ResourceGroupManager.RESOURCE_SYSTEM_NUM_REFERENCE_COUNTS">
      <summary>Sets/The number of reference counts held per resource by the resource system. </summary>
    </member>
    <member name="P:Mogre.ResourceGroupManager.AUTODETECT_RESOURCE_GROUP_NAME">
      <summary>Sets/Special resource group name which causes resource group to be automatically determined based on searching for the resource in all groups. </summary>
    </member>
    <member name="P:Mogre.ResourceGroupManager.INTERNAL_RESOURCE_GROUP_NAME">
      <summary>Sets/Internal resource group name (should be used by OGRE internal only). </summary>
    </member>
    <member name="P:Mogre.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME">
      <summary>Sets/Default resource group name. </summary>
    </member>
    <member name="P:Mogre.ResourceGroupManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.RibbonTrail">
      <summary>Subclass of BillboardChain which automatically leaves a trail behind one or more Node instances. An instance of this class will watch one or more Node instances, and automatically generate a trail behind them as they move. Because this class can monitor multiple modes, it generates its own geometry in world space and thus, even though it has to be attached to a SceneNode to be visible, changing the position of the scene node it is attached to makes no difference to the geometry rendered. The 'head' element grows smoothly in size until it reaches the required size, then a new element is added. If the segment is full, the tail element shrinks by the same proportion as the head grows before disappearing. Elements can be faded out on a time basis, either by altering their colour or altering their alpha. The width can also alter over time. 'v' texture coordinates are fixed at 0.0 if used, meaning that you can use a 1D texture to 'smear' a colour pattern along the ribbon if you wish. The 'u' coordinates are by default (0.0, 1.0), but you can alter this using setOtherTexCoordRange if you wish. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.AddNode(Mogre.Node)">
      <summary>Add a node to be tracked. </summary>
      <param name="n">The node that will be tracked. </param>
    </member>
    <member name="M:Mogre.RibbonTrail.RemoveNode(Mogre.Node)">
      <summary>Remove tracking on a given node. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.GetNodeIterator">
      <summary>Get an iterator over the nodes which are being tracked. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.GetChainIndexForNode(Mogre.Node)">
      <summary>Get the chain index for a given Node being tracked. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.ClearChain(System.UInt32)">
      <summary>Remove all elements of a given chain (but leave the chain intact).</summary>
    </member>
    <member name="M:Mogre.RibbonTrail.SetInitialColour(System.UInt32,System.Single,System.Single,System.Single)">
      <summary>Set the starting ribbon colour. Only used if this instance is using vertex colours. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="r">The initial colour </param>
    </member>
    <member name="M:Mogre.RibbonTrail.SetInitialColour(System.UInt32,System.Single,System.Single,System.Single,System.Single)">
      <summary>Set the starting ribbon colour. Only used if this instance is using vertex colours. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="r">The initial colour </param>
    </member>
    <member name="M:Mogre.RibbonTrail.SetInitialColour(System.UInt32,Mogre.ColourValue)">
      <summary>Set the starting ribbon colour for a given segment. Only used if this instance is using vertex colours. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="col">The initial colour </param>
    </member>
    <member name="M:Mogre.RibbonTrail.GetInitialColour(System.UInt32)">
      <summary>Get the starting ribbon colour. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.SetColourChange(System.UInt32,System.Single,System.Single,System.Single,System.Single)">
      <summary>Enables / disables fading the trail using colour. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="r">The amount to subtract from each colour channel per second </param>
    </member>
    <member name="M:Mogre.RibbonTrail.SetColourChange(System.UInt32,Mogre.ColourValue)">
      <summary>Enables / disables fading the trail using colour. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="valuePerSecond">The amount to subtract from colour each second </param>
    </member>
    <member name="M:Mogre.RibbonTrail.SetInitialWidth(System.UInt32,System.Single)">
      <summary>Set the starting ribbon width in world units. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="width">The initial width of the ribbon </param>
    </member>
    <member name="M:Mogre.RibbonTrail.GetInitialWidth(System.UInt32)">
      <summary>Get the starting ribbon width in world units. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.SetWidthChange(System.UInt32,System.Single)">
      <summary>Set the change in ribbon width per second. </summary>
      <param name="chainIndex">The index of the chain </param>
      <param name="widthDeltaPerSecond">The amount the width will reduce by per second </param>
    </member>
    <member name="M:Mogre.RibbonTrail.GetWidthChange(System.UInt32)">
      <summary>Get the change in ribbon width per second. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.GetColourChange(System.UInt32)">
      <summary>Get the per-second fading amount </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.NodeUpdated(Mogre.Node)">
      <summary>Node::Listener::nodeUpdated</summary>
    </member>
    <member name="M:Mogre.RibbonTrail.NodeDestroyed(Mogre.Node)">
      <summary>Node::Listener::nodeDestroyed</summary>
    </member>
    <member name="M:Mogre.RibbonTrail._timeUpdate(System.Single)">
      <summary>Perform any fading / width delta required; internal method. </summary>
    </member>
    <member name="M:Mogre.RibbonTrail.ClearChain(System.UInt32)">
      <summary>Remove all elements of a given chain (but leave the chain intact).</summary>
    </member>
    <member name="M:Mogre.RibbonTrail.#ctor(System.String)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
    </member>
    <member name="M:Mogre.RibbonTrail.#ctor(System.String,System.UInt32)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
    </member>
    <member name="M:Mogre.RibbonTrail.#ctor(System.String,System.UInt32,System.UInt32)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
      <param name="numberOfChains">The number of separate chain segments contained in this object, ie the maximum number of nodes that can have trails attached </param>
    </member>
    <member name="M:Mogre.RibbonTrail.#ctor(System.String,System.UInt32,System.UInt32,System.Boolean)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
      <param name="numberOfChains">The number of separate chain segments contained in this object, ie the maximum number of nodes that can have trails attached </param>
      <param name="useTextureCoords">If true, use texture coordinates from the chain elements </param>
    </member>
    <member name="M:Mogre.RibbonTrail.#ctor(System.String,System.UInt32,System.UInt32,System.Boolean,System.Boolean)">
      <summary>Constructor (don't use directly, use factory) </summary>
      <param name="name">The name to give this object </param>
      <param name="maxElements">The maximum number of elements per chain </param>
      <param name="numberOfChains">The number of separate chain segments contained in this object, ie the maximum number of nodes that can have trails attached </param>
      <param name="useTextureCoords">If true, use texture coordinates from the chain elements </param>
    </member>
    <member name="P:Mogre.RibbonTrail.TrailLength">
      <summary>Sets/Get the length of the trail. </summary>
    </member>
    <member name="P:Mogre.RibbonTrail.MovableType">
      <summary>Overridden from MovableObject</summary>
    </member>
    <member name="T:Mogre.RibbonTrailFactory">
      <summary>Factory object for creating RibbonTrail instances </summary>
    </member>
    <member name="T:Mogre.DefaultSceneManagerFactory">
      <summary>Factory for default scene manager. </summary>
    </member>
    <member name="P:Mogre.DefaultSceneManagerFactory.FACTORY_TYPE_NAME">
      <summary>Factory type name. </summary>
    </member>
    <member name="T:Mogre.SceneManagerEnumerator">
      <summary>Enumerates the SceneManager classes available to applications. As described in the SceneManager class, SceneManagers are responsible for organising the scene and issuing rendering commands to the RenderSystem. Certain scene types can benefit from different rendering approaches, and it is intended that subclasses will be created to special case this. In order to give applications easy access to these implementations, this class has a number of methods to create or retrieve a SceneManager which is appropriate to the scene type. SceneManagers are created by SceneManagerFactory instances. New factories for new types of SceneManager can be registered with this class to make them available to clients. Note that you can still plug in your own custom SceneManager without using a factory, should you choose, it's just not as flexible that way. Just instantiate your own SceneManager manually and use it directly. </summary>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.AddFactory(Mogre.SceneManagerFactory)">
      <summary>Register a new SceneManagerFactory. Plugins should call this to register as new SceneManager providers. </summary>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.RemoveFactory(Mogre.SceneManagerFactory)">
      <summary>Remove a SceneManagerFactory. </summary>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.GetMetaData(System.String)">
      <summary>Get more information about a given type of SceneManager. The metadata returned tells you a few things about a given type of SceneManager, which can be created using a factory that has been registered already. </summary>
      <param name="typeName">The type name of the SceneManager you want to enquire on. If you don't know the typeName already, you can iterate over the metadata for all types using getMetaDataIterator. </param>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.GetMetaDataIterator">
      <summary>Iterate over all types of SceneManager available for construction, providing some information about each one. </summary>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.CreateSceneManager(Mogre.SceneType)">
      <summary>Create a SceneManager instance based on scene type support. Creates an instance of a SceneManager which supports the scene types identified in the parameter. If more than one type of SceneManager has been registered as handling that combination of scene types, in instance of the last one registered is returned. This method always succeeds, if a specific scene manager is not found, the default implementation is always returned. </summary>
      <param name="typeMask">A mask containing one or more SceneType flags </param>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.CreateSceneManager(Mogre.SceneType,System.String)">
      <summary>Create a SceneManager instance based on scene type support. Creates an instance of a SceneManager which supports the scene types identified in the parameter. If more than one type of SceneManager has been registered as handling that combination of scene types, in instance of the last one registered is returned. This method always succeeds, if a specific scene manager is not found, the default implementation is always returned. </summary>
      <param name="typeMask">A mask containing one or more SceneType flags </param>
      <param name="instanceName">Optional name to given the new instance that is created. If you leave this blank, an auto name will be assigned. </param>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.CreateSceneManager(System.String)">
      <summary>Create a SceneManager instance of a given type. You can use this method to create a SceneManager instance of a given specific type. You may know this type already, or you may have discovered it by looking at the results from getMetaDataIterator. This method throws an exception if the named type is not found. </summary>
      <param name="typeName">String identifying a unique SceneManager type </param>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.CreateSceneManager(System.String,System.String)">
      <summary>Create a SceneManager instance of a given type. You can use this method to create a SceneManager instance of a given specific type. You may know this type already, or you may have discovered it by looking at the results from getMetaDataIterator. This method throws an exception if the named type is not found. </summary>
      <param name="typeName">String identifying a unique SceneManager type </param>
      <param name="instanceName">Optional name to given the new instance that is created. If you leave this blank, an auto name will be assigned. </param>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.DestroySceneManager(Mogre.SceneManager)">
      <summary>Destroy an instance of a SceneManager. </summary>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.GetSceneManager(System.String)">
      <summary>Get an existing SceneManager instance that has already been created, identified by the instance name. </summary>
      <param name="instanceName">The name of the instance to retrieve. </param>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.HasSceneManager(System.String)">
      <summary>Identify if a SceneManager instance already exists. </summary>
      <param name="instanceName">The name of the instance to retrieve. </param>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.GetSceneManagerIterator">
      <summary>Get an iterator over all the existing SceneManager instances. </summary>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.SetRenderSystem(Mogre.RenderSystem)">
      <summary>Notifies all SceneManagers of the destination rendering system. </summary>
    </member>
    <member name="M:Mogre.SceneManagerEnumerator.ShutdownAll">
      <summary>Utility method to control shutdown of the managers. </summary>
    </member>
    <member name="P:Mogre.SceneManagerEnumerator.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.Root">
      <summary>The root class of the Ogre system. The Ogre::Root class represents a starting point for the client application. From here, the application can gain access to the fundamentals of the system, namely the rendering systems available, management of saved configurations, logging, and access to other classes in the system. Acts as a hub from which all other objects may be reached. An instance of Root must be created before any other Ogre operations are called. Once an instance has been created, the same instance is accessible throughout the life of that object by using Root::getSingleton (as a reference) or Root::getSingletonPtr (as a pointer). </summary>
    </member>
    <member name="M:Mogre.Root.SaveConfig">
      <summary>Saves the details of the current configuration Stores details of the current configuration so it may be restored later on. </summary>
    </member>
    <member name="M:Mogre.Root.RestoreConfig">
      <summary>Checks for saved video/sound/etc settings This method checks to see if there is a valid saved configuration from a previous run. If there is, the state of the system will be restored to that configuration.If a valid configuration was found, true is returned. If there is no saved configuration, or if the system failed with the last config settings, false is returned. </summary>
    </member>
    <member name="M:Mogre.Root.ShowConfigDialog">
      <summary>Displays a dialog asking the user to choose system settings. This method displays the default dialog allowing the user to choose the rendering system, video mode etc. If there is are any settings saved already, they will be restored automatically before displaying the dialogue. When the user accepts a group of settings, this will automatically call Root::setRenderSystem, RenderSystem::setConfigOption and Root::saveConfig with the user's choices. This is the easiest way to get the system configured. If the user clicked 'Ok', true is returned. If they clicked 'Cancel' (in which case the app should strongly consider terminating), false is returned. </summary>
    </member>
    <member name="M:Mogre.Root.AddRenderSystem(Mogre.RenderSystem)">
      <summary>Adds a new rendering subsystem to the list of available renderers. Intended for use by advanced users and plugin writers only! Calling this method with a pointer to a valid RenderSystem (subclass) adds a rendering API implementation to the list of available ones. Typical examples would be an OpenGL implementation and a Direct3D implementation. 
This should usually be called from the dllStartPlugin() function of an extension plug-in. </summary>
    </member>
    <member name="M:Mogre.Root.GetAvailableRenderers">
      <summary>Retrieve a list of the available render systems. Retrieves a pointer to the list of available renderers as a list of RenderSystem subclasses. Can be used to build a custom settings dialog. </summary>
    </member>
    <member name="M:Mogre.Root.GetRenderSystemByName(System.String)">
      <summary>Retrieve a pointer to the render system by the given name A pointer to the render system, NULL if no found. </summary>
      <param name="name">Name of the render system intend to retrieve. </param>
    </member>
    <member name="M:Mogre.Root.Initialise(System.Boolean)">
      <summary>Initialises the renderer. This method can only be called after a renderer has been selected with Root::setRenderSystem, and it will initialise the selected rendering system ready for use. A pointer to the automatically created window, if requested, otherwise NULL. </summary>
      <param name="autoCreateWindow">If true, a rendering window will automatically be created (saving a call to Root::createRenderWindow). The window will be created based on the options currently set on the render system. </param>
    </member>
    <member name="M:Mogre.Root.Initialise(System.Boolean,System.String)">
      <summary>Initialises the renderer. This method can only be called after a renderer has been selected with Root::setRenderSystem, and it will initialise the selected rendering system ready for use. A pointer to the automatically created window, if requested, otherwise NULL. </summary>
      <param name="autoCreateWindow">If true, a rendering window will automatically be created (saving a call to Root::createRenderWindow). The window will be created based on the options currently set on the render system. </param>
    </member>
    <member name="M:Mogre.Root.Initialise(System.Boolean,System.String,System.String)">
      <summary>Initialises the renderer. This method can only be called after a renderer has been selected with Root::setRenderSystem, and it will initialise the selected rendering system ready for use. A pointer to the automatically created window, if requested, otherwise NULL. </summary>
      <param name="autoCreateWindow">If true, a rendering window will automatically be created (saving a call to Root::createRenderWindow). The window will be created based on the options currently set on the render system. </param>
    </member>
    <member name="M:Mogre.Root.UseCustomRenderSystemCapabilities(Mogre.RenderSystemCapabilities)">
      <summary>Requests active RenderSystem to use custom RenderSystemCapabilitiesThis is useful for testing how the RenderSystem would behave on a machine with less advanced GPUs. This method MUST be called before creating the first RenderWindow</summary>
    </member>
    <member name="M:Mogre.Root.AddSceneManagerFactory(Mogre.SceneManagerFactory)">
      <summary>Register a new SceneManagerFactory, a factory object for creating instances of specific SceneManagers. Plugins should call this to register as new SceneManager providers. </summary>
    </member>
    <member name="M:Mogre.Root.RemoveSceneManagerFactory(Mogre.SceneManagerFactory)">
      <summary>Unregister a SceneManagerFactory. </summary>
    </member>
    <member name="M:Mogre.Root.GetSceneManagerMetaData(System.String)">
      <summary>Get more information about a given type of SceneManager. The metadata returned tells you a few things about a given type of SceneManager, which can be created using a factory that has been registered already. </summary>
      <param name="typeName">The type name of the SceneManager you want to enquire on. If you don't know the typeName already, you can iterate over the metadata for all types using getMetaDataIterator. </param>
    </member>
    <member name="M:Mogre.Root.GetSceneManagerMetaDataIterator">
      <summary>Iterate over all types of SceneManager available for construction, providing some information about each one. </summary>
    </member>
    <member name="M:Mogre.Root.CreateSceneManager(Mogre.SceneType)">
      <summary>Create a SceneManager instance based on scene type support. Creates an instance of a SceneManager which supports the scene types identified in the parameter. If more than one type of SceneManager has been registered as handling that combination of scene types, in instance of the last one registered is returned. This method always succeeds, if a specific scene manager is not found, the default implementation is always returned. </summary>
      <param name="typeMask">A mask containing one or more SceneType flags </param>
    </member>
    <member name="M:Mogre.Root.CreateSceneManager(Mogre.SceneType,System.String)">
      <summary>Create a SceneManager instance based on scene type support. Creates an instance of a SceneManager which supports the scene types identified in the parameter. If more than one type of SceneManager has been registered as handling that combination of scene types, in instance of the last one registered is returned. This method always succeeds, if a specific scene manager is not found, the default implementation is always returned. </summary>
      <param name="typeMask">A mask containing one or more SceneType flags </param>
      <param name="instanceName">Optional name to given the new instance that is created. If you leave this blank, an auto name will be assigned. </param>
    </member>
    <member name="M:Mogre.Root.CreateSceneManager(System.String)">
      <summary>Create a SceneManager instance of a given type. You can use this method to create a SceneManager instance of a given specific type. You may know this type already, or you may have discovered it by looking at the results from getMetaDataIterator. This method throws an exception if the named type is not found. </summary>
      <param name="typeName">String identifying a unique SceneManager type </param>
    </member>
    <member name="M:Mogre.Root.CreateSceneManager(System.String,System.String)">
      <summary>Create a SceneManager instance of a given type. You can use this method to create a SceneManager instance of a given specific type. You may know this type already, or you may have discovered it by looking at the results from getMetaDataIterator. This method throws an exception if the named type is not found. </summary>
      <param name="typeName">String identifying a unique SceneManager type </param>
      <param name="instanceName">Optional name to given the new instance that is created. If you leave this blank, an auto name will be assigned. </param>
    </member>
    <member name="M:Mogre.Root.DestroySceneManager(Mogre.SceneManager)">
      <summary>Destroy an instance of a SceneManager. </summary>
    </member>
    <member name="M:Mogre.Root.GetSceneManager(System.String)">
      <summary>Get an existing SceneManager instance that has already been created, identified by the instance name. </summary>
      <param name="instanceName">The name of the instance to retrieve. </param>
    </member>
    <member name="M:Mogre.Root.HasSceneManager(System.String)">
      <summary>Determines if a given SceneManager already exists </summary>
      <param name="instanceName">The name of the instance to retrieve. </param>
    </member>
    <member name="M:Mogre.Root.GetSceneManagerIterator">
      <summary>Get an iterator over all the existing SceneManager instances. </summary>
    </member>
    <member name="M:Mogre.Root.GetErrorDescription(System.Int32)">
      <summary>Utility function for getting a better description of an error code. </summary>
    </member>
    <member name="M:Mogre.Root.QueueEndRendering">
      <summary>Queues the end of rendering. This method will do nothing unless startRendering() has been called, in which case before the next frame is rendered the rendering loop will bail out. Root, Root::startRendering</summary>
    </member>
    <member name="M:Mogre.Root.StartRendering">
      <summary>Starts / restarts the automatic rendering cycle. This method begins the automatic rendering of the scene. It will NOT return until the rendering cycle is halted. During rendering, any FrameListener classes registered using addFrameListener will be called back for each frame that is to be rendered, These classes can tell OGRE to halt the rendering if required, which will cause this method to return. 
Users of the OGRE library do not have to use this automatic rendering loop. It is there as a convenience and is most useful for high frame rate applications e.g. games. For applications that don't need to constantly refresh the rendering targets (e.g. an editor utility), it is better to manually refresh each render target only when required by calling RenderTarget::update, or if you want to run your own render loop you can update all targets on demand using Root::renderOneFrame. This frees up the CPU to do other things in between refreshes, since in this case frame rate is less important. This method can only be called after Root::initialise has been called. </summary>
    </member>
    <member name="M:Mogre.Root.RenderOneFrame(System.Single)">
      <summary>Render one frame, with custom frame time information. Updates all the render targets automatically and then returns, raising frame events before and after - all per-frame times are based on the time value you pass in. </summary>
    </member>
    <member name="M:Mogre.Root.RenderOneFrame">
      <summary>Render one frame. Updates all the render targets automatically and then returns, raising frame events before and after. </summary>
    </member>
    <member name="M:Mogre.Root.Shutdown">
      <summary>Shuts down the system manually. This is normally done by Ogre automatically so don't think you have to call this yourself. However this is here for convenience, especially for dealing with unexpected errors or for systems which need to shut down Ogre on demand. </summary>
    </member>
    <member name="M:Mogre.Root.AddResourceLocation(System.String,System.String)">
      <summary>Adds a location to the list of searchable locations for a Resource type. Resource files (textures, models etc) need to be loaded from specific locations. By calling this method, you add another search location to the list. Locations added first are preferred over locations added later. Locations can be folders, compressed archives, even perhaps remote locations. Facilities for loading from different locations are provided by plugins which provide implementations of the Archive class. All the application user has to do is specify a 'loctype' string in order to indicate the type of location, which should map onto one of the provided plugins. Ogre comes configured with the 'FileSystem' (folders) and 'Zip' (archive compressed with the pkzip / WinZip etc utilities) types. You can also supply the name of a resource group which should have this location applied to it. The ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME group is the default, and one resource group which will always exist. You should consider defining resource groups for your more specific resources (e.g. per level) so that you can control loading / unloading better. Archive</summary>
      <param name="name">The name of the location, e.g. './data' or '/compressed/gamedata.zip' </param>
      <param name="locType">A string identifying the location type, e.g. 'FileSystem' (for folders), 'Zip' etc. Must map to a registered plugin which deals with this type (FileSystem and Zip should always be available) </param>
    </member>
    <member name="M:Mogre.Root.AddResourceLocation(System.String,System.String,System.String)">
      <summary>Adds a location to the list of searchable locations for a Resource type. Resource files (textures, models etc) need to be loaded from specific locations. By calling this method, you add another search location to the list. Locations added first are preferred over locations added later. Locations can be folders, compressed archives, even perhaps remote locations. Facilities for loading from different locations are provided by plugins which provide implementations of the Archive class. All the application user has to do is specify a 'loctype' string in order to indicate the type of location, which should map onto one of the provided plugins. Ogre comes configured with the 'FileSystem' (folders) and 'Zip' (archive compressed with the pkzip / WinZip etc utilities) types. You can also supply the name of a resource group which should have this location applied to it. The ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME group is the default, and one resource group which will always exist. You should consider defining resource groups for your more specific resources (e.g. per level) so that you can control loading / unloading better. Archive</summary>
      <param name="name">The name of the location, e.g. './data' or '/compressed/gamedata.zip' </param>
      <param name="locType">A string identifying the location type, e.g. 'FileSystem' (for folders), 'Zip' etc. Must map to a registered plugin which deals with this type (FileSystem and Zip should always be available) </param>
      <param name="groupName">Type of name of the resource group which this location should apply to; defaults to the General group which applies to all non-specific resources. </param>
    </member>
    <member name="M:Mogre.Root.AddResourceLocation(System.String,System.String,System.String,System.Boolean)">
      <summary>Adds a location to the list of searchable locations for a Resource type. Resource files (textures, models etc) need to be loaded from specific locations. By calling this method, you add another search location to the list. Locations added first are preferred over locations added later. Locations can be folders, compressed archives, even perhaps remote locations. Facilities for loading from different locations are provided by plugins which provide implementations of the Archive class. All the application user has to do is specify a 'loctype' string in order to indicate the type of location, which should map onto one of the provided plugins. Ogre comes configured with the 'FileSystem' (folders) and 'Zip' (archive compressed with the pkzip / WinZip etc utilities) types. You can also supply the name of a resource group which should have this location applied to it. The ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME group is the default, and one resource group which will always exist. You should consider defining resource groups for your more specific resources (e.g. per level) so that you can control loading / unloading better. Archive</summary>
      <param name="name">The name of the location, e.g. './data' or '/compressed/gamedata.zip' </param>
      <param name="locType">A string identifying the location type, e.g. 'FileSystem' (for folders), 'Zip' etc. Must map to a registered plugin which deals with this type (FileSystem and Zip should always be available) </param>
      <param name="groupName">Type of name of the resource group which this location should apply to; defaults to the General group which applies to all non-specific resources. </param>
      <param name="recursive">If the resource location has a concept of recursive directory traversal, enabling this option will mean you can load resources in subdirectories using only their unqualified name. The default is to disable this so that resources in subdirectories with the same name are still unique. </param>
    </member>
    <member name="M:Mogre.Root.RemoveResourceLocation(System.String)">
      <summary>Removes a resource location from the list. addResourceLocation</summary>
      <param name="name">The name of the resource location as specified in addResourceLocation </param>
    </member>
    <member name="M:Mogre.Root.RemoveResourceLocation(System.String,System.String)">
      <summary>Removes a resource location from the list. addResourceLocation</summary>
      <param name="name">The name of the resource location as specified in addResourceLocation </param>
      <param name="groupName">The name of the resource group to which this location was assigned. </param>
    </member>
    <member name="M:Mogre.Root.CreateFileStream(System.String)">
      <summary>Helper method to assist you in creating writeable file streams. This is a high-level utility method which you can use to find a place to save a file more easily. If the filename you specify is either an absolute or relative filename (ie it includes path separators), then the file will be created in the normal filesystem using that specification. If it doesn't, then the method will look for a writeable resource location via ResourceGroupManager::createResource using the other params provided. </summary>
      <param name="filename">The name of the file to create. If it includes path separators, the filesystem will be accessed direct. If no path separators are present the resource system is used, falling back on the raw filesystem after. </param>
    </member>
    <member name="M:Mogre.Root.CreateFileStream(System.String,System.String)">
      <summary>Helper method to assist you in creating writeable file streams. This is a high-level utility method which you can use to find a place to save a file more easily. If the filename you specify is either an absolute or relative filename (ie it includes path separators), then the file will be created in the normal filesystem using that specification. If it doesn't, then the method will look for a writeable resource location via ResourceGroupManager::createResource using the other params provided. </summary>
      <param name="filename">The name of the file to create. If it includes path separators, the filesystem will be accessed direct. If no path separators are present the resource system is used, falling back on the raw filesystem after. </param>
      <param name="groupName">The name of the group in which to create the file, if the resource system is used </param>
    </member>
    <member name="M:Mogre.Root.CreateFileStream(System.String,System.String,System.Boolean)">
      <summary>Helper method to assist you in creating writeable file streams. This is a high-level utility method which you can use to find a place to save a file more easily. If the filename you specify is either an absolute or relative filename (ie it includes path separators), then the file will be created in the normal filesystem using that specification. If it doesn't, then the method will look for a writeable resource location via ResourceGroupManager::createResource using the other params provided. </summary>
      <param name="filename">The name of the file to create. If it includes path separators, the filesystem will be accessed direct. If no path separators are present the resource system is used, falling back on the raw filesystem after. </param>
      <param name="groupName">The name of the group in which to create the file, if the resource system is used </param>
      <param name="overwrite">If true, an existing file will be overwritten, if false an error will occur if the file already exists </param>
    </member>
    <member name="M:Mogre.Root.CreateFileStream(System.String,System.String,System.Boolean,System.String)">
      <summary>Helper method to assist you in creating writeable file streams. This is a high-level utility method which you can use to find a place to save a file more easily. If the filename you specify is either an absolute or relative filename (ie it includes path separators), then the file will be created in the normal filesystem using that specification. If it doesn't, then the method will look for a writeable resource location via ResourceGroupManager::createResource using the other params provided. </summary>
      <param name="filename">The name of the file to create. If it includes path separators, the filesystem will be accessed direct. If no path separators are present the resource system is used, falling back on the raw filesystem after. </param>
      <param name="groupName">The name of the group in which to create the file, if the resource system is used </param>
      <param name="overwrite">If true, an existing file will be overwritten, if false an error will occur if the file already exists </param>
      <param name="locationPattern">If the resource group contains multiple locations, then usually the file will be created in the first writable location. If you want to be more specific, you can include a location pattern here and only locations which match that pattern (as determined by StringUtil::match) will be considered candidates for creation. </param>
    </member>
    <member name="M:Mogre.Root.OpenFileStream(System.String)">
      <summary>Helper method to assist you in accessing readable file streams. This is a high-level utility method which you can use to find a place to open a file more easily. It checks the resource system first, and if that fails falls back on accessing the file system directly. </summary>
      <param name="filename">The name of the file to open. </param>
    </member>
    <member name="M:Mogre.Root.OpenFileStream(System.String,System.String)">
      <summary>Helper method to assist you in accessing readable file streams. This is a high-level utility method which you can use to find a place to open a file more easily. It checks the resource system first, and if that fails falls back on accessing the file system directly. </summary>
      <param name="filename">The name of the file to open. </param>
      <param name="groupName">The name of the group in which to create the file, if the resource system is used </param>
    </member>
    <member name="M:Mogre.Root.OpenFileStream(System.String,System.String,System.String)">
      <summary>Helper method to assist you in accessing readable file streams. This is a high-level utility method which you can use to find a place to open a file more easily. It checks the resource system first, and if that fails falls back on accessing the file system directly. </summary>
      <param name="filename">The name of the file to open. </param>
      <param name="groupName">The name of the group in which to create the file, if the resource system is used </param>
      <param name="locationPattern">If the resource group contains multiple locations, then usually the file will be created in the first writable location. If you want to be more specific, you can include a location pattern here and only locations which match that pattern (as determined by StringUtil::match) will be considered candidates for creation. </param>
    </member>
    <member name="M:Mogre.Root.ConvertColourValue(Mogre.ColourValue,System.UInt32&amp;)">
      <summary>Generates a packed data version of the passed in ColourValue suitable for use with the current RenderSystem. Since different render systems have different colour data formats (eg RGBA for GL, ARGB for D3D) this method allows you to use 1 method for all. </summary>
      <param name="colour">The colour to convert </param>
      <param name="pDest">Pointer to location to put the result. </param>
    </member>
    <member name="M:Mogre.Root.CreateRenderWindow(System.String,System.UInt32,System.UInt32,System.Boolean)">
      <summary>Creates a new rendering window. This method creates a new rendering window as specified by the paramteters. The rendering system could be responible for only a single window (e.g. in the case of a game), or could be in charge of multiple ones (in the case of a level editor). The option to create the window as a child of another is therefore given. This method will create an appropriate subclass of RenderWindow depending on the API and platform implementation. After creation, this window can be retrieved using getRenderTarget(). nameThe name of the window. Used in other methods later like setRenderTarget and getRenderTarget. widthThe width of the new window. heightThe height of the new window. fullScreenSpecify true to make the window full screen without borders, title bar or menu bar. miscParamsA NameValuePairList describing the other parameters for the new rendering window. Options are case sensitive. Unrecognised parameters will be ignored silently. These values might be platform dependent, but these are present for all platforms unless indicated otherwise: KeyType/ValuesDefaultDescriptionNotestitle Any string RenderTarget name The title of the window that will appear in the title bar colourDepth 16, 32 Desktop depth Colour depth of the resulting rendering window; only applies if fullScreen Win32 Specific  left Positive integers Centred Screen x coordinate from left top Positive integers Centred Screen y coordinate from left depthBuffer true, false true Use depth buffer DirectX9 specific  externalWindowHandle Win32: HWND as integer
 GLX: poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) 0 (none) External window handle, for embedding the OGRE render in an existing window externalGLControl true, false false Let the external window control OpenGL i.e. don't select a pixel format for the window, do not change v-sync and do not swap buffer. When set to true, the calling application is responsible of OpenGL initialization and buffer swapping. It should also create an OpenGL context for its own rendering, Ogre will create one for its use. Then the calling application must also enable Ogre OpenGL context before calling any Ogre function and restore its OpenGL context after these calls. OpenGL specific  externalGLContext Context as Unsigned Long 0 (create own context) Use an externally created GL context OpenGL Specific  parentWindowHandle Win32: HWND as integer
 GLX: poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) 0 (none) Parent window handle, for embedding the OGRE in a child of an external window macAPI String: "cocoa" or "carbon" "carbon" Specifies the type of rendering window on the Mac Platform. macAPICocoaUseNSView bool "true" or "false" "false" On the Mac platform the most diffused method to embed ogre in a custom application is to use the IntefaceBuilder and add to the interface an instance of OgreView. The pointer to this instance is then used as "externalWindowHandle". However, there are cases where you are NOT using the Interface Builder and you get the Cocoa NSView* of an existing interface. For example, this is happens when you want to render into a Java/AWT interface. In short, by setting this flag to "true" the Ogre::Root::createRenderWindow interprets the "externalWindowHandle" as a NSView* instead of an OgreView*. See OgreOSXCocoaView.h/mm.  FSAA Positive integer (usually 0, 2, 4, 8, 16) 0 Full screen antialiasing factor FSAAHint Depends on RenderSystem and hardware. Currently supports:
 "Quality": on systems that have an option to prefer higher AA quality over speed, use it Blank Full screen antialiasing hint displayFrequency Refresh rate in Hertz (e.g. 60, 75, 100) Desktop vsync rate Display frequency rate, for fullscreen mode vsync true, false false Synchronize buffer swaps to monitor vsync, eliminating tearing at the expense of a fixed frame rate vsyncInterval 1, 2, 3, 4 1 If vsync is enabled, the minimum number of vertical blanks that should occur between renders. For example if vsync is enabled, the refresh rate is 60 and this is set to 2, then the frame rate will be locked at 30. border none, fixed, resize resize The type of window border (in windowed mode) outerDimensions true, false false Whether the width/height is expressed as the size of the outer window, rather than the content area useNVPerfHUD true, false false Enable the use of nVidia NVPerfHUD gamma true, false false Enable hardware conversion from linear colour space to gamma colour space on rendering to the window. </summary>
    </member>
    <member name="M:Mogre.Root.CreateRenderWindow(System.String,System.UInt32,System.UInt32,System.Boolean,Mogre.Const_NameValuePairList)">
      <summary>Creates a new rendering window. This method creates a new rendering window as specified by the paramteters. The rendering system could be responible for only a single window (e.g. in the case of a game), or could be in charge of multiple ones (in the case of a level editor). The option to create the window as a child of another is therefore given. This method will create an appropriate subclass of RenderWindow depending on the API and platform implementation. After creation, this window can be retrieved using getRenderTarget(). nameThe name of the window. Used in other methods later like setRenderTarget and getRenderTarget. widthThe width of the new window. heightThe height of the new window. fullScreenSpecify true to make the window full screen without borders, title bar or menu bar. miscParamsA NameValuePairList describing the other parameters for the new rendering window. Options are case sensitive. Unrecognised parameters will be ignored silently. These values might be platform dependent, but these are present for all platforms unless indicated otherwise: KeyType/ValuesDefaultDescriptionNotestitle Any string RenderTarget name The title of the window that will appear in the title bar colourDepth 16, 32 Desktop depth Colour depth of the resulting rendering window; only applies if fullScreen Win32 Specific  left Positive integers Centred Screen x coordinate from left top Positive integers Centred Screen y coordinate from left depthBuffer true, false true Use depth buffer DirectX9 specific  externalWindowHandle Win32: HWND as integer
 GLX: poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) 0 (none) External window handle, for embedding the OGRE render in an existing window externalGLControl true, false false Let the external window control OpenGL i.e. don't select a pixel format for the window, do not change v-sync and do not swap buffer. When set to true, the calling application is responsible of OpenGL initialization and buffer swapping. It should also create an OpenGL context for its own rendering, Ogre will create one for its use. Then the calling application must also enable Ogre OpenGL context before calling any Ogre function and restore its OpenGL context after these calls. OpenGL specific  externalGLContext Context as Unsigned Long 0 (create own context) Use an externally created GL context OpenGL Specific  parentWindowHandle Win32: HWND as integer
 GLX: poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) 0 (none) Parent window handle, for embedding the OGRE in a child of an external window macAPI String: "cocoa" or "carbon" "carbon" Specifies the type of rendering window on the Mac Platform. macAPICocoaUseNSView bool "true" or "false" "false" On the Mac platform the most diffused method to embed ogre in a custom application is to use the IntefaceBuilder and add to the interface an instance of OgreView. The pointer to this instance is then used as "externalWindowHandle". However, there are cases where you are NOT using the Interface Builder and you get the Cocoa NSView* of an existing interface. For example, this is happens when you want to render into a Java/AWT interface. In short, by setting this flag to "true" the Ogre::Root::createRenderWindow interprets the "externalWindowHandle" as a NSView* instead of an OgreView*. See OgreOSXCocoaView.h/mm.  FSAA Positive integer (usually 0, 2, 4, 8, 16) 0 Full screen antialiasing factor FSAAHint Depends on RenderSystem and hardware. Currently supports:
 "Quality": on systems that have an option to prefer higher AA quality over speed, use it Blank Full screen antialiasing hint displayFrequency Refresh rate in Hertz (e.g. 60, 75, 100) Desktop vsync rate Display frequency rate, for fullscreen mode vsync true, false false Synchronize buffer swaps to monitor vsync, eliminating tearing at the expense of a fixed frame rate vsyncInterval 1, 2, 3, 4 1 If vsync is enabled, the minimum number of vertical blanks that should occur between renders. For example if vsync is enabled, the refresh rate is 60 and this is set to 2, then the frame rate will be locked at 30. border none, fixed, resize resize The type of window border (in windowed mode) outerDimensions true, false false Whether the width/height is expressed as the size of the outer window, rather than the content area useNVPerfHUD true, false false Enable the use of nVidia NVPerfHUD gamma true, false false Enable hardware conversion from linear colour space to gamma colour space on rendering to the window. </summary>
    </member>
    <member name="M:Mogre.Root.DetachRenderTarget(System.String)">
      <summary>Destroys a named rendering window. </summary>
    </member>
    <member name="M:Mogre.Root.DetachRenderTarget(Mogre.RenderTarget)">
      <summary>Destroys a rendering window. </summary>
    </member>
    <member name="M:Mogre.Root.GetRenderTarget(System.String)">
      <summary>Retrieves a pointer to the a named render window. </summary>
    </member>
    <member name="M:Mogre.Root.LoadPlugin(System.String)">
      <summary>Manually load a Plugin contained in a DLL / DSO. Plugins embedded in DLLs can be loaded at startup using the plugin configuration file specified when you create Root (default: plugins.cfg). This method allows you to load plugin DLLs directly in code. The DLL in question is expected to implement a dllStartPlugin method which instantiates a Plugin subclass and calls Root::installPlugin. It should also implement dllStopPlugin (see Root::unloadPlugin) </summary>
      <param name="pluginName">Name of the plugin library to load </param>
    </member>
    <member name="M:Mogre.Root.UnloadPlugin(System.String)">
      <summary>Manually unloads a Plugin contained in a DLL / DSO. Plugin DLLs are unloaded at shutdown automatically. This method allows you to unload plugins in code, but make sure their dependencies are decoupled first. This method will call the dllStopPlugin method defined in the DLL, which in turn should call Root::uninstallPlugin. </summary>
      <param name="pluginName">Name of the plugin library to unload </param>
    </member>
    <member name="M:Mogre.Root.InstallPlugin(Mogre.IPlugin)">
      <summary>Install a new plugin. This installs a new extension to OGRE. The plugin itself may be loaded from a DLL / DSO, or it might be statically linked into your own application. Either way, something has to call this method to get it registered and functioning. You should only call this method directly if your plugin is not in a DLL that could otherwise be loaded with loadPlugin, since the DLL function dllStartPlugin should call this method when the DLL is loaded. </summary>
    </member>
    <member name="M:Mogre.Root.UninstallPlugin(Mogre.IPlugin)">
      <summary>Uninstall an existing plugin. This uninstalls an extension to OGRE. Plugins are automatically uninstalled at shutdown but this lets you remove them early. If the plugin was loaded from a DLL / DSO you should call unloadPlugin which should result in this method getting called anyway (if the DLL is well behaved). </summary>
    </member>
    <member name="M:Mogre.Root.GetInstalledPlugins">
      <summary>Gets a read-only list of the currently installed plugins. </summary>
    </member>
    <member name="M:Mogre.Root._fireFrameStarted">
      <summary>Method for raising frame started events. This method is only for internal use when you use OGRE's inbuilt rendering loop (Root::startRendering). However, if you run your own rendering loop then you should call this method to ensure that FrameListener objects are notified of frame events; processes like texture animation and particle systems rely on this. Calling this method also increments the frame number, which is important for keeping some elements of the engine up to date. This method takes an event object as a parameter, so you can specify the times yourself. If you are happy for OGRE to automatically calculate the frame time for you, then call the other version of this method with no parameters. False if one or more frame listeners elected that the rendering loop should be terminated, true otherwise. </summary>
    </member>
    <member name="M:Mogre.Root._fireFrameStarted(Mogre.FrameEvent)">
      <summary>Method for raising frame started events. This method is only for internal use when you use OGRE's inbuilt rendering loop (Root::startRendering). However, if you run your own rendering loop then you should call this method to ensure that FrameListener objects are notified of frame events; processes like texture animation and particle systems rely on this. Calling this method also increments the frame number, which is important for keeping some elements of the engine up to date. This method takes an event object as a parameter, so you can specify the times yourself. If you are happy for OGRE to automatically calculate the frame time for you, then call the other version of this method with no parameters. False if one or more frame listeners elected that the rendering loop should be terminated, true otherwise. </summary>
      <param name="evt">Event object which includes all the timing information which you have calculated for yourself </param>
    </member>
    <member name="M:Mogre.Root._fireFrameRenderingQueued">
      <summary>Method for raising frame rendering queued events. This method is only for internal use when you use OGRE's inbuilt rendering loop (Root::startRendering). However, if you run your own rendering loop then you should call this method too, to ensure that all state is updated correctly. You should call it after the windows have been updated but before the buffers are swapped, or if you are not separating the update and buffer swap, then after the update just before _fireFrameEnded. </summary>
    </member>
    <member name="M:Mogre.Root._fireFrameRenderingQueued(Mogre.FrameEvent)">
      <summary>Method for raising frame rendering queued events. This method is only for internal use when you use OGRE's inbuilt rendering loop (Root::startRendering). However, if you run your own rendering loop then you should call this method too, to ensure that all state is updated correctly. You should call it after the windows have been updated but before the buffers are swapped, or if you are not separating the update and buffer swap, then after the update just before _fireFrameEnded. </summary>
    </member>
    <member name="M:Mogre.Root._fireFrameEnded">
      <summary>Method for raising frame ended events. This method is only for internal use when you use OGRE's inbuilt rendering loop (Root::startRendering). However, if you run your own rendering loop then you should call this method to ensure that FrameListener objects are notified of frame events; processes like texture animation and particle systems rely on this. This method takes an event object as a parameter, so you can specify the times yourself. If you are happy for OGRE to automatically calculate the frame time for you, then call the other version of this method with no parameters. False if one or more frame listeners elected that the rendering loop should be terminated, true otherwise. </summary>
    </member>
    <member name="M:Mogre.Root._fireFrameEnded(Mogre.FrameEvent)">
      <summary>Method for raising frame ended events. This method is only for internal use when you use OGRE's inbuilt rendering loop (Root::startRendering). However, if you run your own rendering loop then you should call this method to ensure that FrameListener objects are notified of frame events; processes like texture animation and particle systems rely on this. This method takes an event object as a parameter, so you can specify the times yourself. If you are happy for OGRE to automatically calculate the frame time for you, then call the other version of this method with no parameters. False if one or more frame listeners elected that the rendering loop should be terminated, true otherwise. </summary>
      <param name="evt">Event object which includes all the timing information which you have calculated for yourself </param>
    </member>
    <member name="M:Mogre.Root._getCurrentSceneManager">
      <summary>Returns the scene manager currently being used to render a frame. This is only intended for internal use; it is only valid during the rendering of a frame. </summary>
    </member>
    <member name="M:Mogre.Root._pushCurrentSceneManager(Mogre.SceneManager)">
      <summary>Pushes the scene manager currently being used to render. This is only intended for internal use. </summary>
    </member>
    <member name="M:Mogre.Root._popCurrentSceneManager(Mogre.SceneManager)">
      <summary>Pops the scene manager currently being used to render. This is only intended for internal use. </summary>
    </member>
    <member name="M:Mogre.Root._updateAllRenderTargets(Mogre.FrameEvent)">
      <summary>Internal method used for updating all RenderTarget objects (windows, renderable textures etc) which are set to auto-update, with a custom time passed to the frameRenderingQueued events. You don't need to use this method if you're using Ogre's own internal rendering loop (Root::startRendering). If you're running your own loop you may wish to call it to update all the render targets which are set to auto update (RenderTarget::setAutoUpdated). You can also update individual RenderTarget instances using their own update() method. false if a FrameListener indicated it wishes to exit the render loop </summary>
    </member>
    <member name="M:Mogre.Root._updateAllRenderTargets">
      <summary>Internal method used for updating all RenderTarget objects (windows, renderable textures etc) which are set to auto-update. You don't need to use this method if you're using Ogre's own internal rendering loop (Root::startRendering). If you're running your own loop you may wish to call it to update all the render targets which are set to auto update (RenderTarget::setAutoUpdated). You can also update individual RenderTarget instances using their own update() method. false if a FrameListener indicated it wishes to exit the render loop </summary>
    </member>
    <member name="M:Mogre.Root.CreateRenderQueueInvocationSequence(System.String)">
      <summary>Create a new RenderQueueInvocationSequence, useful for linking to Viewport instances to perform custom rendering. </summary>
      <param name="name">The name to give the new sequence </param>
    </member>
    <member name="M:Mogre.Root.GetRenderQueueInvocationSequence(System.String)">
      <summary>Get a RenderQueueInvocationSequence. </summary>
      <param name="name">The name to identify the sequence </param>
    </member>
    <member name="M:Mogre.Root.DestroyRenderQueueInvocationSequence(System.String)">
      <summary>Destroy a RenderQueueInvocationSequence. You must ensure that no Viewports are using this sequence. </summary>
      <param name="name">The name to identify the sequence </param>
    </member>
    <member name="M:Mogre.Root.DestroyAllRenderQueueInvocationSequences">
      <summary>Destroy all RenderQueueInvocationSequences. You must ensure that no Viewports are using custom sequences. </summary>
    </member>
    <member name="M:Mogre.Root.ClearEventTimes">
      <summary>Clears the history of all event times. OGRE stores a history of the last few event times in order to smooth out any inaccuracies and temporary fluctuations. However, if you pause or don't render for a little while this can cause a lurch, so if you're resuming rendering after a break, call this method to reset the stored times </summary>
    </member>
    <member name="M:Mogre.Root.AddMovableObjectFactory(Mogre.MovableObjectFactory)">
      <summary>Register a new MovableObjectFactory which will create new MovableObject instances of a particular type, as identified by the getType() method. Plugin creators can create subclasses of MovableObjectFactory which construct custom subclasses of MovableObject for insertion in the scene. This is the primary way that plugins can make custom objects available. </summary>
      <param name="fact">Pointer to the factory instance </param>
    </member>
    <member name="M:Mogre.Root.AddMovableObjectFactory(Mogre.MovableObjectFactory,System.Boolean)">
      <summary>Register a new MovableObjectFactory which will create new MovableObject instances of a particular type, as identified by the getType() method. Plugin creators can create subclasses of MovableObjectFactory which construct custom subclasses of MovableObject for insertion in the scene. This is the primary way that plugins can make custom objects available. </summary>
      <param name="fact">Pointer to the factory instance </param>
      <param name="overrideExisting">Set this to true to override any existing factories which are registered for the same type. You should only change this if you are very sure you know what you're doing. </param>
    </member>
    <member name="M:Mogre.Root.RemoveMovableObjectFactory(Mogre.MovableObjectFactory)">
      <summary>Removes a previously registered MovableObjectFactory. All instances of objects created by this factory will be destroyed before removing the factory (by calling back the factories 'destroyInstance' method). The plugin writer is responsible for actually destroying the factory. </summary>
    </member>
    <member name="M:Mogre.Root.HasMovableObjectFactory(System.String)">
      <summary>Checks whether a factory is registered for a given MovableObject type. </summary>
    </member>
    <member name="M:Mogre.Root.GetMovableObjectFactory(System.String)">
      <summary>Get a MovableObjectFactory for the given type. </summary>
    </member>
    <member name="M:Mogre.Root._allocateNextMovableObjectTypeFlag">
      <summary>Allocate the next MovableObject type flag. This is done automatically if MovableObjectFactory::requestTypeFlags returns true; don't call this manually unless you're sure you need to. </summary>
    </member>
    <member name="M:Mogre.Root.#ctor">
      <summary>Constructor </summary>
    </member>
    <member name="M:Mogre.Root.#ctor(System.String)">
      <summary>Constructor </summary>
      <param name="pluginFileName">The file that contains plugins information. Defaults to "plugins.cfg", may be left blank to ignore. </param>
    </member>
    <member name="M:Mogre.Root.#ctor(System.String,System.String)">
      <summary>Constructor </summary>
      <param name="pluginFileName">The file that contains plugins information. Defaults to "plugins.cfg", may be left blank to ignore. </param>
      <param name="configFileName">The file that contains the configuration to be loaded. Defaults to "ogre.cfg", may be left blank to load nothing. </param>
    </member>
    <member name="M:Mogre.Root.#ctor(System.String,System.String,System.String)">
      <summary>Constructor </summary>
      <param name="pluginFileName">The file that contains plugins information. Defaults to "plugins.cfg", may be left blank to ignore. </param>
      <param name="configFileName">The file that contains the configuration to be loaded. Defaults to "ogre.cfg", may be left blank to load nothing. </param>
      <param name="logFileName">The logfile to create, defaults to Ogre.log, may be left blank if you've already set up LogManager &amp; Log yourself </param>
    </member>
    <member name="P:Mogre.Root.Timer">
      <summary>Gets a pointer to the central timer used for all OGRE timings </summary>
    </member>
    <member name="P:Mogre.Root.RemoveRenderQueueStructuresOnClear">
      <summary>Sets/Get whether the entire render queue structure should be emptied on clearing, or whether just the objects themselves should be cleared. </summary>
    </member>
    <member name="P:Mogre.Root.NextFrameNumber">
      <summary>Gets the number of the next frame to be rendered. Note that this is 'next frame' rather than 'current frame' because it indicates the frame number that current changes made to the scene will take effect. It is incremented after all rendering commands for the current frame have been queued, thus reflecting that if you start performing changes then, you will actually see them in the next frame. </summary>
    </member>
    <member name="P:Mogre.Root.IsInitialised">
      <summary>Returns whether the system is initialised or not. </summary>
    </member>
    <member name="P:Mogre.Root.FrameSmoothingPeriod">
      <summary>Sets/Gets the period over which OGRE smooths out fluctuations in frame times. </summary>
    </member>
    <member name="P:Mogre.Root.DisplayMonitorCount">
      <summary>Gets the number of display monitors. </summary>
    </member>
    <member name="P:Mogre.Root.AutoCreatedWindow">
      <summary>Retrieves a pointer to the window that was created automatically When Root is initialised an optional window is created. This method retreives a pointer to that window. returns a null pointer when Root has not been initialised with the option of creating a window. </summary>
    </member>
    <member name="P:Mogre.Root.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.RotationalSpline">
      <summary>This class interpolates orientations (rotations) along a spline using derivatives of quaternions. Like the SimpleSpline class, this class is about interpolating values smoothly over a spline. Whilst SimpleSpline deals with positions (the normal sense we think about splines), this class interpolates orientations. The theory is identical, except we're now in 4-dimensional space instead of 3. In positional splines, we use the points and tangents on those points to generate control points for the spline. In this case, we use quaternions and derivatives of the quaternions (i.e. the rate and direction of change at each point). This is the same as SimpleSpline since a tangent is a derivative of a position. We effectively generate an extra quaternion in between each actual quaternion which when take with the original quaternion forms the 'tangent' of that quaternion. </summary>
    </member>
    <member name="M:Mogre.RotationalSpline.AddPoint(Mogre.Quaternion)">
      <summary>Adds a control point to the end of the spline. </summary>
    </member>
    <member name="M:Mogre.RotationalSpline.GetPoint(System.UInt16)">
      <summary>Gets the detail of one of the control points of the spline. </summary>
    </member>
    <member name="M:Mogre.RotationalSpline.Clear">
      <summary>Clears all the points in the spline. </summary>
    </member>
    <member name="M:Mogre.RotationalSpline.UpdatePoint(System.UInt16,Mogre.Quaternion)">
      <summary>Updates a single point in the spline. This point must already exist in the spline. </summary>
    </member>
    <member name="M:Mogre.RotationalSpline.Interpolate(System.UInt32,System.Single)">
      <summary>Interpolates a single segment of the spline given a parametric value. </summary>
      <param name="fromIndex">The point index to treat as t=0. fromIndex + 1 is deemed to be t=1 </param>
      <param name="t">Parametric value </param>
    </member>
    <member name="M:Mogre.RotationalSpline.Interpolate(System.UInt32,System.Single,System.Boolean)">
      <summary>Interpolates a single segment of the spline given a parametric value. </summary>
      <param name="fromIndex">The point index to treat as t=0. fromIndex + 1 is deemed to be t=1 </param>
      <param name="t">Parametric value </param>
      <param name="useShortestPath">Defines if rotation should take the shortest possible path </param>
    </member>
    <member name="M:Mogre.RotationalSpline.Interpolate(System.Single)">
      <summary>Returns an interpolated point based on a parametric value over the whole series. Given a t value between 0 and 1 representing the parametric distance along the whole length of the spline, this method returns an interpolated point. </summary>
      <param name="t">Parametric value. </param>
    </member>
    <member name="M:Mogre.RotationalSpline.Interpolate(System.Single,System.Boolean)">
      <summary>Returns an interpolated point based on a parametric value over the whole series. Given a t value between 0 and 1 representing the parametric distance along the whole length of the spline, this method returns an interpolated point. </summary>
      <param name="t">Parametric value. </param>
      <param name="useShortestPath">Defines if rotation should take the shortest possible path </param>
    </member>
    <member name="M:Mogre.RotationalSpline.SetAutoCalculate(System.Boolean)">
      <summary>Tells the spline whether it should automatically calculate tangents on demand as points are added. The spline calculates tangents at each point automatically based on the input points. Normally it does this every time a point changes. However, if you have a lot of points to add in one go, you probably don't want to incur this overhead and would prefer to defer the calculation until you are finished setting all the points. You can do this by calling this method with a parameter of 'false'. Just remember to manually call the recalcTangents method when you are done. </summary>
      <param name="autoCalc">If true, tangents are calculated for you whenever a point changes. If false, you must call reclacTangents to recalculate them when it best suits. </param>
    </member>
    <member name="M:Mogre.RotationalSpline.RecalcTangents">
      <summary>Recalculates the tangents associated with this spline. If you tell the spline not to update on demand by calling setAutoCalculate(false) then you must call this after completing your updates to the spline points. </summary>
    </member>
    <member name="P:Mogre.RotationalSpline.NumPoints">
      <summary>Gets the number of control points in the spline. </summary>
    </member>
    <member name="T:Mogre.StaticGeometry">
      <summary>Pre-transforms and batches up meshes for efficient use as static geometry in a scene. Modern graphics cards (GPUs) prefer to receive geometry in large batches. It is orders of magnitude faster to render 10 batches of 10,000 triangles than it is to render 10,000 batches of 10 triangles, even though both result in the same number of on-screen triangles. Therefore it is important when you are rendering a lot of geometry to batch things up into as few rendering calls as possible. This class allows you to build a batched object from a series of entities in order to benefit from this behaviour. Batching has implications of it's own though: Batched geometry cannot be subdivided; that means that the whole group will be displayed, or none of it will. This obivously has culling issues. A single world transform must apply to the entire batch. Therefore once you have batched things, you can't move them around relative to each other. That's why this class is most useful when dealing with static geometry (hence the name). In addition, geometry is effectively duplicated, so if you add 3 entities based on the same mesh in different positions, they will use 3 times the geometry space than the movable version (which re-uses the same geometry). So you trade memory and flexibility of movement for pure speed when using this class. A single material must apply for each batch. In fact this class allows you to use multiple materials, but you should be aware that internally this means that there is one batch per material. Therefore you won't gain as much benefit from the batching if you use many different materials; try to keep the number down. In order to retain some sort of culling, this class will batch up meshes in localised regions. The size and shape of these blocks is controlled by the SceneManager which constructs this object, since it makes sense to batch things up in the most appropriate way given the existing partitioning of the scene. The LOD settings of both the Mesh and the Materials used in constructing this static geometry will be respected. This means that if you use meshes/materials which have LOD, batches in the distance will have a lower polygon count or material detail to those in the foreground. Since each mesh might have different LOD distances, during build the furthest distance at each LOD level from all meshes in that region is used. This means all the LOD levels change at the same time, but at the furthest distance of any of them (so quality is not degraded). Be aware that using Mesh LOD in this class will further increase the memory required. Only generated LOD is supported for meshes. There are 2 ways you can add geometry to this class; you can add Entity objects directly with predetermined positions, scales and orientations, or you can add an entire SceneNode and it's subtree, including all the objects attached to it. Once you've added everthing you need to, you have to call build() the fix the geometry in place. This class is not a replacement for world geometry (SceneManager::setWorldGeometry). The single most efficient way to render large amounts of static geometry is to use a SceneManager which is specialised for dealing with that particular world structure. However, this class does provide you with a good 'halfway house' between generalised movable geometry (Entity) which works with all SceneManagers but isn't efficient when using very large numbers, and highly specialised world geometry which is extremely fast but not generic and typically requires custom world editors. You should not construct instances of this class directly; instead, cal SceneManager::createStaticGeometry, which gives the SceneManager the option of providing you with a specialised version of this class if it wishes, and also handles the memory management for you like other classes. Warning: this class only works with indexed triangle lists at the moment, do not pass it triangle strips, fans or lines / points, or unindexed geometry. </summary>
    </member>
    <member name="M:Mogre.StaticGeometry.AddEntity(Mogre.Entity,Mogre.Vector3)">
      <summary>Adds an Entity to the static geometry. This method takes an existing Entity and adds its details to the list of elements to include when building. Note that the Entity itself is not copied or referenced in this method; an Entity is passed simply so that you can change the materials of attached SubEntity objects if you want. You can add the same Entity instance multiple times with different material settings completely safely, and destroy the Entity before destroying this StaticGeometry if you like. The Entity passed in is simply used as a definition. Must be called before 'build'. </summary>
      <param name="ent">The Entity to use as a definition (the Mesh and Materials referenced will be recorded for the build call). </param>
      <param name="position">The world position at which to add this Entity</param>
    </member>
    <member name="M:Mogre.StaticGeometry.AddEntity(Mogre.Entity,Mogre.Vector3,Mogre.Quaternion)">
      <summary>Adds an Entity to the static geometry. This method takes an existing Entity and adds its details to the list of elements to include when building. Note that the Entity itself is not copied or referenced in this method; an Entity is passed simply so that you can change the materials of attached SubEntity objects if you want. You can add the same Entity instance multiple times with different material settings completely safely, and destroy the Entity before destroying this StaticGeometry if you like. The Entity passed in is simply used as a definition. Must be called before 'build'. </summary>
      <param name="ent">The Entity to use as a definition (the Mesh and Materials referenced will be recorded for the build call). </param>
      <param name="position">The world position at which to add this Entity</param>
      <param name="orientation">The world orientation at which to add this Entity</param>
    </member>
    <member name="M:Mogre.StaticGeometry.AddEntity(Mogre.Entity,Mogre.Vector3,Mogre.Quaternion,Mogre.Vector3)">
      <summary>Adds an Entity to the static geometry. This method takes an existing Entity and adds its details to the list of elements to include when building. Note that the Entity itself is not copied or referenced in this method; an Entity is passed simply so that you can change the materials of attached SubEntity objects if you want. You can add the same Entity instance multiple times with different material settings completely safely, and destroy the Entity before destroying this StaticGeometry if you like. The Entity passed in is simply used as a definition. Must be called before 'build'. </summary>
      <param name="ent">The Entity to use as a definition (the Mesh and Materials referenced will be recorded for the build call). </param>
      <param name="position">The world position at which to add this Entity</param>
      <param name="orientation">The world orientation at which to add this Entity</param>
      <param name="scale">The scale at which to add this entity </param>
    </member>
    <member name="M:Mogre.StaticGeometry.AddSceneNode(Mogre.SceneNode)">
      <summary>Adds all the Entity objects attached to a SceneNode and all it's children to the static geometry. This method performs just like addEntity, except it adds all the entities attached to an entire sub-tree to the geometry. The position / orientation / scale parameters are taken from the node structure instead of being specified manually. The SceneNode you pass in will not be automatically detached from it's parent, so if you have this node already attached to the scene graph, you will need to remove it if you wish to avoid the overhead of rendering both the original objects and their new static versions! We don't do this for you incase you are preparing this in advance and so don't want the originals detached yet. Must be called before 'build'. </summary>
      <param name="node">Pointer to the node to use to provide a set of Entity templates </param>
    </member>
    <member name="M:Mogre.StaticGeometry.Build">
      <summary>Build the geometry. Based on all the entities which have been added, and the batching options which have been set, this method constructs the batched geometry structures required. The batches are added to the scene and will be rendered unless you specifically hide them. Once you have called this method, you can no longer add any more entities. </summary>
    </member>
    <member name="M:Mogre.StaticGeometry.Destroy">
      <summary>Destroys all the built geometry state (reverse of build). You can call build() again after this and it will pick up all the same entities / nodes you queued last time. </summary>
    </member>
    <member name="M:Mogre.StaticGeometry.Reset">
      <summary>Clears any of the entities / nodes added to this geometry and destroys anything which has already been built. </summary>
    </member>
    <member name="M:Mogre.StaticGeometry.SetVisible(System.Boolean)">
      <summary>Hides or shows all the batches. </summary>
    </member>
    <member name="M:Mogre.StaticGeometry.GetRegionIterator">
      <summary>Get an iterator over the regions in this geometry. </summary>
    </member>
    <member name="M:Mogre.StaticGeometry.Dump(System.String)">
      <summary>Dump the contents of this StaticGeometry to a file for diagnostic purposes. </summary>
    </member>
    <member name="M:Mogre.StaticGeometry.#ctor(Mogre.SceneManager,System.String)">
      <summary>Constructor; do not use directly (. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.VisibilityFlags">
      <summary>Sets/Returns the visibility flags of the regions. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.SquaredRenderingDistance">
      <summary>Gets the squared distance at which batches are no longer rendered. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.RenderQueueGroup">
      <summary>Sets/Gets the queue group for this entity, see setRenderQueueGroup for full details. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.RenderingDistance">
      <summary>Sets/Gets the distance at which batches are no longer rendered. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.RegionDimensions">
      <summary>Sets/Gets the size of a single batch of geometry. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.Origin">
      <summary>Sets/Gets the origin of this geometry. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.Name">
      <summary>Get the name of this object. </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.IsVisible">
      <summary>Are the batches visible? </summary>
    </member>
    <member name="P:Mogre.StaticGeometry.CastShadows">
      <summary>Sets/Will the geometry from this object cast shadows? </summary>
    </member>
    <member name="T:Mogre.FocusedShadowCameraSetup">
      <summary>Implements the uniform shadow mapping algorithm in focused mode. Differs from the default shadow mapping projection in that it focuses the shadow map on the visible areas of the scene. This results in better shadow map texel usage, at the expense of some 'swimming' of the shadow texture on receivers as the basis is constantly being reevaluated. Original implementation by Matthias Fink &lt;matthias.fink@web.de&gt;, 2006. </summary>
    </member>
    <member name="M:Mogre.FocusedShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a uniform shadow camera with a focused view. </summary>
    </member>
    <member name="M:Mogre.FocusedShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a uniform shadow camera with a focused view. </summary>
    </member>
    <member name="M:Mogre.FocusedShadowCameraSetup.#ctor">
      <summary>Default constructor. Temporary frustum and camera set up here. </summary>
    </member>
    <member name="T:Mogre.LiSPSMShadowCameraSetup">
      <summary>Implements the Light Space Perspective Shadow Mapping Algorithm. Implements the LiSPSM algorithm for an advanced shadow map generation. LiSPSM was developed by Michael Wimmer, Daniel Scherzer and Werner Purgathofer of the TU Wien. The algorithm was presented on the Eurographics Symposium on Rendering 2004. Shadow mapping was introduced by Williams in 1978. First a depth image is rendered from the light's view and compared in a second pass with depth values of the normal camera view. In case the depth camera's depth value is greater than the depth seen by the light the fragment lies in the shadow. The concept has a major draw back named perspective aliasing. The shadow map distri- butes the samples uniformly meaning the position of the viewer is ignored. For the viewer however the perspective projection affects near objects to be displayed bigger than further away objects. The same thing happens with the shadow map texels: Near shadows appear very coarse and far away shadows are perfectly sampled. In 2002 Stamminger et al. presented an algorithm called Perspective Shadow Maps (PSM). PSM battles the perspective aliasing by distributing 50% of the shadow map texels for objects in the range of &lt;near clipping="" plane&gt;=""&gt; to &lt;near clipping plane * 2&gt; which inverts the problem: The shadows near the viewer are perfectly sampled, however far away shadow may contain aliasing artefacts. A near clipping plane may be a problem. But this is not the only one. In the post-perspective space the light sources are non-intuitively mapped: Directional lights may become point light and point lights may become directional lights. Also light sinks (opposite of a light source) may appear. Another problem are shadow casters located behind the viewer. In post-projective space objects behind the viewer are mapped in front of him with a flipped up-vector. LiSPSM battles the light source problem of the post-projective space by rearranging the light space before transformation in such a way that no special cases appear. This is done by converting point/spot lights into directional lights. The light space is arranged in such a way that the light direction equals the inverse UNIT_Y. In this combination the directional light will neither change its type nor its direction. Furthermore all visible objects and shadow casters affecting the user's visible area lie in front of the shadow camera: After building the intersection body that contains all these objects (body intersection building was introduced with PSM; have a look at the description for the method "calculateB" for further info) a frustum around the body's light space bounding box is created. A parameter (called 'n') automatically adjusts the shadow map sample distribution by specifying the frustum's view point - near plane which affects the perspective warp. In case the distance is small the perspecive warp will be strong. As a consequence near objects will gain quality. However there are still problems. PSM as well as LiSPSM only devote to minimize perspective aliasing. Projection aliasing is still a problem, also 'swimming artefacts' still occur. The LiSPSM quality distribution is very good but not the best available: Some sources say logarithmic shadow mapping is the non plus ultra, however others reject this thought. There is a research project on logarithmic shadow maps. The web page url is http://gamma.cs.unc.edu/logsm/. However there is no techical report available yet (Oct 23rd, 2006). More information can be found on the webpage of the TU Wien: http://www.cg.tuwien.ac.at/research/vr/lispsm/Original implementation by Matthias Fink &lt;matthias.fink@web.de&gt;, 2006. </summary>
    </member>
    <member name="M:Mogre.LiSPSMShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a LiSPSM shadow camera. Builds and returns a LiSPSM shadow camera. More information can be found on the webpage of the TU Wien: http://www.cg.tuwien.ac.at/research/vr/lispsm/</summary>
    </member>
    <member name="M:Mogre.LiSPSMShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a LiSPSM shadow camera. Builds and returns a LiSPSM shadow camera. More information can be found on the webpage of the TU Wien: http://www.cg.tuwien.ac.at/research/vr/lispsm/</summary>
    </member>
    <member name="M:Mogre.LiSPSMShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a LiSPSM shadow camera. Builds and returns a LiSPSM shadow camera. More information can be found on the webpage of the TU Wien: http://www.cg.tuwien.ac.at/research/vr/lispsm/</summary>
    </member>
    <member name="M:Mogre.LiSPSMShadowCameraSetup.#ctor">
      <summary>Default constructor. Nothing done here. </summary>
    </member>
    <member name="P:Mogre.LiSPSMShadowCameraSetup.UseSimpleOptimalAdjust">
      <summary>Sets/Gets whether or not to use a slightly simpler version of the camera near point derivation (default is true) </summary>
    </member>
    <member name="P:Mogre.LiSPSMShadowCameraSetup.OptimalAdjustFactor">
      <summary>Sets/Get the parameter n used to produce optimal shadows. setOptimalAdjustFactor</summary>
    </member>
    <member name="P:Mogre.LiSPSMShadowCameraSetup.CameraLightDirectionThreshold">
      <summary>Sets/Sets the threshold between the camera and the light direction below which the LiSPSM projection is 'flattened', since coincident light and camera projections cause problems with the perspective skew. </summary>
    </member>
    <member name="T:Mogre.PlaneOptimalShadowCameraSetup">
      <summary>Implements the plane optimal shadow camera algorithm. Given a plane of interest, it is possible to set up the shadow camera matrix such that the mapping between screen and shadow map is the identity (when restricted to pixels that view the plane of interest). Therefore, if the shadow map resolution matches the screen space resolution (of the seen planar receiver), we can get pixel perfect shadowing on the plane. Off the plane, the shadowing is not guaranteed to be perfect and will likely exhibit the usual sampling artifacts associated with shadow mapping. Important: this routine requires double-precision calculations. When you are running under Direct3D, you must ensure that you set the floating point mode to 'Consistent' rather than 'Fastest' to ensure this precision. This does allegedly come with some performance cost but when measuring it appears to be negligible in modern systems for normal usage. Second important note: this projection also only works for lights with a finite position. Therefore you cannot use it for directional lights at this time. </summary>
    </member>
    <member name="M:Mogre.PlaneOptimalShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns shadow camera configured to get 1-1 homography between screen and shadow map when restricted to plane. </summary>
    </member>
    <member name="M:Mogre.PlaneOptimalShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns shadow camera configured to get 1-1 homography between screen and shadow map when restricted to plane. </summary>
    </member>
    <member name="M:Mogre.PlaneOptimalShadowCameraSetup.#ctor(Mogre.MovablePlane)">
      <summary>Constructor -- requires a plane of interest. </summary>
    </member>
    <member name="T:Mogre.PSSMShadowCameraSetup">
      <summary>Parallel Split Shadow Map (PSSM) shadow camera setup. A PSSM shadow system uses multiple shadow maps per light and maps each texture into a region of space, progressing away from the camera. As such it is most appropriate for directional light setups. This particular version also uses LiSPSM projection for each split to maximise the quality. Because PSSM uses multiple shadow maps per light, you will need to increase the number of shadow textures available (via SceneManager) to match the number of shadow maps required (default is 3 per light). </summary>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.SetOptimalAdjustFactor(System.Int32,System.Single)">
      <summary>Set the LiSPSM optimal adjust factor for a given split (call after configuring splits). </summary>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.CalculateSplitPoints(System.UInt32,System.Single,System.Single)">
      <summary>Calculate a new splitting scheme. </summary>
      <param name="splitCount">The number of splits to use </param>
      <param name="nearDist">The near plane to use for the first split </param>
      <param name="farDist">The far plane to use for the last split </param>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.CalculateSplitPoints(System.UInt32,System.Single,System.Single,System.Single)">
      <summary>Calculate a new splitting scheme. </summary>
      <param name="splitCount">The number of splits to use </param>
      <param name="nearDist">The near plane to use for the first split </param>
      <param name="farDist">The far plane to use for the last split </param>
      <param name="lambda">Factor to use to reduce the split size </param>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.SetSplitPoints(Mogre.PSSMShadowCameraSetup+Const_SplitPointList)">
      <summary>Manually configure a new splitting scheme. </summary>
      <param name="newSplitPoints">A list which is splitCount + 1 entries long, containing the split points. The first value is the near point, the last value is the far point, and each value in between is both a far point of the previous split, and a near point for the next one. </param>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a LiSPSM shadow camera with PSSM splits base on iteration. </summary>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.GetSplitPoints">
      <summary>Returns the calculated split points. </summary>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a LiSPSM shadow camera with PSSM splits base on iteration. </summary>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a LiSPSM shadow camera with PSSM splits base on iteration. </summary>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.GetShadowCamera(Mogre.SceneManager,Mogre.Camera,Mogre.Viewport,Mogre.Light,Mogre.Camera,System.UInt32)">
      <summary>Returns a LiSPSM shadow camera with PSSM splits base on iteration. </summary>
    </member>
    <member name="M:Mogre.PSSMShadowCameraSetup.#ctor">
      <summary>Constructor, defaults to 3 splits. </summary>
    </member>
    <member name="P:Mogre.PSSMShadowCameraSetup.SplitPadding">
      <summary>Sets/Get the padding factor to apply to the near &amp; far distances when matching up splits to one another, to avoid 'cracks'. </summary>
    </member>
    <member name="P:Mogre.PSSMShadowCameraSetup.SplitCount">
      <summary>Get the number of splits. </summary>
    </member>
    <member name="P:Mogre.PSSMShadowCameraSetup.OptimalAdjustFactor">
      <summary>Returns the optimal adjust factor for a given split. </summary>
    </member>
    <member name="T:Mogre.SimpleSpline">
      <summary>A very simple spline class which implements the Catmull-Rom class of splines. Splines are bendy lines. You define a series of points, and the spline forms a smoother line between the points to eliminate the sharp angles. Catmull-Rom splines are a specialisation of the general Hermite spline. With a Hermite spline, you define the start and end point of the line, and 2 tangents, one at the start of the line and one at the end. The Catmull-Rom spline simplifies this by just asking you to define a series of points, and the tangents are created for you. </summary>
    </member>
    <member name="M:Mogre.SimpleSpline.AddPoint(Mogre.Vector3)">
      <summary>Adds a control point to the end of the spline. </summary>
    </member>
    <member name="M:Mogre.SimpleSpline.GetPoint(System.UInt16)">
      <summary>Gets the detail of one of the control points of the spline. </summary>
    </member>
    <member name="M:Mogre.SimpleSpline.Clear">
      <summary>Clears all the points in the spline. </summary>
    </member>
    <member name="M:Mogre.SimpleSpline.UpdatePoint(System.UInt16,Mogre.Vector3)">
      <summary>Updates a single point in the spline. This point must already exist in the spline. </summary>
    </member>
    <member name="M:Mogre.SimpleSpline.Interpolate(System.UInt32,System.Single)">
      <summary>Interpolates a single segment of the spline given a parametric value. </summary>
      <param name="fromIndex">The point index to treat as t=0. fromIndex + 1 is deemed to be t=1 </param>
      <param name="t">Parametric value </param>
    </member>
    <member name="M:Mogre.SimpleSpline.Interpolate(System.Single)">
      <summary>Returns an interpolated point based on a parametric value over the whole series. Given a t value between 0 and 1 representing the parametric distance along the whole length of the spline, this method returns an interpolated point. </summary>
      <param name="t">Parametric value. </param>
    </member>
    <member name="M:Mogre.SimpleSpline.SetAutoCalculate(System.Boolean)">
      <summary>Tells the spline whether it should automatically calculate tangents on demand as points are added. The spline calculates tangents at each point automatically based on the input points. Normally it does this every time a point changes. However, if you have a lot of points to add in one go, you probably don't want to incur this overhead and would prefer to defer the calculation until you are finished setting all the points. You can do this by calling this method with a parameter of 'false'. Just remember to manually call the recalcTangents method when you are done. </summary>
      <param name="autoCalc">If true, tangents are calculated for you whenever a point changes. If false, you must call reclacTangents to recalculate them when it best suits. </param>
    </member>
    <member name="M:Mogre.SimpleSpline.RecalcTangents">
      <summary>Recalculates the tangents associated with this spline. If you tell the spline not to update on demand by calling setAutoCalculate(false) then you must call this after completing your updates to the spline points. </summary>
    </member>
    <member name="P:Mogre.SimpleSpline.NumPoints">
      <summary>Gets the number of control points in the spline. </summary>
    </member>
    <member name="T:Mogre.SkeletonManager">
      <summary>Handles the management of skeleton resources. This class deals with the runtime management of skeleton data; like other resource managers it handles the creation of resources (in this case skeleton data), working within a fixed memory budget. </summary>
    </member>
    <member name="M:Mogre.SkeletonManager.#ctor">
      <summary>Constructor. </summary>
    </member>
    <member name="P:Mogre.SkeletonManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.SkeletonSerializer">
      <summary>Class for serialising skeleton data to/from an OGRE .skeleton file. This class allows exporters to write OGRE .skeleton files easily, and allows the OGRE engine to import .skeleton files into instantiated OGRE Skeleton objects. Note that a .skeleton file includes not only the Skeleton, but also definitions of any Animations it uses. To export a Skeleton:Create a Skeleton object and populate it using it's methods. Call the exportSkeleton method </summary>
    </member>
    <member name="M:Mogre.SkeletonSerializer.ExportSkeleton(Mogre.Skeleton,System.String)">
      <summary>Exports a skeleton to the file specified. This method takes an externally created Skeleton object, and exports both it and animations it uses to a .skeleton file. </summary>
      <param name="pSkeleton">Weak reference to the Skeleton to export </param>
      <param name="filename">The destination filename </param>
    </member>
    <member name="M:Mogre.SkeletonSerializer.ExportSkeleton(Mogre.Skeleton,System.String,Mogre.Serializer+Endian)">
      <summary>Exports a skeleton to the file specified. This method takes an externally created Skeleton object, and exports both it and animations it uses to a .skeleton file. </summary>
      <param name="pSkeleton">Weak reference to the Skeleton to export </param>
      <param name="filename">The destination filename </param>
      <param name="endianMode">The endian mode to write in </param>
    </member>
    <member name="M:Mogre.SkeletonSerializer.ImportSkeleton(Mogre.DataStreamPtr,Mogre.Skeleton)">
      <summary>Imports Skeleton and animation data from a .skeleton file DataStream. This method imports data from a DataStream opened from a .skeleton file and places it's contents into the Skeleton object which is passed in. </summary>
      <param name="stream">The DataStream holding the .skeleton data. Must be initialised (pos at the start of the buffer). </param>
      <param name="pDest">Weak reference to the Skeleton object which will receive the data. Should be blank already. </param>
    </member>
    <member name="T:Mogre.StringConverter">
      <summary>Class for converting the core Ogre data types to/from Strings. The code for converting values to and from strings is here as a separate class to avoid coupling String to other datatypes (and vice-versa) which reduces compilation dependency: important given how often the core types are used. This class is mainly used for parsing settings in text files. External applications can also use it to interface with classes which use the StringInterface template class. The String formats of each of the major types is listed with the methods. The basic types like int and Real just use the underlying C runtime library atof and atoi family methods, however custom types like Vector3, ColourValue and Matrix4 are also supported by this class using custom formats. Steve Streeting </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseReal(System.String)">
      <summary>Converts a String to a Real. 0.0 if the value could not be parsed, otherwise the Real version of the String. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseAngle(System.String)">
      <summary>Converts a String to a Angle. 0.0 if the value could not be parsed, otherwise the Angle version of the String. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseInt(System.String)">
      <summary>Converts a String to a whole number. 0.0 if the value could not be parsed, otherwise the numeric version of the String. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseUnsignedInt(System.String)">
      <summary>Converts a String to a whole number. 0.0 if the value could not be parsed, otherwise the numeric version of the String. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseLong(System.String)">
      <summary>Converts a String to a whole number. 0.0 if the value could not be parsed, otherwise the numeric version of the String. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseUnsignedLong(System.String)">
      <summary>Converts a String to a whole number. 0.0 if the value could not be parsed, otherwise the numeric version of the String. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseBool(System.String)">
      <summary>Converts a String to a boolean. Returns true if case-insensitive match of the start of the string matches "true", "yes" or "1", false otherwise. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseVector2(System.String)">
      <summary>Parses a Vector2 out of a String. Format is "x y" ie. 2 Real components, space delimited. Failure to parse returns Vector2::ZERO. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseVector3(System.String)">
      <summary>Parses a Vector3 out of a String. Format is "x y z" ie. 3 Real components, space delimited. Failure to parse returns Vector3::ZERO. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseVector4(System.String)">
      <summary>Parses a Vector4 out of a String. Format is "x y z w" ie. 4 Real components, space delimited. Failure to parse returns Vector4::ZERO. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseMatrix3(System.String)">
      <summary>Parses a Matrix3 out of a String. Format is "00 01 02 10 11 12 20 21 22" where '01' means row 0 column 1 etc. Failure to parse returns Matrix3::IDENTITY. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseMatrix4(System.String)">
      <summary>Parses a Matrix4 out of a String. Format is "00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33" where '01' means row 0 column 1 etc. Failure to parse returns Matrix4::IDENTITY. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseQuaternion(System.String)">
      <summary>Parses a Quaternion out of a String. Format is "w x y z" (i.e. 4x Real values, space delimited). Failure to parse returns Quaternion::IDENTITY. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseColourValue(System.String)">
      <summary>Parses a ColourValue out of a String. Format is "r g b a" (i.e. 4x Real values, space delimited), or "r g b" which implies an alpha value of 1.0 (opaque). Failure to parse returns ColourValue::Black. </summary>
    </member>
    <member name="M:Mogre.StringConverter.ParseStringVector(System.String)">
      <summary>Pareses a StringVector from a string. Strings must not contain spaces since space is used as a delimiter in the output. </summary>
    </member>
    <member name="M:Mogre.StringConverter.IsNumber(System.String)">
      <summary>Checks the String is a valid number value. </summary>
    </member>
    <member name="T:Mogre.TextAreaOverlayElement">
      <summary>This class implements an overlay element which contains simple unformatted text. </summary>
    </member>
    <member name="M:Mogre.TextAreaOverlayElement.GetRenderOperation(Mogre.RenderOperation)">
      <summary>See Renderable. </summary>
    </member>
    <member name="M:Mogre.TextAreaOverlayElement._update">
      <summary>Overridden from OverlayElement</summary>
    </member>
    <member name="M:Mogre.TextAreaOverlayElement._update">
      <summary>Overridden from OverlayElement</summary>
    </member>
    <member name="M:Mogre.TextAreaOverlayElement.#ctor(System.String)">
      <summary>Constructor. </summary>
    </member>
    <member name="P:Mogre.TextAreaOverlayElement.TypeName">
      <summary>See OverlayElement. </summary>
    </member>
    <member name="P:Mogre.TextAreaOverlayElement.ColourTop">
      <summary>Sets/Gets the colour of the top of the letters. </summary>
    </member>
    <member name="P:Mogre.TextAreaOverlayElement.ColourBottom">
      <summary>Sets/Gets the colour of the bottom of the letters. </summary>
    </member>
    <member name="P:Mogre.TextAreaOverlayElement.Colour">
      <summary>Sets/Gets the colour of the text. </summary>
    </member>
    <member name="T:Mogre.TextureManager">
      <summary>Class for loading &amp; managing textures. Note that this class is abstract - the particular RenderSystem that is in use at the time will create a concrete subclass of this. Note that the concrete class will be available via the abstract singleton obtained from TextureManager::getSingleton(), but you should not assume that it is available until you have a) initialised Ogre (after selecting a RenderSystem and calling initialise from the Root object), and b) created at least one window - this may be done at the same time as part a if you allow Ogre to autocreate one. </summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.TextureType)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.TextureType,System.Int32)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.TextureType,System.Int32,System.Single)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.TextureType,System.Int32,System.Single,System.Boolean)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat,System.Boolean)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,Mogre.TextureType)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,Mogre.TextureType,System.Int32)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,Mogre.TextureType,System.Int32,System.Single)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,Mogre.TextureType,System.Int32,System.Single,System.Boolean)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat,System.Boolean)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,Mogre.TextureType)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,Mogre.TextureType,System.Int32)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,Mogre.TextureType,System.Int32,System.Single)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) during loading </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,Mogre.TextureType,System.Int32,System.Single,System.Boolean)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) during loading </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) during loading </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture. Pass PF_UNKNOWN to default. </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat,System.Boolean)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="numMipmaps">The number of pre-filtered mipmaps to generate. If left to MIP_DEFAULT then the TextureManager's default number of mipmaps will be used (see setDefaultNumMipmaps()) If set to MIP_UNLIMITED mipmaps will be generated until the lowest possible level, 1x1x1. </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) during loading </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture. Pass PF_UNKNOWN to default. </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadImage(System.String,System.String,Mogre.Image)">
      <summary>Loads a texture from an Image object. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="img">The Image object which contains the data to load </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadImage(System.String,System.String,Mogre.Image,Mogre.TextureType)">
      <summary>Loads a texture from an Image object. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="img">The Image object which contains the data to load </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadImage(System.String,System.String,Mogre.Image,Mogre.TextureType,System.Int32)">
      <summary>Loads a texture from an Image object. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="img">The Image object which contains the data to load </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadImage(System.String,System.String,Mogre.Image,Mogre.TextureType,System.Int32,System.Single)">
      <summary>Loads a texture from an Image object. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="img">The Image object which contains the data to load </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadImage(System.String,System.String,Mogre.Image,Mogre.TextureType,System.Int32,System.Single,System.Boolean)">
      <summary>Loads a texture from an Image object. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="img">The Image object which contains the data to load </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadImage(System.String,System.String,Mogre.Image,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat)">
      <summary>Loads a texture from an Image object. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="img">The Image object which contains the data to load </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadImage(System.String,System.String,Mogre.Image,Mogre.TextureType,System.Int32,System.Single,System.Boolean,Mogre.PixelFormat,System.Boolean)">
      <summary>Loads a texture from an Image object. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="img">The Image object which contains the data to load </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) </param>
      <param name="isAlpha">Only applicable to greyscale images. If true, specifies that the image should be loaded into an alpha texture rather than a single channel colour texture - useful for fixed-function systems. </param>
      <param name="desiredFormat">The format you would like to have used instead of the format being based on the contents of the texture </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadRawData(System.String,System.String,Mogre.DataStreamPtr,System.UInt16,System.UInt16,Mogre.PixelFormat)">
      <summary>Loads a texture from a raw data stream. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="stream">Incoming data stream </param>
      <param name="format">The format of the data being passed in; the manager reserves the right to create a different format for the texture if the original format is not available in this context. </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadRawData(System.String,System.String,Mogre.DataStreamPtr,System.UInt16,System.UInt16,Mogre.PixelFormat,Mogre.TextureType)">
      <summary>Loads a texture from a raw data stream. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="stream">Incoming data stream </param>
      <param name="format">The format of the data being passed in; the manager reserves the right to create a different format for the texture if the original format is not available in this context. </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadRawData(System.String,System.String,Mogre.DataStreamPtr,System.UInt16,System.UInt16,Mogre.PixelFormat,Mogre.TextureType,System.Int32)">
      <summary>Loads a texture from a raw data stream. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="stream">Incoming data stream </param>
      <param name="format">The format of the data being passed in; the manager reserves the right to create a different format for the texture if the original format is not available in this context. </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadRawData(System.String,System.String,Mogre.DataStreamPtr,System.UInt16,System.UInt16,Mogre.PixelFormat,Mogre.TextureType,System.Int32,System.Single)">
      <summary>Loads a texture from a raw data stream. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="stream">Incoming data stream </param>
      <param name="format">The format of the data being passed in; the manager reserves the right to create a different format for the texture if the original format is not available in this context. </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) while loading </param>
    </member>
    <member name="M:Mogre.TextureManager.LoadRawData(System.String,System.String,Mogre.DataStreamPtr,System.UInt16,System.UInt16,Mogre.PixelFormat,Mogre.TextureType,System.Int32,System.Single,System.Boolean)">
      <summary>Loads a texture from a raw data stream. The texture will create as manual texture without loader. </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="stream">Incoming data stream </param>
      <param name="format">The format of the data being passed in; the manager reserves the right to create a different format for the texture if the original format is not available in this context. </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="gamma">The gamma adjustment factor to apply to this texture (brightening/darkening) while loading </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat)">
      <summary>Create a manual texture with a depth of 1 (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32)">
      <summary>Create a manual texture with a depth of 1 (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader)">
      <summary>Create a manual texture with a depth of 1 (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader,System.Boolean)">
      <summary>Create a manual texture with a depth of 1 (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader,System.Boolean,System.UInt32)">
      <summary>Create a manual texture with a depth of 1 (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
      <param name="fsaa">The level of multisampling to use if this is a render target. Ignored if usage does not include TU_RENDERTARGET or if the device does not support it. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader,System.Boolean,System.UInt32,System.String)">
      <summary>Create a manual texture with a depth of 1 (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
      <param name="fsaa">The level of multisampling to use if this is a render target. Ignored if usage does not include TU_RENDERTARGET or if the device does not support it. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat)">
      <summary>Create a manual texture with specified width, height and depth (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32)">
      <summary>Create a manual texture with specified width, height and depth (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader)">
      <summary>Create a manual texture with specified width, height and depth (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader,System.Boolean)">
      <summary>Create a manual texture with specified width, height and depth (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader,System.Boolean,System.UInt32)">
      <summary>Create a manual texture with specified width, height and depth (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
      <param name="fsaa">The level of multisampling to use if this is a render target. Ignored if usage does not include TU_RENDERTARGET or if the device does not support it. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateManual(System.String,System.String,Mogre.TextureType,System.UInt32,System.UInt32,System.UInt32,System.Int32,Mogre.PixelFormat,System.Int32,Mogre.IManualResourceLoader,System.Boolean,System.UInt32,System.String)">
      <summary>Create a manual texture with specified width, height and depth (not loaded from a file). </summary>
      <param name="name">The name to give the resulting texture </param>
      <param name="group">The name of the resource group to assign the texture to </param>
      <param name="texType">The type of texture to load/create, defaults to normal 2D textures </param>
      <param name="width">The dimensions of the texture </param>
      <param name="format">The internal format you wish to request; the manager reserves the right to create a different format if the one you select is not available in this context. </param>
      <param name="usage">The kind of usage this texture is intended for. It is a combination of TU_STATIC, TU_DYNAMIC, TU_WRITE_ONLY, TU_AUTOMIPMAP and TU_RENDERTARGET (see TextureUsage enum). You are strongly advised to use HBU_STATIC_WRITE_ONLY wherever possible, if you need to update regularly, consider HBU_DYNAMIC_WRITE_ONLY. </param>
      <param name="loader">If you intend the contents of the manual texture to be regularly updated, to the extent that you don't need to recover the contents if the texture content is lost somehow, you can leave this parameter as 0. However, if you intend to populate the texture only once, then you should implement ManualResourceLoader and pass a pointer to it in this parameter; this means that if the manual texture ever needs to be reloaded, the ManualResourceLoader will be called to do it. </param>
      <param name="hwGammaCorrection">Pass 'true' to enable hardware gamma correction (sRGB) on this texture. The hardware will convert from gamma space to linear space when reading from this texture. Only applicable for 8-bits per channel textures, will be ignored for other types. Has the advantage over pre-applied gamma that the texture precision is maintained. </param>
      <param name="fsaa">The level of multisampling to use if this is a render target. Ignored if usage does not include TU_RENDERTARGET or if the device does not support it. </param>
    </member>
    <member name="M:Mogre.TextureManager.SetPreferredIntegerBitDepth(System.UInt16)">
      <summary>Sets preferred bit depth for integer pixel format textures. </summary>
      <param name="bits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for the pixel. </param>
    </member>
    <member name="M:Mogre.TextureManager.SetPreferredIntegerBitDepth(System.UInt16,System.Boolean)">
      <summary>Sets preferred bit depth for integer pixel format textures. </summary>
      <param name="bits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for the pixel. </param>
      <param name="reloadTextures">If true (the default), will reloading all reloadable textures. </param>
    </member>
    <member name="M:Mogre.TextureManager.SetPreferredFloatBitDepth(System.UInt16)">
      <summary>Sets preferred bit depth for float pixel format textures. </summary>
      <param name="bits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for a channel of the pixel. </param>
    </member>
    <member name="M:Mogre.TextureManager.SetPreferredFloatBitDepth(System.UInt16,System.Boolean)">
      <summary>Sets preferred bit depth for float pixel format textures. </summary>
      <param name="bits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for a channel of the pixel. </param>
      <param name="reloadTextures">If true (the default), will reloading all reloadable textures. </param>
    </member>
    <member name="M:Mogre.TextureManager.SetPreferredBitDepths(System.UInt16,System.UInt16)">
      <summary>Sets preferred bit depth for integer and float pixel format. </summary>
      <param name="integerBits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for the pixel. </param>
      <param name="floatBits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for a channel of the pixel. </param>
    </member>
    <member name="M:Mogre.TextureManager.SetPreferredBitDepths(System.UInt16,System.UInt16,System.Boolean)">
      <summary>Sets preferred bit depth for integer and float pixel format. </summary>
      <param name="integerBits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for the pixel. </param>
      <param name="floatBits">Number of bits. Available values: 0, 16 and 32, where 0 (the default) means keep original format as it is. This value is number of bits for a channel of the pixel. </param>
      <param name="reloadTextures">If true (the default), will reloading all reloadable textures. </param>
    </member>
    <member name="M:Mogre.TextureManager.IsFormatSupported(Mogre.TextureType,Mogre.PixelFormat,System.Int32)">
      <summary>Returns whether this render system can natively support the precise texture format requested with the given usage options. You can still create textures with this format even if this method returns false; the texture format will just be altered to one which the device does support. Sometimes the device may just slightly change the format, such as reordering the channels or packing the channels differently, without it making and qualitative differences to the texture. If you want to just detect whether the quality of a given texture will be reduced, use isEquivalentFormatSupport instead. true if the format is natively supported, false if a fallback would be used. </summary>
      <param name="format">The pixel format requested </param>
      <param name="usage">The kind of usage this texture is intended for, a combination of the TextureUsage flags. </param>
    </member>
    <member name="M:Mogre.TextureManager.IsEquivalentFormatSupported(Mogre.TextureType,Mogre.PixelFormat,System.Int32)">
      <summary>Returns whether this render system can support the texture format requested with the given usage options, or another format with no quality reduction. </summary>
    </member>
    <member name="M:Mogre.TextureManager.GetNativeFormat(Mogre.TextureType,Mogre.PixelFormat,System.Int32)">
      <summary>Gets the format which will be natively used for a requested format given the constraints of the current device. </summary>
    </member>
    <member name="M:Mogre.TextureManager.IsHardwareFilteringSupported(Mogre.TextureType,Mogre.PixelFormat,System.Int32)">
      <summary>Returns whether this render system has hardware filtering supported for the texture format requested with the given usage options. Not all texture format are supports filtering by the hardware, i.e. some cards support floating point format, but it doesn't supports filtering on the floating point texture at all, or only a subset floating point formats have flitering supported. In the case you want to write shader to work with floating point texture, and you want to produce better visual quality, it's necessary to flitering the texture manually in shader (potential requires four or more texture fetch instructions, plus several arithmetic instructions) if filtering doesn't supported by hardware. But in case on the hardware that supports floating point filtering natively, it had better to adopt this capability for performance (because only one texture fetch instruction are required) and doesn't loss visual quality. This method allow you queries hardware texture filtering capability to deciding which verion of the shader to be used. Note it's up to you to write multi-version shaders for support various hardware, internal engine can't do that for you automatically. Under GL, texture filtering are always supported by driver, but if it's not supported by hardware natively, software simulation will be used, and you will end up with very slow speed (less than 0.1 fps for example). To slove this performance problem, you must disable filtering manually (by use filtering none in the material script's texture_unit section, or call TextureUnitState::setTextureFiltering with TFO_NONE if populate material in code). true if the texture filtering is supported. </summary>
      <param name="ttype">The texture type requested </param>
      <param name="format">The pixel format requested </param>
      <param name="usage">The kind of usage this texture is intended for, a combination of the TextureUsage flags. </param>
    </member>
    <member name="M:Mogre.TextureManager.IsHardwareFilteringSupported(Mogre.TextureType,Mogre.PixelFormat,System.Int32,System.Boolean)">
      <summary>Returns whether this render system has hardware filtering supported for the texture format requested with the given usage options. Not all texture format are supports filtering by the hardware, i.e. some cards support floating point format, but it doesn't supports filtering on the floating point texture at all, or only a subset floating point formats have flitering supported. In the case you want to write shader to work with floating point texture, and you want to produce better visual quality, it's necessary to flitering the texture manually in shader (potential requires four or more texture fetch instructions, plus several arithmetic instructions) if filtering doesn't supported by hardware. But in case on the hardware that supports floating point filtering natively, it had better to adopt this capability for performance (because only one texture fetch instruction are required) and doesn't loss visual quality. This method allow you queries hardware texture filtering capability to deciding which verion of the shader to be used. Note it's up to you to write multi-version shaders for support various hardware, internal engine can't do that for you automatically. Under GL, texture filtering are always supported by driver, but if it's not supported by hardware natively, software simulation will be used, and you will end up with very slow speed (less than 0.1 fps for example). To slove this performance problem, you must disable filtering manually (by use filtering none in the material script's texture_unit section, or call TextureUnitState::setTextureFiltering with TFO_NONE if populate material in code). true if the texture filtering is supported. </summary>
      <param name="ttype">The texture type requested </param>
      <param name="format">The pixel format requested </param>
      <param name="usage">The kind of usage this texture is intended for, a combination of the TextureUsage flags. </param>
      <param name="preciseFormatOnly">Whether precise or fallback format mode is used to detecting. In case the pixel format doesn't supported by device, false will be returned if in precise mode, and natively used pixel format will be actually use to check if in fallback mode. </param>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.CreateOrRetrieve(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Create a new texture, or retrieve an existing one with the same name if it already exists. ResourceManager::createOrRetrieve</summary>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,System.Boolean)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Prepare(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,System.Boolean)">
      <summary>Prepares to loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,System.Boolean)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="M:Mogre.TextureManager.Load(System.String,System.String,System.Boolean,Mogre.IManualResourceLoader,Mogre.Const_NameValuePairList,System.Boolean)">
      <summary>Loads a texture from a file. </summary>
      <param name="name">The file to load, or a String identifier in some cases </param>
      <param name="group">The name of the resource group to assign the texture to </param>
    </member>
    <member name="P:Mogre.TextureManager.PreferredIntegerBitDepth">
      <summary>gets preferred bit depth for integer pixel format textures. </summary>
    </member>
    <member name="P:Mogre.TextureManager.PreferredFloatBitDepth">
      <summary>gets preferred bit depth for float pixel format textures. </summary>
    </member>
    <member name="P:Mogre.TextureManager.DefaultNumMipmaps">
      <summary>Sets/Gets the default number of mipmaps to be used for loaded textures. </summary>
    </member>
    <member name="P:Mogre.TextureManager.Singleton">
      <summary>Override standard Singleton retrieval. Why do we do this? Well, it's because the Singleton implementation is in a .h file, which means it gets compiled into anybody who includes it. This is needed for the Singleton template to work, but we actually only want it compiled into the implementation of the class based on the Singleton, not all of them. If we don't change this, we get link errors when trying to use the Singleton-based class from an outside dll. This method just delegates to the template version anyway, but the implementation stays in this single compilation unit, preventing link errors. </summary>
    </member>
    <member name="T:Mogre.UnifiedHighLevelGpuProgram">
      <summary>Specialisation of HighLevelGpuProgram which just delegates its implementation to one other high level program, allowing a single program definition to represent one supported program from a number of options Whilst you can use Technique to implement several ways to render an object depending on hardware support, if the only reason to need multiple paths is because of the high-level shader language supported, this can be cumbersome. For example you might want to implement the same shader in HLSL and GLSL for portability but apart from the implementation detail, the shaders do the same thing and take the same parameters. If the materials in question are complex, duplicating the techniques just to switch language is not optimal, so instead you can define high-level programs with a syntax of 'unified', and list the actual implementations in order of preference via repeated use of the 'delegate' parameter, which just points at another program name. The first one which has a supported syntax will be used. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.AddDelegateProgram(System.String)">
      <summary>Adds a new delegate program to the list. Delegates are tested in order so earlier ones are preferred. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.ClearDelegatePrograms">
      <summary>Remove all delegate programs. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram._getDelegate">
      <summary>Get the chosen delegate. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.CreateParameters">
      <summary>Creates a new parameters object compatible with this program definition. Unlike low-level assembly programs, parameters objects are specific to the program and therefore must be created from it rather than by the HighLevelGpuProgramManager. This method creates a new instance of a parameters object containing the definition of the parameters this program understands. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.CreateParameters">
      <summary>Creates a new parameters object compatible with this program definition. Unlike low-level assembly programs, parameters objects are specific to the program and therefore must be created from it rather than by the HighLevelGpuProgramManager. This method creates a new instance of a parameters object containing the definition of the parameters this program understands. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.CreateParameters">
      <summary>Creates a new parameters object compatible with this program definition. Unlike low-level assembly programs, parameters objects are specific to the program and therefore must be created from it rather than by the HighLevelGpuProgramManager. This method creates a new instance of a parameters object containing the definition of the parameters this program understands. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String)">
      <summary>Constructor, should be used only by factory classes. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean)">
      <summary>Constructor, should be used only by factory classes. </summary>
    </member>
    <member name="M:Mogre.UnifiedHighLevelGpuProgram.#ctor(Mogre.ResourceManager,System.String,System.UInt64,System.String,System.Boolean,Mogre.IManualResourceLoader)">
      <summary>Constructor, should be used only by factory classes. </summary>
    </member>
    <member name="P:Mogre.UnifiedHighLevelGpuProgram.Language">
      <summary>Returns a string that specifies the language of the gpu programs as specified in a material script. ie: asm, cg, hlsl, glsl</summary>
    </member>
    <member name="P:Mogre.UnifiedHighLevelGpuProgram.IsSupported">
      <summary>Returns whether this program can be supported on the current renderer and hardware.</summary>
    </member>
    <member name="P:Mogre.UnifiedHighLevelGpuProgram.IsSkeletalAnimationIncluded">
      <summary>Returns whether a vertex program includes the required instructions to perform skeletal animation. If this returns true, OGRE will not blend the geometry according to skeletal animation, it will expect the vertex program to do it.</summary>
    </member>
    <member name="T:Mogre.WindowEventListener">
      <summary>Callback class used to send out window events to client app </summary>
    </member>
    <member name="M:Mogre.WindowEventListener.WindowMoved(Mogre.RenderWindow)">
      <summary>Window has moved position </summary>
      <param name="rw">The RenderWindow which created this events </param>
    </member>
    <member name="M:Mogre.WindowEventListener.WindowResized(Mogre.RenderWindow)">
      <summary>Window has resized </summary>
      <param name="rw">The RenderWindow which created this events </param>
    </member>
    <member name="M:Mogre.WindowEventListener.WindowClosing(Mogre.RenderWindow)">
      <summary>Window is closing (Only triggered if user pressed the [X] button) True will close the window(default). </summary>
      <param name="rw">The RenderWindow which created this events </param>
    </member>
    <member name="M:Mogre.WindowEventListener.WindowClosed(Mogre.RenderWindow)">
      <summary>Window has been closed (Only triggered if user pressed the [X] button) The window has not actually close yet when this event triggers. It's only closed after all windowClosed events are triggered. This allows apps to deinitialise properly if they have services that needs the window to exist when deinitialising. </summary>
      <param name="rw">The RenderWindow which created this events </param>
    </member>
    <member name="M:Mogre.WindowEventListener.WindowFocusChange(Mogre.RenderWindow)">
      <summary>Window has lost/gained focus </summary>
      <param name="rw">The RenderWindow which created this events </param>
    </member>
    <member name="T:Mogre.WindowEventUtilities">
      <summary>Utility class to handle Window Events/Pumping/Messages </summary>
    </member>
    <member name="M:Mogre.WindowEventUtilities.MessagePump">
      <summary>Call this once per frame if not using Root:startRendering(). This will update all registered RenderWindows (If using external Windows, you can optionally register those yourself) </summary>
    </member>
    <member name="M:Mogre.WindowEventUtilities.AddWindowEventListener(Mogre.RenderWindow,Mogre.IWindowEventListener)">
      <summary>Add a listener to listen to renderwindow events (multiple listener's per renderwindow is fine) The same listener can listen to multiple windows, as the Window Pointer is sent along with any messages. </summary>
      <param name="window">The RenderWindow you are interested in monitoring </param>
    </member>
    <member name="M:Mogre.WindowEventUtilities.RemoveWindowEventListener(Mogre.RenderWindow,Mogre.IWindowEventListener)">
      <summary>Remove previously added listener </summary>
      <param name="window">The RenderWindow you registered with </param>
    </member>
    <member name="M:Mogre.WindowEventUtilities._addRenderWindow(Mogre.RenderWindow)">
      <summary>Called by RenderWindows upon creation for Ogre generated windows. You are free to add your external windows here too if needed. </summary>
      <param name="window">The RenderWindow to monitor </param>
    </member>
    <member name="M:Mogre.WindowEventUtilities._removeRenderWindow(Mogre.RenderWindow)">
      <summary>Called by RenderWindows upon creation for Ogre generated windows. You are free to add your external windows here too if needed. </summary>
      <param name="window">The RenderWindow to remove from list </param>
    </member>
    <member name="T:Mogre.WireBoundingBox">
      <summary>Allows the rendering of a wireframe bounding box. This class builds a wireframe renderable from a given aabb. A pointer to this class can be added to a render queue to display the bounding box of an object. </summary>
    </member>
    <member name="M:Mogre.WireBoundingBox.SetupBoundingBox(Mogre.AxisAlignedBox)">
      <summary>Builds the wireframe line list. </summary>
      <param name="aabb">bounding box to build a wireframe from. </param>
    </member>
    <member name="M:Mogre.WireBoundingBox.GetWorldTransforms(Mogre.Matrix4+NativeValue*)">
      <summary>Override this method to prevent parent transforms (rotation,translation,scale) </summary>
    </member>
    <member name="T:Mogre.ZipArchive">
      <summary>Specialisation of the Archive class to allow reading of files from a zip format source archive. This archive format supports all archives compressed in the standard zip format, including iD pk3 files. </summary>
    </member>
    <member name="M:Mogre.ZipArchive.Load">
      <summary>Loads the archive. This initializes all the internal data of the class. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Unload">
      <summary>Unloads the archive. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Open(System.String)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Open(System.String,System.Boolean)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Create(System.String)">
      <summary>Create a new file (or overwrite one already there). If the archive is read-only then this method will fail. filenameThe fully qualified name of the file A shared pointer to a DataStream which can be used to read / write the file. </summary>
    </member>
    <member name="M:Mogre.ZipArchive.Remove(System.String)">
      <summary>Delete a named file. Not possible on read-only archives filenameThe fully qualified name of the file</summary>
    </member>
    <member name="M:Mogre.ZipArchive.List">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.List(System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.List(System.Boolean,System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.ListFileInfo">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.ListFileInfo(System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.ListFileInfo(System.Boolean,System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Find(System.String)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Find(System.String,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Find(System.String,System.Boolean,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.FindFileInfo(System.String)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.FindFileInfo(System.String,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.FindFileInfo(System.String,System.Boolean,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Exists(System.String)">
      <summary>Find out if the named file exists (note: fully qualified filename required)</summary>
    </member>
    <member name="M:Mogre.ZipArchive.GetModifiedTime(System.String)">
      <summary>Retrieve the modification time of a given file</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Load">
      <summary>Loads the archive. This initializes all the internal data of the class. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Unload">
      <summary>Unloads the archive. Do not call this function directly, it is meant to be used only by the ArchiveManager class.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Open(System.String)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Open(System.String,System.Boolean)">
      <summary>Open a stream on a given file. There is no equivalent 'close' method; the returned stream controls the lifecycle of this file operation. filenameThe fully qualified name of the file readOnlyWhether to open the file in read-only mode or not (note, if the archive is read-only then this cannot be set to false) A shared pointer to a DataStream which can be used to read / write the file. If the file is not present, returns a null shared pointer.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Create(System.String)">
      <summary>Create a new file (or overwrite one already there). If the archive is read-only then this method will fail. filenameThe fully qualified name of the file A shared pointer to a DataStream which can be used to read / write the file. </summary>
    </member>
    <member name="M:Mogre.ZipArchive.Remove(System.String)">
      <summary>Delete a named file. Not possible on read-only archives filenameThe fully qualified name of the file</summary>
    </member>
    <member name="M:Mogre.ZipArchive.List">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.List(System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.List(System.Boolean,System.Boolean)">
      <summary>List all file names in the archive. This method only returns filenames, you can also retrieve other information using listFileInfo. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.ListFileInfo">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.ListFileInfo(System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.ListFileInfo(System.Boolean,System.Boolean)">
      <summary>List all files in the archive with accompanying information. recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of structures detailing quite a lot of information about all the files in the archive.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Find(System.String)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Find(System.String,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Find(System.String,System.Boolean,System.Boolean)">
      <summary>Find all file or directory names matching a given pattern in this archive. This method only returns filenames, you can also retrieve other information using findFileInfo. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of filenames matching the criteria, all are fully qualified</summary>
    </member>
    <member name="M:Mogre.ZipArchive.Exists(System.String)">
      <summary>Find out if the named file exists (note: fully qualified filename required)</summary>
    </member>
    <member name="M:Mogre.ZipArchive.GetModifiedTime(System.String)">
      <summary>Retrieve the modification time of a given file</summary>
    </member>
    <member name="M:Mogre.ZipArchive.FindFileInfo(System.String)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.FindFileInfo(System.String,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="M:Mogre.ZipArchive.FindFileInfo(System.String,System.Boolean,System.Boolean)">
      <summary>Find all files or directories matching a given pattern in this archive and get some detailed information about them. patternThe pattern to search for; wildcards (*) are allowed recursiveWhether all paths of the archive are searched (if the archive has a concept of that) dirsSet to true if you want the directories to be listed instead of files A list of file information structures for all files matching the criteria.</summary>
    </member>
    <member name="P:Mogre.ZipArchive.IsCaseSensitive">
      <summary>Returns whether this archive is case sensitive in the way it matches files.</summary>
    </member>
  </members>
</doc>